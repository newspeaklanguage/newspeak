Newspeak3
'NS2PrimordialSoup'
class Network usingPlatform: p = (
|
private ArgumentError = p kernel ArgumentError.
private Resolver = p actors Resolver.
private List = p collections List.
private multipleReturn = Array new: 6.
private handleMap = p actors handleMap.
|) (
class IOBuffer = (
|
	readCursor ::= 0.
	writeCursor ::= 0.
	public buffer ::= ByteArray new: 512.
	public closed ::= false.
|
) (
public advance: n = (
	readCursor:: readCursor + n.
)
ensureCapacity: needed = (
	| available = buffer size - writeCursor. oldSize oldReadCursor newBuffer |
	available >= needed ifTrue: [^self].
	oldSize:: size.
	oldReadCursor:: readCursor.
	newBuffer:: ByteArray new: oldSize + needed.
	1 to: oldSize do: [:index | newBuffer at: index put: (buffer at: index + oldReadCursor)].
	buffer:: newBuffer.
	readCursor:: 0.
	writeCursor:: oldSize.
)
public readStart = (
	^readCursor + 1
)
public size = (
	^writeCursor - readCursor
)
public write: chunk <ByteArray> = (
	ensureCapacity: chunk size.
	1 to: chunk size do: [:index | buffer at: index + writeCursor put: (chunk at: index)].
	writeCursor:: writeCursor + chunk size.
)
) : (
)
public class InternetAddress _family: f rawAddress: a = (
|
public family <Integer> = f.
public rawAddress <ByteArray> = a.
|
) (
private primPrint: a family: f multipleReturn: _ = (
	(* :literalmessage: primitive: 155 *)
	halt
)
public printString = (
	checkStatus:: primPrint: rawAddress family: family multipleReturn: multipleReturn.
	^multipleReturn at: 1.
)
) : (
public anyV4 ^<InternetAddress> = (
	(* 0.0.0.0 *)
	^InternetAddress _family: 4 rawAddress: (ByteArray new: 4)
)
public anyV6 ^<InternetAddress> = (
	(* :: *)
	^InternetAddress _family: 6 rawAddress: (ByteArray new: 16)
)
public lookup: hostname <String> ^<Promise[InternetAddress]> = (
	(* :todo: Non-blocking implementation. *)
	^[ | pairs addresses |
	checkStatus:: primLookup: hostname multipleReturn: multipleReturn.
	pairs:: multipleReturn at: 1.
	addresses:: List new.
	1 to: pairs size by: 2 do:
		[:index |
		 addresses add: (self _family: (pairs at: index) rawAddress: (pairs at: index + 1))].
	addresses] <-: value
)
public loopbackV4 ^<InternetAddress> = (
	(* 127.0.0.1 *)
	| rawAddress = ByteArray new: 4. |
	rawAddress at: 1 put: 127.
	rawAddress at: 4 put: 1.
	^InternetAddress _family: 4 rawAddress: rawAddress
)
public loopbackV6 ^<InternetAddress> = (
	(* ::1 *)
	| rawAddress = ByteArray new: 16. |
	rawAddress at: 16 put: 1.
	^InternetAddress _family: 6 rawAddress: rawAddress
)
public parse: address <String> ^<InternetAddress> = (
	(* E.g. 1.2.3.4 or 1::2:3:4 *)
	| pairs addresses |
	checkStatus:: primParse: address multipleReturn: multipleReturn.
	^self _family: (multipleReturn at: 1) rawAddress: (multipleReturn at: 2)
)
private primLookup: hostname multipleReturn: _ = (
	(* :literalmessage: primitive: 156 *)
	halt
)
private primParse: address multipleReturn: _ = (
	(* :literalmessage: primitive: 154 *)
	^(ArgumentError value: address) signal
)
)
class OSException status: s = Exception (
|
public status = s.
|
) (
public printString ^<String> = (
	^'OSException(', (statusToString: status), ', ', status printString, ')'
)
private statusToString: s <Integer> ^<String> = (
	(* :literalmessage: primitive: 166 *)
	^(ArgumentError value: s) signal
)
) : (
)
public class ServerSocket _fromHandle: h = (* Source[Socket] *) (
|
private handle = h.
private acceptSink
private localPort_
private localAddress_
|
) (
public >> sink <Sink[Socket]> = (
	(* Begin sending accept events to the given sink. *)
	(* Implementing Source<Socket> *)
	acceptSink:: sink.
	subscribe.
)
private addresses = (
	checkStatus:: primAddresses: handle remote: false multipleReturn: multipleReturn.
	localPort_:: multipleReturn at: 1.
	localAddress_:: InternetAddress _family: (multipleReturn at: 2) rawAddress: (multipleReturn at: 3).
)
public close = (
	acceptSink done.
	checkStatus:: primClose: handle multipleReturn: multipleReturn.
)
public localAddress ^<InternetAddress> = (
	(* The IP address of this socket. Signals an exception if the socket is not connected. *)
	nil = localAddress_ ifTrue: [addresses].
	^localAddress_
)
public localPort ^<Integer> = (
	(* The TCP port of this socket. Signals an exception if the socket is not connected. *)
	nil = localPort_ ifTrue: [addresses].
	^localPort_
)
private onClosed = (
	acceptSink <-: done.
)
private onError: status = (
	acceptSink <-: error: (OSException signal: status).
)
private onReadable = (
	| client |
	checkStatus:: primAccept: handle multipleReturn: multipleReturn.
	client:: Socket _fromHandle: (multipleReturn at: 1) onConnect: nil.
	acceptSink <-: receiveValue: client.
)
private primAccept: h multipleReturn: _ = (
	(* :literalmessage: primitive: 158 *)
	halt.
)
private primAddresses: h remote: r multipleReturn: _ = (
	(* :literalmessage: primitive: 161 *)
	halt.
)
private primClose: h multipleReturn: _ = (
	(* :literalmessage: primitive: 159 *)
	halt.
)
private subscribe = (
	handleMap at: handle put:
		[:status :pending |
		 0 = (pending & kReadEvent) ifFalse: [onReadable].
		 0 = (pending & kCloseEvent) ifFalse: [onClosed].
		 0 = (pending & kErrorEvent) ifFalse: [onError: status]].
	primAwait: handle signals: kReadEvent | kErrorEvent | kCloseEvent.
)
) : (
public bind: address <InternetAddress> port: port <Integer> backlog: backlog <Integer> ^<Promise[ServerSocket]> = (
	(* Creates a TCP socket listening at the given address and port. *)
	^[checkStatus::
		primBind: address rawAddress
		family: address family
		port: port
		backlog: backlog
		reuse: 1
		multipleReturn: multipleReturn.
	ServerSocket _fromHandle: (multipleReturn at: 1)] <-: value.
)
private primBind: address family: family port: port backlog: backlog reuse: reuse multipleReturn: _ = (
	(* :literalmessage: primitive: 157 *)
	halt.
)
)
public class Socket _fromHandle: h onConnect: c = (* Sink[ByteArray], Source[ByteArray] *) (
|
handle = h.
onConnect <Resolver> ::= c.
outgoing = IOBuffer new.
readSink
readState ::= stateInitial.
writeState ::= nil = c ifTrue: [stateWait] ifFalse: [stateInitial].
localPort_
localAddress_
remotePort_
remoteAddress_
|
subscribe.
) (
public >> sink <Sink[ByteArray]> = (
	(* Begin sending read events to the given sink. *)
	(* Implementing Source<ByteArray> *)
	readSink:: sink.

	primAwait: handle signals: kWriteEvent | kReadEvent | kErrorEvent | kCloseEvent.
)
private addresses = (
	checkStatus:: primAddresses: handle remote: true multipleReturn: multipleReturn.
	localPort_:: multipleReturn at: 1.
	localAddress_:: InternetAddress _family: (multipleReturn at: 2) rawAddress: (multipleReturn at: 3).
	remotePort_:: multipleReturn at: 4.
	remoteAddress_:: InternetAddress _family: (multipleReturn at: 5) rawAddress: (multipleReturn at: 6).
)
public close = (
	nil = readSink ifFalse: [readSink <-: noticeEnd].
	checkStatus:: primClose: handle multipleReturn: multipleReturn.
)
private issueShutdownWrite = (
	checkStatus:: primShutdown: handle how: kWriteEvent multipleReturn: multipleReturn.
	writeState:: stateShutdown.
)
private issueWrite = (
	writeState = stateReady ifFalse: [halt].

	outgoing size > 0 ifTrue:
		[checkStatus::
			primWrite: handle
			buffer: outgoing buffer
			startingAt: outgoing readStart
			count: outgoing size
		multipleReturn: multipleReturn.
		outgoing advance: (multipleReturn at: 1).
		writeState:: stateWait.
		^self].

	outgoing closed ifTrue:
		[issueShutdownWrite].
)
public localAddress ^<InternetAddress> = (
	(* The IP address of this socket. Signals an exception if the socket is not connected. *)
	nil = localAddress_ ifTrue: [addresses].
	^localAddress_
)
public localPort ^<Integer> = (
	(* The TCP port of this socket. Signals an exception if the socket is not connected. *)
	nil = localPort_ ifTrue: [addresses].
	^localPort_
)
public noticeEnd = (
	(* Closes the write half of this socket. *)
	(* Implementing Sink<ByteArray> *)
	outgoing closed: true.
	writeState = stateReady ifTrue: [issueWrite].
)
private onClosed = (
	nil = readSink ifFalse: [readSink <-: noticeEnd].
)
private onError: status = (
	| error = OSException status: status. |

	writeState = stateShutdown ifTrue: ['dup error?' out. ^self].

	writeState = stateInitial ifTrue:
		[writeState:: stateShutdown.
		 onConnect break: error.
		 onConnect:: nil.
		 close.
		 ^self].

	readSink <-: receiveError: error.
)
private onReadable = (
	readState:: stateReady.
	checkStatus:: primRead: handle multipleReturn: multipleReturn.
	readState:: stateWait.
	readSink <-: receiveValue: (multipleReturn at: 1).
)
private onWritable = (
	writeState = stateShutdown ifTrue:
		[^self. (* Is this event meant to signal everything was flushed? *)].

	writeState = stateInitial ifTrue:
		[onConnect fulfill: self.
		 onConnect:: nil].

	writeState:: stateReady.
	issueWrite.
)
private primAddresses: h remote: r multipleReturn: _ = (
	(* :literalmessage: primitive: 161 *)
	halt.
)
private primClose: h multipleReturn: _ = (
	(* :literalmessage: primitive: 165 *)
	halt.
)
private primRead: h multipleReturn: _ = (
	(* :literalmessage: primitive: 162 *)
	halt.
)
private primShutdown: h how: how multipleReturn: _ = (
	(* :literalmessage: primitive: 164 *)
	halt.
)
private primWrite: h buffer: b startingAt: s count: c multipleReturn: _ = (
	(* :literalmessage: primitive: 163 *)
	halt.
)
public receiveError: e <Exception> = (
	(* Implementing Sink<ByteArray> *)

	(* Should this close the socket? *)
)
public receiveValue: v <ByteArray> = (
	(* Send data on this socket. *)
	(* Implementing Sink<ByteArray> *)
	outgoing closed ifTrue: [^Error signal: 'write already closed'].
	outgoing write: v.
	writeState = stateReady ifTrue: [issueWrite].
)
public remoteAddress ^<InternetAddress> = (
	(* The IP address of this socket's peer. Signals an exception if the socket is not connected. *)
	nil = remoteAddress_ ifTrue: [addresses].
	^remoteAddress_
)
public remotePort ^<Integer> = (
	(* The TCP port of this socket's peer. Signals an exception if the socket is not connected. *)
	nil = remotePort_ ifTrue: [addresses].
	^remotePort_
)
private stateInitial = ( ^0 )
private stateReady = ( ^2 )
private stateShutdown = ( ^3 )
private stateWait = ( ^1 )
private subscribe = (
	handleMap at: handle put:
		[:status :pending |
		 0 = (pending & kReadEvent) ifFalse: [onReadable].
		 0 = (pending & kWriteEvent) ifFalse: [onWritable].
		 0 = (pending & kCloseEvent) ifFalse: [onClosed].
		 0 = (pending & kErrorEvent) ifFalse: [onError: status]].
	primAwait: handle signals: kWriteEvent | kErrorEvent | kCloseEvent.
)
) : (
public connect: address <InternetAddress> port: port <Integer> ^<Promise[Socket]> = (
	(* Creates a TCP connection to the given address and port. *)

	| resolver |
	checkStatus::
		primConnect: address rawAddress
		family: address family
		port: port
		multipleReturn: multipleReturn.
	resolver:: Resolver new.
	Socket _fromHandle: (multipleReturn at: 1) onConnect: resolver.
	^resolver promise
)
private primConnect: address family: family port: port multipleReturn: _ = (
	(* :literalmessage: primitive: 160 *)
	halt.
)
)
private checkStatus: status = (
	0 = status ifFalse: [^(OSException status: status) signal].
)
private kCloseEvent = ( ^16r4 )
private kErrorEvent = ( ^16r8 )
private kReadEvent = ( ^16r1 )
private kWriteEvent = ( ^16r2 )
private primAwait: h signals: s = (
	(* :literalmessage: primitive: 143 *)
	halt
)
) : (
)
