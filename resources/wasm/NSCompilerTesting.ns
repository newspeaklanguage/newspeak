Newspeak3
'Newspeak'
class NSCompilerTesting usingPlatform: platform testingStrategy: strategy minitest: minitest = (
(* A replacement of NSCompilerTests, relying on a separate testing strategy object to actually run the tests in some target environment. See the class comment of InImageNSCompilerTestingStrategy for a description of the testing strategy protocol.

Copyright 2011 Vassili Bykov
Copyright 2012 Google Inc

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)
|
	private TestContext = minitest TestContext.
	private StringBuilder = platform kernel StringBuilder.

	private testingStrategy = strategy.
|) (
public class CompilerTests = TestContext (
) (
assertCompilationErrorIn: classSource <String> = (
	[
		testingStrategy
			test: classSource
			with: 'class SampleTest test: sampleClass = ()( public test = () )'
			ifFailure: [:message | ^self]
			ifError: [:message | ^self]]
		on: Error (* not Exception, which catches InMidstOfFileinNotifications *)
		do: [:ex | ^self].
	failWithMessage: 'Expected a compilation error, but succeeded'
)
assertNoCompilationErrorIn: classSource <String> = (
	[
		testingStrategy
			test: classSource
			with: 'class SampleTest test: sampleClass = ()( public test = () )'
			ifFailure: [:message | ^self]
			ifError: [:message | ^self]]
		on: Error (* not Exception, which catches InMidstOfFileinNotifications *)
		do: [:ex | ^failWithMessage: 'Unexpected compilation error'].
)
test: sampleClassSource <String> with: testClassSource <String> = (
	testingStrategy
		test: sampleClassSource
		with: testClassSource
		ifFailure: [:message | failWithMessage: message]
		ifError: [:message | Error new signal: message]
)
public testAssignBooleanLiteral = (
	testSampleMethod: 'public run = (| t | t:: false)'
	with: 'assert: [sample = sample run]'
)
public testAssignCharacterLiteral = (
	testSampleMethod: 'public run = (| t | t:: "c")'
	with: 'assert: [sample = sample run]'
)
public testAssignFloatLiteral = (
	testSampleMethod: 'public run = (| t | t:: 3.14159)'
	with: 'assert: [sample = sample run]'
)
public testAssignIntLiteral = (
	testSampleMethod: 'public run = (| t | t:: 42)'
	with: 'assert: [sample = sample run]'
)
public testAssignNil = (
	testSampleMethod: 'public run = (| t | t:: nil)'
	with: 'assert: [sample = sample run]'
)
public testAssignParam = (
	testSampleMethod: 'public assignParam: x = (| t | t:: x)'
	with: 'assert: [sample = (sample assignParam: 91)]'
)
public testAssignStringLiteral = (
	testSampleMethod: 'public run = (| t | t:: ''abc'')'
	with: 'assert: [sample = sample run]'
)
public testAssignSymbolLiteral = (
	testSampleMethod: 'public run = (| t | t:: #abc)'
	with: 'assert: [sample = sample run]'
)
public testAssignTemps = (
	testSampleMethod: 'public run = (| t1 t2 | t1:: t2)'
	with: 'assert: [sample = sample run]'
)
public testBooleanLiteral = (
	testSampleMethod: 'public run = (true)'
	with: 'assert: [sample = sample run]'
)
public testCascadeGuardedSend = (
	testSampleMethod: 'public cascadeGuardedSend = (
		^[:x | x] value: 3; value: 4
	)'
	with: 'assert: sample cascadeGuardedSend equals: 4'
)
public testCascadeSelfSend = (
	testSampleMethod: 'public cascadeSelfSend = (
		^self yourself; yourself; yourself
	)'
	with: 'assert: sample cascadeSelfSend equals: sample'
)
public testCharacterLiteral = (
	testSampleMethod: 'public run = ("c")'
	with: 'assert: [sample = sample run]'
)
public testClassMethodScope15 = (
	test:
		'class Sample = () (
			public class Inner = () (
				public klass = (^self class)
			) : (
				public static = (^Inner new)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				| innerClass |
				innerClass:: sample Inner.
				assert: innerClass static klass equals: innerClass.
			)
		)'
)
public testClassMethodsNotBlockingOuterMethods = (
	test:
		'class Sample = (
		) (
			public class Inner = () (
				public bar = (^ foo)
	       	) : (
				public foo = (^ 91)
			)
			public foo = (^42)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. | ) (
			public test = (
				assert: klass new Inner new bar equals: 42.
			)
		)'
)
public testClassWithManySlots = (
	| manySlotsWithInitializers = StringBuilder new. |
	1 to: 257 do: [:n | manySlotsWithInitializers add: 'slot', n printString, ' = ''v', n printString, '''.'].

	test:
'class Sample = () (
	class ManySlots = (
		| ', manySlotsWithInitializers asString, ' |
	) ()
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = ( (* Merely check instantiation does not cause an error. *) )
)'
)
public testClosureInTempInitializer = (
	(* Regression test against bug in scope building. *)
	testSampleMethod:
'public closureInInitializer = (
	| value ::= 9. closure = [value: value + 1]. |
	^closure
)'
	with:
'
	| closure |
	closure:: sample closureInInitializer.
	assert: closure value equals: 10.
	assert: closure value equals: 11.
	assert: closure value equals: 12.
'
)
public testClosureNLR = (
	testSampleMethod: 'public nlr: x = ( [^x] value. ^2 )'
	with: 'assert: (sample nlr: 42) equals: 42'
)
public testClosureNLR2 = (
	testSampleMethod: 'public closureNLR2 = (
		| block |
		block:: [:n | n < 10 ifTrue: [^true] ifFalse: [block value: n-1]].
		block value: 20.
		^false
	)'
	with: 'assert: sample closureNLR2 equals: true'
)
public testClosureNestCounters = (
	testSampleMethod: '
public counterGenerator: param = (
	| totalCount ::= 9. |
	^[
		| count ::= 0. |
		[
			count:: count+1.
			totalCount:: totalCount + 1.
			{count. totalCount}
		]
	].
)'
	with:
'
	| gen c1 c2 |
	gen:: sample counterGenerator: #ignored.
	c1:: gen value.
	c2:: gen value.
	assertList: c1 value equals: {1. 10}.
	assertList: c1 value equals: {2. 11}.
	assertList: c2 value equals: {1. 12}.
	assertList: c1 value equals: {3. 13}.
	assertList: c2 value equals: {2. 14}.
	c1:: gen value.
	assertList: c1 value equals: {1. 15}.
	assertList: c1 value equals: {2. 16}.
	assertList: c2 value equals: {3. 17}.
'
)
public testClosureReentrancy = (
	testSampleMethod: '
public closureFactorial = (
	| factorial |
	factorial: [:n | n = 1 ifTrue: [1] ifFalse: [(factorial value: n - 1) * n]].
	^{1. 2. 3. 4. 5. 6. 7. 8. 9. 10} collect: factorial
)'
	with:
'	assertList: sample closureFactorial equals: {1. 2. 6. 24. 120. 720. 5040. 40320. 362880. 3628800}.
'
)
public testClosureRegression = (
	testSampleMethod: '
public evaluate: expression <String>
ifCompilerError: onCompilerError <[:String]>
ifError: onError <[:NewspeakDebugging ThreadSubject :Exception]> ^<ObjectMirror> = (
	| compilerError failed sem result process |
	failed:: false.
	sem:: Semaphore new.
	process::
		[
			[result:: activationMirror
				evaluate: expression
				withBlackMarket: blackMarket
				ifCompilerError: [:ex <Exception> |
					compilerError:: ex.
					sem signal.
					process suspend]
				ifError: [:ex <Exception> |
					failed:: true.
					result:: ex.
					sem signal.
					process suspend].
			sem signal]
				on: UnhandledError
				do:	[:ex |
					failed ifTrue: [ex pass]. (* dont fire twice *)
					failed:: true.
					result:: ex exception.
					sem signal.
					process suspend].
		] newProcess.
	process
		name: ''Evaluating '', expression asString;
		resume.
	sem wait.
	process offList.
	compilerError ifNotNil:
		[^onCompilerError value: compilerError description].
	failed ifFalse:
		[^result].
	(* position the process to continue in the signalerContext *)
	process suspendedContext unwindTo: result signalerContext.
	result signalerContext push: result.
	process suspendedContext: result signalerContext.
	^onError value: (registry subjectFor: result in: process) value: result
)'
	with: ''
)
public testClosureTempFrame = (
	testSampleMethod: '
public insideInlinedBlock = (
	| a b c|
	a: 10.
	b: 20.
	c: 40.
	a < 200 ifTrue: [
		^(b < 1000) and: [c > 0]
	]
) '
	with:
'
	assert: sample insideInlinedBlock equals: true.
'
)
public testCompilePseudoVariables = (
	test:
		'class Sample = (
			| slot slot2 slot3 |
		) (
			public foo: param314159 = (^param314159 + 7)
			public bar = (^self foo: 5)
			public snafu: x = (	^x foo: 84)
			public baz = (^snafu:: self	)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assert: [(sample foo: 3) = 10] description: ''Assertion failed: (sample foo: 3) = 10''.
				assert: [sample bar = 12] description: ''Assertion failed: sample bar = 12''.
				assert: [sample baz = sample] description: ''Assertion failed: sample baz = sample''.
			)
		)'
)
public testControlMessageValues = (
	testSampleMethod: ''
	with: '
assert: (false ifTrue: [7]) equals: nil.
assert: (true ifFalse: [7]) equals: nil.
assert: (7 timesRepeat: [9]) equals: nil.
assert: (3 to: 7 do: [:ignore | ]) equals: nil.
assert: (3 to: 7 by: 2 do: [:ignore|]) equals: nil.
assert: ([false] whileTrue: [7]) equals: nil.
assert: ([true] whileFalse: [7]) equals: nil.
assert: ([false] whileTrue) equals: nil.
assert: ([true] whileFalse) equals: nil.
'
)
public testDivisionTowardNegInfinity = (
	testSampleMethod: ''
	with: '
assert: (13 // 5) equals: 2.
assert: (-13 // 5) equals: -3.
assert: (13 // -5) equals: -3.
assert: (-13 // -5) equals: 2.
assert: (5 // 13) equals: 0.
assert: (-5 // 13) equals: -1.
assert: (5 // -13) equals: -1.
assert: (-5 // -13) equals: 0.
assert: (16 // 8) equals: 2.
assert: (-16 // 8) equals: -2.
assert: (16 // -8) equals: -2.
assert: (-16 // -8) equals: 2.'
)
public testDivisionTowardZero = (
	testSampleMethod: ''
	with: '
assert: (13 quo: 5) equals: 2.
assert: (-13 quo: 5) equals: -2.
assert: (13 quo: -5) equals: -2.
assert: (-13 quo: -5) equals: 2.
assert: (5 quo: 13) equals: 0.
assert: (-5 quo: 13) equals: 0.
assert: (5 quo: -13) equals: 0.
assert: (-5 quo: -13) equals: 0.
assert: (16 quo: 8) equals: 2.
assert: (-16 quo: 8) equals: -2.
assert: (16 quo: -8) equals: -2.
assert: (-16 quo: -8) equals: 2.'
)
public testDoublyNestedIWhileInIf = (
	testSampleMethod: 'public doublyNestedWhileInIf = (| tf tg |
		tf:: 1 + 1 * 2.
	tg:: 2*2*2*2.
	tg <1000
		ifTrue: [
			[tg < 10000]
				whileTrue: [
					tg < 5000
						ifTrue: [tg:: tg *2]
						ifFalse: [
							tg:: tg + 1000.
							[tf > 10] whileFalse: [tf:: tf+ 1].
							]
				]
			]
		ifFalse: [].
	^tg + tf
	)'
	with: 'assert: sample doublyNestedWhileInIf equals: 10203.'
)
public testDuplicateNames = (
	assertCompilationErrorIn: 'class Sample = (| foo |) (class foo = ()() foo = ())'.

	assertCompilationErrorIn: 'class Sample = (| foo |) (foo = ())'.
	assertCompilationErrorIn: 'class Sample = () (class foo = ()() foo = ())'.
	assertCompilationErrorIn: 'class Sample = (| foo |) (class foo = ()())'.

	assertCompilationErrorIn: 'class Sample = () (foo = () foo = ())'.
	assertCompilationErrorIn: 'class Sample = (| foo foo |) ()'.
	assertCompilationErrorIn: 'class Sample = () (class foo = ()() class foo = ()())'.

	assertCompilationErrorIn: 'class Sample = ( | foo ::= 42. | ) (foo: x = ())'.
	assertNoCompilationErrorIn: 'class Sample = ( | foo = 42. | ) (foo: x = ())'.
)
public testDynamicSuper = (
	test:
'class Sample = () (
	public class Super1 = () (
		m = (^1984)
	)
	public class Super2 = () (
		m = (^1948)
	)
	public class DynamicSuperSample sup: Sup = (
		| public App = Inner mixinApply: Sup. |
	) (
		class Inner = () (
			public foo = (^super m)
		)
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| klass instance1 instance2 |
		klass: sample DynamicSuperSample.
		instance1:: klass sup: sample Super1.
		instance2:: klass sup: sample Super2.
		assert: instance1 App new foo equals: 1984.
		assert: instance2 App new foo equals: 1948.
	)
)'.
)
public testEmptyNoParamBlock = (
	testSampleMethod: 'public emptyNoParamBlock = (^[]) '
	with:
'
   assert: [sample emptyNoParamBlock isKindOfClosure].
   assert: sample emptyNoParamBlock value equals: nil.
'
)
public testEmptyOneParam = (
	testSampleMethod: 'public emptyOneParam: aParam = () '
	with: 'assert: [sample = (sample emptyOneParam: 3)]'
)
public testEmptyOneParamBlock = (
	testSampleMethod: 'public emptyOneParamBlock = (^[:x | ])'
	with:
'
	assert: [sample emptyOneParamBlock isKindOfClosure].
	assert: [nil = (sample emptyOneParamBlock value: 91)]
'
)
public testEmptyTwoParamBlock = (
	testSampleMethod: 'public emptyTwoParamBlock = (^[:x :y | ])'
	with:
'
	assert: [sample emptyTwoParamBlock isKindOfClosure].
	assert: (sample emptyTwoParamBlock value: 91 value: 42) equals: nil.
'
)
public testEmptyTwoParams = (
	testSampleMethod: 'public emptyParam1: x param2: y = ()'
	with: 'assert: [sample = (sample emptyParam1: 42 param2: 91)]'
)
public testEmptyZeroParams = (
	testSampleMethod: 'public emptyZeroParams = ()'
	with: 'assert: [sample = sample emptyZeroParams]'
)
public testEnclosingObject = (
	test:
		'class Sample = () (
			public class Nested = ()(
				public foo = (^outer Sample)
				public bar = (^[outer Sample] value)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assert: sample Nested new foo equals: sample.
				assert: sample Nested new bar equals: sample.
			)
		)'.
)
public testEventualSendParsed = (
	testSampleMethod: 'unary = ( bob <-: foo. )' with: ''.
	testSampleMethod: 'binary = ( bob <-: + carol. )' with: ''.
	testSampleMethod: 'keyword = ( bob <-: foo: carol. )' with: ''.
	testSampleMethod: 'cascade = ( bob <-: foo; foo; <-: foo: carol; <-: ** 7; yourself. )' with: ''.
)
public testExplicitOuterInInitializer = (
	test:
'class Sample = () (
	public class Inner = (
		| public f = 2 * outer Sample m. |
	) ()
	m = (^91)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		assert: sample Inner new f equals: 182.
	)
)'
)
public testExtendedDigits = (
	testSampleMethod: ''
	with: '
assert: 2r10 equals: 2.
assert: 8r7654321 equals: 2054353.
assert: 10r9876543210 equals: 9876543210.
assert: 16rABCDEF equals: 11259375.
assert: 36rABCXYZ equals: 623741435.'
)
public testFactoryEarlyReturn = (
	(* Previously, the factory would incorrectly return the result of the instance initializer. *)
	test:
'class Sample = () (
	public class EarlyReturn foo: x = (
		| public foo = x. |
		true ifTrue: [^''Eastasia''].
	) ()
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		assert: (sample EarlyReturn foo: ''Oceania'') foo equals: ''Oceania''.
	)
)'
)
public testFactoryInitializationExpressions = (
	assertNoCompilationErrorIn: 'class Sample = ( 1984 ) ()'.
	assertCompilationErrorIn: 'class Sample = ( ^1984 ) ()'.
)
public testFloatLiteral = (
	testSampleMethod: 'public floatLiteral = (5.2)'
	with: 'assert: [sample = sample floatLiteral]'
)
public testIfCascade = (
(* Regression for bitbucket issue 85 *)
	test:
		'class Sample = ( | public slot1 public slot2 | ) (
			public fail = (
				| x |
				x: class new.
				x
					slot1: (true ifTrue: [3] ifFalse: [4]);
					slot2: 8.
				^x
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assert: [sample fail slot1 = 3] description: ''Assertion failed: slot1 = 3''.
				assert: [sample fail slot2 = 8] description: ''Assertion failed: slot2 = 8''.
			)
		)'
)
public testIfFalse1 = (
	testSampleMethod: 'public testIfFalse1 = (| ta tb  tc td te tf tg th | tf:: 37.
^tf < 32 ifFalse: [tf:: 96]. )'
	with: 'assert: sample testIfFalse1 equals: 96'
)
public testIfFalse2 = (
	testSampleMethod: 'public testIfFalse2 = (| ta tb  tc td te tf tg th | tf:: 37.
^tf > 32 ifFalse: [tf:: 96].)'
	with: 'assert: sample testIfFalse2 equals: nil'
)
public testIfTrue1 = (
	testSampleMethod: 'public testIfTrue1 = (| ta tb  tc td te tf tg th | tf:: 37.
^tf > 32 ifTrue: [tf:: 64]. ) '
	with: 'assert: sample testIfTrue1 equals: 64'
)
public testIfTrue2 = (
	testSampleMethod: 'public testIfTrue2 = (| ta tb  tc td te tf tg th | tf:: 37.
^tf < 32 ifTrue: [tf:: 64]. ) '
	with: 'assert: sample testIfTrue2 equals: nil'
)
public testIfTrueIfFalseElse = (
	testSampleMethod: 'public testIfTrueIfFalse = (| ta tb  tc td te tf tg th | tf:: 37.
^tf < 32 ifTrue: [tf:: 64] ifFalse: [tf:: 96]. ) '
	with: 'assert: sample testIfTrueIfFalse equals: 96'
)
public testIfTrueIfFalseThen = (
	testSampleMethod: 'public testIfTrueIfFalse = (| ta tb  tc td te tf tg th | tf:: 37.
^tf > 32 ifTrue: [tf:: 64] ifFalse: [tf:: 96]. ) '
	with: 'assert: sample testIfTrueIfFalse equals: 64'
)
public testImmutableInstVar = (
	test:
		'class Sample = (
			| public slot = 9. |
		)()'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assert: [sample slot = 9] description: ''Slot not properly initialized''.
				assert: [sample slot: 10] signals: Error description: ''Assignment did not raise error''.
				assert: [sample slot = 9] description: ''Slot did not retain value''.
			)
		)'
)
public testImmutableTempEnforced = (
	testSampleMethod: 'public immutableTemp = ( | a = 9. | a:: 10. )'
	with: 'assert: [sample immutableTemp] signals: Error.'
)
public testImmutableTempInitialized = (
	testSampleMethod: 'public immutableTemp = ( | a = 9. | ^a )'
	with: 'assert: sample immutableTemp equals: 9.'
)
public testImplicitOuterInInitializer = (
	test:
'class Sample = () (
	public class Inner = (
		| public f = 2 * m. |
	) (
	)
	m = (^91)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		assert: sample Inner new f equals: 182.
	)
)'
)
public testInit17 = (
	test:
'class Sample = () (
	public class Test17 x: i y: j z: k = (
		(*Test initializers.*)
		|
			public x ::= i.
			public y ::= j.
			public z
			public rho
			public theta
		|
			z: x + y + k.
			rho: 1000 * z.
			theta:: rho + y
	) (
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| anInstance |
		anInstance:: sample Test17 x: 42 y: 91 z: 19.
		assert: [anInstance z = (anInstance x + anInstance y + 19)].
		assert: [anInstance rho = 152000].
		assert: [anInstance theta = 152091].
	)
)'
)
public testInlinedConditionalForValue = (
	(* Regression test. The ifTrue:ifFalse: was mistakenly rewritten for effect, resulting in a syntax error in js output due to an if statement in the for loop's condition instead of an expression. *)
	testSampleMethod: 'public test = ( [3 > 4 ifTrue: [true] ifFalse: [false]] whileTrue. ^self)'
	with: 'sample test'
)
public testInlinedParameterCopyDown = (
	testSampleMethod: 'public inlinedParameterCopyDown = (
		3 to: 4 do: [:param |
			[^param] value.
		])'
	with: 'assert: sample inlinedParameterCopyDown equals: 3'
)
public testInlinedParameterShadowingIndirection = (
	testSampleMethod: 'public inlinedParameterShadowingIndirection = (
	     | param ::= 7. |
		3 to: 4 do: [:param |
			[param:: param] value].
		^param
		)'
	with: 'assert: sample inlinedParameterShadowingIndirection equals: 4'
)
public testInlinedSetters = (
(* Regression for bitbucket issue 91 *)
	test:
		'class Sample = ( | public slot1 public slot2 public field0 public field1 public field2 public field3 public field4 | ) (
			public expr1 = (^23)
			public expr2 = (^36)
			public expr3 = (^52)
			public expr4 = (^69)

			public y = (
			 	| a b |
				field0: (slot1:: 0). (*Correct: uses method''s setter temp*)
				[
					field1: (slot2:: self expr1).(*Correct: uses closures''s setter temp*)
					field2: (true ifTrue: [slot2:: self expr2]). (*WRONG: uses method''s setter temp*)
					field3: ([true] value ifTrue: [slot2:: self expr3]). (*WRONG: uses method''s setter temp*)
					field4:(slot2:: self expr4). (*Correct: uses closures''s setter temp*)
				] value.
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				sample y.
				assert: [sample slot1 = 0].
				assert: [sample field1 = sample expr1].
				assert: [sample field2 = sample expr2].
				assert: [sample field3 = sample expr3].
				assert: [sample field4 = sample expr4].
				assert: [sample slot2 = sample expr4].
			)
		)'
)
public testInlinedTemporaryShadowingIndirection = (
	testSampleMethod: 'public inlinedTemporaryShadowingIndirection = (
	     | temp ::= 7. |
		true ifTrue: [ | temp = 4. |
			[temp:: temp] value].
		^temp
		)'
	with: 'assert: sample inlinedTemporaryShadowingIndirection equals: 4'
)
public testInner12 = (
	test:
'class Sample = () (
	public class NS2Test12 s: aClass = (
		(*Test for n-levels of nesting*)
		| Sup = aClass. |
	) (
		public class Inner1 = Sup () (
			public class Inner11 = Sup () (
				public class Inner111 = Sup () (
					public baz = (^outer Inner11 bar + outer Inner1 foo + outer NS2Test12 m)
				)
		    		public bar = (^outer NS2Test12 m + outer Inner1 foo)
			)
			public foo = (
				^outer NS2Test12 m
			)

		)
		(*(NS2Test12 s: Object) Inner1 new Inner11 new Inner111 new bar = 364*)
		m = (^91)
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| klass innerKlass innerInnerKlass innerInnerInnerKlass anInstance anInnerInstance anInnerInnerInstance |
		klass:: sample NS2Test12.
		anInstance:: klass s: Object.
		assert: [anInstance Inner1 = anInstance Inner1].
		assert: [anInstance Inner1 new foo = 91].

		innerKlass:: anInstance Inner1.
		anInnerInstance:: innerKlass new.
		assert: [anInnerInstance Inner11 = anInnerInstance Inner11].
		assert: [anInnerInstance  Inner11 new bar = 182].

		innerInnerKlass:: anInnerInstance Inner11.
		anInnerInnerInstance:: innerInnerKlass  new.
		innerInnerInnerKlass:: anInnerInnerInstance Inner111.
		assert: [anInnerInnerInstance Inner111 = anInnerInnerInstance Inner111].
		assert: [anInnerInnerInstance  Inner111 new baz = 364].
	)
)'
)
public testInner14 = (
	test:
'class Sample = () (
	public class NS2Test14a = (
		(*A nested test case*)
	) (
		public class Inner1 create = () (
		 	public foo = (^m)
		)
		public m = (^91)
	)
	public class NS2Test14b s: aClass = (
		(*A nested test case*)
		|
		Sup = aClass.
		|
	) (
		public class Inner2 = Sup create ( ) (
			public bar = (^foo)
		)
		(*(NS2Test14b s: NS2Test14a new Inner1) Inner2 new bar = 91*)
		public m = (^42)
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| klassA klassB innerKlass innerInnerKlass innerInnerInnerKlass anInstance anInnerInstance anInnerInnerInstance |
		klassA:: sample NS2Test14a.
		klassB:: sample NS2Test14b.
		anInstance:: klassB s: klassA new Inner1.
		assert: [anInstance Inner2 = anInstance Inner2].
		assert: [anInstance m = 42].

		innerKlass:: anInstance Inner2.
		anInnerInstance:: innerKlass new.
		assert: [anInnerInstance bar = 91].
	)
)'
)
public testInner18 = (
(* This test creates a situation where the an object's enclosing instance with respect to its class (Inner2) is an instance of the same class (Sample) as its enclosing instance with respect to its superclass (Inner1). *)

	test:
		'class Sample s: Sup = (
			| SuperClass = Sup. |
		) (
			public class Inner1 = () (
				public i1 = (^Inner1)
			)
			public class Inner2 = SuperClass () (
				public i1 = (^Inner1)
				public supI1 = (^super i1)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. |) (
			public test = (
				| o1 o2 o1i1 o1i2 o2i1 o2i2 innerKlass11 innerKlass12 innerKlass21 innerKlass22 |
				o1:: klass s: Object.
				o2:: klass s: o1 Inner1.
				o1i1:: o1 Inner1 new.
				o1i2:: o1 Inner2 new.
				o2i1:: o2 Inner1 new.
				o2i2:: o2 Inner2 new.
				innerKlass11:: o1 Inner1.
				innerKlass12:: o1 Inner2.
				innerKlass21:: o2 Inner1.
				innerKlass22:: o2 Inner2.
				assert: [o1 Inner1 = o1i1 i1] description: ''Assertion failed: o1 Inner1 = o1i1 i1''.
				assert: [o1 Inner1 = o1i2 i1] description: ''Assertion failed: o1 Inner1 = o1i2 i1''.
				assert: [o2 Inner1 = o2i1 i1] description: ''Assertion failed: o2 Inner1 = o2i1 i1''.
				assert: [o2 Inner1 = o2i2 i1] description: ''Assertion failed: o2 Inner1 = o2i2 i1''.
				assert: [o1 Inner1 = o1i2 i1] description: ''Assertion failed: o1 Inner1 = o1i2 i1''.
				assert: [o1 Inner1 = o2i2 supI1] description: ''Assertion failed: o1 Inner1 = o2i2 supI1''.
				assert: [(o1 Inner1 = o2 Inner1) not] description: ''Assertion failed: o1 Inner1 ~= o2 Inner1''.
			)
		)'
)
public testInner20 = (
	test:
		'class Sample = () (
			class Outer = () (
				public class Inner = () (
					public foo = (^m + y)
				)
				m = (^91)
				y = (^8)
			)
			public class OuterSub = Outer () (
				m = (^77)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				| innerKlass innerInnerKlass anInnerInstance |
				innerKlass:: sample OuterSub.
				anInnerInstance:: innerKlass new.
				innerInnerKlass:: anInnerInstance Inner.
				assert: [innerInnerKlass new foo = 85].
			)
		)'
)
public testInner21 = (
	test:
		'class Sample = () (
			class A = () ()
			class B = A () (
				public class B1 = () (
					public class B1a = A () ()
				)
			)
			public class C = B () ()
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				| anInnerInstance anInnerInnerInstance innerKlass innerInnerKlass innerInnerInnerKlass |
				innerKlass: sample C.
				anInnerInstance:: innerKlass new.
				innerInnerKlass:: anInnerInstance B1.
				anInnerInnerInstance:: innerInnerKlass new.
				innerInnerInnerKlass:: anInnerInnerInstance B1a.
				innerInnerInnerKlass new.
			)
		)'
)
public testInner3 = (
	test:
		'class Sample s: aClass = (
			| Sup = aClass. |
		) (
			public class Inner create = Sup () (
				public foo = (^m)
			)
			m = (^91)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. | ) (
			public test = (
				| anInstance |
				anInstance:: klass s: Object.
				assert: [anInstance Inner = anInstance Inner] description: ''Assertion failed: anInstance Inner = anInstance Inner''.
				assert: [anInstance Inner create foo = 91] description: ''Assertion failed: anInstance Inner create foo = 91''.
			)
		)'
)
public testInner7 = (
	test:
		'class Sample s: aClass = (
			(*A perverse nested test case. This example only works if nested classes
			are created lazily (as they are right now). An eager semantics would
			cause an infinite regress of nested classes being created.
			Is even the eager case actually a problem? One can always write an
			infinite loop in an initializer. How is this different?*)
			| Sup = aClass. |
		) (
			public class Inner = Sup s: Sup (
				(*Under comb semantics the argument refers to Inner''s Sup, which is not yet initialized. A real puzzler.
				Under new semantics, lexically evident Sup will be used rather than inherited one - which is what we expect.
				Arguably, both should work, but Squeak dies if the superclass is nil.*)
			) (
				public foo = (^m)
	       	)
			 m = (^91)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. | ) (
			public test = (
				| anInstance anInnerInstance anInnerInnerInstance |
				anInstance:: klass s: klass.
				assert: [anInstance Inner = anInstance Inner]
					description: ''Assertion failed: anInstance Inner = anInstance Inner''.
				assert: [anInstance Inner new foo = 91]
					description: ''Assertion failed: anInstance Inner new foo = 91''.
				anInnerInstance:: anInstance Inner new.
				assert: [anInnerInstance Inner new foo = 91]
					description: ''Assertion failed: anInnerInstance Inner new foo = 91''.
				assert: [anInnerInstance Inner = anInnerInstance Inner]
					description: ''Assertion failed: anInnerInstance Inner = anInnerInstance Inner''.
				anInnerInnerInstance:: anInstance Inner new Inner new.
				assert: [anInnerInnerInstance Inner new foo = 91]
					description: ''Assertion failed: anInnerInnerInstance Inner new foo = 91''.
				assert: [anInnerInnerInstance Inner = anInnerInnerInstance Inner]
					description: ''Assertion failed: anInnerInnerInstance Inner = anInnerInnerInstance Inner''.
			)
		)'
)
public testInner8 = (
	test:
		'class Sample s: aClass = (
			(*Test for n-levels of nesting*)
			| Sup = aClass. |
		) (
			public class Inner1 = Sup () (
				public class Inner11 = Sup () (
					public class Inner111 = Sup () (
						public baz = (^bar + foo + m)
					)
					public bar = (^m + foo)
				)
				public foo = (^m)
			)
			(*(NS2Test8 s: Object) Inner1 new Inner11 new Inner111 new bar = 364*)
			m = (^91)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. | ) (
			public test = (
				| innerKlass innerInnerKlass innerInnerInnerKlass anInstance anInnerInstance anInnerInnerInstance |
				anInstance:: klass s: Object.
				assert: [anInstance Inner1 = anInstance Inner1]
					description: ''Assertion failed: anInstance Inner1 = anInstance Inner1''.
				assert: [anInstance Inner1 new foo = 91]
					description: ''Assertion failed: anInstance Inner1 new foo = 91''.
				innerKlass:: anInstance Inner1.
				anInnerInstance:: innerKlass new.
				assert: [anInnerInstance Inner11 = anInnerInstance Inner11]
					description: ''Assertion failed: anInnerInstance Inner11 = anInnerInstance Inner11''.
				assert: [anInnerInstance  Inner11 new bar = 182]
					description: ''Assertion failed: anInnerInstance  Inner11 new bar = 182''.
				innerInnerKlass:: anInnerInstance Inner11.
				anInnerInnerInstance:: innerInnerKlass  new.
				innerInnerInnerKlass:: anInnerInnerInstance Inner111.
				assert: [anInnerInnerInstance Inner111 = anInnerInnerInstance Inner111]
					description: ''Assertion failed: anInnerInnerInstance Inner111 = anInnerInnerInstance Inner111''.
				assert: [anInnerInnerInstance  Inner111 new baz = 364]
					description: ''Assertion failed: anInnerInnerInstance  Inner111 new baz = 364''.
			)
		)'
)
public testInner9 = (
	test:
		'class Sample = (
(*Test mutually referential nested classes (and implicit use of Object).*)
) (
			public class Inner1 = () (
				public foo = (^Inner2 new val)
			)
			(* (NS2Test9 new Inner1 new foo = 91 *)
			class Inner2 = () (
				public val = (^91)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				| innerKlass anInnerInstance |
				assert: [sample Inner1 = sample Inner1] description: ''Assertion failed: sample Inner1 = sample Inner1''.
				assert: [sample Inner1 new foo = 91] description: ''Assertion failed: sample Inner1 new foo = 91''.
				innerKlass:: sample Inner1.
				anInnerInstance:: innerKlass new.
			)
		)'.
	TODO (* Do we want to do anything with innerKlass and anInnerInstance? *)
)
public testIntLiteral = (
	testSampleMethod: 'public intLiteral = (5)'
	with: 'assert: [sample = sample intLiteral]'
)
public testMNUFromImplicitReceiverSend = (
	test:
		'class Sample = () (
			class Super = ()(
				doesNotUnderstand: message = (^#super)
				public doImplicitReceiverFoo = (^foo)
			)
			public class Sub = Super ()(
				doesNotUnderstand: message = (^#sub)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				| aSub |
				aSub:: sample Sub new.
				10 timesRepeat:
					[assert: aSub doImplicitReceiverFoo equals: #sub].
			)
		)'.
)
public testMNUFromOuterSend = (
	test:
		'class Sample = () (
			class Super = ()(
				public class Inner = ()(
					public doOuterFoo = (^outer Super foo)
				)
				doesNotUnderstand: message = (^#super)
			)
			public class Sub = Super ()(
				doesNotUnderstand: message = (^#sub)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				| aSub |
				aSub:: sample Sub new Inner new.
				10 timesRepeat:
					[assert: aSub doOuterFoo equals: #sub].
			)
		)'.
)
public testMNUFromSelfSend = (
	test:
		'class Sample = () (
			class Super = ()(
				doesNotUnderstand: message = (^#super)
				public doSelfFoo = (^self foo)
			)
			public class Sub = Super ()(
				doesNotUnderstand: message = (^#sub)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				| aSub |
				aSub:: sample Sub new.
				10 timesRepeat:
					[assert: aSub doSelfFoo equals: #sub].
			)
		)'.
)
public testMNUFromSuperSend = (
	test:
		'class Sample = () (
			class Super = ()(
				doesNotUnderstand: message = (^#super)
			)
			public class Sub = Super ()(
				doesNotUnderstand: message = (^#sub)
				public doSuperFoo = (^super foo)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				| aSub |
				aSub:: sample Sub new.
				1 timesRepeat:
					[assert: aSub doSuperFoo equals: #super].
			)
		)'.
)
public testMultipleSetters = (
	testSampleMethod: 'public testMultipleSetters = (
	| x y z |
	^x:: (y:: 42) + (z:: 49).
)'
	with: 'assert: [sample testMultipleSetters = 91]'
)
public testMultipleSetters22 = (
	test:
		'class Sample = () (
			a: alpha = ()
			b: beta = ()
			public invokeMultipleSetters = (
				| x |
				^x:: (a:: 42) + (b:: 49).
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assert: [sample invokeMultipleSetters = 91].
			)
		)'
)
public testMultipleSetters23 = (
	test:
		'class Sample = () (
			a: alpha = ()
			b: beta = ()
			c: gamma = ()
			public invokeMultipleSetters = (
				^a:: 42 + (b:: 49) + (c:: 44).
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assert: [sample invokeMultipleSetters = 135].
			)
		)'
)
public testNLR0 = (
	testSampleMethod: 'public NLR0: x = ( [^x] value. ^2) '
	with:
		'assert: (sample NLR0: 1) equals: 1.
	 	assert: (sample NLR0: 3) equals: 3.'
)
public testNLR1 = (
	testSampleMethod: 'public NLR1: x = ( x > 2 ifTrue: [^x]. ^2) '
	with:
		'assert: (sample NLR1: 1) equals: 2.
	 	assert: (sample NLR1: 3) equals: 3.'
)
public testNLR2 = (
	testSampleMethod: 'public NLR2: x = ( x > 2 ifTrue: [^x+1]. ^2) '
	with:
		'assert: (sample NLR2: 1) equals: 2.
	 	assert: (sample NLR2: 3) equals: 4.'
)
public testNLR3 = (
	testSampleMethod: 'public NLR3: x = ( [^x + 2] value. ^2) '
	with:
		'assert: (sample NLR3: 1) equals: 3.
	 	assert: (sample NLR3: 3) equals: 5.'
)
public testNLRInIf1 = (
	testSampleMethod: 'public depth: arg = (^arg ifTrue: [1] ifFalse: [^0].)'
	with:
		'assert: [true]. (*Mostly just checking for no error during compilation*)
		assert: [(sample depth: true) = 1].
		assert: [(sample depth: false) = 0].'
)
public testNLRInIf2 = (
	testSampleMethod: 'public depth: arg = (^arg ifTrue: [^1] ifFalse: [0].)'
	with:
		'assert: [true]. (*Mostly just checking for no error during compilation*)
		assert: [(sample depth: true) = 1].
		assert: [(sample depth: false) = 0].'
)
public testNLRInIf3 = (
	testSampleMethod: 'public depth: arg = (^arg ifTrue: [^1] ifFalse: [^0].)'
	with:
		'assert: [true]. (*Mostly just checking for no error during compilation*)
		assert: [(sample depth: true) = 1].
		assert: [(sample depth: false) = 0].'
)
public testNestedIWhileInIf = (
	testSampleMethod: 'public nestedWhileInIf = (| tf tg |
	tg:: 2*2*2*2.
	tg <1000
		ifTrue: [[tg < 10000] whileTrue: [tg:: tg *2]]
		ifFalse: [tg:: tg +200].
	^tg
	)'
	with:
		'assert: sample nestedWhileInIf equals: 16384'
)
public testNestedIfFalse = (
	testSampleMethod: 'public nestedIfFalse = (| ta tb  tc td te tf tg th | tf:: 37. tg:: tf *2.
tf < 32 ifTrue: [tf:: 64] ifFalse: [tf*tf > 100 ifTrue: [tf:: 96]]. ^tg + tf) '
	with:
		'assert: sample nestedIfFalse equals: 170'
)
public testNestedIfInWhile = (
	testSampleMethod: 'public nestedIfInWhile = (| tf tg |
	tf:: 50.
	tg:: tf *2.
	[tg < 10000] whileTrue: [
		tg > 1000 ifTrue: [
			tg:: tg *2
			] ifFalse: [
				tg:: tg +200.
			]
		].
	^tg)
	'
	with:
		'assert: sample nestedIfInWhile equals: 17600'
)
public testNestedIfTrue = (
	testSampleMethod: 'public nestedIfTrue = (| ta tb  tc td te tf tg th | tf:: 37. tg:: tf *2.
tf > 32 ifTrue: [tf*tf > 100 ifTrue: [tf:: 64] ifFalse: [tf:: 96]]. ^tg + tf) '
	with:
		'assert: sample nestedIfTrue equals: 138'
)
public testNilLiteral = (
	testSampleMethod: 'public nilLiteral = (nil)'
	with: 'assert: [sample = sample nilLiteral]'
)
public testOneParamBlock = (
	testSampleMethod: 'public oneParamBlock = (^[:x | x + 32] value:59) '
	with: 'assert: sample oneParamBlock equals: 91'
)
public testOperandStackDepth1 = (
	(* Regression - flushes out bug in operand stack depth required for closures *)
	testSampleMethod:
'public testOperandStackDepth1 = (
	100 timesRepeat:
		[{1. 2. 3} do:
			[:x | x = x ifTrue: []]].
)'
	with: 'assert: [sample testOperandStackDepth1 = sample]'
)
public testOuterBindings = (
	test:
		'class Sample = () (
			public class Sup = ()(
				protected baz = (^6)
			)
			public class Inner = Sup ()(
				public test1 = ( | bar = 1. | ^outer Sample bar)
				public test2 = ( | bar = 1. | ^outer Inner bar)
				private bar = (^2)
				public test3 = ( | baz = 4. | ^outer Inner baz)
			)
			private bar = (^3)
			private baz = (^5)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assert: sample Inner new test1 equals: 3.
				assert: sample Inner new test2 equals: 2.
				assert: sample Inner new test3 equals: 6.
			)
		)'.
)
public testOuterSendLegalTargets = (
	test:
		'class Sample = () (
			public class A = ()(
				public class C = ()(
					public foo = (^{outer C bar. outer A bar. outer Sample bar})
					public bar = (^1)
				) : (
					public foo = (^{outer C bar. outer A bar. outer Sample bar})
					public bar = (^2)
				)
				public class D = ()(
					public foo = (^{outer D bar. outer A bar. outer Sample bar})
					public bar = (^3)
				) : (
					public foo = (^{outer D bar. outer A bar. outer Sample bar})
					public bar = (^4)
				)
				public foo = (^{outer A bar. outer Sample bar})
				public bar = (^5)
			) : (
				public foo = (^{outer A bar. outer Sample bar})
				public bar = (^6)
			)
			public class B = ()(
				public class C = ()(
					public foo = (^{outer C bar. outer B bar. outer Sample bar})
					public bar = (^7)
				) : (
					public foo = (^{outer C bar. outer B bar. outer Sample bar})
					public bar = (^8)
				)
				public class D = ()(
					public foo = (^{outer D bar. outer B bar. outer Sample bar})
					public bar = (^9)
				) : (
					public foo = (^{outer D bar. outer B bar. outer Sample bar})
					public bar = (^10)
				)
				public foo = (^{outer B bar. outer Sample bar})
				public bar = (^11)
			) : (
				public foo = (^{outer B bar. outer Sample bar})
				public bar = (^12)
			)
			public foo = (^{outer Sample bar})
			public bar = (^13)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assertList: sample A new C new foo equals: {1. 5. 13}.
				assertList: sample A new C foo equals: {2. 5. 13}.
				assertList: sample A new D new foo equals: {3. 5. 13}.
				assertList: sample A new D foo equals: {4. 5. 13}.
				assertList: sample A new foo equals: {5. 13}.
				assertList: sample A foo equals: {6. 13}.
				assertList: sample B new C new foo equals: {7. 11. 13}.
				assertList: sample B new C foo equals: {8. 11. 13}.
				assertList: sample B new D new foo equals: {9. 11. 13}.
				assertList: sample B new D foo equals: {10. 11. 13}.
				assertList: sample B new foo equals: {11. 13}.
				assertList: sample B foo equals: {12. 13}.
				assertList: sample foo equals: {13}.
			)
		)'.
)
public testOuterSendToSibling = (
	assertCompilationErrorIn:
'class Sample = () (
 class Sibling = ()()
 class Nested = ()(method= (^outer Sibling yourself))
)'.
)
public testOuterSendToSlot = (
	assertCompilationErrorIn:
'class Sample = ( | slot | ) (
 class Nested = ()(method = (^outer slot yourself))
)'.
	assertCompilationErrorIn:
'class Sample = () (
 class Nested = ( | slot | )(method = (^outer slot yourself))
)'.
)
public testOverrideSelectorClass = (
	test:
		'class Sample = () (
			public class = (^42)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = ( | p |
				assert: sample class equals: 42.
			)
		)'.
)
public testOverrideSelectorIdentical = (
	test:
		'class Sample = () (
			public == other = (^42)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = ( | p |
				assert: (sample == sample) equals: 42.
			)
		)'.
)
public testParameterImmutabilityEnforced = (
	testSampleMethod: 'public immutableParem: x = ( x:: 10. )'
	with: 'assert: [sample immutableParem: 9] signals: Error.'
)
public testParameterTemporaryConflictInBlock = (
	assertCompilationErrorIn: 'class Sample = () (foo = ( [:x | | x | ] ))'.
)
public testParameterTemporaryConflictInMethod = (
	assertCompilationErrorIn: 'class Sample = () (foo: x = ( | x | ))'.
)
public testParseAccessors = (
	assertNoCompilationErrorIn:
		'class Sample = () (
			private wintergreen = (^true)
			protected schweik = (^true)
			public enemy = (^true)
			privateFirstClass = (^true)
			protectedSpeech = (^true)
			publicServant = (^true)
		)'
)
public testRemainderTowardNegInfinity = (
	testSampleMethod: ''
	with: '
assert: (13 \\ 5) equals: 3.
assert: (-13 \\ 5) equals: 2.
assert: (13 \\ -5) equals: -2.
assert: (-13 \\ -5) equals: -3.
assert: (5 \\ 13) equals: 5.
assert: (-5 \\ 13) equals: 8.
assert: (5 \\ -13) equals: -8.
assert: (-5 \\ -13) equals: -5.
assert: (16 \\ 8) equals: 0.
assert: (-16 \\ 8) equals: 0.
assert: (16 \\ -8) equals: 0.
assert: (-16 \\ -8) equals: 0.'
)
public testRemainderTowardZero = (
	testSampleMethod: ''
	with: '
assert: (13 rem: 5) equals: 3.
assert: (-13 rem: 5) equals: -3.
assert: (13 rem: -5) equals: 3.
assert: (-13 rem: -5) equals: -3.
assert: (5 rem: 13) equals: 5.
assert: (-5 rem: 13) equals: -5.
assert: (5 rem: -13) equals: 5.
assert: (-5 rem: -13) equals: -5.
assert: (16 rem: 8) equals: 0.
assert: (-16 rem: 8) equals: 0.
assert: (16 rem: -8) equals: 0.
assert: (-16 rem: -8) equals: 0.'
)
public testReservedWordsAsClasses = (
	assertCompilationErrorIn: 'class Sample = () ( class self = ()() )'.
	assertCompilationErrorIn: 'class Sample = () ( class super = ()() )'.
	assertCompilationErrorIn: 'class Sample = () ( class outer = ()() )'.
	assertCompilationErrorIn: 'class Sample = () ( class true = ()() )'.
	assertCompilationErrorIn: 'class Sample = () ( class false = ()() )'.
	assertCompilationErrorIn: 'class Sample = () ( class nil = ()() )'.
	assertNoCompilationErrorIn: 'class Sample = () ( class thisContext = ()() )'.
)
public testReservedWordsAsMessageSends = (
	(* For effect *)
	assertCompilationErrorIn: 'class Sample = () (foo = (super))'.
	assertCompilationErrorIn: 'class Sample = () (foo = (outer))'.
	(* For value *)
	assertCompilationErrorIn: 'class Sample = () (foo = (^super))'.
	assertCompilationErrorIn: 'class Sample = () (foo = (^outer))'.
)
public testReservedWordsAsMethods = (
	assertCompilationErrorIn: 'class Sample = ()( self = () )'.
	assertCompilationErrorIn: 'class Sample = ()( super = () )'.
	assertCompilationErrorIn: 'class Sample = ()( outer = () )'.
	assertCompilationErrorIn: 'class Sample = ()( true = () )'.
	assertCompilationErrorIn: 'class Sample = ()( false = () )'.
	assertCompilationErrorIn: 'class Sample = ()( nil = () )'.
	assertNoCompilationErrorIn: 'class Sample = ()( thisContext = () )'.
)
public testReservedWordsAsParams = (
	assertCompilationErrorIn: 'class Sample = ()( foo: self = () )'.
	assertCompilationErrorIn: 'class Sample = ()( foo: super = () )'.
	assertCompilationErrorIn: 'class Sample = ()( foo: outer = () )'.
	assertCompilationErrorIn: 'class Sample = ()( foo: true = () )'.
	assertCompilationErrorIn: 'class Sample = ()( foo: false = () )'.
	assertCompilationErrorIn: 'class Sample = ()( foo: nil = () )'.
	assertNoCompilationErrorIn: 'class Sample = ()( foo: thisContext = () )'.

	assertCompilationErrorIn: 'class Sample = ()( foo = ( [:self | ] ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( [:super | ] ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( [:outer | ] ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( [:true | ] ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( [:false | ] ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( [:nil | ] ) )'.
	assertNoCompilationErrorIn: 'class Sample = ()( foo = ( [:thisContext | ] ) )'.
)
public testReservedWordsAsSlots = (
	assertCompilationErrorIn: 'class Sample = ( | self | ) ()'.
	assertCompilationErrorIn: 'class Sample = ( | super | ) ()'.
	assertCompilationErrorIn: 'class Sample = ( | outer | ) ()'.
	assertCompilationErrorIn: 'class Sample = ( | true | ) ()'.
	assertCompilationErrorIn: 'class Sample = ( | false | ) ()'.
	assertCompilationErrorIn: 'class Sample = ( | nil | ) ()'.
	assertNoCompilationErrorIn: 'class Sample = ( | thisContext | ) ()'.
)
public testReservedWordsAsTemps = (
	assertCompilationErrorIn: 'class Sample = ()( foo = ( | self | ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( | super | ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( | outer | ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( | true | ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( | false | ) )'.
	assertCompilationErrorIn: 'class Sample = ()( foo = ( | nil | ) )'.
	assertNoCompilationErrorIn: 'class Sample = ()( foo = ( | thisContext | ) )'.
)
public testReservedWordsCorrespondingSetters = (
	testSampleMethod: 'public self: x = (^x)' with: 'assert: [1 = (sample self: 1)]'.
	testSampleMethod: 'public super: x = (^x)' with: 'assert: [2 = (sample super: 2)]'.
	testSampleMethod: 'public outer: x = (^x)' with: 'assert: [3 = (sample outer: 3)]'.
	testSampleMethod: 'public true: x = (^x)' with: 'assert: [4 = (sample true: 4)]'.
	testSampleMethod: 'public false: x = (^x)' with: 'assert: [5 = (sample false: 5)]'.
	testSampleMethod: 'public nil: x = (^x)' with: 'assert: [6 = (sample nil: 6)]'.
	testSampleMethod: 'public thisContext: x = (^x)' with: 'assert: [7 = (sample thisContext: 7)]'.
)
public testReturnAssignBooleanLiteral = (
	testSampleMethod: 'public returnAssignBooleanLiteral = (| t | ^t:: false) '
	with: 'assert: sample returnAssignBooleanLiteral equals: false'
)
public testReturnAssignCharacterLiteral = (
	testSampleMethod: 'public returnAssignCharacterLiteral = (| t | ^t:: "c") '
	with: 'assert: sample returnAssignCharacterLiteral equals: "c".'
)
public testReturnAssignFloatLiteral = (
	testSampleMethod: 'public returnAssignIntLiteral = (| t | ^t:: 3.14159) '
	with: 'assert: sample returnAssignIntLiteral equals: 3.14159.'
)
public testReturnAssignIntLiteral = (
	testSampleMethod: 'public returnAssignIntLiteral = (| t | ^t:: 42) '
	with: 'assert: sample returnAssignIntLiteral equals: 42.'
)
public testReturnAssignNil = (
	testSampleMethod: 'public returnAssignNil = (| t | ^t:: nil) '
	with: 'assert: sample returnAssignNil equals: nil'
)
public testReturnAssignParam = (
	testSampleMethod: 'public returnAssignParam: x = (| t | ^t:: x) '
	with: 'assert: (sample returnAssignParam: 91) equals: 91.'
)
public testReturnAssignStringLiteral = (
	testSampleMethod: 'public assignReturnStringLiteral = (| t | ^t:: ''abc'') '
	with: 'assert: sample assignReturnStringLiteral equals: ''abc''.'
)
public testReturnAssignSymbolLiteral = (
	testSampleMethod: 'public assignReturnSymbolLiteral = (| t | ^t:: #abc) '
	with: 'assert: sample assignReturnSymbolLiteral equals: #abc.'
)
public testReturnAssignTemps = (
	testSampleMethod: 'public returnAssignTemps = (| t1 t2 | ^t1:: t2) '
	with: 'assert: sample returnAssignTemps equals: nil.'
)
public testReturnBooleanLiteral = (
	testSampleMethod: 'public returnBooleanLiteral = (^false) '
	with: 'assert: sample returnBooleanLiteral equals: false.'
)
public testReturnCharacterLiteral = (
	testSampleMethod: 'public returnCharacterLiteral = (^"c") '
	with: 'assert: sample returnCharacterLiteral equals: "c".'
)
public testReturnClosure = (
	testSampleMethod: 'public returnClosure = (| t | t::1. ^[t:: t + 1]) '
	with:
	'| closure1 closure2 |
	closure1:: sample returnClosure.
	closure2:: sample returnClosure.
 	assert: closure1 value equals: 2.
 	assert: closure1 value equals: 3.
 	assert: closure2 value equals: 2.
 	assert: closure1 value equals: 4.
 	assert: closure2 value equals: 3.'
)
public testReturnConditionalClosure = (
	testSampleMethod:
		'public returnConditionalClosure = (| t | t::1.
		^[t > 1 ifFalse: [t::t * 2. t] ifTrue: [t:: t + 1]]) '
	with:
	'| closure1 closure2 |
	closure1:: sample returnConditionalClosure.
	closure2:: sample returnConditionalClosure.
 	assert: closure1 value equals: 2.
 	assert: closure1 value equals: 3.
 	assert: closure2 value equals: 2.
 	assert: closure1 value equals: 4.
 	assert: closure2 value equals: 3.'
)
public testReturnConditionalClosure2 = (
	testSampleMethod:
		'public returnConditionalClosure2 = (
	| t |
	t::1.
	^[ | x |
		x:: t > 1
			ifFalse: [t::t * 2. t]
			ifTrue: [t:: t + 1].
		x = t ifTrue: [| y z | y:: x -1.  z:: y + 1. z]
		]
	) '
	with:
	'| closure1 closure2 |
	closure1:: sample returnConditionalClosure2.
	closure2:: sample returnConditionalClosure2.
 	assert: closure1 value equals: 2.
 	assert: closure1 value equals: 3.
 	assert: closure2 value equals: 2.
 	assert: closure1 value equals: 4.
 	assert: closure2 value equals: 3.'
)
public testReturnFinalClosure = (
	testSampleMethod: 'public returnFinalClosure = (| t | t::1. ^[t ]) '
	with:
	'| closure1 closure2 |
	closure1:: sample returnFinalClosure.
	closure2:: sample returnFinalClosure.
	assert: closure1 value equals: 1.
	assert: closure1 value equals: 1.
 	assert: closure2 value equals: 1.
	assert: closure2 value equals: 1.'
)
public testReturnFloatLiteral = (
	testSampleMethod: 'public returnFloatLiteral = (^3.14159) '
	with: 'assert: sample returnFloatLiteral equals: 3.14159.'
)
public testReturnIntLiteral = (
	testSampleMethod: 'public returnIntLiteral = (^42) '
	with: 'assert: sample returnIntLiteral equals: 42.'
)
public testReturnNestedClosure = (
	testSampleMethod: 'public returnNestedClosure = (| t | t::1. ^[[t:: t + 1]]) '
	with:
	'| closure1 closure2 |
	closure1:: sample returnNestedClosure.
	closure2:: sample returnNestedClosure.
 	assert: closure1 value value equals: 2.
 	assert: closure1 value value equals: 3.
 	assert: closure2 value value equals: 2.
 	assert: closure1 value value equals: 4.
 	assert: closure2 value value equals: 3.'
)
public testReturnNil = (
	testSampleMethod: 'public returnNil = (^nil)'
	with: 'assert: sample returnNil equals: nil.'
)
public testReturnNoParamBlock = (
	testSampleMethod: 'public returnNoParamBlock = (^[false]) '
	with: 'assert: sample returnNoParamBlock value equals: false.'
)
public testReturnOneParamBlock = (
	testSampleMethod: 'public returnOneParamBlock = (^[:x | x ])'
	with: 'assert: (sample returnOneParamBlock value: 3) equals: 3.'
)
public testReturnOneParamBlockIncrement = (
	testSampleMethod: 'public returnOneParamBlockIncrement = (^[:x | x + 1]) '
	with: 'assert: (sample returnOneParamBlockIncrement value: 3) equals: 4.'
)
public testReturnOneParamBlockWithTemp = (
	testSampleMethod: 'public returnOneParamBlockWithTemp = (^[:x | | y | y:: x ]) '
	with: 'assert: (sample returnOneParamBlockWithTemp value: 3) equals: 3.'
)
public testReturnOneParamBlockWithTempIncrement = (
	testSampleMethod: 'public returnOneParamBlockWithTempIncrement = (^[:x | | y | y:: x. y + 1]) '
	with: 'assert: (sample returnOneParamBlockWithTempIncrement value: 3) equals: 4.'
)
public testReturnParam = (
	testSampleMethod: 'public returnParam: x = (^x) '
	with: 'assert: (sample returnParam: 91) equals: 91.'
)
public testReturnStringLiteral = (
	testSampleMethod: 'public returnStringLiteral = (^''abc'')'
	with: 'assert: sample returnStringLiteral equals: ''abc''.'
)
public testReturnSymbolLiteral = (
	testSampleMethod: 'public returnSymbolLiteral = (^#abc) '
	with: 'assert: sample returnSymbolLiteral equals: #abc.'
)
public testReturnTupleLiteral0 = (
	testSampleMethod: 'public returnTupleLiteral0 = (^{}) '
	with: 'assertList: sample returnTupleLiteral0 equals: {}.'
)
public testReturnTupleLiteral1 = (
	testSampleMethod: 'public returnTupleLiteral1 = (^{ 1 }) '
	with: 'assertList: sample returnTupleLiteral1 equals: { 1 }.'
)
public testReturnTupleLiteral16 = (
	testSampleMethod: 'public returnTupleLiteral16 = (^{ #abc.  0. "z".  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8.}) '
	with: 'assertList: sample returnTupleLiteral16 equals: { #abc.  0. "z".  ''def''. true. false. nil. sample.  1. 2. 3. 4. 5. 6. 7. 8.}'
)
public testReturnTupleLiteral2 = (
	testSampleMethod: 'public returnTupleLiteral2 = (^{ #abc.  1 }) '
	with: 'assertList: sample returnTupleLiteral2 equals: { #abc.  1 }.'
)
public testReturnTupleLiteral8 = (
	testSampleMethod: 'public returnTupleLiteral8 = (^{ #abc.  1. "z".  ''def''. true. false. nil. self }) '
	with: 'assertList: sample returnTupleLiteral8 equals: { #abc.  1. "z".  ''def''. true. false. nil. sample }'
)
public testReturnUnarySend = (
	test:
'class Sample = ( | public testSlot = 42. | ) (
	public returnUnarySend = (^testSlot)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (sample returnUnarySend = sample testSlot)
)'
)
testSampleMethod: sampleMethod <String> with: testMethodBody <String> = (
	test:
'class Sample = () (
',
	sampleMethod,
')'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (',
	testMethodBody,
	')
)'
)
public testSelectorInstanceInitializer = (
	testSampleMethod: 'public instanceInitializer = (^true)'
	with: 'assert: [sample instanceInitializer].'
)
public testSelfBindings = (
	test:
		'class Sample = () (
			public class Sup = ()(
				protected baz = (^6)
			)
			public class Inner = Sup ()(
				public test1 = ( | bar = 1. | ^self bar)
				private bar = (^2)
				public test2 = ( | baz = 4. | ^self baz)
			)
			private bar = (^3)
			private baz = (^5)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assert: sample Inner new test1 equals: 2.
				assert: sample Inner new test2 equals: 6.
			)
		)'.
)
public testSetter = (
	test:
		'class Sample = (
			| public slot public slot2 public slot3 |
		) (
			public method = (
				| local |
				local:: local:: 1.
				assert: [local = 1] description: ''Assertion failed: 1''.
				slot:: slot:: slot:: 2.
				assert: [slot = 2] description: ''Assertion failed: 2''.
				local:: slot:: 3.
				assert: [local = 3] description: ''Assertion failed: l3''.
				assert: [slot = 3] description: ''Assertion failed: s3''.
				local:: 4.
				^slot:: slot2:: slot3:: local
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			public test = (
				assert: [sample slot = nil] description: ''Assertion failed: slot = nil''.
				assert: [sample method = 4] description: ''Assertion failed: method = 4''.
				assert: [sample slot = 4] description: ''Assertion failed: slot = 4''.
				assert: [sample slot2 = 4] description: ''Assertion failed: slot2 = 4''.
				assert: [sample slot3 = 4] description: ''Assertion failed: slot3 = 4''.
			)
		)'
)
public testSlotDeclarationInInlinedLoop = (
(* Regression test for NS2Dart inlining. When the condition sequence was split, the slot declaration was duplicated, appearing both in the prologue and after the loop body. The variable in the loop body shadowed the one in the prologue, so the condition expression only ever sees the first value. *)
	testSampleMethod:
'public run = (
 | w ::= 0. |
  [ | t | t: w. t = w ifFalse: [assert: [false]] ifTrue: [w < 2]]
	whileTrue: [w: w+1]
)'
	with: 'assert: [sample = sample run]'
)
public testSlotInitializerInLoop = (
	(* Regression test for loop splitting bug in NS2Dart. *)
	testSampleMethod: ''
	with: '
| count ::= 0. |
[ | seven ::= 7. |
	assert: [seven = 7].
	seven: 6.
	count: count + 1.
	count = 3 ifTrue: [^self].
] repeat.'
)
public testSlotInitializerNotOverridable = (
	test:
'class Sample = () (
	class X = ( | public a = 1. public b = 2. | )()
	public class Y = X ( | public b = 3. public c = 4. | )( public superB = (^super b) )
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| y = sample Y new. |
		assert: y a equals: 1.
		assert: y superB equals: 2.
		assert: y b equals: 3.
		assert: y c equals: 4.
	)
)'
)
public testSlotInitializerNotOverridable2 = (
	test:
'class Sample = () (
	class X = ( | public a ::= 1. public b ::= 2. | )()
	public class Y = X ( | public b ::= 3. public c ::= 4. | )( public superB = (^super b) )
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| y = sample Y new. |
		assert: y a equals: 1.
		assert: y superB equals: 2.
		assert: y b equals: 3.
		assert: y c equals: 4.
	)
)'
)
public testSlotInitializerNotOverridable3 = (
	test:
'class Sample = () (
	class X = ( | public a ::= 1. public b ::= 2. | )()
	public class Y = X ( | public c ::= 4. | b: 3 )(
		public superB = (^super b) b: capture = ()
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| y = sample Y new. |
		assert: y a equals: 1.
		assert: y superB equals: 2.
		assert: y b equals: 2.
		assert: y c equals: 4.
	)
)'
)
public testSlotNamedSameAsFactory = (
(* Testing issue 108:
	If a slot with the name of the factory method exists, other slots are not initialized *)
	test:
'class Sample platform: p = (
|
	public foo = 42.
	platform
|) ()'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass platform: 23. | ) (
	public test = (assert: [sample foo = 42])
)'
)
public testStackDepthTracking2 = (
	testSampleMethod:
'createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	| lpProcessInformation lpStartupInfo result |
	lpProcessInformation:: PROCESS_INFORMATION newGC.
	lpStartupInfo:: STARTUPINFO newGC.
	Alien autoFreeAfter: [:autoFree |
		lpStartupInfo
			dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			wShowWindow: SW_HIDE;
			lpTitle: (autoFree value: (Alien newCString: title)) address;
			hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]);
			hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]);
			hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
		result:: self CreateProcess
			boolValue: 0 (*lpApplicationName*)
			value: (autoFree value: (Alien newCString: commandLine)) address
			value: 0 (*lpProcessAttributes*)
			value: 0 (*lpThreadAttributes*)
			value: 1 (*bInheritHandles*)
			value: 0 (*dwCreationFlags*)
			value: 0 (*lpEnvironment*)
			value: (autoFree value: (Alien newCString: dir fullName)) address
			value: lpStartupInfo address
			value: lpProcessInformation address.
		result ifFalse: [^reportError]].
	^Process new lpProcessInformation: lpProcessInformation
)'
	with: 'assert: [true].' (* Just checking no error during compilation.  Error is avoided by removing the cascaded sends. *)
)
public testStackDepthTracking3 = (
	testSampleMethod:
'createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	| lpProcessInformation lpStartupInfo result |
	lpProcessInformation:: PROCESS_INFORMATION newGC.
	lpStartupInfo:: STARTUPINFO newGC.
	Alien autoFreeAfter: [:autoFree |
		lpStartupInfo
			dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			wShowWindow: SW_HIDE;
			lpTitle: (autoFree value: (Alien newCString: title)) address;
			hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]);
			hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]);
			hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
		result:: self CreateProcess
			boolValue: 0 (*lpApplicationName*)
			value: (autoFree value: (Alien newCString: commandLine)) address
			value: 0 (*lpProcessAttributes*)
			value: 0 (*lpThreadAttributes*)
			value: 1 (*bInheritHandles*)
			value: 0 (*dwCreationFlags*)
			value: 0 (*lpEnvironment*)
			value: (autoFree value: (Alien newCString: dir fullName)) address
			value: lpStartupInfo address
			value: lpProcessInformation address.
		result ifFalse: [^reportError]].
	^Process new lpProcessInformation: lpProcessInformation
)'
	with: 'assert: [true].' (* Just checking no error during compilation.  Error is avoided by removing the cascaded sends. *)
)
public testStackDepthTracking4 = (
	testSampleMethod:
'createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	| lpStartupInfo |
	Alien autoFreeAfter: [:autoFree |
		lpStartupInfo
			dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			wShowWindow: SW_HIDE;
			lpTitle: (autoFree value: (Alien newCString: title)) address;
			hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]);
			hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]);
			hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
			^3
		].
)'
	with: 'assert: [true].' (* Just checking no error during compilation.  Error is avoided by removing the cascaded sends. *)
)
public testStringLiteral = (
	testSampleMethod: 'public stringLiteral = (''abc'')'
	with: 'assert: [sample = sample stringLiteral].'
)
public testSuperClassClause1 = (
	test:
'class Sample = () (
	public class SuperHierarchy = (
	) (
		public class Inner1 new: x = ( | v = x. |) (
			public foo = (
				^v + 42
			)
		)
			public makeInnerInstance = (^(Inner1 new: 1) foo)
	)
	public class SubHierarchy = SuperHierarchy (
	) (
		public class Inner1 new: x = super Inner1 new: x () (
			public foo = (
				^v * super foo
			)
		)
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| subklass superklass subInstance superInstance |
		superklass:: sample SuperHierarchy.
		superInstance:: superklass new.
		assert: [superInstance Inner1 = superInstance Inner1].
		assert: [(superInstance Inner1 new: 2) foo = 44].
		subklass:: sample SubHierarchy.
		subInstance:: subklass new.
		assert: [subInstance Inner1 = subInstance Inner1].
		assert: [(subInstance Inner1 new: 2) foo = 88].
	)
)'
)
public testSuperClassClause2 = (
	test:
'class Sample = () (
	public class InnerHierarchy = (
	) (
		public class Inner1 new: x = ( | v = x. |) (
			public foo = (
				^v + 42
			)
		)
		public class InnerInnerHierarchy = () (
			public class Inner1 new: x = outer InnerHierarchy Inner1 new: x () (
				public foo = (
					^v * super foo
				)
			)
		)
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| innerInnerklass innerklass innerInnerInstance innerInstance |
		innerklass:: sample InnerHierarchy.
		innerInstance:: innerklass new.
		assert: [innerInstance Inner1 = innerInstance Inner1].
		assert: [(innerInstance Inner1 new: 2) foo = 44].
		innerInnerklass:: innerInstance InnerInnerHierarchy.
		innerInnerInstance:: innerInnerklass new.
		assert: [innerInnerInstance Inner1 = innerInnerInstance Inner1].
		assert: [(innerInnerInstance Inner1 new: 2) foo = 88].
	)
)'
)
public testSuperClassClause3 = (
	test:
'class Sample = () (
	public class Inner0 new: x = ( | v = x. |) (
		public foo = (
			^v + 42
		)
	)
	public class Inner1 new: x = outer Sample Inner0 new: x () (
		public foo = (
			^v * super foo
		)
	   )
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| innerklass0 innerklass1 innerInstance0 innerInstance1 |
		innerklass0:: sample Inner0.
		assert: [(innerklass0 new: 2) foo = 44].
		innerklass1:: sample Inner1.
		assert: [(innerklass1 new: 2) foo = 88].
	)
)'
)
public testSuperClassClause4 = (
	test:
'class Sample = () (
	public class Inner0 new: x = ( | v = x. |) (
		public foo = (
			^v + 42
		)
	)
	public class Inner1 new: x = self Inner0 new: x () (
		public foo = (
			^v * super foo
		)
	   )
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		| innerklass0 innerklass1 innerInstance0 innerInstance1 |
		innerklass0:: sample Inner0.
		assert: [(innerklass0 new: 2) foo = 44].
		innerklass1:: sample Inner1.
		assert: [(innerklass1 new: 2) foo = 88].
	)
)'
)
public testSymbolLiteral = (
	testSampleMethod: 'public symbolLiteral = (#abc)'
	with: 'assert: [sample = sample symbolLiteral].'
)
public testSymbolLiteralBlock = (
	testSampleMethod: 'public symbolLiteralBlock = (^[#xx])'
	with: 'assert: [#xx = sample symbolLiteralBlock value].'
)
public testTargetReservedWords = (
	(* To stress the name mangler, try to define slots/temps with identifiers that are often reserved words in target languages. The temporaries are split across two methods to avoid hitting the Squeak limit of 63.*)

	assertNoCompilationErrorIn: 'class Sample = (
	| abstract as assert boolean break byte case catch class const continue debugger default delete do double dynamic else enum export extends factory final finally float for function get goto if in implements import is int instanceof interface long native negate new null operator package private protected public return set short static switch synchronized this throw throws transient try typedef typeof use var void volatile while with |
	)(
	foo = (
		| abstract as assert boolean break byte case catch class const continue debugger default delete do double dynamic else enum export extends factory final finally float for function get goto if in implements import |
	)
	bar = (
		| is int instanceof interface long native negate new null operator package private protected public return set short static switch synchronized this throw throws transient try typedef typeof use var void volatile while with |
	))'
)
public testTempInInstanceInitializer = (
	test:
'class Sample = (
	| public slot ::= 0. |
   1 to: 10 do: [:n |
	| temp |
	temp:: n * n.
	slot:: slot + temp.
 ].
) ()'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	public test = (
		assert: sample slot equals: 385.
	)
)'
)
public testTemporaryTemporaryConflictInClosure = (
	assertCompilationErrorIn: 'class Sample = () (foo = ( ^[ | x x | ] ))'.
)
public testTemporaryTemporaryConflictInMethod = (
	assertCompilationErrorIn: 'class Sample = () (foo = ( | x x | ))'.
)
public testThisContext = (
	testSampleMethod: 'public testThisContext = ( ^thisContext )'
	with: 'assert: [sample testThisContext] signals: Error.'  (* MessageNotUnderstood *)
)
public testTimesRepeat = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'public testTimesRepeat = (
	| ta tb  tc td te tf tg th |
	tf:: 37.
	tf timesRepeat: [tf:: tf +1].
	^tf
	 ) '
	with: 'assert: sample testTimesRepeat equals: 74.'
)
public testTimesRepeatNonLiteralBlock = (
	testSampleMethod: 'public testTimesRepeatNonLiteralBlock = (
		| sum ::= 0. block = [sum:: sum + 1]. |
		10 timesRepeat: block.
		^sum
	)'
	with: 'assert: sample testTimesRepeatNonLiteralBlock equals: 10.'
)
public testToByDo1 = (
	testSampleMethod: 'public testToByDo1 = (
	| ta tb  tc td te tf tg th |
	tf:: 37.
	tf to: 74 by: 1 do: [:i <integer> | tf:: tf +1].
	^tf
	 ) '
	with: 'assert: sample testToByDo1 equals: 75.'
)
public testToByDo2 = (
	testSampleMethod: 'public testToByDo2 = (
	| ta tb  tc td te tf tg th |
	tf:: 37.
	tf to: 74 by: 36 do: [:i <integer> | tf:: tf +1].
	^tf
	 ) '
	with: 'assert: sample testToByDo2 equals: 39.'
)
public testToByDoNonLiteralBlock = (
	testSampleMethod: 'public testToByDoNonLiteralBlock = (
		| sum ::= 0. block = [:value | sum:: sum + value]. |
		0 to: 100 by: 25 do: block.
		^sum
	) '
	with: 'assert: sample testToByDoNonLiteralBlock equals: 250.'
)
public testToByDoNonLiteralStep = (
	testSampleMethod: 'public testToByDoNonLiteralStep = (
		| start = 0. stop = 100. step = 25. sum ::= 0. |
		start to: stop by: step do: [:value | sum:: sum + value].
		^sum
	) '
	with: 'assert: sample testToByDoNonLiteralStep equals: 250.'
)
public testToDo1 = (
	testSampleMethod: 'public testToDo1 = (
		| ta tb tc td te tf tg th |
		tf:: 37.
		tf to: 74 do: [:i <integer> | tf:: tf +1].
		^tf
	)'
	with: 'assert: sample testToDo1 equals: 75.'
)
public testToDo2 = (
	testSampleMethod: 'public testToDo2 = (
		| ta tb tc td te tf tg th |
		tf:: 37.
		tf to: tf * 2 do: [:i <integer> | tf:: tf +1].
		^tf
	)'
	with: 'assert: sample testToDo2 equals: 75.'
)
public testToDo3 = (
	testSampleMethod: 'public testToDo3 = (
		| ta tb  tc td te tf tg th |
		tf:: 37.
		tf to: tf*2  do: [:i <integer> | tf:: i].
		^tf
	)'
	with: 'assert: sample testToDo3 equals: 74.'
)
public testToDoNonLiteralBlock = (
	testSampleMethod: 'public testToDoNonLiteralBlock = (
		| sum ::= 0. block = [:value | sum:: sum + value]. |
		0 to: 10 do: block.
		^sum
	) '
	with: 'assert: sample testToDoNonLiteralBlock equals: 55.'
)
public testToDoByCapturesUniqueVariables = (
	testSampleMethod: 'public testToDoByCapturesUniqueVariables = (
	| closures = Array new: 5. |
	1 to: 5 by: 2 do: [:i | closures at: i put: [i]].
	assert: (closures at: 1) value equals: 1.
	assert: (closures at: 3) value equals: 3.
	assert: (closures at: 5) value equals: 5.
	)'
	with: 'sample testToDoByCapturesUniqueVariables'
)
public testToDoCapturesUniqueVariables = (
	testSampleMethod: 'public testToDoCapturesUniqueVariables = (
	| closures = Array new: 3. |
	1 to: 3 do: [:i | closures at: i put: [i]].
	assert: (closures at: 1) value equals: 1.
	assert: (closures at: 2) value equals: 2.
	assert: (closures at: 3) value equals: 3.
	)'
	with: 'sample testToDoCapturesUniqueVariables'
)
public testTupleLiteral0 = (
	testSampleMethod: 'public tupleLiteral0 = ({})'
	with: 'assert: [sample = sample tupleLiteral0].'
)
public testTupleLiteral1 = (
	testSampleMethod: 'public tupleLiteral1 = ({ 1 }) '
	with: 'assert: [sample = sample tupleLiteral1].'
)
public testTupleLiteral16 = (
	testSampleMethod: 'public tupleLiteral16 = ({ #abc.  0. "z".  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8.}) '
	with: 'assert: [sample = sample tupleLiteral16].'
)
public testTupleLiteral2 = (
	testSampleMethod: 'public tupleLiteral2 = ({ #abc.  1 }) '
	with: 'assert: [sample = sample tupleLiteral2].'
)
public testTupleLiteral8 = (
	testSampleMethod: 'public tupleLiteral8 = ({ #abc.  1. "z".  ''def''. true. false. nil. self }) '
	with: 'assert: [sample = sample tupleLiteral8].'
)
public testTupleOfIntegers = (
	(* Regression test against fraction literals useing a token dot instead of a character dot. *)
	testSampleMethod: ''
	with: '
assert: [{1. 2} size = 2].
assert: [{1 .2} size = 2].
assert: [{1 . 2} size = 2].
assert: [{16r1. 2} size = 2].
assert: [{16r1 .2} size = 2].
assert: [{16r1 . 2} size = 2].
'
)
public testTwoParamBlock = (
	testSampleMethod: 'public twoParamBlock = (^[:x :y | x -y] value: 91 value: 49) '
	with: 'assert: [42 = sample twoParamBlock].'
)
public testWhileFalse = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'public testWhileFalse = (| ta tb  tc td te tf tg th | tf:: 37. tg:: tf *2.
[tg:: tg *2. tg > 10000] whileFalse.
^tg)'
	with: 'assert: sample testWhileFalse equals: 18944.'
)
public testWhileFalseColon = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'public testWhileFalseColon = (| ta tb  tc td te tf tg th | tf:: 37. tg:: tf *2.
[tg >= 10000] whileFalse: [tg:: tg *2].
^tg)'
	with: 'assert: sample testWhileFalseColon equals: 18944.'
)
public testWhileTrue = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'public testWhileTrue = (| ta tb  tc td te tf tg th | tf:: 37. tg:: tf *2.
[tg:: tg *2. tg < 10000] whileTrue.
^tg)'
	with: 'assert: sample testWhileTrue equals: 18944.'
)
public testWhileTrueColon = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'public testWhileTrueColon = (| ta tb  tc td te tf tg th | tf:: 37. tg:: tf *2.
[tg < 10000] whileTrue: [tg:: tg *2].
^tg)'
	with: 'assert: sample testWhileTrueColon equals: 18944.'
)
public testWhileWithScope = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'public testWhileWithScope = ( | i n |
i:: 5.
n:: 1.
[ | j | j:: 0. i > j] whileTrue: [i:: i -1. n:: n*2].
^n
) '
	with: 'assert: sample testWhileWithScope equals: 32.'
)
) : (
TEST_CONTEXT = (
)
)
TODO = (
	(* A marker method. Look for senders to find methods that still need work. *)
)
test: sampleClassSource <String> with: testClassSource <String> = (
	testingStrategy test: sampleClassSource with: testClassSource
)
) : (
)