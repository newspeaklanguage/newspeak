Newspeak3
'Root'
class VoiceController recognizer: sr transcript: t editor: anEditor = (
(* WIP, largely written by ChatGPT.
A speech recognizer for coding Newspeak and controlling the IDE.
*)
|
    webSpeech = sr.
    transcript = t.

    editor   = (*DummyEditor new *) anEditor.         (* Abstraction over the Newspeak editor*)
  (* Internal state*)

    public mode ::= #command.   (* Either #command or #code *)
    listening ::= false.
    interimTranscript ::= ''.
    lastFinalTranscript ::= ''.
  (* Optional UI callbacks *)
    public onInterimTranscript ::=  [ :text | ('[interim] ', text) out].
    public onFinalTranscript ::= [ :text | ('[final] ', text) out].
    public onStatusChanged ::= [ :msg | ('[status] ', msg) out].
|
) (
class DummyEditor = () (
public goToNextMethod = (
    '[DummyEditor] goToNextMethod' out.
  )
public goToPreviousMethod = (
    '[DummyEditor] goToPreviousMethod' out.
  )
public goToMethodNamed: aName = (
    ('[DummyEditor] goToMethodNamed: ', aName) out.
  )
public selectCurrentLine = (
    '[DummyEditor] selectCurrentLine' out.
  )
public selectCurrentMethod = (
    '[DummyEditor] selectCurrentMethod' out.
  )
public selectCurrentBlock = (
    '[DummyEditor] selectCurrentBlock' out.
  )
public deleteCurrentLine = (
    '[DummyEditor] deleteCurrentLine' out.
  )
public commentSelection = (
    '[DummyEditor] commentSelection' out.
  )
public formatSelection = (
    '[DummyEditor] formatSelection' out.
  )
public runCurrentProgram = (
    '[DummyEditor] runCurrentProgram' out.
  )
public runTests = (
    '[DummyEditor] runTests' out.
  )
public toggleConsole = (
  '[DummyEditor] toggleConsole' out.
)
public insertTextAtCaret: text = (
    ('[DummyEditor] insertTextAtCaret: ', text) out.
)
public back = (
    '[DummyEditor] back' out.
  )
public forward = (
    '[DummyEditor] forward' out.
  )
public goHome = (
    '[DummyEditor] goHome' out.
  )
public showHistory = (
    '[DummyEditor] showHistory' out.
  )
public refresh = (
    '[DummyEditor] refresh' out.
  )
public showHelp = (
    '[DummyEditor] showHelp' out.
  )
public showReferences = (
    '[DummyEditor] showReferences' out.
  )
public showTests = (
    '[DummyEditor] showTests' out.
  
  )
public expand = (
    '[DummyEditor] expand' out.
  )
public collapseAll = (
    '[DummyEditor] collapseAll' out.
  )
public expandAll = (
    '[DummyEditor] expandAll' out.
  )
public collapse = (
    '[DummyEditor] collapse' out.
  )
) : (
)
lazy speechRecognizer ::= webSpeech new
  at: #continuous     put: true;
  at: #interimResults put: true;
  at: #lang           put: 'en-US';
  at: #onresult       put: [ :event | self handleResultEvent: event. nil];
  at: #onerror        put: [ :event | self handleErrorEvent: event. nil ];
  at: #onend          put: [ :event | self handleEndEvent: event. nil ];
  yourself.
public start = (
    listening ifTrue: [ ^self ].
    speechRecognizer start.
    listening:: true.
    self statusChanged: 'listening'.
  )
public stop = (
    listening ifFalse: [ ^self ].
    speechRecognizer stop.
    listening:: false.
    self statusChanged: 'stopped'.
  )
public toggleMode = (
    mode:: (mode == #command ifTrue: [ #code ] ifFalse: [ #command ]).
    self statusChanged: ('mode: ', mode asString).
  )
public setModeToCommand = (
    mode:: #command.
    self statusChanged: 'mode: command'.
  )
public setModeToCode = (
    mode:: #code.
    self statusChanged: 'mode: code'.
  )
isCommandMode = ( ^mode == #command )
isCodeMode    = ( ^mode == #code )
handleCommandTranscript: text = (
    (*For now, implement a tiny pattern-based parser.
     Later, you can plug in an LLM or a more structured command grammar.*)

    (self tryHandleNavigationCommand: text) ifTrue: [ ^self ].
    (self tryHandleSelectionCommand: text) ifTrue: [ ^self ].
    (self tryHandleEditingCommand:   text) ifTrue: [ ^self ].
    (self tryHandleUICommand:        text) ifTrue: [ ^self ].

    (* Fallback: unknown command *)
    self statusChanged: ('unrecognized command: ', text).
  )
handleCodeTranscript: text = (
    (*First naive version: convert some obvious spoken punctuation to characters,
     then insert at the caret. Later you swap this for something smarter
     (AST-based or LLM-backed).*)

    | normalized = normalizeCodeSpeech: text. |

    editor insertTextAtCaret: normalized.
  )
normalizeCodeSpeech: text = (
    | lower  = text asLowercase.
      tokens = lower splitOnWhitespace.
      builder ::= ''.
    |
    tokens do: [ :t |
      builder addAll:
        (t = 'colon'       ifTrue: [ ':' ]
         ifFalse: (t = 'comma'   ifTrue: [ ',' ]
         ifFalse: (t = 'dot'     ifTrue: [ '.' ]
         ifFalse: (t = 'equals'  ifTrue: [ ' = ' ]
         ifFalse: (t = 'newline' ifTrue: [ '\n' ]
           ifFalse: t))))).
	   
      builder add: '$' .  
    ].
    ^builder
  )
handleResultEvent: event = (
  | results = event at: #results.
    index   = event at: #resultIndex.
    final   ::= ''.
    interim ::= ''.
    length  = results at: #length.
  |

  (index to: length - 1) do: [ :i |
    | result = results at: i. 
      alt    = result at: 0.
      text   = alt at: #transcript.
      isFinal = result at: #isFinal.
    |
    isFinal
      ifTrue:  [ final:: final, text ]
      ifFalse: [ interim:: interim, text ].
  ].

  interim isEmpty ifFalse: [ self handleInterimTranscript: interim ].
  final   isEmpty ifFalse: [ self handleFinalTranscript: final ].
)
handleInterimTranscript: text = (
    interimTranscript:: text.
    onInterimTranscript value: text.
  )
handleFinalTranscript: text = (
    interimTranscript:: ''.
    lastFinalTranscript:: text.
    onFinalTranscript value: text.
    self handleTranscript: text
  )
handleErrorEvent: event = (
  | error = event at: #error. |
  self statusChanged: ('speech error: ', error printString).
)
handleTranscript: text = (
    (* Simple router based on current mode and maybe magic phrases.*)
    | trimmed = text withBlanksTrimmed. |

    (self isCommandMode and: [ self isExplicitModeSwitchCommand: trimmed ])
      ifTrue: [ ^self handleModeSwitchCommand: trimmed ].

    self isCommandMode
      ifTrue:  [ self handleCommandTranscript: trimmed ]
      ifFalse: [ self handleCodeTranscript: trimmed ].
  )
isExplicitModeSwitchCommand: text = (
    (* You can expand this over time; for now just a few phrases. Worry about lower/upper case later *)
    ^{ 'switch to code mode'.
       'code mode'.
       'switch to command mode'.
       'command mode' } anySatisfy: [ :phrase |
      text asLowercase = phrase
    ]
  )
tryHandleEditingCommand: text = (
    | lower = text asLowercase. |
    (lower = 'delete line')
      ifTrue: [ editor deleteCurrentLine. ^true ].

    (lower = 'comment selection')
      ifTrue: [ editor commentSelection. ^true ].

    (lower = 'format selection')
      ifTrue: [ editor formatSelection. ^true ].

    ^false
  )
tryHandleNavigationCommand: text = (
    | lower = text asLowercase. |
    (lower = 'go to next method')
      ifTrue: [ editor goToNextMethod. ^true ].

    (lower = 'go to previous method')
      ifTrue: [ editor goToPreviousMethod. ^true ].

    (lower startsWith: 'go to method ')
      ifTrue: [
        | name = (text copyFrom: 'go to method ' size + 1 to: text size) withBlanksTrimmed. |
        editor goToMethodNamed: name.
        ^true
      ].

    ^false
  )
tryHandleSelectionCommand: text = (
    | lower = text asLowercase. |
    (lower = 'select line')
      ifTrue: [ editor selectCurrentLine. ^true ].

    (lower = 'select method')
      ifTrue: [ editor selectCurrentMethod. ^true ].

    (lower = 'select block')
      ifTrue: [ editor selectCurrentBlock. ^true ].

    ^false
  )
handleModeSwitchCommand: text = (
    | lower = text asLowercase. |
    (lower includesSubstring: 'code')
      ifTrue: [setModeToCode ]
      ifFalse: [setModeToCommand ].
  )
statusChanged: message = (
    onStatusChanged value: message.
    transcript show: '[Voice] ', message
  )
handleEndEvent: event = (
  (* Only restart if we *expect* to be listening *)
  listening ifTrue: [
    '[VoiceController] restarting after onend' out.
    speechRecognizer start.
  ].
)
tryHandleUICommand: text = (
    | lower = text asLowercase. |
    
    (* VoiceController-level commands *)
    (lower = 'stop')
      ifTrue: [
        self stop.
        ^true
      ].


    (* Existing commands *)
    (lower = 'run program')
      ifTrue: [ editor runCurrentProgram. ^true ].

    (lower = 'run tests')
      ifTrue: [ editor runTests. ^true ].

    (lower = 'toggle console')
      ifTrue: [ editor toggleConsole. ^true ].


    (* New IDE/navigation commands *)

    (lower = 'back')
      ifTrue: [ editor goBack. ^true ].

    (lower = 'go back')
      ifTrue: [ editor goBack. ^true ].

    (lower = 'forward')
      ifTrue: [ editor goForward. ^true ].

    (lower = 'go forward')
      ifTrue: [ editor goForward. ^true ].

    (lower = 'home')
      ifTrue: [ editor goHome. ^true ].

    (lower = 'go home')
      ifTrue: [ editor goHome. ^true ].

    (lower = 'history')
      ifTrue: [ editor showHistory. ^true ].

    (lower = 'show history')
      ifTrue: [ editor showHistory. ^true ].

    (lower = 'refresh')
      ifTrue: [ editor refresh. ^true ].

    (lower = 'reload')
      ifTrue: [ editor refresh. ^true ].

    (lower = 'help')
      ifTrue: [ editor showHelp. ^true ].

    (lower = 'show help')
      ifTrue: [ editor showHelp. ^true ].

    (lower = 'references')
      ifTrue: [ editor showReferences. ^true ].

    (lower = 'show references')
      ifTrue: [ editor showReferences. ^true ].

    (lower = 'show tests')
      ifTrue: [ editor showTests. ^true ].
      
    (lower = 'workspace')
      ifTrue: [ editor openWorkspaces. ^true].
      
    (lower = 'namespace')
      ifTrue: [ editor openRootNamespace. ^true ].      
      
    (lower startsWith: 'go to')
       ifTrue: [ | words = lower splitOnWhitespace. |
         editor goTo: (words copyFrom: 3 to: words size). 
         ^true 
        ].      
   
       (lower startsWith: 'references to')
       ifTrue: [ | words = lower splitOnWhitespace. |
         editor showReferencesTo: (words copyFrom: 3 to: words size). 
         ^true 
        ].  
    (* Expand / collapse structure in the IDE *)

    (lower = 'expand')
      ifTrue: [ editor expand. ^true ].

    (lower = 'collapse')
      ifTrue: [ editor collapse. ^true ].

    (lower = 'expand all')
      ifTrue: [ editor expandAll. ^true ].

    (lower = 'collapse all')
      ifTrue: [ editor collapseAll. ^true ].   

    ^false
)
) : (
public usingPlatform: p editor: e ^ <Instance>
(* Usually, this would be the factory. However, this class is used by Hopscotch, and bootstrapping constraints prevent access to JS during hopscotch instantiation. So this class must be instantiated lazily by hopscotch. In turn, this means that the class factory must not require platform access, but only the elements that it needs, which can be provided later. 

On the other hand, the reason this class is not internal to Hopscotch is that it may be useful independently. To faciliate such use, this secondary factory method is used.
*)
  = (
  ^recognizer: (p js global at: #webkitSpeechRecognition) transcript: p transcript editor: e
)
)
