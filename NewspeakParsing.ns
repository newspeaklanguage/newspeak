Newspeak3
'Newspeak'
class NewspeakParsing usingPlatform: platform grammar: grammar asts: asts = ((* The Newspeak parser.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2010 Felix Geller and Ryan Macnak
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
	private List = platform collections List.

	private TypedGrammar = grammar TypedNS3Grammar.
	
	private BinaryTypeOpAST = asts BinaryTypeOpAST.
	private BlockAST = asts BlockAST.
	private BlockTypeAST = asts BlockTypeAST.
	private CascadedSendAST = asts CascadedSendAST.
	private CharacterAST = asts CharacterAST.
	private ClassBodyAST = asts ClassBodyAST.
	private ClassDeclarationAST = asts ClassDeclarationAST.
	private ClassHeaderAST = asts ClassHeaderAST.
	private ClassPrefixAST = asts ClassPrefixAST.
	private CodeBodyAST = asts CodeBodyAST.
	private ImmutableSlotDefAST = asts ImmutableSlotDefAST.
	private InitializerAST = asts InitializerAST.
	private ParameterizedTypeAST = asts ParameterizedTypeAST.
	private MessageAST = asts MessageAST.
	private MessagePatternAST = asts MessagePatternAST.
	private MethodAST = asts MethodAST.
      private MixinApplicationClassAST = asts MixinApplicationClassAST.
	private MutableSlotDefAST = asts MutableSlotDefAST.
	private UnresolvedSendAST = asts UnresolvedSendAST.
	private NumberAST = asts NumberAST.
	private ReturnStatAST = asts ReturnStatAST.
	private SetterSendAST = asts SetterSendAST.
	private SideAST = asts SideAST.
	private StringAST = asts StringAST.
	private SymbolAST = asts SymbolAST.
	private TupleAST = asts TupleAST.
	private TypeIdAST = asts TypeIdAST.
	private UnaryTypeOpAST = asts UnaryTypeOpAST.
	private VarDeclAST = asts VarDeclAST.
	private VariableAST = asts VariableAST.

	private MixinApplicationAST = asts MixinApplicationAST.

	(* patterns *)
	private KeywordPatternAST = asts KeywordPatternAST.
	private KeywordPatternPairAST = asts KeywordPatternPairAST.
	private WildcardPatternAST = asts WildcardPatternAST.
	private LiteralPatternAST = asts LiteralPatternAST.
	private VariablePatternAST = asts VariablePatternAST.
|) (
public class InternalParser = Parser ((* A parser able to handle identifiers involving the backquote character, `. 
Such identifiers are illegal in regular Newspeak code, and are used as synthetic names in generated code, precisely because they cannot conflict with user code.

Synthetic code that references such identifiers cannot be processed by the usual parser pipeline, and has often been manufactured by tedious and error prone manual AST construction.

The intent is that instead, such code could be written as source code and parsed using this parser, producing a valid AST that the rest of the compiler can use.
*)|
  backTick = char: "`".
  backTickIdentifier = tokenFor:( 
		(letter | _ | backTick),  ((letter | digit | _ | backTick)) star
                 wrapper:[:fst   :snd  | String fromRunes: {fst}, snd]
	).
|) (
public identifier = (
  ^backTickIdentifier
)
) : (
)
public class Parser = TypedGrammar ((* Parser for Newpeak. Produces a Newspeak AST. This tree represents syntax only. No attribution information such as scopes/symbol tables, types etc. is present in the tree. The tree  only gives its structure and the source code positions of the nodes.

The parser works by overridding the accessors for most grammar productions in its superclasses. The superclass methods deal with the grammar alone; each production defines a parser that will parse the syntax and return the corresponding set of tokens. The methods here process the output of the superclass methods to yield parsers that will construct ASTs. Hence, the typical method for a production foo is something like

foo

^super foo wrapper:[:w :x :y :z | FooAST new from: x and: y; start: w start; end: z end]

This example assumes that the semantic content of foo is given by x and y. Typically, x and y will be the results of  productions that have also been overridden, to provide  ASTs that will be subtrees of the Foo node. In contarst, w and z are likely to be tokens used in the concrete syntax to delimit the Foo construct. They may (or may not) be used to extract source code position information, and then discarded. *)) (
public accessModifier = (
	^super accessModifier wrapper: [:am :ws | am]
)
public binaryExpression = (
	^super binaryExpression wrapper:
		[:ue :bmsgs | (* unaryExpression binaryMsg* *)
		bmsgs inject: ue into:
			[:receiverExpr :b <MessageAST> |
				UnresolvedSendAST new
					to: receiverExpr send: b;
					left: receiverExpr; right: b]]
)
public binaryMsg ^ <MessageAST> = (
	^super binaryMsg wrapper:
		[:esend :b :e |
		| args = {e}. |
		MessageAST new 
			send: b value with: args;
			isEventual: (nil = esend) not;
			start: b start;
			right: e].
)
public binaryMsgPattern = (

^super binaryMsgPattern
    wrapper:[:sel :p  |
                | params |
                 params:: List new add:p; yourself.
                 MessagePatternAST new selector: sel value parameters: params ;
                                              start: sel start; right: p            
               ].
)
public block = (
	^super block wrapper:
		[:lb :params :cb :rb |
		| ps |
		ps:: params isNil ifTrue: [List new] ifFalse: [params].
		cb parameters: ps.
		BlockAST new 
			body: cb;
			start: lb start; end: rb end]
)
public blockArgType = (
	^super blockArgType wrapper: 
		[:c :rt | 
		rt concreteStart: c start.
		rt]
)
public blockParameter = (
	^super blockParameter wrapper:
		[:c :v  | 
		v concreteStart: c start.
		v]                             
)
public blockParameters = (
	^super blockParameters wrapper:
		[:params :vb  | 
		params last concreteEnd: vb end. (* dubious *)
		params]
)
public blockType = (
	^super blockType wrapper: 
		[:lb :tas :rb |
		(nil = tas 
			ifTrue: 
				[BlockTypeAST
					formals: {}
					return: (TypeIdAST new name: #Object)]
			ifFalse: 
				[ | fs r |
				tas isCollection
					ifTrue: [fs:: tas. r:: fs removeLast] 
					ifFalse: [fs:: {}. r:: tas].
				BlockTypeAST
					formals: fs
					return: r])
		start: lb start;
		end: rb end].
)
public blockTypeArgList = (
	^super blockTypeArgList wrapper:
		[:tas :rt | 
		| targs |
		targs:: tas collect: [:p | p last].
		nil = rt 
			ifTrue: [targs addLast: (TypeIdAST new name: #Object)]
			ifFalse: [targs add: rt].
		targs]
)
public cascadeMsg = (

^super cascadeMsg
    wrapper:[:sm :msg  | msg].
                                
                         
)
public cascadedMessageExpression ^ <CascadedSendAST> = (

^super cascadedMessageExpression
          wrapper:[:p <ExpressionAST> 
				:msgs <Tuple[Tuple[List[MessageAST], List[MessageAST], MessageAST], List[MessageAST]]>  |
				| 
				se <SendAST> 
				unaries <List[MessageAST]> 
				binaries <List[MessageAST]> 
				kwMsg <MessageAST> 
				cascade  <List[MessageAST]> 
				unarySend <ExpressionAST>  
				binarySend <ExpressionST> 
				|
				(* primary [msgCascade] *)
				msgs isNil 
					ifTrue:[p]
					ifFalse:[
							unaries:: msgs first first.
							binaries:: msgs first at: 2.
							kwMsg:: msgs first last.
							cascade:: msgs last.
							unarySend:: sendMessages: unaries to: p.
							binarySend:: sendMessages: binaries to: unarySend.
							se:: kwMsg isNil 
								ifTrue:[binarySend] 
								ifFalse:[sendMessages: {kwMsg} to: binarySend].
                       				cascade inject: se into:[:e  <SendAST> :m  <MessageASAT> |
                                                     CascadedSendAST new to: e cascade: m;
													left: e;  right: m                
                                                    ]  
							]
]      
                     
)
public characterConstant = (
	^super characterConstant wrap: 
		[:t | 
		| v ::= (Character fromRune: (t value at: 2)). |
		v isString ifTrue: [v:: v asSymbol].
		CharacterAST new value: v; start: t start; end: t end].
)
public classBody ^ <ClassBodyAST> = (
	^super classBody wrapper: 
		[:instInit <InitializerAST> :instanceSide <SideAST>  :classSide <SideAST> |
		|
		klassSide <SideAST> = classSide isNil 
			ifTrue: [emptySide]
			ifFalse: [classSide].
		|
		ClassBodyAST initializer: instInit instanceSide: instanceSide classSide: klassSide].
)
public classComment = (
	^super classComment wrapper: [:ws :c | c value]
)
public classDecl ^ <ClassDeclarationAST> = (
 	^super classDecl wrapper:
		[:am :ckw :klassName <Token> :cons :eq :listAndBody <{List[SendAST]. ClassBodyAST}> |
		|
		start = nil = am ifTrue: [ckw start] ifFalse: [am start].
		konstruktor = nil = cons 
			ifTrue: [defaultConstructorPattern start: klassName end + 1; end: klassName end]
			ifFalse: [cons].
		bodyOrDot <ClassBodyAST> = listAndBody last.
		iList <List[SendAST]> = listAndBody first.
		end <Integer> = bodyOrDot end.
		|
		bodyOrDot isAST ifTrue: [
			| c |
			c:: (ClassDeclarationAST 
				named: klassName 
				factoryMsg: konstruktor 
				inheriting: iList body: bodyOrDot)
			start: start;
			end: end.
			c header accessModifier: (nil = am ifTrue: [#protected] ifFalse: [am value]).
			c header start: start.
			c
             ] ifFalse: [
			(MixinApplicationClassAST 
				named: klassName value factoryMsg: konstruktor inheriting: iList)
				accessModifier: (nil = am ifTrue: [#protected] ifFalse: [am value])]
		].
)
public classDeclaration ^ <ClassDeclarationAST> = (
	^super classDeclaration wrapper:
		[:hdr :instSide :classSide |
		| klassSide kat |
		klassSide:: classSide isNil
			ifTrue: [emptySide]
			ifFalse: [classSide].
		ClassDeclarationAST new
			header: hdr;
			instanceSide: instSide;
			classSide: klassSide;
			start: hdr start;
			end: (classSide isNil ifTrue: [instSide end] ifFalse: [classSide end])]
)
classDefinition = (
halt.
(* %Cleanup when NS1 and NS0  are gone *)
(* Retained for compatibility with older Newsqueak versions. We renamed classDefinition to ClassDeclaration in the grammar, but there is code that needs to use older parsers, and hence uses the old protocol *)
^compilationUnit
)
public classHeader ^ <ClassHeaderAST> = (
	^super classHeader wrapper:
		[:am :ckw :klassName :cons :eq :superClause :lp :cmnt :instVars :inits :rp | 
		| vs kat start konstruktor superCall isSeq |
		isSeq:: true.
		kat:: nil.
		start:: am isNil ifTrue: [ckw start] ifFalse: [am start].
		konstruktor:: cons isNil 
			ifTrue: [defaultConstructorPattern start: klassName end + 1; end: klassName end]
			ifFalse: [cons].
		superCall:: superClause isNil 
			ifTrue: [defaultSuperCallAt: eq end + 1 ending: eq end] 
			ifFalse: [superClause].
		vs:: instVars isNil
			ifTrue: [List new]
			ifFalse: [isSeq:: instVars first. instVars last].
		ClassHeaderAST new
			name: klassName value asSymbol; 
			constructor: konstruktor;
			superclassName: superCall receiver message selector;
			superclassCall: superCall receiver;
			superConstructorCall: superCall message;
			slots: vs; isSeq: isSeq; initExprs: inits; category: kat ;
			classComment: cmnt;
			inheritanceChain: {superCall};
			accessModifier: (am isNil ifTrue: [#protected] ifFalse: [am value]);
			start: start; end: rp end].
)
public classPrefix ^ <ClassHeaderAST> = (

^super classPrefix
     wrapper: [:klassName :cons :eq :superClause  | 
                |  start  konstruktor superCall  |

                  start:: klassName start.
                  konstruktor:: cons isNil 
                       ifTrue: [defaultConstructorPattern start: klassName end + 1; end: klassName end]
                       ifFalse: [cons].
                  superCall:: superClause isNil 
                                     ifTrue: [defaultSuperCallAt: eq end + 1 ending: eq end] 
                                     ifFalse: [superClause].
                 
                  (ClassPrefixAST 
				name: klassName value asSymbol
                        constructor: konstruktor
				superclassName: superCall receiver message selector
				superclassCall: superCall receiver
				superConstructorCall: superCall message)
                        start: start; end: superCall end                   
                ].
)
public classSideDecl ^ <SideAST> = (
	^super classSideDecl wrapper:
		[:cn :lp :methods :rp  | 
		 SideAST new
			nestedClasses: {};
			methods: methods;
			start: cn start; end: rp end]
)
public codeBody ^ <CodeBodyAST> = (

^super codeBody
          wrapper:[:litMsgs :tmps :stmts |
                      | ts ss start end  cstart cend isSeq | 
				isSeq:: true.
                       end:: nil.
                       start:: end.
                       ts:: tmps isNil ifTrue:[List new] ifFalse:[isSeq:: tmps first. tmps last].      
                       ss:: stmts isNil ifTrue:[List new]  ifFalse:[stmts]. 
                       ts isEmpty 
				ifFalse:[cstart:: ts first concreteStart. start:: ts first start.
					cend::  ts last concreteEnd. end::  ts last end.
					].       
                       ss isEmpty ifFalse:[start isNil 
								ifTrue:[start:: ss first start]. 
								end:: ss last end. 
								cend:: ss last concreteEnd
							].
                       CodeBodyAST new temporaries: ts
                                            statements: ss;
							  literalMessages: (litMsgs select: [:e | e isMessageNode]);
							  isSeq: isSeq;
                                            start: start;
                                            end: end;
					    		  concreteStart:  cstart;
                                            concreteEnd: cend
                     ].
)
public compilationUnit = (
	^super compilationUnit wrapper: [:lid :u :e | u] (* throw out end-of-input indicator *) 
)
computeDigits: ds <List[Character]> ^ <Integer> = (
	| s ::= 0. |
	ds do: [:d | s:: (10 * s) + (d - 48)].
	^s
)
computeDigits: digitCharCodes <List[Integer]> radix: radixValue <Integer> ^<Integer> = (
	| sum ::= 0. |
	digitCharCodes do: 
		[:digitCharCode | | digitValue |
		(digitCharCode > 47 and: [digitCharCode < 58])
			ifTrue: 
				[digitValue:: digitCharCode - 48]
			ifFalse: 
				[(digitCharCode > 64 and: [digitCharCode < 71])
					ifTrue: 
						[digitValue:: digitCharCode - 55]
					ifFalse: 
						[assert: [digitCharCode > 96 and:[digitCharCode < 123]] 
						message: 'Internal error - illegal character in radix number'.
						digitValue:: digitCharCode - 87]].
		assert: [digitValue < radixValue] message: 'Malformed number: digit exceeds radix'.
		sum:: (radixValue * sum) + (digitValue)].
	^sum
)
computeFraction: ds <List[Character]> ^ <Number> = (
	| 
	numerator ::= 0. 
	denominator ::= 1.
	|
	ds do: [:d | 
		numerator:: (10 * numerator) + (d - 48).
		denominator:: 10 * denominator].
	^numerator / denominator
)
computeFraction: digitCharCodes <List[Integer]> radix: radixValue <Integer> ^<Integer> = (
	| 
	numerator ::= 0. 
	denominator ::= 1.
	|
	digitCharCodes do: 
		[:digitCharCode | | digitValue |
		(digitCharCode > 47 and: [digitCharCode < 58])
			ifTrue: 
				[digitValue:: digitCharCode - 48]
			ifFalse: 
				[(digitCharCode > 64 and: [digitCharCode < 71])
					ifTrue: 
						[digitValue:: digitCharCode - 55]
					ifFalse: 
						[assert: [digitCharCode > 96 and:[digitCharCode < 123]] 
						message: 'Internal error - illegal character in radix number'.
						digitValue:: digitCharCode - 87]].
		assert: [digitValue < radixValue] message: 'Malformed number: digit exceeds radix'.
		numerator:: (radixValue * numerator) + (digitValue).
		denominator:: radixValue * denominator].
	^numerator / denominator
)
public decimalNum ^ <Number> = (
	^super decimalNum wrapper:
		[:sgn :ip <List[Character]> :fp <Number> :ep <Integer> | 
		| sum <Number>  | 
		sum:: computeDigits: ip.
		nil = fp ifFalse: [sum:: sum + fp].
		nil = sgn ifFalse: [sum:: -1 * sum].
		nil = ep ifFalse: [sum:: sum * (10 ** ep)].
		sum]
)
defaultConstructorCall ^ <MessageAST> = (

(* default constructor is 'new' *)
^MessageAST new send: defaultConstructorSelector with: {}
)
defaultConstructorPattern ^ <MessagePatternAST> = (

(* default constructor is 'new' *)
^MessagePatternAST new selector: defaultConstructorSelector parameters: {}
)
defaultConstructorSelector ^ <Symbol> = (

(* default constructor is 'new' *)
^#new
)
defaultSuperCallAt: start <Integer> ending: end  <Integer> ^ <NormalSendAST> = (
	| objId |
	objId:: hereSendFromMsg: (MessageAST new send: #Object with: {}; start: start; end: end).
	^UnresolvedSendAST new receiver: objId; message: (defaultConstructorCall start: start; end: end)
)
public defaultSuperclassAndBody ^ <{List[SendAST]. ClassBodyAST}> = (
	^super defaultSuperclassAndBody wrap:
		[:body <ClassBodyAST> |
		{{defaultSuperCallAt: body start -1 ending: body start - 1}. body}]
)
public doItExpression = (
	(* throw out end-of-input indicator *) 
	^super doItExpression wrapper: [:cb :end | cb]
)
emptySide = (
	^SideAST new nestedClasses: {}; methods: {}
)
public explicitInheritanceListAndOrBody ^ <{List[SendAST]. ClassBodyAST}> = (
	^super explicitInheritanceListAndOrBody
		wrapper:[:ic <SendAST> :ms <{List[{Token. SendAST}]. ClassBodyAST} | ClassBodyAST> |
			ms isCollection 
				ifFalse:[{{ic}. ms}]
				ifTrue:[
					| iList <List[SendAST]> = (ms first collect:[:p | p last]) addFirst: ic; yourself. |
					{iList. ms last}
					]
			]
)
public exponent ^ <Integer> = (
	^super exponent wrapper:
		[:e :sgn :ds <List[Character]> | 
		| exp <Integer> |
		exp:: computeDigits: ds.
		sgn isNil ifTrue: [exp] ifFalse: [-1*exp]].
)
public expression = (
	^super expression wrapper:
		[:setters :msg |
		| e setSend args setSelector |
		e:: msg.
		setters isNil ifFalse:
			[setters size to: 1 by: -1 do: 
				[:index |
				| setter = setters at: index. |
				args:: List new add: e; yourself.
				setSelector:: setter value asString.
				setSend:: MessageAST new
					send: (setSelector copyFrom: 1 to: setSelector size - 1) asSymbol with: args;
					start: setter start; end: setter end;
					right: e.
				e:: self hereSetterSendFromMsg: setSend]].
		e].
)
public extendedFraction ^ <List[Character]> = ( 
	^super extendedFraction wrapper:[:period  :ds  | ds]
)
public fraction ^ <Number> = ( 
	^super fraction wrapper: [:period :ds | computeFraction: ds]
)
public furtherStatements = (

^super furtherStatements
     wrapper:[:d :stmts  | stmts].
)
hereNode ^<VariableAST> = (
	(* Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier *)
	
	^VariableAST new name: #'@here'; start: 0; end: 0.
)
hereSendFromMsg: msg = (
	(* Build an implicit here send with the message msg *)
	^UnresolvedSendAST new 
		to: hereNode send: msg;
		start: msg start; end: msg end
)
hereSetterSendFromMsg: msg = (

	(* Build an implicit here send with the message msg *)

	^SetterSendAST to: self hereNode  
                          	send: msg
    	                      	start: msg start
					end: msg end
)
public instanceInitializer ^ <InitializerAST> = (
	^super instanceInitializer
		wrapper:[:lp <Token> :cmnt :instVars :inits <List[ExpressionAST]> :rp <Token> |
			| vs isSeq |
			isSeq:: true.
			vs:: instVars isNil ifTrue:[List new] ifFalse:[isSeq:: instVars first. instVars last].
			(InitializerAST  slots: vs initializerExpressions: inits comment: cmnt slotsAreSequential: isSeq)
				start: lp start; end: rp end
			]
)
public keywordExpression ^ <NormalSendAST> = (
	^super keywordExpression wrapper:
		[:bo :msg <MessageAST> |
		msg isNil 
			ifTrue: [bo]
			ifFalse: [UnresolvedSendAST new to: bo send: msg; left: bo; right: msg]]
)
public keywordHereSend = (

^super keywordHereSend
          wrap:[:msg  |
                  self hereSendFromMsg: msg                               
                 ].
)
public keywordMessages ^<Tuple[List[MessageAST], List[MessageAST], MessageAST]> = (
	^super keywordMessages wrap:
		[:kwMsg <MessageAST> |
		{{}. {}. kwMsg}.]
)
public keywordMsg ^ <MessageAST> = (
	^super keywordMsg wrapper:
		[:esend :kws  |
		| sel <String> args <List[Expression]> |
		args:: List new.
		sel:: kws inject: '' into:
			[:s <String> :kwd | 
			args add: (kwd at:2). 
			s, (kwd at:1) value].
		MessageAST new
			send: sel asSymbol with: args;
			isEventual: (nil = esend) not;
			start: kws first first start;
			right: args last].
)
public keywordMsgPattern ^ <MessagePatternAST> = (

^super keywordMsgPattern
     wrap:[:kws  |
             | sel  params |
              params:: List new.
              self assert:[kws isEmpty not] message: 'Assert failed'.
              sel:: kws inject: '' into:[:s  :kwp | 
                                           params add: kwp last.
                                           s, kwp first value
                                          ].
              MessagePatternAST new selector: sel asSymbol parameters: params  ;
                                          start: kws first first start;
                                          right: params last
            ].
)
public keywordPattern ^ <KeywordPatternAST> = (
^ super keywordPattern
	wrap: [ :pairs | |kws kwsAST pats patsAST st ed |
		st:: pairs first start.
		ed:: pairs last end.
		
		kws:: List new.
		pats:: pairs inject: List new 
					into: [:m :p | |kwAST|
							kwAST:: SymbolAST new 
										val: p keyword value asSymbol;
										start: p keyword start;
										end: p keyword end.
							kws add: kwAST.
							m add: p pattern; yourself].
						
		kwsAST:: TupleAST new
					elements: kws;
					start: st; end: ed.
		patsAST:: TupleAST new
					elements: pats;
					start: st; end: ed.

		KeywordPatternAST new
			keywords: kwsAST;
			patterns: patsAST;
			start: st;
			end: ed.
	].
)
public kwPatternPair = (
^ super kwPatternPair
	wrapper: [ :keyw  :val |
		KeywordPatternPairAST new
			keyword: keyw;
			pattern: (val isNil 
						ifTrue: [WildcardPatternAST new 
									start: keyw end; end: keyw end] 
						ifFalse: [val]);
			start: keyw start;
			end: (val isNil ifTrue: [keyw end] ifFalse: [val end])
	].
)
public literalMessage = (
	^super literalMessage wrap:
		[:kwsOrMsg |
		kwsOrMsg isCollection
			ifTrue:
				[| sel  args  |
				args:: List new.
				sel:: kwsOrMsg inject: '' into:
						[:s :kwd | 
						args add: (kwd at:2). 
						s, (kwd at:1) value].
				MessageAST new send: sel asSymbol with: args;
					start: kwsOrMsg first first concreteStart;
					end: args last concreteEnd]
			ifFalse:
				[kwsOrMsg]]
)
public literalMessageComment = (
	^super literalMessageComment wrap:
		[:tokens| (* beginNSComment :literalmessage: wsp literalMessage endNSComment *)
		tokens at: 5]
)
public literalPattern ^ <LiteralPatternAST> = (
^ super literalPattern
	wrap: [ :litTok | 
		LiteralPatternAST new
			literal: litTok value;
			start: litTok start; end: litTok end.
	].
)
public messagePattern ^ <MessagePattern> = (

^super messagePattern
    wrapper:[:pt :rt :tp  |
                tp isNil ifTrue:[rt isNil ifFalse:[pt end: rt concreteEnd]]
                         ifFalse:[pt end: tp concreteEnd].
                                 
                pt returnType: rt; typePattern: tp                    
               ].
)
method ^ <MethodAST> = (
halt.
^super method
     wrapper:[:msg :cb :ei  |
                   cb parameters: msg parameters.
                   MethodAST new pattern: msg 
                                      body: cb
                                      accessModifier: #public;
                                      start: msg start;
                                      right: cb                             
                ].
)
public methodDecl ^ <MethodAST> = (
	^super methodDecl wrapper:
		[:am :msg :eq :lp :cb :rp  |
		cb parameters: msg parameters.
		MethodAST new
			pattern: msg 
			body: cb
			accessModifier: (nil = am ifTrue: [#protected] ifFalse: [am value]);
			start: (nil = am ifTrue: [msg start] ifFalse: [am start]);
			end: rp end]
)
public mixinApplication ^ <MixinApplicationAST> = (

	^super mixinApplication wrapper:
		[:cp <ClassPrefixAST> :mixinOp <Token> :me <Expression> |
				(MixinApplicationAST prefix: cp mixin: me) left:  cp; right: me
		]
)
nestedClassDecl = (
	halt.
^super nestedClassDecl 
   wrapper:[:accessModifier  :classDeclaration  |
	accessModifier ifNil: [
			(* According to the language spec the accessModifier is #protected if not otherwise specified. *)
			classDeclaration accessModifier: #protected
		] ifNotNil: [
			classDeclaration accessModifier: accessModifier first value ].
	classDeclaration ]
)
public nestedPatternLiteral = (
 ^ super nestedPatternLiteral wrap: [ :nestedTok | nestedTok value ]	
)
public nonEmptyBlockArgList = (
	^super nonEmptyBlockArgList wrapper:
		[:ats :vbarreturnt | 
		| targs |
		targs:: List new addAll: ats; yourself.
            nil = vbarreturnt
			ifTrue: [targs addLast: (TypeIdAST new name: #Object)]
                  ifFalse: [targs add: (vbarreturnt at: 2)].
		targs]
)
public nonEmptyBlockTypeArgList = (
	^super nonEmptyBlockTypeArgList wrapper:
		[:tas :rt | 
		| targs |
		targs:: List new addAll:tas; yourself.
		nil = rt 
			ifTrue: [targs addLast: (TypeIdAST new name: #Object)]
			ifFalse: [targs add: rt last].
		targs]
)
public nontrivialBinaryMessages ^ <Tuple[List[MessageAST], List[MessageAST], MessageAST]> = (
	^super nontrivialBinaryMessages wrapper:
		[:bmsgs <List[MessageAST]> :kwMsg <MessageAST> | 
		{{}. bmsgs. kwMsg}]
)
public number = (
	^super number wrap: [:t | NumberAST new value: t value; start: t start; end: t end].
)
public outerReceiver ^ <NormalSendAST> = (
	^super outerReceiver wrapper:
		[:okw :idn | | osend |
		osend:: (pseudoVariableNode: okw value asSymbol)
			start: okw start; end: okw end.
		UnresolvedSendAST new 
			receiver: osend; 
			message: (MessageAST new send: idn value asSymbol with: {}); 
			start: osend start; end: idn end]
)
public parenthesizedExpression = (

^super parenthesizedExpression
    wrapper:[:l :e :r  | 
                e concreteStart: l start; concreteEnd: r end.
                e
               ].
)
public parenthesizedTypeExpression = (


^super parenthesizedTypeExpression
   wrapper:[:lp :te :rp | 
               te concreteStart: lp start; concreteEnd: rp end.
               te
               ].
)
public parse: input inContext: context ifError: blk = (
 
	[ super parse: input inContext: context ifError: blk ]
		on: ParserError
		do: [ :ex | ^blk value: ex message with: ex position ]
)
public pattern ^ <PatternAST> = (
^ super pattern
	wrapper: [ :del1 :pat :del2 | pat. ]
)
pseudoVariableNode: psvName = (
	(* generate a an AST representing self; used for implicit self sends *)
	self assert: [{#self. #super. #outer.} includes: psvName] message: 'Assert failed'.
	^VariableAST new name: psvName asSymbol; start: 0; end: 0.
)
public radix ^<Integer> = (
	^super radix wrapper: [:ds :r | computeDigits: ds]
)
public radixNum = (
	^super radixNum wrapper:
		[:r <Integer> :sgn :ip <List[Character]> :fp <List[Character]> :ep <Integer> | 
		| sum <Number> |
		assert: [ip isEmpty not] message: 'internal error: integer part is empty'.
		sum:: computeDigits: ip radix: r.
		nil = fp ifFalse: [sum:: sum + (computeFraction: fp radix: r)].
		nil = sgn ifFalse: [sum:: -1 * sum].
		nil = ep ifFalse: [sum:: sum * (10 ** ep)].
		sum]
)
public returnStatement ^ <ReturnStatAST> = (
	^super returnStatement wrapper:
		[:r :e :od |
		List new
			add: (ReturnStatAST new expression: e; start: r start; right: e); yourself]
)
public returnType = (

^super returnType 
   wrapper:[:h :rt | 
               rt concreteStart: h start.
               rt
              ].
)
sendMessages: msgs <List[MessageAST]> to: receiver <ExpressionAST> ^ <ExpressionAST> = (
	(* if msgs is non-empty, the return type will always be NormalSendAST *)
	^msgs inject: receiver into: 
		[:r :msg | 
		UnresolvedSendAST new 
			to: r send: msg;
			left: r; right: msg]
)
public seqSlotDecls = (

^super seqSlotDecls
     wrapper: [:vb1 :sds :vb2  | 
                  sds isEmpty ifFalse: [sds first concreteStart: vb1 start.
                                           sds last concreteEnd: vb2 end.
                                           ].
                  {true. sds}
                ].
)
public sideDecl ^ <SideAST> = (
	^super sideDecl wrapper:
		[:lp :nestedClasses :methods :rp |
		 SideAST new
			nestedClasses: nestedClasses;
			methods: methods;
			start: lp start; end: rp end]
)
public simSlotDecls = (

^super simSlotDecls
     wrapper: [:vb1 :vb2 :sds :vb3 :vb4  | 
                  sds isEmpty ifFalse: [sds first concreteStart: vb1 start.
                                           sds last concreteEnd: vb4 end.
                                           ].
                  {false. sds}
                ].
)
public slotDecl ^ <VarDeclAST> = (

^super slotDecl
    wrapper: [:n :t  | 
                | end |
                end:: t isNil ifTrue: [n end] ifFalse: [t concreteEnd].
                (VarDeclAST name: n value asSymbol type: t)
                                   start: n start; end: end 
               ].
)
public slotDef = (
	^super slotDef wrapper: 
		[:am :sd :init  |   
		| start end slotClass expr msg | 
		start:: am isNil ifTrue: [sd start] ifFalse: [am start].
		init isNil
			ifTrue: 
				[end:: sd end. 
				slotClass:: MutableSlotDefAST]
			ifFalse:
				[end:: init last concreteEnd. 
				expr:: init at: 2. 
				slotClass:: (init at: 1) value = #'::='
					ifTrue: [MutableSlotDefAST] 
					ifFalse: [ImmutableSlotDefAST]].
		slotClass new
			accessModifier: (am isNil ifTrue: [#protected] ifFalse: [am value]);
			slotDecl: sd; 
			initializer: expr;
			start: start;
			end: end].
)
public slotName = (
	(* change to create a here send *)
	^super slotName wrap:
		[:n | | msg sn |
		sn:: n value asSymbol.
		(sn = #self or: [sn = #super or: [sn = #outer]])
			ifTrue: [(pseudoVariableNode: sn) start: n start; end: n end]
			ifFalse: 
				[msg:: MessageAST new 
					send: sn with: List new;
					start: n start; end: n end.
				hereSendFromMsg: msg]].
)
public statementSequence = (

^super statementSequence
     wrapper:[:e :rst  |
                  rst isNil
                    ifTrue:[List new add:e; yourself]
                    ifFalse:[List new add:e; addAll: rst; yourself]                
                ].
)
public string = (
	^super string wrap: [:t | StringAST new value: t value; start: t start; end: t end]. 
)
public superclassClause = (
	^super superclassClause wrapper:
		[:sp :sn :msg | | constructorCall  sc |
		 sc:: sp isNil 
			ifTrue: [hereSendFromMsg: sn] 
			ifFalse: 
				[UnresolvedSendAST new 
					receiver: sp; 
					message: (MessageAST new send: sn selector with: {}); 
					start: sp start; end: sn end].
		constructorCall:: msg isNil (* default constructor is 'new' *)
			ifTrue: [defaultConstructorCall start: sn start; end: sn end]
			ifFalse: [msg].
		UnresolvedSendAST new
			receiver: sc; 
			message: constructorCall; 
			start: sc start; end: constructorCall end]
)
public superclassPrefix  = (
	^super superclassPrefix wrap:
		[:p | | sp |
		sp:: p isUnresolvedSendNode 
			ifTrue: [p] (* an outer receiver *)
			ifFalse:
				[(pseudoVariableNode: p value asSymbol) 
					start: p start; end: p end (* a #self or #super token *)].
		sp]
)
public symbol = (
	^super symbol wrap: [:t | SymbolAST new value: t value asSymbol; start: t start; end: t end].
)
public symbolConstant = (

^super symbolConstant
     wrapper:[:h :s  | s start: h start].
)
public toplevelClass = (
	^super toplevelClass wrapper:
		[:cat :cd |
		| kat |
		cat isNil ifFalse:
			[cd header category: cat value.
			cd start: cat start].
		cd]
)
public tuple = (

^super tuple
   wrapper:[:lc :es :rc | 
               TupleAST new elements: es; start: lc start; end: rc end
              ].
)
public tupleType = (


^super tupleType
   wrapper:[:lc :es :rc | 
               ParameterizedTypeAST new generic: (TypeIdAST new name: #Tuple); 
                                               arguments:  es;
                                               start: lc start;
                                               end: rc end
              ].
)
public type = (


^super type 
   wrapper:[:lb :te :rb |
               te concreteStart: lb start; concreteEnd: rb end.
               te
              ]
)
public typeArguments ^  <{List[TypeExpr]. Token}> = (


^super typeArguments 
   wrapper:[:lb <Token>  :tas <List[TypeExpr]> :rb <Token>  |   
                 {tas. rb}
              ]
)
public typeExpr = (

^super typeExpr 
   wrapper:[:lOperand :msg | 
               | operator rOperand |
                 msg isNil ifTrue:[ lOperand] 
                            ifFalse:[BinaryTypeOpAST new leftOperand: lOperand; 
                                                                 operator: msg first value; 
                                                                 rightOperand: msg last ;
                                                                 start: lOperand start;
                                                                 end: msg last end
                                     ]
              ]
)
public typePrimary ^ <TypeIdAST | GenericInvocationAST> = (

^super typePrimary
   wrapper:[:g <Token> :tas <{List[TypeExpr]. Token}>  | 
               | tid <TypeIdAST>  |
                tid:: TypeIdAST new name: g value; start: g start; end: g end.
                tas isNil ifTrue:[tid]
                          ifFalse:[ParameterizedTypeAST new generic: tid; 
                                                                   arguments: tas first; 
                                                                   start: g start;
                                                                   end: tas last end
                                   ]
             ]
         
)
public typeTerm ^ <TypeExpression> = (

^super typeTerm 
   wrapper:[:operand :operators | 
               operators inject: operand into:[:te <TypeExpression> :op | 
                                                    UnaryTypeOpAST new operand: te; operator: op value;
                                                                               start: te start; end: op end
                                                  ] 
              ]
)
public unaryExpression ^ <ExpressionAST> = (
	^super unaryExpression wrapper:
		[:o <ExpressionAST> :s <List[MessageAST]> |
		self assert: [s isNil not] message: 'Assert failed'.
		s inject: o into: 
			[:e <ExpressionAST> :umsg <MessageAST> |
			UnresolvedSendAST new 
				to: e send: umsg;
				start: e start; end: umsg end]]
)
public unaryMsg ^ <MessageAST> = (
	^super unaryMsg wrapper:
		[:esend :u  | 
		MessageAST new
			send: u value asSymbol with: List new;
			isEventual: (nil = esend) not;
			start: u start;
			end: u end].
)
public unaryMsgPattern ^ <MessagePatternAST> = (

^super unaryMsgPattern
          wrap: [:sel   <Symbol> |
                   MessagePatternAST new selector: sel value asSymbol parameters: List new;
                                               start: sel start; end: sel end
                 ].
)
public variablePattern ^ <VariablePatternAST> = (
^ super variablePattern
	wrapper: [ :varTok | VariablePatternAST new
					variableName: (varTok value at: 2); 
					start: varTok start; end: varTok end ].
)
public wildcardPattern ^ <WildcardPatternAST> = (
^ super wildcardPattern
	wrap: [ :wcTok | WildcardPatternAST new
					start: wcTok start; end: wcTok end ].
)
) : (
)
) : (
)
