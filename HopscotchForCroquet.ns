Newspeak3
'Root'
class HopscotchForCroquet usingPlatform: p <Platform> hopscotch: H <HopscotchForHTML5 class> = (
(* 
Module definition enclosing Hopscotch UI subclass that integrates Croquet style synchronization. 
See that class (#Hopscotch) for details. 
*)
   |
(* imports *)
    private HopscotchForHTML5 = H.
    private Promise = p actors Promise.
    private Resolver = p actors Resolver.
    private List  = p collections List.
    private Map = p collections Map.
    |
) (
public class Hopscotch usingPlatform: p <Platform> images: images ducts: ds =
  HopscotchForHTML5 usingPlatform: p images: images ducts: ds

(
(*
This class overrides the normal Hopscotch UI module to allow the UI to synchronize using croquet.io.
For every interactive fragment class, we maintain:

1) A subclass, defined here, that manages the interaction with Croquet.
2) A counter that is used to generate unique ids for each fragment.

Each fragment sets its id upon instantiation, accessing and incrementing the per-fragment type counter via a dedicated method in this class.

The fragment notifies the Croquet root view when an interaction occurs. The croquet view notifies the croquet model, which notifies the reflector; when the reflector has signaled the croquet model, it notifies the croquet view; the view then executes a call back in which the fragment performs the normal behavior defined in its superclass.

As a general recipe:

Every fragment type has a per type croquet event scope id, of the form #ns<fragmentypename>_, and, for each of its actions, a croquet event.  When an action occurs, we publish an event with the fragment type scope id, the action-specific event name, and event specific data. Usually this data is  a JS object with two fields: fid, containing the individual fragment id publishing, and a data field for additional even info. We produce these objects by calling out to JS via #newspeakFragmentData:data:. This JS function takes a fragment id and a data object, which can be anything that Croquet can serialize (so numbers, strings or vanilla objects, but not instances of specific classes with function valued fields etc.).

Back in Javascript, the root model subscribes to these events , scoping them using the aforementioned fragment type scope id.  The subscription specifies a root model method. When an event is detected, the method will be called with the event data as a parameter. The method in turn publishes an event whose name is of the form #model_<fragment specific scope>_ <action>. The fragment specific scope is the concatenation of the fragment type scope id and a fragment id number, which is usually found in the fid field of the incoming method argument. Associated with the event is the data from the incoming parameter.

Each fragment subscribes to such an event for each of its actions. Thus, it will be notified when croquet has processed the action - regardless of whether the action originated on the client that actually published, or any other client. Now it can act on the event data it receives.

The scheme is designed so that we only generate events upon user interaction. Thus the event pressure is bounded by the speed of human input. 

A series of croquet clients running a Newspeak application can be synchronized, without any modification to the Newspeak application code; the only requirement is that application be deployed using a platform object that uses an instance of this class as its GUI.

To reach that goal, we have to implement all interactive Hopscotch fragments here, and we have to deal with the problem of saving a model of the application as a whole to the Croquet root model; presumably by adding an image mechanism to Newspeak.

Ultimately, we hope to go beyond the above, and be able to diff the saved model state and extend this to full local-first solution.
*)
  |
  (* Per fragment-type counters for managing fragment ids *)
  buttonCount <Integer> ::= 0.
  imageButtonCount <Integer> ::= 0.  
  radioButtonCount <Integer> ::= 0. 
  checkboxCount <Integer> ::= 0.
  hyperlinkCount <Integer> ::= 0.
  hyperlinkImageCount <Integer> ::= 0.
  codeMirrorCount <Integer> ::= 0.
  toggleComposerCount <Integer> ::= 0.
  textEditorCount <Integer> ::= 0.
  pickerCount <Integer> ::= 0.
  colorPickerCount <Integer> ::= 0.
  datePickerCount <Integer> ::= 0.  
  timePickerCount <Integer> ::= 0.
  sliderCount <Integer> ::= 0.
  dropDownMenuCount <Integer> ::= 0.  
  menuCount <Integer> ::= 0.
  windowCount <Integer> ::= 0.
  fileChooserCount <Integer> ::= 0.
  (* JS access *)
  js = p js.   
|
) (
public class ButtonFragment label: l action: a = super ButtonFragment label: l action: a (
    |
    buttonId <Integer> ::= newButtonId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <ButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[rootView <-: publish: 'nsbutton_' event: #button_click data: buttonId printString]
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsbutton_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        rootView <-: subscribe: scope eventSpec: #model_button_click handler: [:e | super action value. nil]
)
) : (
)
public class ImageButtonFragment = super ImageButtonFragment (
    |
    imageButtonId <Integer> ::= newImageButtonId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsImagebutton_', imageButtonId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ImageButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[rootView <-: publish: 'nsImagebutton_' event: #image_button_click data: imageButtonId printString]
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_image_button_click handler: [:e | super action value. nil]
)
) : (
)
public class CheckboxFragment text: t <Holder> value: v <Boolean | Holder> action: a <[:Boolean]>  = super CheckboxFragment text: t value: v action: a (
    |
    checkboxId <Integer> ::= newCheckboxId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscheckbox_', checkboxId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <CheckboxFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
writeInput: v = (
     checkbox at: 'checked' put: v.
     super writeInput: v.
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_checkBox_checked handler: [:e |  'checkbox checked event ' out. writeInput: true. nil].
        rootView <-: subscribe: scope eventSpec: #model_checkBox_unchecked handler: [:e |  'checkbox unchecked event ' out. writeInput: false. nil]
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:b <Boolean> | (checkbox at: 'checked') printString out. rootView <-: publish: 'nscheckbox_' event: ((checkbox at: 'checked') ifTrue: [#checkBox_unchecked] ifFalse: [#checkBox_checked]) data: checkboxId printString. nil]
)
) : (
)
public class RadioButtonFragment text: t <String> 
	value: v <Boolean | Holder> 
	group: g <String> 
	action: a <[:Boolean]> = super RadioButtonFragment text: t value: v group: g action: a (
    |
    radioButtonId <Integer> ::= newRadioButtonId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsradiobutton_', radioButtonId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <RadioButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
  rootView <-: subscribe: scope eventSpec: #model_radioButton_pressed handler: [:e | writeInput: true. nil].
  rootView <-: subscribe: scope eventSpec: #model_radioButton_released handler: [:e | writeInput: false. nil]        
)
writeInput: v = (
     button at: 'checked' put: v.
     super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:b <Boolean> | rootView <-: publish: 'nsradiobutton_' event: ((button at: 'checked') ifTrue: [#radioButton_pressed] ifFalse: [#radioButton_released]) data: radioButtonId printString. nil]
)
) : (
)
public class HyperlinkFragment label: l action: a = super HyperlinkFragment label: l action: a (
   |
    hyperlinkId <Integer> ::= newHyperlinkId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <HyperlinkFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[rootView <-: publish: 'nshyperlink_' event: #hyperlink_click data: hyperlinkId printString]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlink_', hyperlinkId printString].
  ^scope_slot
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_hyperlink_click handler: [:e | super action value. nil]
)
) : (
)
public class CodeMirrorFragment onText: t <String> = super CodeMirrorFragment onText: t (
    |
    codeMirrorId <Integer> ::= newCodeMirrorId.
    scope_slot <String>
    reflecting <Boolean> ::= true.
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscodemirror_', codeMirrorId printString].
  ^scope_slot
)
preventDefault: event <Alien>  = (
  (* Only the initiating client has an event to manage, and others have no access to this event; it cannot be serialized, so cannot be passed via croquet to other clients, and it would not be a valid event if it was. *)
)
respondToCancel = (
   reflecting ifTrue: [rootView <-: publish: 'nscodemirror_' event: #codeMirror_cancel data: codeMirrorData]
)
acceptFromKeydown: event <Alien> = (
  super respondToAccept: event
)
convertKeydown: kde <Alien[KeydownEvent]> ^ <Alien[JSObject]> = (
  ^js global sanitizeKeydownEvent: kde
)
cancelFromKeydown = (
  super respondToCancel
)
codeMirrorData = (
  ^js global newspeakFragmentData: codeMirrorId data: textBeingAccepted 
)
codeMirrorData: change <Alien[CodeMirrorChangeObject]> = (
  ^js global newspeakFragmentData: codeMirrorId data: (js global nsCodeMirrorData: textBeingAccepted change: change)
)
adjustCursorPos: change <Alien[CodeMirrorChangeRecord]> = (
(*
The change record from CodeMirror will have information on:

indices of change (#from, #to fields)
new text (#text field - an array of lines of new text)
old text (#removed field)
*)
  |
  text = change at: #text.
  linesInserted = text at: #length.
  from = change at: #from.
  fromLine = from at: #line.
  toLine = (change at: #to) at: #line.
  linesReplaced = toLine - fromLine +1.
  linesAdded = linesInserted - linesReplaced.
  targetLine = toLine + linesAdded.
  lastLineLength = linesInserted = 0 ifTrue: [0] ifFalse: [(text at: linesInserted - 1) size].
  baseCh = fromLine = targetLine ifTrue: [from at: #ch] ifFalse: [0].
  targetCh = baseCh + lastLineLength.
  |
  editor setCursor: (
    js global nsCursorPos: targetCh line: targetLine
  )
)
respondToKeyDown: event <Alien[Event]> = (
	| 
	key <Character> = event at: 'key'. 
    (* customary on mac, does not work on windows *)
	metaPressed <Boolean> = event at: 'metaKey'.
    (* works on windows *)
    ctrlPressed <Boolean> = event at: 'ctrlKey'.   
    shiftPressed <Boolean> = event at: 'shiftKey'.
	|
	reflecting ifTrue: [
          ((key = 'Enter' and: [metaPressed or: [ctrlPressed or: [shiftPressed]]])
	      or: [key = 'Escape']) ifTrue: [event preventDefault].
          rootView <-: publish: 'nscodemirror_' event: #codeMirror_keydown data: (js global newspeakFragmentData: codeMirrorId data: (convertKeydown: event))
      ]
)
respondToAccept: event <Alien[Event]> = (
  reflecting ifTrue: [rootView <-: publish: 'nscodemirror_' event: #codeMirror_accept data: codeMirrorData]
)
respondToBeforeChange: event <Alien[Event]> = (
 ('code mirror respond before change event ', codeMirrorId printString) out.
   reflecting ifTrue: [rootView <-: publish: 'nscodemirror_' event: #codeMirror_beforeChange data: codeMirrorData]
)
respondToChange: change <Alien[CodeMirrorChangeObject]> = (
 ('code mirror respond change event: ', codeMirrorId printString) out.
  
  reflecting ifTrue: [rootView <-: publish: 'nscodemirror_' event: #codeMirror_change data: (codeMirrorData: (js global nsCodeMirrorChange: change))]
)
selectionEventData: event = (
  ^js global nsCodeMirrorSelectionChange: event 
)
adjustSelection: selection <Alien[Range]> = (
  editor setSelection: (selection at: #anchor) head: (selection at: #head)
)
setupCroquetView = (
   rootView <-: subscribe: scope eventSpec: #model_codeMirror_change handler: [:e | 
     reflecting ifTrue: [
       reflecting:: false. 
       hasVisual ifTrue: [ 
         | newText = e at: #textBeingAccepted. |
         editor setValue: newText.
         adjustCursorPos: (e at: #change).
         ]. 
       super respondToChange: e. 
       reflecting:: true
     ] ifFalse: [reflecting:: true]. nil].
   rootView <-: subscribe: scope eventSpec: #model_codeMirror_beforeChange handler: [:e | reflecting ifTrue: [reflecting:: false. super respondToBeforeChange: e. reflecting:: true] ifFalse: [reflecting:: true]. nil].  
   rootView <-: subscribe: scope eventSpec: #model_codeMirror_keydown handler: [:e | reflecting ifTrue: [reflecting:: false. super respondToKeyDown: e. reflecting:: true] ifFalse: [reflecting:: true]. nil].
   rootView <-: subscribe: scope eventSpec: #model_codeMirror_accept handler: [:e | reflecting ifTrue: [reflecting:: false. super respondToAccept: e. reflecting:: true] ifFalse: [reflecting:: true]. nil].
   rootView <-: subscribe: scope eventSpec: #model_codeMirror_cancel handler: [:e | reflecting ifTrue: [reflecting:: false. super respondToCancel. reflecting:: true] ifFalse: [reflecting:: true]. nil].
      rootView <-: subscribe: scope eventSpec: #model_codeMirror_beforeSelectionChange handler: [:e | reflecting ifTrue: [reflecting:: false. adjustSelection: e. reflecting:: true] ifFalse: [reflecting:: true]. nil]
)
respondToBeforeSelectionChange: event <Alien[Event]> = (
   reflecting ifTrue: [rootView <-: publish: 'nscodemirror_' event: #codeMirror_beforeSelectionChange data: (js global newspeakFragmentData: codeMirrorId data: (selectionEventData: event))]
)
updateVisualsFromSameKind: oldFragment <CodeMirrorFragment>  ^ <Alien[Element]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
updateEditedText: oldFragment <CodeMirrorFragment> = (
(* We don't want spurious changes signaling croquet, so we update only when needed. This isn't quite right. This will update when needed, but even that is not a real change. This method is called when no edits have occurred. The situation to worry about is when we edited a method and changed the selector, changing a different method. That method has changed, even though it was not being edited. At the same time, the edited method has not changed, yet the text in its editor has. So it was always best to just update the method. However, we do need to avoid the change events thereby generated. Once the correct test for this is implemented, it will likely be cheaper to use it to avoid the notification than to compare old and new text. *)
  textSlot = oldFragment textBeingAccepted ifFalse: [editor setValue: textSlot].
)
) : (
)
public class HyperlinkImageFragment image: i action: a = super HyperlinkImageFragment (|
    hyperlinkImageId <Integer> ::= newHyperlinkImageId.
    scope_slot <String>
    |
    croquetView
) (
action = (
  ^[rootView <-: publish: 'nshyperlinkImage_' event: #hyperlink_image_click data: hyperlinkImageId printString]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlinkImage_', hyperlinkImageId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <HyperlinkImageFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_hyperlink_image_click handler: [:e | super action value. nil]
)
) : (
)
public class ToggleComposer collapsedDefinition: collapsed <[Fragment]>
    expandedDefinition: expanded <[Fragment]>
    initiallyExpanded: flag <Boolean> = super ToggleComposer collapsedDefinition: collapsed 
    expandedDefinition: expanded 
    initiallyExpanded: flag (
    |
    toggleComposerId <Integer> ::= newToggleComposerId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nstogglecomposer_', toggleComposerId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ToggleComposer>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
interactiveToggle = (
  rootView <-: publish: 'nstogglecomposer_' event: #toggleComposer_toggle data: toggleComposerId printString
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_toggleComposer_toggle handler: [:e | super interactiveToggle. nil]
)
) : (
)
public class TextEditorFragment = super TextEditorFragment (
    |
    textEditorId <Integer> ::= newTextEditorId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <TextEditorFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstexteditor_', textEditorId printString].
  ^scope_slot
)
textEditorData = (
  ^js global newspeakFragmentData: textEditorId data: (textEditor at: 'value')
)
respondToCancel: event <Alien[Event]> = (
  rootView <-: publish: 'nstexteditor_' event: #textEditor_cancel data: textEditorData 
)
respondToAccept: event <Alien[InputEvent]> = (
  rootView <-: publish: 'nstexteditor_' event: #textEditor_accept data: textEditorData
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)

        rootView <-: subscribe: scope eventSpec: #model_textEditor_accept handler: [:e | 
          textEditor at: 'value' put: e. 
          super respondToAccept: e. 
          nil
        ].
        rootView <-: subscribe: scope eventSpec: #model_textEditor_change handler: [:e | 
          textEditor at: 'value' put: e.
          textEditor setSelectionRange: e size to: e size.
           super respondToChange: e. 
           nil
         ].
        rootView <-: subscribe: scope eventSpec: #model_textEditor_cancel handler: [:e | super respondToCancel: e. nil].        
)
respondToChange: event <Alien[InputEvent]> = (
  rootView <-: publish: 'nstexteditor_' event: #textEditor_change data: textEditorData
)
) : (
)
public class PickerFragment text: t <String> items: i <List[String]> action: a <[:String]> = super PickerFragment text: t items: i action: a (
    |
    buttonId <Integer> ::= newPickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <PickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nspicker_', buttonId printString].
  ^scope_slot
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)   
   super writeInput: v.
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        (* When the Croquet view is notified of a click, it will write the input *)
        rootView <-: subscribe: scope eventSpec: #model_picker_pick handler: [:e | writeInput: e. nil]
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | rootView <-: publish: 'nspicker_' event: #picker_pick data: pickerData. nil]
)
pickerData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
public class ColorPickerFragment value: v <String | Holder> action: a <[:String]> = super ColorPickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newColorPickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <ColorPickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nscolorpicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will write the input *)
        rootView <-: subscribe: scope eventSpec: #model_colorPicker_pick handler: [:e | writeInput: e. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | rootView <-: publish: 'nscolorpicker_' event: #colorPicker_pick data: colorPickerData. nil]
)
colorPickerData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
public class DatePickerFragment value: v <String | Holder> action: a <[:String]> = super DatePickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newDatePickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <DatePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsdatepicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will write the input *)
        rootView <-: subscribe: scope eventSpec: #model_datePicker_pick handler: [:e | writeInput: e. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | rootView <-: publish: 'nsdatepicker_' event: #datePicker_pick data: datePickerData. nil]
)
datePickerData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
public class TimePickerFragment value: v <String | Holder> action: a <[:String]> = super TimePickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newTimePickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <TimePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstimepicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will write the input *)
        rootView <-: subscribe: scope eventSpec: #model_timePicker_pick handler: [:e |  writeInput: e. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | rootView <-: publish: 'nstimepicker_' event: #timePicker_pick data: timePickerData. nil]
)
timePickerData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
public class SliderFragment value: v <Holder> min: mn <Float> max: mx <Float> = super SliderFragment value: v min: mn max: mx (
    |
    buttonId <Integer> ::= newSliderId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsslider_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        rootView <-: subscribe: scope eventSpec: #model_slider_pick handler: [:e | writeInput: e. nil]
)
writeInput: v = (
  visual at: 'value' put: v.
   super writeInput: v.
)
inputHandler ^ <[:Ailen | Boolean]> = (
  ^[:event | rootView <-: publish: 'nsslider_' event: #slider_pick data: sliderData. nil]
)
sliderData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
public class DropDownMenuFragment menu: ms image: img <Image> alignment: side <Symbol> = super DropDownMenuFragment menu: ms image: img alignment: side (
    |
    buttonId <Integer> ::= newDropDownMenuId.
    public scope <String> =  'nsdropdownmenu_', buttonId printString.
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <DropDownMenuFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
  (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
  rootView <-: subscribe: scope eventSpec: #model_dropDownMenu_click handler: [:e |
  super clickHandler value: e.
  nil].
)
updateContent ^ <Alien[Element]> = (
    | menu <Alien[Div]> = computeContentForMenu: [(Menu supplier: menuSupplier) menuContents] . |
    isActive: true.
	showMenu: menu forShell: shell inVisual: visual.
    ^menu.
)
clickHandler ^ <[:Alien | Boolean]> = (
  ^[:event | rootView <-: publish: 'nsdropdownmenu_' event: #dropDownMenu_click data: buttonId. nil]
)
) : (
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: #right
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> alignment: side <Symbol> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: side
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> image: img <Image> ^ <Instance> = (
   ^menu: ms image: img alignment: #right
)
)
public class Fragment = super Fragment (
|
public croquetView_slot <Promise[Alien[NewspeakCroquetFragmentView]]>
|
) (
croquetModel = (
    ^croquetView model.
)
croquetView = (
    croquetView_slot isNil ifTrue: [setupCroquetView].
    ^croquetView_slot
)
setupCroquetView = (
  (* only fragments that actively need croquet support need this *)
  subclassResponsibility
)
) : (
)
public class Menu supplier: ms <[{Symbol | {String. []}}]>  = (
	| 
    menuId <Integer> ::= newMenuId.
    public menuContents <List[Symbol | {String. []}]> = List new.
    menuItemMap <Map[String, []]> = Map new.
	|
    buildMenuItemMap: ms.
    setupCroquetView.
) (
lazy scope <String> = 'nsmenu_', menuId printString.
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_menu_click handler: [:e <String> | (menuItemMap at: e) value. nil]
)
buildMenuItemMap: ms <[{Symbol | {String. []}}]> ^  <Map[String, []]> = (
   ms value do: [:item <Symbol | {String. []}> |
       item = #separator ifFalse: [
	 menuItemMap at: item first put: item last.	 
	 menuContents add: {item first. [
         rootView <-: publish: 'nsmenu_' event: 'menu_click' data: (js global newspeakFragmentData: menuId data: item first)]}.
     ]
     ifTrue: [menuContents add: #separator].
   ]
)
) : (
)
class HopscotchShell = super HopscotchShell (
(* We override HopscotchShell, much like we override fragments. This is needed because users interact via the navigation buttons in the web browser (or our own navigation buttons in non-browser configurations. 

This behavior is routed through the #userBack: method, which handles web browser navigation events ('onpopstate'). 
*)
  | windowId <Integer> = newWindowId. |
  setupCroquetView.
) (
scope = (
  ^'nsshell_', windowId printString
)
setupCroquetView = (
  rootView <-: subscribe: scope eventSpec: #model_shell_userBack handler: [:e | super userBack: e. nil]
)
convertPopState: event  = (
   ^js global nsPopstateData: event
)
userBack: event  = (
   rootView <-: publish: 'nsshell_' event: #shell_userBack data: (js global newspeakFragmentData: windowId data: (convertPopState: event))
)
) : (
)
class FileChooserFragment allowMultiples: b <Boolean> = super FileChooserFragment allowMultiples: b (
(*
This fragment is a bit unusual. We deviate somewhat from this module's standard formula for overriding fragments. The browser will not allow the standard (i.e., inherited) FileChooserFragment action to take place unless there was an actual user action (i.e., the user activated the UI).
As a result, only the client where the request to load files was initiated can respond with a file dialog, and only in the same turn.  This means we must take action to read files immediately, and so the #chooseFileList: method calls the super method. However, it sends it a different closure than the one passed in to it.
The original closure is stored in the #lastAction slot, while super method is passed a closure accepts the locally read file list, and forwards that data as part of the event sent to the croquet reflector.  When the reflector responds, the data is fed into the original closure kept in #lastAction. See #setupCroquetView for the details.

A complication is that the file API is asynchronous, so we only have promises initially. We must wait for these promises to be resolved to obtain the required data which we will forward to the reflector. This is handled in #fileChoiceData:whenReady:.
*)
    |
    fragmentId <Integer> ::= newFileChooserId.
    scope_slot <String>
    lastAction <[:List[Alien[File]]]>
    |
    croquetView
) (
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsfilechooser_', fragmentId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <FileChooserFragment>  ^ <Alien[Node]> = (
  scope_slot: oldFragment scope.
  ^self.
)
createFile: fd ^ <Alien[File]> = (
  | contents <JSArray> = (js global at: 'Array') new: 1. options = JSObject new. |
  contents at: 1 put: (fd at: #arrayBuff).
  options at: #name put: (fd at: #name);
               at: #type put: (fd at: #type);
               at: #lastModified put: (fd at: #lastModified).
  
  ^ (js global at: #File) new: contents options: options
)
public chooseFileList:  blk <[:List[Alien[File]]]> = (
  (* Save the original closure for later *)
  lastAction:: blk.
  (* locally read the files and pass their data to the reflector *)
  super chooseFileList: [:fs <List[Alien[File]]> |  
    (* For now, the data is their contents, presumed to be strings. Really should be an interface to the general data in a File *)
    extractFileData: fs whenReady: [:fds <JSArray[JSObject]> |
      rootView <-: publish: 'nsfilechooser_' event: #fileChooser_click data: (js global newspeakFragmentData: fragmentId data: fds)
      ]
    ]
)
setupCroquetView = (
        (* When the Croquet view is notified of the chosen files, it will message us back with the file data, which we want to submit to the original action block. 
        The block wants a list of Files, so we need to feed it objects with the same API - including async methods that return the data. Of course, we actually resolved that data before posting the original event, and so the incoming data needs to repackaged into File-like objects with a fake async API.
        *)
        rootView <-: subscribe: scope eventSpec: #model_fileChooser_click handler: [:e <JSArray[JSObject]> | 
          | len <Integer> = e at: #length. fds <List[Alien[File]]> = List new. |
          (* repackage the file data into File-ish objects *)
          1 to: len do: [:i <Integer> | fds add: (createFile: (e at: i-1))].
          (* feed the resulting 'Files' into the original closure *)
          lastAction value: fds. 
          nil
          ]
)
extractFileData: fs <List[Alien[File]]> whenReady: blk <[:JSArray[JSObject]]> = (
(* In principle, the data is the file list, fs. However, we cannot serialize File objects. We must obtain their contents via their asynchronous API, and package it up. When that data is received by clients (including the one that sent it), it will be placed in File-like objects so that the original closure (now stored in #lastAction) can consume it.  See #setupCroquetView for details. *)
  |
  ps <List[Alien[Promise[[ArrayBuffer]]]]>  = (js global at: 'Array') new: fs size.
  fds <JSArray[JSObject]>  = (js global at: 'Array') new: fs size.
  |
  1 to: fs size do: [:i <Integer> | | f <Alien[File]> = fs at: i. |
    ps at: i - 1 put: (fs at: i) arrayBuffer.
    fds at: i - 1 put: JSObject new.
    {#name. #type. #lastModified. #webkitRelativePath } do: [:pn <Symbol> |
      (fds at: i - 1) at: pn put: (f at: pn)
      ]
  ].
  ((js global at: 'Promise') all: ps) then: [:buffers <JSArray[ArrayBuffer]> |
      0 to: fs size -1 do: [:i <Integer> | (fds at: i) at: #arrayBuff put: (buffers at: i)].
	  [blk value: fds. nil] on: Error do:  [:ex | alert: ex printString. nil].
      nil
	] onError: [:ex |  alert: ex printString. nil]
)
) : (
public new ^ <Instance> = (
  ^allowMultiples: false
)
)
lazy rootView <Alien[NewspeakCroquetView]> = js global at: #theView.
newImageButtonId ^ <Integer> = (
  imageButtonCount:: imageButtonCount + 1.
  ^imageButtonCount
)
newRadioButtonId ^ <Integer> = (
  radioButtonCount:: radioButtonCount + 1.
  ^radioButtonCount
)
newHyperlinkId ^ <Integer> = (
  hyperlinkCount:: hyperlinkCount + 1.
  ^hyperlinkCount
)
newCodeMirrorId ^ <Integer> = (
  codeMirrorCount:: codeMirrorCount + 1.
  ^codeMirrorCount
)
newHyperlinkImageId ^ <Integer> = (
  hyperlinkImageCount:: hyperlinkImageCount + 1.
  ^hyperlinkImageCount
)
newToggleComposerId ^ <Integer> = (
  toggleComposerCount:: toggleComposerCount + 1.
  ^toggleComposerCount
)
newCheckboxId ^ <Integer> = (
  checkboxCount:: checkboxCount + 1.
  ^checkboxCount
)
newTextEditorId ^ <Integer> = (
  textEditorCount:: textEditorCount + 1.
  ^textEditorCount
)
rootModel ^ <Alien[NewspeakCroquetView]> = (
  ^rootView model
)
newPickerId ^ <Integer> = (
  pickerCount:: pickerCount + 1.
  ^pickerCount
)
newSliderId ^ <Integer> = (
  sliderCount:: sliderCount + 1.
  ^sliderCount
)
newColorPickerId ^ <Integer> = (
  colorPickerCount:: colorPickerCount + 1.
  ^colorPickerCount
)
newDatePickerId ^ <Integer> = (
  datePickerCount:: datePickerCount + 1.
  ^datePickerCount
)
newTimePickerId ^ <Integer> = (
  timePickerCount:: timePickerCount + 1.
  ^timePickerCount
)
newDropDownMenuId ^ <Integer> = (
  dropDownMenuCount:: dropDownMenuCount + 1.
  ^dropDownMenuCount
)
public dropDownImage = (
  ^super dropDownImage
)
replaceUndefined: event = (
  ^js global replaceUndefined: event
)
printJSObjectTree: event  = (
  ^js global printJSObjectTree: event
)
newMenuId ^ <Integer> = (
  menuCount::menuCount + 1.
  ^menuCount
)
openMenu: aMenu <Menu> = (	
	showMenu: (computeContentForMenu: [(Menu supplier: [aMenu]) menuContents]) forShell: shell inVisual: visual.
)
computeContentForMenu: menuSupplier <[Menu]> ^ <Alien[Div]> = (
  ^super computeContentForMenu: menuSupplier
)
showMenu: menu <Alien[Div]> 
		forShell: s <HopscotchShell> 
		inVisual: v <Visual> = (
   super showMenu: menu forShell: s inVisual: v 
)
newWindowId ^ <Integer> = (
  windowCount:: windowCount + 1.
  ^windowCount
)
newFileChooserId ^ <Integer> = (
  fileChooserCount:: fileChooserCount + 1.
  ^fileChooserCount
)
newButtonId ^ <Integer> = (
  buttonCount:: buttonCount + 1.
  ^buttonCount
)
JSObject  = ((* make JS Object constructor available to nested classes *)
  ^super JSObject
)
) : (
)
) : (
)
