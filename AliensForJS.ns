Newspeak3
'Root'
class AliensForJS usingPlatform: p = (
(* Aliens are a capability-based API for a foreign function interface (FFI). On NS2JS, they allow Newspeak code to invoke JavaScript code and vice versa.

An Alien is a Newspeak proxy for a JavaScript object. Upon receiving a message, an Alien expatriates the arguments, sends the message to the target JavaScript object, and alienates the result.

An Expat is a JavaScript proxy for a Newspeak object. Upon receiving a message, an Expat alienates the arguments, sends the message to the target Newspeak object, and expatriates the result.

A bilingual object is one whose representation is the same in both languages: unwrapped basic types such as numbers, booleans. Note that even though Newspeak and JavaScript closures have the same representation, they are not bilingual and wrapping should occur because Newspeak closures expect Newspeak/Alien arguments and JavaScript closures expect JavaScript/Expat arguments. What about strings and arrays? It would seem we have to wrap arrays because their elements should be alieniated/expatriated. It may be safe to treat strings as bilingual if they always respond to messages with other bilingual objects.

Alien mappings:
alien sort: a ignored: b ignored: c -> alien.sort(a, b, c)
alien new: a ignored: b ignored: c  -> new alien(a, b, c)
alien at: 'a' -> alien.a
alien at: 'a' put: b -> alien.a = b

Expat mappings:
?

*)
|
public global = Alien wrapping: (_js ident: 'theGlobalObject').
public undefined = Alien wrapping: (_js ident: 'undefined').
|) (
class Alien wrapping: o = (
	_js assign: (_js propertyOf: self at: (_js literal: 'jsTarget')) toBe: o.
) (
public at: key = (
	^alienate: (_js 
		call: (_js propertyOf: (_js ident: 'Reflect') at: (_js literal: 'get'))
		with: {_js propertyOf: self at: (_js literal: 'jsTarget'). expatriate: key})
)
public at: key put: value = (
	_js
		call: (_js propertyOf: (_js ident: 'Reflect') at: (_js literal: 'set'))
		with: {_js propertyOf: self at: (_js literal: 'jsTarget'). expatriate: key. expatriate: value}.
	^value
)
doesNotUnderstand: msg = (
	| jsTarget jsArguments jsSelector jsResult |
	jsTarget:: _js propertyOf: self at: (_js literal: 'jsTarget').
	jsArguments:: msg arguments collect: [:arg | expatriate: arg].
	jsSelector:: copyUntilFirstColon: msg mangledSelector.
	jsResult:: jsSelector = 'new'
		ifTrue:
			[_js call: (_js propertyOf: (_js ident: 'Reflect') at: (_js literal: 'construct')) with: {jsTarget. jsArguments}]
		ifFalse:
			[ | jsFunction |
			jsFunction:: _js propertyOf: jsTarget at: jsSelector.
			(_js operator: '===' with: jsFunction and: (_js ident: 'undefined'))
				ifTrue: [^super doesNotUnderstand: msg].
			_js call: (_js propertyOf: (_js ident: 'Reflect') at: (_js literal: 'apply')) with: {jsFunction. jsTarget. jsArguments}].
	^alienate: jsResult
)
public isUndefined = (
	^_js operator: '===' with: (_js propertyOf: self at: (_js literal: 'jsTarget')) and: (_js ident: 'undefined')
)
public printString = (
	self isUndefined ifTrue: [^'undefined']. (* undefined.toString() throws in JS *)
	^(_js call: (_js propertyOf: (_js propertyOf: self at: (_js literal: 'jsTarget')) at: (_js literal: 'toString')) with: {})
)
public value = (
	| jsTarget = _js propertyOf: self at: (_js literal: 'jsTarget'). |
	^alienate: (_js
		call: (_js propertyOf: jsTarget at: (_js literal: 'call'))
		with: {jsTarget})
)
public value: a1 = (
	| jsTarget = _js propertyOf: self at: (_js literal: 'jsTarget'). |
	^alienate: (_js
		call: (_js propertyOf: jsTarget at: (_js literal: 'call'))
		with: {jsTarget. expatriate: a1})
)
public value: a1 value: a2 = (
	| jsTarget = _js propertyOf: self at: (_js literal: 'jsTarget'). |
	^alienate: (_js
		call: (_js propertyOf: jsTarget at: (_js literal: 'call'))
		with: {jsTarget. expatriate: a1. expatriate: a2})
)
public value: a1 value: a2 value: a3 = (
	| jsTarget = _js propertyOf: self at: (_js literal: 'jsTarget'). |
	^alienate: (_js
		call: (_js propertyOf: jsTarget at: (_js literal: 'call'))
		with: {jsTarget. expatriate: a1. expatriate: a2. expatriate: a3})
)
public valueWithArguments: args = (
	| jsTarget = _js propertyOf: self at: (_js literal: 'jsTarget'). |
	^alienate: (_js
		call: (_js propertyOf: jsTarget at: (_js literal: 'apply'))
		with: {jsTarget. args collect: [:nsArg | expatriate: nsArg]})
)
public isKindOfJSAlien ^<Boolean> = (
	^true
)
) : (
)
class Expat wrapping: o = (
	(* :todo: Implement with ES6 Proxy instead. *)
	_js assign: (_js propertyOf: self at: (_js literal: 'nsTarget')) toBe: o.
) (
public isKindOfJSAlien ^<Boolean> = (
	^false
)
) : (
)
copyUntilFirstColon: sel = (
	#BOGUS. (* DNU does not yet pass unmangled selectors. *)
	2 to: sel size do: [:i |
		((sel at: i) = "$") ifTrue: [^sel copyFrom: 2 to: i - 1]].
	^sel copyFrom: 2 to: sel size
)
expatriateBlock: b = (
	^_js functionOf: {} body: (
		_js return: (
			expatriate: (
				b valueWithArguments: (
					(_js verbatim: 'Array.prototype.slice.call(arguments, 0)') collect: [:ea | alienate: ea]))))
)
alienate: jsObj = (
	#TODO.
	(_js operator: '===' with: (_js ident: 'null') and: jsObj) ifTrue: [^nil].
	(_js prefixOperator: 'typeof ' on: jsObj) == 'string' ifTrue: [^jsObj].
	(_js prefixOperator: 'typeof ' on: jsObj) == 'number' ifTrue: [^jsObj].
	(_js prefixOperator: 'typeof ' on: jsObj) == 'boolean' ifTrue: [^jsObj].
	(* This does not discrimate NS vs JS closures *)
	(_js prefixOperator: 'typeof ' on: jsObj) == 'function' ifTrue: [^Alien wrapping: jsObj].
	(_js operator: 'instanceof' with: jsObj and: (_js propertyOf: (_js propertyOf: Object at: (_js literal: 'runtimeClass')) at: (_js literal: 'basicNew')))
		ifTrue:
			[jsObj isKindOfJSAlien ifTrue: [Error signal: 'Shouldnt be asked to double alienate...'].
			jsObj isKindOfExpat ifTrue: [^_js propertyOf: jsObj at: (_js literal: 'nsTarget')].
			Error signal: 'Asked to alienate a raw Newspeak object...'].
	(_js operator: 'instanceof' with: jsObj and: (_js ident: 'Uint8Array')) ifTrue: [^jsObj].
	^Alien wrapping: jsObj
)
expatriate: nsObj = (
	#TODO.
	(_js operator: '===' with: nil and: nsObj) ifTrue: [^_js ident: 'null'].
	(_js prefixOperator: 'typeof ' on: nsObj) == 'string' ifTrue: [^nsObj].
	(_js prefixOperator: 'typeof ' on: nsObj) == 'number' ifTrue: [^nsObj].
	(_js prefixOperator: 'typeof ' on: nsObj) == 'boolean' ifTrue: [^nsObj].
	(* This does not discrimate NS vs JS closures *)
	(_js prefixOperator: 'typeof ' on: nsObj) == 'function' ifTrue: [^expatriateBlock: nsObj].
	(_js operator: 'instanceof' with: nsObj and: (_js propertyOf: (_js propertyOf: Object at: (_js literal: 'runtimeClass')) at: (_js literal: 'basicNew')))
		ifTrue:
			[nsObj isKindOfJSAlien ifTrue: [^_js propertyOf: nsObj at: (_js literal: 'jsTarget')].
			nsObj isKindOfExpat ifTrue: [Error signal: 'Shouldnt be asked to double expatriate...'].
			^Expat wrapping: nsObj.].
	(_js operator: 'instanceof' with: nsObj and: (_js ident: 'Uint8Array')) ifTrue: [^nsObj].
	Error signal: 'Asked to expatriate a raw JS object...'
)
public localStorage ^ <Alien> = (
  ^(global at: #window) at: #localStorage
)
) : (
)
