Newspeak3
'NS2V8'
class Newspeak2V8Compilation usingPlatform: platform
 asts: asts
 parsing: parsing
 generation: generation
 mirrors: mirrors = NewspeakCompilation
 usingPlatform: platform
 asts: asts ((* This module provides a Newspeak-to-Javascript cross-compiler. It is a descendent of Newspeak2Javascript which takes care to generate code that is easier for V8 to optimize and which is easier to maintain because of a simpler bootstrapping story and strategy for including bits that need to be written directly in Javascript. The output is not V8-specific and should run in any Javascript implementation that supports apply(), call() and bind().

The current compilation scheme does not address async sends or reified activation records. It priovides only limited support for refection. Also,  it does not provide generalized mixin application.

At runtime, a Newspeak object O is represented as a Javascript object J with properties that correspond directly to the Newspeak slots. The prototype of J is a runtime-class JRC, whose properties correspond to the instance methods of O's class, including any necessary synthetic methods. The prototype of JRC is another runtime class object corresponding to the superclass of O's class, and so on up to Object. The prototype of the runtime class of Object is ImplementationBase, which is hand-written and contains stub implementations to end the upward recursion in basicNew and the instance initializers.

JRC includes synthetic slots that refer to its runtime mixin, its enclosing object chain, and its metaclass or non-metaclass counterpart.

The main output of the compiler is an object containing all of the runtime mixins corresponding to the top-level class declarations. A runtime mixin has properties containing the definitions of its Newspeak and synthetic methods and its nested mixins. It also has a function that takes a runtime superclass and produces a runtime class that represents the application of the mixin. This function produces either a runtime class or a runtime metaclass, not the pair.

One synthetic method deserves particular attention: basicNew(). The prototype of basicNew is the runtime class. The body of basicNew calls the basicNew of the superclass using call(), then initializes properties corresponding to each Newspeak slot to nil.

All mixin applications share the same Newspeak and synthetic functions, except basicNew.

[PERFORMANCE NOTE] It is important that objects have all their slots initialized up front, rather than lazily. This ensures that all instances of the same Newspeak class go through the same transitions in the same order so V8 will give them all the same "hidden class" (what Self called a map).

[PERFORMANCE NOTE] It is important that an object's methods are defined in a prototype, rather than in the constructor call. If they were defined in the constructor, they would be different objects with different contexts.

[PERFORMANCE NOTE] The current structure where the functions for methods are defined in other deeply nested functions may produce functions that perform slower than if they had been defined at the top level. This is because of a need to give them contexts, even if they never access their free variables. This used to be an issue in V8, but it was fixed under pressure from dart2js (who wanted to nest all of their code at least one level to avoid polluting the global scope). It may still be the case in other Javascript engines.

Object creation follows the same pattern as the Squeak and Dart implementations: basicNew is followed by running a synthetic instance initializer.

Mixin application is implemented by a hand-written method on VMMirror. First a pair of runtime class and runtime metaclass are produced by applying the runtime mixin and runtime metamixin to the runtime class of the superclass and the runtime class of Class, respectively. Then an instance of Metaclass is created to represent the Newspeak metaclass, and an instance of the metaclass is created to represent the Newspeak class. Newspeak objects never directly interact with runtime classes or runtime mixins; the objects answered by #class are the Newspeak class or metaclass.

Self sends and ordinary sends map to Javascript method invocation. Outer sends map to an invocation on an entry in the enclosing objects array at the correct depth. Implicit receiver sends are resolved either as the self sends or outer sends at compile-time. Super sends are implemented as call() applied to the corresponding property of the runtime superclass.

Newspeak selectors are mangled into legal Javascript identifiers. The mangling differs according to the accessibility of the selector. Public selectors are always prefixed with$. In addition,  keyword selectors have each colon replaced with dollar. For binary selectors, they are the concatenation of a mapping for each of the special characters. Examples:

yourself maps to $yourself.
with:with: maps to $$with$with.
 +- maps to $$plus$minus.

For protected selectors, the public mangling is preceded with an underscore. Hence

 yourself maps to _$yourself.
with:with: maps to _$$with$with.
 +- maps to _$$plus$minus.

The selector #doesNotUnderstand: is treated specially and mapped to dnu.
A full description of the access control scheme is available at:  https://docs.google.com/document/d/1CHTjsOsamXv9AwGTvkhe871QVY5vpZP9sDfz6I40gaA/

[PERFORMANCE NOTE] It is important that we use legal identifiers for our property names. The earlier NS2JS did not mangle selectors and instead used square bracket notation to access properties. For example, foo at: 1 put: 2 would become foo["#at:put:"](1,2) rather than foo.at$put$(1,2). V8 eagerly transitions objects like these to dictionary mode, which means they do not have fast property access. This is the most important difference between NS2JS and NS2V8.

Non-local return is implemented using exceptions. The body of a method containing an NLR is wrapped in a try-catch block. At the beginning, an object is created to represent the current activation. When there is a non-local return, the return value is assigned to a property of this object and the object is thrown. The catch clause checks if the object thrown corresponds to its NLR object, and if so extracts the value and does a Javascript (local) return. Otherwise the object is re-thrown.

[ENGINEERING NOTE]
This is buggy, because if a closure returns after its home context has completed, the exception will not be caught and the entire program will crash (even when debugging in the IDE).  A method that contains an NLR must invalidate its NLR exception object when it exits, and closures must check the vaidity of the NLR exception before throwing; if it is in valid, a CannotReturn must be signaled. The best way to accomplish all this is to set the variable holding the NLR exception to nil upon home context exit, so that the closure can test for nil when executing an NLR. This will have very minor performance impact.

Newspeak closures map to Javascript functions. Accesses to self do *not* map directly to "this". Rather the receiver must be captured in a local at the beginning of a method, and access must be through this local to get proper lexical scope.

[UNIMPLEMENTED] This representation is not suitable for closure mirrors as there is no way in Javascript to get at the closure's free variables. To support closure mirrors, we would have create objects for each closure that took free variables and the enclosing context as arguments and stored them as slots that reflection could later access. dart2js follows this approach (but I believe this is to ensure they cannot be called with the wrong arity).

To implement #doesNotUnderstand:, for every message sent the compiler emits a DNU catcher that creates a Message object from the arguments and forwards to #doesNotUnderstand:.  At bootstrap, these handlers are all installed into ImplementationBase under for both the public and protected manglings of the selector.

[PERFORMANCE NOTE] It is important that these prototypes are all installed up-front, rather than the subset needed at each mixin application, to ensure the prototype chain is stable during the program's execution. Installing these catchers later would trigger deoptimizations.

The basic types (number, array, block, boolean, string) are represented directly as their Javascript counterparts. Where the Javascript behavior differs from the Newspeak behavior, we monkey patch the Javascript prototypes.

[ENGINEERING NOTE] These patches are all defined in classes of KernelForV8, using the js intrinsic described below. Unlike NS2JS, there is no need to look through several places and bootstrapping phases to find where such behavior is defined. Adding or modifying behavior for the basic types is as easy as adding or changing methods in these classes.

[PERFORMANCE NOTE] It is important that these patches are labelled for strict mode to avoid automatic boxing.

[ENGINEERING NOTE] We simply label the whole program for script mode, but if our output got wrapped in or otherwise mixed with other scripts, it wouldn't run in script mode.

[ENGINEERING NOTE] dart2js does not use this technique because they want to interoperate with other Javascript code. Instead they use a technique called interceptors, and can avoid the cost in the common case through fancy type inference and inlining that make runtime modification very difficult. Newspeak doesn't want to go there and is content to monkey patch.

[ENGINEERING NOTE] Like dart2js, we cave on the semantics of integers by directly representing our numbers as Javascript numbers, which are doubles.

Nil is not represented as Javascript's null. We use of a singleton instance of the Newspeak class UndefinedObject.

Source code is not stored with the methods. Instead, each runtime class has an associated metadata structure that stores an index into an array of method sources. The metadata is stored in an array accessed via the property 'methods'. Each method has an entry with properties 'name', 'isSynthetic' and 'source'. This array is stored in the Javascript global variable 'sources'.  The deployment tools can place the code for initializing this array in a separate file, so deployments that do not wish to support debugging can easily avoid the space penalty for the source. 

Bootstrapping: the compiled Javascript starts by hand-initializing the classes of Kernel to deal with the circular references. Then a namespace is populated with the applications of each of the top-level mixins to Object. This namespace is passed to the factory of RuntimeForV8, and the returned object is passed the VMMirror. This causes the platform object to be created and initialized. As part of this process, the DNU catchers and basic type monkey patches are installed. The application configuration is then passed the namespace, and the returned app object is sent #main:args: with the platform.  (Newspeak2Dart follows the same pattern, though without DNU catcher or basic type patches.)

[ENGINEERING NOTE] This is *way* simpler than whatever multi-phase thing NS2JS is doing.

The js intrinsic: When compiling the platform sources, we evaluate sends to "js" at compile-time against a factory for Javascript ASTs (an instance of JavascriptGeneration`Factory). For instance,

at: index = (
  ^js propertyOf: (js ident: 'this') at: index - 1
)

translates to

function $at$(index) { return this[index - 1]; }

Note that arguments in messages to "js" can be arbitrary expressions (index - 1), which will be compiled like any other ordinary expression, allowing one to write implementations partially in the target language and partially in ordinary Newspeak in the same method.

This scheme allows the implementations of primitives to be written in the methods they are implementing and without special language support like pragmas, externs or native clauses, which I think is pretty cool :)


[UNIMPLEMENTED] Async sends

[UNIMPLEMENTED] Reflective modification

This brings up several issues. 
(1) Because implicit sends are resolved statically to self sends or outer sends, it is not sufficient to just add or remove methods. Potentially, the entire class must be recompiled if the change hides/unhides a method in the surrounding scope.
(2) Adding a new selector requires adding a new DNU catcher in ImplementationBase, which may have very negative effects on performance.  We could try and rely on the ES6 handlers if we only care about new browsers.


[UNIMPLEMENTED] Reified activation records

These are needed to provide a proper live debugger.


Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.
Copyright 2013 Ryan Macnak
Copyright 2014-2017 Google Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
	Collection = platform collections Collection.
	Map = platform collections Map.
	List = platform collections List.
	Set = platform collections Set.
	StringBuilder = platform kernel StringBuilder.
	
	Parser = parsing Parser.
	
	javascriptGeneration = generation.
	JavascriptWriter = javascriptGeneration Writer.
	js = javascriptGeneration factory.

	public names = NameMangler new.

	ASTTool = asts ASTTool.
      ASTCopier = asts ASTCopier.
      AST = asts AST.
	AssignmentAST = asts AssignmentAST.
	BlockAST = asts BlockAST.
	CascadedSendAST = asts CascadedSendAST.
	CodeBodyAST = asts CodeBodyAST.
	MessageAST = asts MessageAST.
      MessagePatternAST = asts MessagePatternAST.
	MethodAST = asts MethodAST.
	NormalSendAST = asts NormalSendAST.
	NumberAST = asts NumberAST.
	ReturnStatAST = asts ReturnStatAST.
      SendAST = asts SendAST.
	SymbolAST = asts SymbolAST.
	TupleAST = asts TupleAST.
      VarDeclAST = asts VarDeclAST.
	VariableAST = asts VariableAST.
	
	public parser = Parser new.
	
	cachedCompilations = Map new.
	sourcesList ::= List new. (* Ick, should really belong to ProgramBuilder. *)
|) (
class CachedCompilation = (|
	public source <String>
	public enableIntrinsics <Boolean>
	public ir <ClassDeclarationIR>
	public sentSelectors <Set[Symbol]>
|) (
) : (
)
public class Compiler = super Compiler ((* A work-in-progress Compiler reimplementation, with Javascript AST as the output. This makes automated testing easier and provides control over formatting (for example, placing every expression on its own line to allow for precise breakpoint placement in substandard JS debugger implementations). *)|
	scopeStack ::= List new.
	input
	public sentSelectors ::= Set new.

	rewriter = Rewriter new.	
	translator = Translator new.
	currentDepth
	currentMixinUID
	jsWriter = JavascriptWriter new.
	public supportDoesNotUnderstand ::= true.
	public inlineOperators ::= true.
	public enableIntrinsics ::= true.
|) (
class PropertyCallAST = MessageAST ((* Sepcialized node to represent applications of JS properties. In some cases (well, at least one) we need to generate ASTs that call javascript methods directly. These calls need to be translated slightly differently (their names must not be mangled). To distinguish these form normal message sends, we use this node. *)) (
public apply: tool <ASTTool> = (
	^tool propertyCallNode: self
)
) : (
)
class Rewriter = super Rewriter (|
	protected inlinableOperators <Map[String, String]> = Map new.
	protected inlinableNumericOperators <Map[String, String]> = Map new.
|inlinableOperators
		at: #+ put: '+';
		at: #- put: '-';
		at: #* put: '*';
		at: #/ put: '/';
		at: #'==' put: '==='.
	inlinableNumericOperators	
		at: #'<' put: '<';
		at: #'<=' put: '<=';
		at: #'>' put: '>';
		at: #'>=' put: '>=') (
class InlinedOperatorAST = NormalSendAST ((* When the inlineOperators mode is on, message sends with certain selectors are replaced with this node. Javascript code generated for those nodes uses native Javascript operators instead of real message sends. The selector of the message of this AST is not a real Newspeak selector but rather the Javascript operator such as &&. *)|
|) (
public apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinedOperatorNode: self
)
) : (
)
class SchedulerAST = AST () (
public apply: visitor <ASTVisitor> = (
	^visitor schedulerNode: self
)
) : (
)
__isInlinableAsExpressionConditional: node <NormalSendAST> ^ <Boolean> = (
	((conditionalSelectors includes: node msg sel) and: [valueExpected]) ifFalse: [^false].
	node msg args do:
		[:each <AST> |
		((isRemovableBlock: each withArgs: 0)
			and: [each body statements size = 1
			and: [each body statements first isReturnStatNode not]])
				ifFalse: [^false]].
	^true
)
canInlineSeqexps ^<Boolean> = (
	^false
)
currentScope = (
	^super currentScope
)
inline: node as: sendClass selector: selector rewriteArgsAs: argRewriteBlock = (
	| receiver message |
	receiver:: applyForValueTo: node receiver.
	message:: MessageAST new
		send: selector
		with: (node message arguments collect: argRewriteBlock).
	^sendClass new
		to: receiver send: message;
		start: node start;
		end: node end
)
isInlinableBooleanOperator: node <NormalSendAST> = (
	| selector |
	selector:: node message selector.
	^(selector = 'or:' or: [selector = 'and:'])
		and: [node message arguments size = 1
		and: [node message arguments first isBlockNode
		and: [node message arguments first body statements size = 1]]]
)
isInlinableNumericOperator: node <NormalSendAST> = (
	| args |
	args:: node message arguments.
	args size = 1 ifFalse: [^false].
	(inlinableNumericOperators includesKey: node message selector) ifFalse: [^false].
	(node receiver isLiteralNode and: [node receiver value isNumber]) ifTrue: [^true].
	(args first isLiteralNode and: [args first value isNumber]) ifTrue: [^true].
	^false
)
isInlinableOperator: node <NormalSendAST> = (
	^(inlinableOperators includesKey: node message selector)
		and: [node message arguments size = 1]
)
public normalSendNode: node <NormalSendAST> ^ <AST> = (
	#BOGUS. (* Eventual sends trump inlining, but we shouldn't need to duplicate the eventual send check. Maybe the inlining should be deferred until we know it is an immediate ordinary send? *)
	(node message isEventual)
		ifTrue: [^processEventualSend: node].

	(inlineOperators and: [isInlinableNumericOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableNumericOperators at: node message selector)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableOperators at: node message selector)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableBooleanOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (node message selector = 'and:' ifTrue: ['&&'] ifFalse: ['||']) (* BOGUS *)
			rewriteArgsAs: [:each <BlockAST> | applyForValueTo: each body statements first]].
	
	^super normalSendNode: node
)
processEventualSend: node <NormalSendAST> = (
	| scheduler receiver selector arguments |
	scheduler:: SchedulerAST new.
		
	receiver:: node receiver apply: self.
	selector:: (SymbolAST new value: node message selector) apply: self.
	arguments:: (TupleAST new elements: node message arguments) apply: self.

	^(OrdinarySendAST
		to: scheduler
		send: ((MessageAST new
			send: #eventualSendTo:selector:arguments: 
			with: {receiver. selector. arguments})
				copyPositionFrom: node message))
		copyPositionFrom: node
)
public propertyCallNode: node <PropertyCallAST> ^ <PropertyCallAST> = (
	| args |
	assert: [node isMessageNode].
	args:: List new.
	node arguments do: [:each | args add: (applyForValueTo: each)].
	^PropertyCallAST new
		send: node selector with: args;
		start: node start;
		end: node end
)
setterBlockArgName = (
	^ ('setter_arg') asSymbol
)
public setterSendNode: node <SetterSendAST> ^ <AST> = (
(* Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send. *)
	| binding block blockArg blockParam blockScope send rewrittenSetterSend |
	binding:: currentScope at: node message selector ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		(* This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned. *)
		[^processLocalAccess: node message of: binding].
	valueExpected ifFalse:
		(* The parent ignores the expression value; use a plain cheap here message send. *)
		[^processImplicitReceiverSend: node].

	(* The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr *)
	(* a -- ok to use a constant name as long as it cannot collide with a user's name *)
	blockArg:: NormalSendAST new
		to: implicitReceiverNode
		send: (MessageAST new send: setterBlockArgName with: {}).
	blockParam:: ParameterAST name: setterBlockArgName type: nil.
	(* setter: a *)
	send:: NormalSendAST new to: node receiver send:
		(MessageAST new selector: node message selector; arguments: {blockArg};
		start: node message start; end: node message end; yourself);
		start: node start; end: node end.
	(* [:a | setter: a. a] *)
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {blockParam}
			temporaries: {}
			statements: {
				send.
				blockArg
			};			
			start: node start; end: node end);
			start: node start; end: node end.
	blockScope:: Scope new.
	blockScope
		superScope: currentScope;
		at: setterBlockArgName put: (LocalEntry forDeclaration: blockParam atDepth: nil).
	scopeMap at: block put: blockScope.
	scopeMap at: block body put: blockScope.
	(* [:a | setter: a. a] value: expr *)
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				selector: #value:;
				arguments: {node message arguments first};
				start: node message start; end: node message end);
				start: node start; end: node end.
	^applyForValueTo: rewrittenSetterSend
)
) : (
)
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = super ScopeBuilder nestedIn: initialScope atLevel: initialDepth () (
public propertyCallNode: aNode <PropertyCallAST> = (
	self messageNode: aNode
)
) : (
public new ^<Instance> = (
	^self nestedIn: Scope new atLevel: 0
)
)
class Translator = ASTTool ((* Visits nodes of an NS AST to produce a Javascript AST. The usual translation unit is a method. Translation is initiated by sending the translateMethodNode: message. The argument is the method to translate, the returned value is the translation. *)|
	scopeStack
	public currentSelector
	protected containsNonLocalReturn <Boolean> (* Set to false at the beginning of translating a method. The code that emits a non-local return sets this to true. The top-level code checks the value to see whether to emit a try-catch wrapper for an NLR. *)
	protected methodIsPrivate <Boolean>
|) (
addCascadedSend: node to: statements = (
	node isCascadedSendNode ifTrue:
		[addCascadedSend: node previousSend to: statements].
	statements add:
		(js call: (js propertyOf: (js ident: 'cascadeReceiver') at: (publicMessage: node message))
			with: (node message arguments collect: [:each | each apply: self]) asArray). 
)
public beginNewTranslationCycle = (
	scopeStack:: List new.
	containsNonLocalReturn:: false.
)
public blockLocalReturnNode: node <BlockLocalReturnAST> = (
	^js return: (node expression apply: self)
)
public blockNode: node <BlockAST> = (
(* Commented out code creates a special object that may be examined by ClosureMirrors.
*)
       ^(* js new: (js ident: #JsBlock) with: { *)
		js functionOf: (node parameters collect: [:each | each apply: self]) asArray
			body: (node body apply: self).
		(* freeNameLiteralOf: node.
		astFunctionForBlock: node. 
		js literal:  (sourceForNode: node). 
		js literal: parsedLanguage
		} *)
)
public boolNode: node <BoolAST> = (
	^js literal: node value
)
public cascadedSendNode: node <CascadedSendAST> = (
	| statements |
	statements:: List new.
	addCascadedSend: node to: statements.
	statements at: statements size put: (js return: statements last).
	^js call: (js functionOf: {'cascadeReceiver'} body: (js block: statements))
		with: {node receiver apply: self}
)
public charNode: node <CharAST> = (
	(* Javascript has no characters, only strings. *)
	^js literal: node value asString
)
public codeBodyNode: node <CodeBodyAST> = (
	| locals statements |
	locals:: node temporaries collect: [:each | each apply: self].
	statements:: node statements collect: [:each | each apply: self].
	^js block: (locals asArray, statements) asArray
)
public conditionalNode: node <ConditionalAST> = (
	^inlinableConditionalNode: node
)
public enclosingObjectNode: node <EnclosingObjectAST> = (
	^processOuterReceiverAtDepth: node depth
)
public implicitReceiverSendNode: node <ImplicitReceiverSendAST> = (
	| receiver = processOuterReceiverAtDepth: node depth. |
	^processLexicalSend: node message to: receiver binding: node binding
)
public inlinableAsExpressionConditionalNode: node <InlinableConditionalAST> = (
	| truePath falsePath condition |
	
	condition:: (node receiver apply: self).
	
	node message selector = 'ifTrue:' ifTrue:
		[truePath:: (node message arguments at: 1) body statements first apply: self.
		falsePath:: js ident: 'nil'].
	node message selector = 'ifFalse:' ifTrue:
		[truePath:: js ident: 'nil'.
		falsePath:: (node message arguments at: 1) body statements first apply: self].
	node message selector = 'ifTrue:ifFalse:' ifTrue:
		[truePath:: (node message arguments at: 1) body statements first apply: self.
		falsePath:: (node message arguments at: 2) body statements first apply: self].
	node message selector = 'ifFalse:ifTrue:' ifTrue:
		[truePath:: (node message arguments at: 2) body statements first apply: self.
		falsePath:: (node message arguments at: 1) body statements first apply: self].
	
	^js ternaryIf: condition then: truePath else: falsePath
)
public inlinableConditionalNode: node <InlinableConditionalAST> = (
	| inverseCondition hasElseClause condition |
	inverseCondition:: node ifTrue not.
	hasElseClause:: node else isNil not.
	condition:: node condition apply: self.
	^js if: (inverseCondition ifTrue: [js prefixOperator: '!' on: condition] ifFalse: [condition])
		then: (node then apply: self)
		else: (hasElseClause ifTrue: [node else apply: self] ifFalse: [nil])
)
public inlinedOperatorNode: node <InlinedOperatorAST> = (
	(* We are not modeling JS operator precedence, so just parenthesize everything. *)
	^js operator: node message selector
		with: (node receiver apply: self)
		and: (node message arguments first apply: self)
)
public localReadNode: node <LocalReadAST> = (
	^js ident: (names mangleLocal: node name)
)
public localWriteNode: node <LocalWriteAST> = (
	^js assign: (js ident: (names mangleLocal: node name)) toBe: (node value apply: self)
)
public loopNode: node <LoopAST> = (

	(* prologue; while(cond==whileTrue) {body}; *)

	|
	prologue = node prologue apply: self.
	cond = node condition apply: self.
	body = node body ifNil: [js block: {}] ifNotNil: [:it | it apply: self].
	
	(* Split the condition is it isn't a single expression *)
	condExpression ::= cond statements last.
	condPrologue = cond statements asOrderedCollection removeLast; yourself.
	|
	
	node isWhileTrue ifFalse: [
		condExpression:: js prefixOperator: '!' on: condExpression].
	
	(* Flatten prologue so its declarations are in scope for the loop *)
	
	^js block: 
		prologue statements,
		condPrologue, {
		js 
			for: (js verbatim: '')
			while: condExpression
			step: (js verbatim: '')
			do: (js block: body statements, condPrologue)}
)
maybeCaptureReceiver = (
	methodIsPrivate
		ifTrue: [^{}]
		ifFalse: [^{js var: selfName value: (js ident: 'this')}].
)
public messageNode: node = (
	halt.
	sentSelectors add: node selector.
	^js literal: (names mangleSelector: node selector)
)
public messagePatternNode: node <MessagePatternAST> ^<List[String]> = (
	| jsParameters = List new. |
	currentSelector:: node selector.
	methodIsPrivate:: node accessModifier = #private.
	methodIsPrivate ifTrue: [jsParameters add: selfName].
	node parameters do: [:each | jsParameters add: (each apply: self)].
	^jsParameters
)
public methodLocalReturnNode: node <MethodLocalReturnAST> = (
	containsNonLocalReturn ifFalse: 
		[^js return: (node expression apply: self)].

	^js block: {
		js var: 't' value: (node expression apply: self).
		js assign: (js ident: nlrName) toBe: (js ident: 'null').
		js return: (js ident: 't')
	}
)
public methodNode: node <MethodAST> ^<Node> = (
	| translatedBody |
	node body apply: self. (* Translate once to compute containsNonLocalReturn. Method-local returns that appear before the non-local return are incorrectly compiled. *)
	translatedBody:: node body apply: self.
	^js functionOf: (node pattern apply: self) asArray
		body: (containsNonLocalReturn
			ifTrue: [wrapBodyForNlrHandling: translatedBody]
			ifFalse: [wrapBodyNoNlrHandling: translatedBody]).
)
public nilNode: node = (
	^js ident: 'nil'
)
nlrName = (
	^'NLR'
)
nlrValuePropertyName = (
	^'value'
)
public nonLocalReturnNode: node <NonlocalReturnAST> = (
	^returnStatNode: node
)
public numberNode: node <NumberAST> = (
	^js literal: node value
)
public ordinarySendNode: node <OrdinarySendAST> = (
	enableIntrinsics ifTrue: [
		node receiver isImplicitReceiverSendNode ifTrue: [
			node receiver message selector = 'js' ifTrue: [^processIntrinsic: node message]]].

	^js 
		call: (js propertyOf: (node receiver apply: self) at: (publicMessage: node message))
		with: (node message arguments collect: [:each | each apply: self]) asArray
)
public outerSendNode: node <OuterSendAST> = (
	| receiver = processOuterReceiverAtDepth: node depth. |
	^processLexicalSend: node message to: receiver binding: node binding
)
public parameterDeclNode: node <ParameterAST> = (
	^names mangleLocal: node name
)
processIntrinsic: msg <MessageAST> = (
	^js perform: msg selector
		withArguments: (msg arguments collect: [:arg | processIntrinsicArg: arg]) asArray.
)
processIntrinsicArg: arg <AST> = (
	arg isTupleNode ifTrue: [^(arg elements collect: [:el | processIntrinsicArg: el]) asArray].
	arg isLiteralNode ifTrue: [^arg value].
	^arg apply: self
)
processLexicalSend: message to: jsReceiver binding: binding = (
	
	(binding notNil and: [binding ast accessModifier = #private]) ifTrue: [
		(* Do early binding. *)
		|
		definingMixinDepth = binding depth - 1.
		definingMixin = js ident: '$', definingMixinDepth printString.
		targetMethod = js propertyOf: definingMixin at: (publicMessage: message).
		|
		^js call: targetMethod (*(js propertyOf: targetMethod at: (js literal: 'call'))*)
			with: {jsReceiver}, (message arguments collect: [:each | each apply: self]) asArray
	].
	
	^js 
		call: (js propertyOf: jsReceiver at: (protectedMessage: message))
		with: (message arguments collect: [:each | each apply: self]) asArray
)
processOuterReceiverAtDepth: depth <Integer> = (
	| slotName |
	depth = 0 ifTrue: [^js ident: 'self'].
	slotName:: names mangleSynthetic: 'enclosingObjects`', currentMixinUID.
	^js propertyOf: (js propertyOf: (js ident: 'self') at: (js literal: slotName))
		at: (js literal: depth - 1) (* Adjust for self not being in the enclosing objects array. *)
)
public propertyCallNode: node <PropertyCallAST> = (
	^js literal: (names mangleSelector: node selector)
)
protectedMessage: node = (
	sentSelectors add: node selector.
	^js literal: (names mangleProtected: node selector)
)
publicMessage: node = (
	sentSelectors add: node selector.
	^js literal: (names manglePublic: node selector)
)
public receiverNode: node <ReceiverNode> = (
	^js ident: selfName
)
public returnStatNode: node <ReturnAST> = (
	containsNonLocalReturn:: true.
	^js block: {
		js var: 't' value: (node expression apply: self).
		js if: (js operator: '===' with: (js ident: nlrName) and: (js ident: 'null')) 
			then: (js call: (js propertyOf: (js ident: selfName) at: (js literal: names privateCannotReturn)) with: {js ident: selfName. js ident: 't'}).
		js assign: (js propertyOf: (js ident: nlrName) at: (js literal: nlrValuePropertyName)) toBe: (js ident: 't').
		js throw: (js ident: nlrName)
	}
)
public schedulerNode: node <SchedulerAST> = (
	^js ident: 'currentActor'
)
selfName = (
	^'self'
)
public selfSendNode: node <SelfSendAST> = (
	| receiver = js ident: selfName. |
	^processLexicalSend: node message to: receiver binding: node binding
)
public stringNode: node <StringAST> = (
	^js literal: node value
)
public superSendNode: node <SuperSendAST> = (
	| superSlotName args |
	superSlotName:: names mangleSlot: 'super`', currentMixinUID.
	args:: List new.
	args add: (js ident: 'self').
	node message arguments do: [:each | args add: (each apply: self)].
	^js call:
			(js propertyOf:
				(js propertyOf: (
					js propertyOf: (js ident: 'self')
						at: (js literal: superSlotName))
					at: (protectedMessage: node message))
				at: (js literal: 'call')) with: args
)
public symbolNode: node <SymbolAST> = (
	assert: [node isSymbolNode].
	^js literal: node value
)
public temporaryDeclNode: node <ParameterAST> ^<String> = (
	^js var: (names mangleLocal: node name)
		value: (js ident: 'nil')
)
public tupleNode: node <TupleAST> = (
	^js array: (node elements collect: [:ea | ea apply: self])
)
public varDeclNode: node <VarDeclNode> = (
	(* Produce the corresponding local decl. *)
	^js var: (names mangleLocal: node name)
)
wrapBodyForNlrHandling: body <Block> = (
	| nlrVarNode nlrParamName nlrParamNode |
	nlrVarNode:: js ident: nlrName.
	nlrParamName:: nlrName, '_exception'.
	nlrParamNode:: js ident: nlrParamName.
	^js block: maybeCaptureReceiver, 
		{js var: nlrName value: (js new: (js ident: 'Object') with: {}).
		js try: body catch: nlrParamName with:
			(js block: {
				js if: (js operator: '===' with: nlrVarNode and: nlrParamNode)
					then: (js return: (js propertyOf: nlrParamNode at: (js literal: nlrValuePropertyName)))
					else: (js throw: nlrParamNode)
			})
	}
)
wrapBodyNoNlrHandling: body <Block> = (
	^js block: maybeCaptureReceiver, body statements
)
) : (
)
accessorForNestedClassNamed: simpleName <String> in: mixinName  <String> superCall: superAccessor <Node> ^ <String> = (
(* Build  a method that will lazily create a nested class 'simpleName' with superclass defined by 'superAccessor' via mixin application, and cache it.  Maybe replace null slot with self-replacing function that computes class and stores in its closure? *)

	| nestedName <String> nestedSlotName <String> nestedSlotNode <Node> enclosingObjectsName <String> |
	nestedName:: names mangleSynthetic: mixinName, '`', simpleName.
	nestedSlotName:: names mangleSlot: mixinName, '`', simpleName.
	nestedSlotNode:: js propertyOf: (js ident: 'this') at: (js literal: nestedSlotName).	
	enclosingObjectsName:: names mangleSynthetic: 'enclosingObjects`', mixinName.
	^js functionOf: {} body: (js block: {
		js if: (js operator: '===' with: (js ident: 'nil') and: nestedSlotNode)
			then: (js block: {
				js var: 'self' value: (js ident: 'this').
				js var: 'superclass' value: superAccessor.
				js var: 'enclosingObjects' value: 
					(js call: (js propertyOf: (js array: {js ident: 'this'}) at: (js literal: 'concat'))
						with: {js propertyOf: (js ident: 'this') at: (js literal: enclosingObjectsName)}).
				js var: 'mixin' value: (js propertyOf: (js ident: '$') at: (js literal: nestedName)).
				js assign: nestedSlotNode toBe: 
					(js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: '$applyMixin$toSuperclass$withEnclosingObjects$'))
						with: {(js ident: 'mixin'). js ident: 'superclass'. js ident: 'enclosingObjects'}).
			}).
		js return: nestedSlotNode.
		})
)
accessorForSuperclass: superclassCall <AST> inScope: s <Scope> ^<Node> = (
	| send scopeBuilder |
	rewriter pushScope: s.
	send:: superclassCall apply: rewriter.
	rewriter popScope.
	
	translator beginNewTranslationCycle.
	^send apply: translator
)
checkForDuplicateNames: aNode = (

	| namesWithDuplicates names duplicateNames |
	
	namesWithDuplicates:: List new.
	aNode instanceSide methods do: [:each | namesWithDuplicates add: each selector].
	
	aNode header slots do: [:each |
		namesWithDuplicates add: each name.
		each isMutable ifTrue: [namesWithDuplicates add: each name, ':']].
	
	namesWithDuplicates
		addAll: (aNode instanceSide nestedClasses collect: [:each | each name]).

	names:: Set new.
	duplicateNames:: Set new.
	namesWithDuplicates do: [:each | | present |
		present:: true.
		names include: each ifNew: [present:: false].
		present ifTrue: [duplicateNames add: each]].
	
	duplicateNames isEmpty ifFalse: [ | message |
		message:: String streamContents: [:s |
			s
				nextPutAll: 'Class ';
				nextPutAll: aNode name;
				nextPutAll: '" has multiple definitions for '.
			duplicateNames
				do: [:each | s nextPutAll: each asString]
				separatedBy: [ s nextPutAll: ','].
			s nextPutAll: '.'.].
		assert: false message: message].

)
classNode: aNode <ClassDeclarationAST> within: mixinIR ^ <ClassDeclarationIR> = (
	| ir <ClassDeclarationIR> priorMixinUID <String> |
	aNode name = #Newspeak2V8Compilation ifTrue: [
		#BOGUS. (* The flaw in the js intrinsic scheme. *)
		enableIntrinsics: false].
	checkForDuplicateNames: aNode.
	ir:: computeMixinFrom: aNode header within: mixinIR.
	ir accessModifier: aNode accessModifier.
	priorMixinUID:: currentMixinUID.
	currentMixinUID:: ir qualifiedName.
	currentDepth:: currentDepth + 1.
	processInstanceSideOf: aNode ofMixin: ir instanceSide.
	generateSlotAccessorsFor:  ir instanceSide. 
	(* must be called after nested classes are processed, so all synthetic slots have been added *)
	processClassSideOf: aNode ofMixin: ir classSide.
	currentDepth:: currentDepth - 1.
	currentMixinUID:: priorMixinUID.
	^ir
)
public compileClassSource: source <String> within: enclosing <MixinMirror> ^<CompiledMixinMirror> = (
	| tree <AST> mixinRep <MixinRep> |
	tree:: parser compilationUnit parseString: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	(*sentSelectors:: Set new.*)
	nil = enclosing ifFalse: [unimplemented].
	mixinRep:: classNode: tree within: nil.
	scopeMap:: Map new.
	^enclosing isNil ifTrue: [mixinRep] ifFalse: [{enclosing. mixinRep}].
)
public compileExpressionSource: expression <String> inMixin: enclosing <MixinMirror> ^<MethodIR> = (
	|
	body <CodeBodyAST>
	method <MethodAST>
	result <LowLevelMethodMirror>
	|
	
	(* Parse as a code body *)
	body:: parser doItExpression parseString: expression.
	input:: expression.

	(* Ensure last statement is a return statement *)
	body statements isEmpty ifFalse:
		[body statements last isReturnStatNode ifFalse:
			[| last |
			last:: body statements removeLast.
			body statements add: (ReturnStatAST new 
				expression: last; start: last start; end: last end)]].

	(* Put into a method *)
	method:: MethodAST new
		pattern: (MessagePatternAST new selector: #DoIt parameters: {});
		body: body;
		accessModifier: #public.
	
	(* Build scope *)
	setScopeFor: method in: enclosing.
	currentMixinUID: enclosing declaration qualifiedName.
	
	(* Rewrite and compile *)
 	result:: methodNode: method.
	scopeMap:: Map new.
	^result
)
public compileMethodSource: source <String> within: enclosing <MixinMirror> ^<IntermediateMethod> = (
	| tree <AST> jsTree <IntermediateMethod> |
	tree:: parser methodDecl parseString: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	currentMixinUID: enclosing declaration qualifiedName.
	jsTree:: methodNode: tree.
	scopeMap:: Map new.
	^jsTree
)
compileNestedClasses: nestedClasses <Collection[ClassDeclarationAST]> within: mixinIR <MixinIR> = (
	
	nestedClasses do:
		[:nc <ClassDeclarationAST> |  
		| nSlotName <String> nSlot <InstanceVariableMirror> |
		nSlotName:: mixinIR declaration qualifiedName, '`', nc name.
		nSlot:: IntermediateSlotDeclaration named: nSlotName mutable: true accessModifier: #public (* questionable*).
		nSlot isSynthetic: true.
		mixinIR slots add: nSlot.
		mixinIR nestedClasses add: (classNode: nc within: mixinIR).
		createNestedClassAccessorFrom: nc within: mixinIR].
)
compileNestedClassesOf: aNode <SideAST> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	(* where do we check that nested classes do not conflict with each other, or with methods or slots? *)
	^compileNestedClasses: aNode nestedClasses within: mixinMirror
)
computeMethod: aNode <MethodAST> inScope: s <Scope> = (
	|  scopeBuilder <ScopeBuilder>  |
	scopeBuilder:: ScopeBuilder nestedIn: s atLevel: currentDepth.
	aNode apply: scopeBuilder.
	(* need to build scope for method before visiting it *)
	^methodNode: aNode.
)
computeMixinFrom: aNode <ClassHeaderAST> within: mixinIR <IntermediateMixin> ^<ClassDeclarationIR> = (
	| 
	ir = IntermediateClassDeclaration new.
	|
	nil = mixinIR
		ifTrue: [ir qualifiedName: aNode name]
		ifFalse: [ir qualifiedName: (mixinIR qualifiedName, '`', aNode name)].
	aNode slots do: [:s |
		ir instanceSide slots add:
			(IntermediateSlotDeclaration 
				named: s name
				mutable: s isMutable
				accessModifier: s accessModifier)].
	ir headerSource: (input copyFrom: aNode start to: aNode end).
	ir depth: currentDepth.
	ir factoryName: aNode constructor selector.
	^ir
)
createNestedClassAccessorFrom: classDecl <ClassDeclarationAST> within: mixinMirror <LowLevelMixinMirror> = (
(* Create an accessor method for the nested class represented by the incoming class tree.
This accessor will lazily generate the nested class when its enclosing instance is first asked for it. *)

	| n <String>  accessorString <String> methodAST hdr <ClassHeaderAST> accessor <MethdMirror>  |
	hdr:: classDecl header.
	n:: hdr name. 
	methodAST:: 
		accessorForNestedClassNamed: n 
		in: mixinMirror qualifiedName 
		superCall: (accessorForSuperclass: hdr superclassCall inScope:  (scopeMap at: classDecl instanceSide)).
	accessor:: IntermediateMethod 
		named: classDecl name
		accessModifier: classDecl accessModifier
		function: methodAST
		source: nil.
	accessor isSynthetic: true.
	mixinMirror methods add: accessor.
)
currentScope ^<Scope> = (
	^scopeStack last
)
public dnuHandlers = (
	(* We used to generate a separate function for each selector. Now we are recycling the same code for each selector and using the JS magic 'arguments' to handle the variable number of arguments in an attempt to reduce the amount of code the must be compiled at start-up (recall DNU handlers must be installed up front). *)
	|
	sortedSelectors = sentSelectors asArray sort: [:a :b | string: a compare: b].
	mangledSelectors = js array: (sortedSelectors collect: [:sel | js literal: (names manglePublic: sel)]).
	catcher = js call: (js ident: 'dnuCatcher') with: {js ident: 'sel'}.
	|
	^js function: 'installDnuHandlersOn' of: {js ident: 'p'} body: (js block: {
		js call: (js propertyOf: mangledSelectors at: (js literal: 'forEach'))
		with: {js functionOf: {'sel'} body: (js block: {
			js assign: (js propertyOf: (js ident: 'p') at: (js operator: '+' with: (js literal: '_') and: (js ident: 'sel'))) toBe: catcher.
			js assign: (js propertyOf: (js ident: 'p') at: (js ident: 'sel')) toBe: catcher
		})}
	}).
	(* function() {  this.dnu(kernel.Message().selector$arguments$(selector, arguments) )  } *)
)
generateSlotAccessorsFor: mixinIR <MixinIR>  = (
	mixinIR slots do:
		[:slotIR  |
		generateSlotInitializerFor: slotIR in: mixinIR.
		generateSlotGetterFor: slotIR in: mixinIR.
		generateSlotSetterFor: slotIR in: mixinIR].
)
generateSlotGetterFor: slotIR <IntermediateSlot> in: mixinIR <IntermediateMixin>  = (
	|
	slotName <String> fieldName <String>
	getter <MethodMirror> getterJS <Node>
	|
	slotName:: slotIR name.
	fieldName:: names mangleSlot: slotName.
	
	slotIR accessModifier = #private
		ifTrue:
			[getterJS:: js functionOf: {'self'} body: (js block: {
				js return: (js propertyOf: (js ident: 'self') at: (js literal: fieldName))})]
		ifFalse:
			[getterJS:: js functionOf: {} body: (js block: {
				js return: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))})].

	getter:: IntermediateMethod
		named: slotName
		accessModifier: slotIR accessModifier
		function: getterJS
		source: nil.
	getter isSynthetic: true.			
	mixinIR methods add: getter.
)
generateSlotInitializerFor: slotIR <IntermediateSlot> in: mixinIR <IntermediateMixin>  = (
	|
	slotName <String> fieldName <String>
	initializer <MethodMirror> initializerJS <Node>
	|
	slotName:: slotIR name.
	fieldName:: names mangleSlot: slotName.
	
	slotIR accessModifier = #private
		ifTrue:
			[initializerJS:: js functionOf: {'self'. 'v'} body: (js block: {
				(js assign: (js propertyOf: (js ident: 'self') at: (js literal: fieldName))
					toBe: (js ident: 'v')).
				js return: (js ident: 'self')}).]
		ifFalse:
			[initializerJS:: js functionOf: {'v'} body: (js block: {
				(js assign: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))
					toBe: (js ident: 'v')).
				js return: (js ident: 'this')}).].
		
	initializer:: IntermediateMethod 
		named: (initializerSelectorForSlot: slotIR)
		accessModifier: slotIR accessModifier (* Should be private. The scope representation needs to be adjusted to allow this to differ from the slot's access modifier. *)
		function: initializerJS
		source: nil.
	initializer isSynthetic: true.	
	mixinIR methods add: initializer.
)
generateSlotSetterFor: slotIR <IntermediateSlot> in: mixinIR <IntermediateMixin>  = (
	|
	slotName <String> fieldName <String>
	setter <MethodMirror> setterJS <JavascriptGeneration Syntax Node> 
	|

	slotIR isMutable ifFalse: [^self].

	slotName:: slotIR name.
	fieldName:: names mangleSlot: slotName.
	
	slotIR accessModifier = #private
		ifTrue:
			[setterJS:: js functionOf: {'self'. 'v'} body: (js block: {
				(js assign: (js propertyOf: (js ident: 'self') at: (js literal: fieldName))
					toBe: (js ident: 'v')).
				js return: (js ident: 'self')})]
		ifFalse:
			[setterJS:: js functionOf: {'v'} body: (js block: {
				(js assign: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))
					toBe: (js ident: 'v')).
				js return: (js ident: 'this')})].

	setter:: IntermediateMethod 
		named: (setterSelectorFor: slotIR)
		accessModifier: slotIR accessModifier
		function: setterJS
		source: nil.
	setter isSynthetic: true.	
	mixinIR methods add: setter.
)
hereNode ^<VariableAST> = (
	(* Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier *)
	
	^VariableAST new name: #'@here'; start: 0; end: 0.
)
hereSendFrom: arg <VarDeclAST> ^<MessageNode> = (
	^NormalSendAST new
		to: hereNode
		send: (MessageAST new 
			send: arg name
			with: {};
			start: arg start; end: arg end); 
		start: arg start; end: arg end
)
initializerFor: aNode <ClassHeaderAST> ^ <MethodAST> = (
| 
stmts  <Collection[StatementAST]>
start <Integer>  
end <Integer> 
initHdr <MessagePatternAST>
body <CodeBodyAST> 
copier <ASTCopier> 
params <List[VarDeclAST]>
|

	start:: aNode superConstructorCall start.
	end:: aNode superConstructorCall end.
	copier:: ASTCopier new.
	params:: aNode constructor parameters collect: 
		[:formal | formal apply: copier].
	initHdr:: MessagePatternAST new
		selector: #'instance`initializer' parameters: params;
		start: start; end: end.
		
	(* set up scope with constructor parameters *)
 	stmts:: List new.
	
	stmts add: (superConstructorCallFor: aNode).
	
	(aNode slots reject: [:ea | ea initializer isNil]) 
		do: [:slot <SlotDefAST> | | aMsg <MessageAST> |
	aMsg:: MessageAST new send: (initializerSelectorForSlot: slot)
					   with: {slot initializer apply: copier};
					   start: slot start; end: slot end.
	stmts add: (NormalSendAST new message: aMsg;
				receiver: hereNode;
                          start: aMsg start; end: aMsg end).			
	].

 stmts addAll: (aNode initExprs collect:[:ie | ie apply: copier]).
 body:: CodeBodyAST new temporaries: List new
                                       statements: stmts; 
                                       start: start; end: end.
 ^MethodAST new pattern: initHdr
                            body: body
                            accessModifier: #public; 
                            start: start; end: end.
)
initializerSelectorForSlot: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^('init`', slot name, ':') asSymbol
)
language = (
	^#NewspeakLanguage2
)
methodNode: aNode <MethodAST> ^ <IntermediateMethod> = (
	| tree <AST> jsTree |
	tree:: aNode apply: rewriter.  (* rewrite ast *)
	translator beginNewTranslationCycle.
	jsTree:: tree apply: translator.	 (* final pass: visit rewritten ast *)
	(* pop scope? *)
	^IntermediateMethod
		named: translator currentSelector
		accessModifier: aNode accessModifier
		function: jsTree
		source: ([sourceForNode: aNode] on: Error do: [nil])
)
nestScope: s <Scope> = (
	(* Hook up a new lexically nested scope, and push onto the scope stack *)
	s setSuperScope: currentScope.
	pushScope: s
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
processClassSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	(* | primaryFactory <MethodMirror> factoryAST <MethodAST> | *)
	processFactoryFor: aNode in: mixinMirror.
	processSide: aNode classSide ofMixin: mixinMirror. (* compile class methods *)
)
processFactoryFor: aNode <ClassAST> in: mixinIR <MixinIR> = (
	| accessor <MethdMirror> argNames ast |
	argNames:: (aNode header constructor parameters collect: [:each | names mangleLocal: each name]) asArray.
	ast:: js functionOf: argNames body: (js block: {
		js return:
			(js call: (js ident: '(new this.nonMeta.basicNew()).$instance$initializer') (* cheat! *)
				with: (argNames collect: [:each | js ident: each]))
		}).
	accessor:: IntermediateMethod 
		named: aNode header constructor selector
		accessModifier: #public
		function: ast
		source: nil.
	accessor isSynthetic: true.
	accessor isFactory: true.
	mixinIR methods add: accessor.
)
processInitializerFor: aNode <ClassAST> in: mixinIR <MixinIR> = (
	processMethod: (superConstructorMethodFor: aNode header) inScope:  (scopeMap at: aNode instanceSide) in: mixinIR. 
	(*makeCreateSlotsFor: aNode hdr within: mixinIR.*)
	processMethod: (initializerFor: aNode header) inScope:  (scopeMap at: aNode instanceSide) in: mixinIR.
)
processInstanceSideOf: aNode <ClassAST> ofMixin: mixinIR <MixinIR> ^ <Collection[MixinRep]> = (
	processInitializerFor: aNode in: mixinIR.
	processSide: aNode instanceSide ofMixin: mixinIR. (* compile instance methods *)
	compileNestedClassesOf: aNode instanceSide within: mixinIR. (* gather nested classes *)
)
processMethod: aNode <MethodAST> inScope: s <Scope> in: mixinIR <MixinIR> = (
	|  method <MethodMirror> |
	method:: computeMethod: aNode inScope: s.
	method isSynthetic: true.
	mixinIR methods add: method.
)
processSide: side <SideAST> ofMixin: mixinIR <MixinIR> = (
	side methods do: 
		[:methodNode | mixinIR methods add: (methodNode: methodNode)].
)
pushScope: scope <Scope> = (
	scopeStack addLast: scope
)
scopeMap = (
	^super scopeMap
)
selfNode ^ <VariableAST> = (
	(* generate a an AST representing self; used for implicit self sends *)
	^VariableAST new name: #self; start: 0; end: 0
)
setInput: source <ReadStream> = (
	input: source. (* save the input *)
)
setScopeFor: node <AST> in: enclosing <MixinMirror | nil> = (
	| scopeBuilder |
	pushScope: Scope new.
	enclosing isNil ifFalse: [nestScope:: ScopeBuilder new buildScopeFor: enclosing].
	currentDepth:: currentScope depth.
	scopeBuilder:: ScopeBuilder nestedIn: currentScope atLevel: currentDepth.
	node apply: scopeBuilder
)
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	slot isMutable ifFalse: [self warnObsolete].
	^((slot isMutable ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
sourceForNode: node <AST> ^ <String> = (
	| savedPos <Integer> pos <Integer> len <Integer> s <String> |
	^input copyFrom: node start to: node end
)
string: a compare: b = (
	1 to: a size do: 
		[:i |
		i > b size ifTrue: [^false].
		(a runeAt: i) < (b runeAt: i) ifTrue: [^true].
		(a runeAt: i) > (b runeAt: i) ifTrue: [^false]].
	^true
)
superConstructorCallFor: aNode <ClassHeaderAST> ^<NormalSendAST> = (
	
	(* create call to super constructor method *)
	|
	var  <VariableAST> 
	send <NormalSendAST>
	start <Integer> 
	end <Integer>  
	superMsg <MessageAST>
	args <List[VariableAST]> 
	|

	start:: aNode superConstructorCall start.
	end:: aNode superConstructorCall end.
	var:: VariableAST new name: #self; start: start; end: end.
	args:: aNode constructor parameters collect:
		[:p <VarDeclAST> | hereSendFrom: p].
	superMsg:: MessageAST new 
		send: (superConstructorNameFor: aNode) with: args; 
		start: start; end: end.
	send:: NormalSendAST new to: var send: superMsg; start: start; end: end.	
	^send
)
superConstructorMethodFor:  aNode <ClassHeaderAST> ^ <MethodAST> = (
| 
start <Integer> 
end <Integer>
stmts <List[StmtAST]> 
var  <VariableAST> 
initHdr <MessagePatternAST>
superMsg <MessageAST> 
send <NormalSendAST>
body  <CodeBodyAST>
copier <ASTCopier>
params <List[VarDeclAST]>
args <List>
|

	start:: aNode superConstructorCall start.
	end::  aNode  superConstructorCall end.
	copier:: ASTCopier new.
	params:: aNode constructor parameters collect:[:formal | formal apply: copier].
	initHdr:: MessagePatternAST new selector: (superConstructorNameFor: aNode) parameters: params;
				start: start; end: end. 
	(* set up scope with constructor parameters *)
	(* create call to superclass initializer *)
	stmts:: List new. 
	var:: VariableAST new name: #super; start: start; end: end.
	args:: aNode superConstructorCall arguments collect:[:actual | actual apply: copier].
	superMsg::  PropertyCallAST new send: 'instance`initializer' with: args; 
				start: start; end: end. 
	(* only copy actual args *)
	(* send these as a tuple? to super instance initializer? *)
	send:: NormalSendAST new to: var send: superMsg; start: start; end: end. 
	stmts addFirst: send.
	body:: CodeBodyAST new temporaries: List new
                                       	statements: stmts;
                                      	start: start; end: end.
	^MethodAST new pattern: initHdr
                            body: body
                            accessModifier: #protected;
                            start: start; end: end	
)
superConstructorNameFor: aNode <ClassHeaderAST> ^ <Symbol> = (
	#BOGUS. (* Should not rely on this running after currentMixinUID is set. *)
	^'superInit`', currentMixinUID
)
) : (
)
public class IntermediateClassDeclaration = (|
	public qualifiedName <String>
	public headerSource <String>
	public factoryName <Symbol>
	public instanceSide <IntermediateMixin> = IntermediateMixin for: self isMeta: false.
	public classSide <IntermediateMixin> = IntermediateMixin for: self isMeta: true.
	public depth <Integer>
	public accessModifier <Symbol>
|) (
basicNew = (
	^js functionOf: {} body: (js block: (
		{
		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.
		},
		(instanceSide slots collect: [:s | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: s name))) toBe: (js ident: 'nil')])
	))
)
basicNewMeta = (
	^js functionOf: {} body: (js block: (
		{
		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.
		}
	))
)
classMethodsMetadata = (
	^js array: (classSide methods collect:
		[:method | js new: (js ident: 'MM') with: {
			js literal: method name.
			js literal: method isSynthetic.
			encodeSource: method source.
		}])
)
copyMethods: methods = (
	| stmts = List new. |
	methods do: [:m | 
		| mixinFunction assignProtected |
		mixinFunction:: js propertyOf: (js ident: '$') at: (js literal: (names manglePublic: m name)).
		assignProtected::
			(js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleProtected: m name)))
				toBe: mixinFunction).

		m isPublic ifTrue: [
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name)))
					toBe: assignProtected).
		].
		m isProtected ifTrue: [
			stmts add: assignProtected.
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name)))
					toBe: (dnuCatcherFor: (names manglePublic: m name))).
		].
		m name = #doesNotUnderstand: ifTrue: [
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: names privateDnu)) toBe: mixinFunction).
		].
		(qualifiedName = 'KernelForV8`Object' and: [m name = #cannotReturn:]) ifTrue: [
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: names privateCannotReturn)) toBe: mixinFunction).
		].
	].
	^stmts
)
dnuCatcherFor: publicMangling = (
	^js call: (js ident: 'dnuCatcher') with: {js literal: publicMangling}
)
encodeSource: source = (
	source isNil ifTrue: [^js literal: 0].
	sourcesList add: source.
	^js literal: sourcesList size.
)
invoke = (				
	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'} body: (js block: {
		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime class for ', qualifiedName).
			},
			(copyMethods: instanceSide methods),
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'enclosingObjects`',qualifiedName)))
				toBe: (js ident: 'enclosingObjects').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: 'super`',qualifiedName)))
				toBe: (js ident: 'runtimeSuperclass').
			(* This first assignment causes devtools to use the class's name as the short name for its instances. *)
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: qualifiedName)) toBe: basicNew.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: (js propertyOf: (js ident: 'this') at: (js literal: qualifiedName)).
			js verbatim: 'this.basicNew.prototype = this'.
			js verbatim: 'this.meta = null'.
			js verbatim: 'this.newspeakClass = null'.
			}
		)).
		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.
		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.
	})
)
invokeMeta = (
	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'.} body: (js block: {
		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta class for ', qualifiedName).
			},
			(copyMethods: classSide methods),
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'enclosingObjects`',qualifiedName)))
				toBe: (js ident: 'enclosingObjects').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'super`',qualifiedName)))
				toBe: (js ident: 'runtimeSuperclass').	
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: basicNewMeta.
			js verbatim: 'this.basicNew.prototype = this'.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nonMeta')) toBe: (js ident: 'null').
			js verbatim: 'this.newspeakClass = null'.
			}
		)).
		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.
		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.
	})
)
makeMixin: rm = (
	^js call: (js propertyOf: (js ident: 'Mixin') at: (js literal: 'fromRuntimeMixin')) with: {rm}
)
methodsMetadata = (
	^js array: (instanceSide methods collect:
		[:method | js new: (js ident: 'MM') with: {
			js literal: method name.
			js literal: method isSynthetic.
			encodeSource: method source.
		}])
)
nestedClassesMetadata = (
	^js array: (instanceSide nestedClasses collect: [:nc | js literal: nc qualifiedName])
)
public printOn: stm = (
	stm nextPutAll: 'ClassDeclarationIR:'.
	stm nextPutAll: qualifiedName.
)
runtimeMetamixin = (
	^js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'meta')) toBe: (
	js new: (js functionOf: {} body: (js block: (
		{
		js var: '$' value: (js ident: 'this').
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta mixin for ', qualifiedName).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'slots')) toBe: (js array: {}).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'methods')) toBe: classMethodsMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nestedClasses')) toBe: (js array: {}).
		},
		(classSide methods collect: [:m | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name))) toBe: m function]),
		{
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invokeMeta.
		}
	))) with: {})
)
public runtimeMixin = (
	^js new: (js functionOf: {} body: (js block: (
		{
		js var: '$' value: (js ident: 'this').
		js var: '$', depth printString value: (js ident: 'this').
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime mixin for ', qualifiedName).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'name')) toBe: (js literal: qualifiedName).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'header')) toBe: (encodeSource: headerSource).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'slots')) toBe: slotsMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'methods')) toBe: methodsMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nestedClasses')) toBe: nestedClassesMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'applications')) toBe: (js array: {}).
		},
		(instanceSide methods collect: [:m | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name))) toBe: m function]),
		(instanceSide nestedClasses collect: [:ncd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: ncd qualifiedName))) toBe: ncd runtimeMixin]),
		(instanceSide nestedClasses collect: [:ncd | 
			js assign: (js propertyOf: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: ncd qualifiedName))) at: (js literal: 'enclosingMixin')) toBe: (js ident: 'this')]),
		{
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invoke.
		runtimeMetamixin.
		js assign: (js propertyOf: (js propertyOf: (js ident: 'this') at: (js literal: 'meta')) at: (js literal: 'nonMeta')) toBe: (js ident: 'this').
		}
	))) with: {}
)
slotsMetadata = (
	^js array: (instanceSide slots collect:
		[:slot | js new: (js ident: 'SM') with: {
			js literal: slot name.
			js literal: slot isMutable.
			js literal: slot isSynthetic
	}]).
)
) : (
)
public class IntermediateMethod named: n accessModifier: am function: f source: s = (|
	public name <Symbol> = n.
	public function <JavascriptGeneration Syntax Node> = f.
	public source <String> = s.
	public isSynthetic ::= false.
	public isFactory ::= false.
	public accessModifier <Symbol> = am.
|) (
public isPrivate ^ <Boolean> = (
	^#private = accessModifier
)
public isProtected ^ <Boolean> = (
	^#protected = accessModifier
)
public isPublic ^ <Boolean> = (
	^#public = accessModifier
)
public printOn: stm = (
	stm nextPutAll: 'MethodIR:'.
	stm nextPutAll: name.
)
) : (
)
public class IntermediateMixin for: d <IntermediateClassDeclaration> isMeta: m <Boolean> = (|
	public declaration <IntermediateClassDeclaration> = d.
	public isMeta <Boolean>  = m.
	public slots <List[IntermediateSlotDeclaration]> = List new.
	public methods <List[IntermediateMethod]> = List new.
	public nestedClasses <List[IntermediateClassDeclaration]>  = List new.
|) (
public qualifiedName = (
	^declaration qualifiedName
)
) : (
)
public class IntermediateSlotDeclaration named: n mutable: m accessModifier: am = (|
	public name = n.
	public isMutable = m.
	public accessModifier = am.
	public isSynthetic ::= false.
|) (
public printOn: stm = (
	stm nextPutAll: 'SlotIR:'.
	stm nextPutAll: name.
)
) : (
)
class NameMangler = (|
	private specialCharacterManglings = Map new.
|specialCharacterManglings
		at: "+" put: '$plus';
		at: "-" put: '$minus';
		at: "*" put: '$times';
		at: "/" put: '$over';
		at: "\" put: '$back';
		at: "<" put: '$less';
		at: ">" put: '$greater';
		at: "~" put: '$tilde';
		at: "=" put: '$equal';
		at: "@" put: '$at';
		at: "%" put: '$percent';
		at: "|" put: '$pipe';
		at: "&" put: '$amp';
		at: "?" put: '$question';
		at: "!" put: '$bang';
		at: "," put: '$comma') (
protected _mangleSelector: selector <String> ^ <String> = (
	(* Convert a Newspeak selector into a JS identifer. *)

	(* Binary *)
	('+-*/\<>~=@%|&?!,' includes: selector first) ifTrue: 
		[ | sb = StringBuilder new. |
		sb add: '$'.
		selector do: [:specialCharacter | sb add: (specialCharacterManglings at: specialCharacter)].
		^sb asString asSymbol].

	^((('$', selector)
		replaceAll: ":" with: "$") (* Keyword *)
		replaceAll: "`" with: "$") (* Qualified *)
		replaceAll: "." with: "$" (* limit temp *)
)
public fullyQualifiedNameToSimple: fullName <String> = (
	| parts |
	
	parts:: splitFullyQualifiedName: fullName.
	^parts last asSymbol
)
public fullyQualifySimpleName: simpleName <Symbol> with: fullyQualifiedPackage <Symbol> = (
	^(fullyQualifiedPackage asString, syntheticNameSeparator, simpleName) asSymbol
)
public mangleLocal: selector <String> ^ <String> = (
	^_mangleSelector: selector
)
public mangleProtected: selector = (
	^'_', (_mangleSelector: selector)
)
public manglePublic: selector = (
	^_mangleSelector: selector
)
public mangleSlot: selector <String> ^ <String> = (
	^(_mangleSelector: selector), '$slot'
)
public mangleSynthetic: selector = (
	^_mangleSelector: selector
)
public privateCannotReturn = (
	^'cannotReturn'
)
public privateDnu = (
	^'dnu'
)
) : (
)
public class ProgramBuilder = (|
private compiler = Compiler new.
private mixins <List[ClassDeclarationIR]> = List new.
private sentSelectors = Set new.
private runtimeConfiguration <ClassDeclarationIR>
private applicationConfiguration <ClassDeclarationIR>
private resources <List[Node]> = List new.
|) (
public addImageResource: relativeUrl under: name = (
	| r i |
	i:: js verbatim: 
	'vmmirror.kernel.$Future().$computing$(
		function(){return vmmirror.platform.$aliens().$yourself()._$alienate$(
			function(){ var i = new Image(); i.src ="', relativeUrl,'"; return i;}() );})'.
	r:: js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: name)))
				toBe: (js functionOf: {} body: (js block: {js return: i})).
	resources add: r.
)
public addStringResource: string under: name = (
	| r |
	r:: js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: name)))
				toBe: (js functionOf: {} body: (js block: {js return: (js literal: string)})).
	resources add: r.
)
public applicationSources: sources <List[String]> = (
	| results |
	results:: sources collect: [:source | compileSource: source enableIntrinsics: false].
	applicationConfiguration: results first.
)
compileSource: source <String> enableIntrinsics: flag <Boolean> ^<ClassDeclarationIR> = (
	| compilation |
	compilation:: cachedCompilations
		at: {source. flag}
		ifAbsentPut:
			[ | newCompilation = CachedCompilation new. |
			newCompilation source: source.
			newCompilation enableIntrinsics: flag.
			compiler enableIntrinsics: flag.
			compiler sentSelectors: Set new.
			newCompilation ir: (compiler compileClassSource: source within: nil).
			newCompilation sentSelectors: compiler sentSelectors].
	mixins add: compilation ir.
	sentSelectors addAll: compilation sentSelectors.
	^compilation ir
)
private main = (
	^js verbatim: 
'var runtime = ns.$',runtimeConfiguration qualifiedName,'().$packageUsing$(ns);
vmmirror.platform = runtime.$using$(vmmirror);
var app = ns.$',applicationConfiguration qualifiedName,'().$packageUsing$(ns);
app.$main$args$(vmmirror.platform, [])'
)
private namespace = (
	^js var: 'ns' value: (js new: (js functionOf: {} body: (js block: (
		(mixins asArray collect: [:cd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd qualifiedName))) 
				toBe: (js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: 'applyTopLevelMixin')) 
						with: {js propertyOf: (js ident: 'mixins') at: (js literal: (names manglePublic: cd qualifiedName))})]),
		(mixins asArray collect: [:cd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: cd qualifiedName)))
				toBe: (js functionOf: {} body: (js block: {js return: 
					(js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd qualifiedName)))}))]),
		resources asArray
	))) with: {})
)
public outputProgram ^<String> = (
	| sb = StringBuilder new. |
	JavascriptWriter new generateSourceFor: script on: sb.
	^sb asString
)
public outputSources ^<String> = (
	| sb = StringBuilder new. |
	JavascriptWriter new generateSourceFor: sourcesScript on: sb.
	^sb asString
)
private runtimeMixinNamespace = (
	^js new: (js functionOf: {} body: (js block: (
		mixins collect: [:cd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: cd qualifiedName))) toBe: cd runtimeMixin]
	))) with: {}
)
public runtimeSources: sources <List[String]> = (
	| results |
	results:: sources collect: [:source | compileSource: source enableIntrinsics: true].
	runtimeConfiguration: results first.
)
private script = (
	compiler sentSelectors: sentSelectors.
	sourcesList:: List new.
	^js script: 
		{js literal: 'use strict'.
		js var: 'nil' value: (js literal: 'patch me with nil').
		js var: 'currentActor'.
		js var: 'theGlobalObject' value: (js ident: 'this').		
		js verbatim: 'function SM(n,m,s){this.name=n; this.isMutable=m; this.isSynthetic=s; }'.
		js verbatim: 'function MM(n,sy,src){this.name=n; this.isSynthetic=sy; this.source=src; }'.
		js verbatim: 'function dnuCatcher(s){ return function() {
return this.dnu(vmmirror.kernel.$Message().$mangledSelector$arguments$(s, Array.prototype.slice.call(arguments)));
} }'.
		js var: 'mixins' value: runtimeMixinNamespace.
		vmmirror.
		namespace.
		compiler dnuHandlers.
		main}
)
private sourcesScript = (
	| elements = List new. |
	elements add: (js ident: 'null').
	sourcesList do: [:source | elements add: (js literal: source)].
	^js assign: (js ident: 'sources') toBe: (js array: elements)
)
private vmmirror = (
	^js verbatim: 
'
var vmmirror = new function(){
	
	this.ImplementationBase$slot = new function(){
		this.debug = "ImplementationBase";
		this.$runtimeClass$slot = new function(){
			this.debug = "Runtime class for ImplementationBase";
			this.basicNew = function(){ this.hashCode = 0; };
			this.$instance$initializer = function(){};
			this._$instance$initializer = function(){};
			this.toString = function(){ return this.$printString(); }
		};
	};
	this.$ImplementationBase = function(){return this.ImplementationBase$slot;};
	this.$Array = function(){return Array;};
	this.$String = function(){return String;};
	this.$printString = function(){return "VMMirrorForV8"};
	
	this.createKernel = function(){
		
		var enclosingObjects = ["patch me with kernel", "patch me with nil"];
		var enclosingObjects2 = ["patch me with nil"];
		
		var Object$runtimeClass = mixins.$KernelForV8.$KernelForV8$Object.invoke(this.$ImplementationBase().$runtimeClass$slot, enclosingObjects);
		var Class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Class.invoke(Object$runtimeClass, enclosingObjects);
		var Metaclass$runtimeClass = mixins.$KernelForV8.$KernelForV8$Metaclass.invoke(Object$runtimeClass, enclosingObjects);
		var Mixin$runtimeClass = mixins.$KernelForV8.$KernelForV8$Mixin.invoke(Object$runtimeClass, enclosingObjects);
		var UndefinedObject$runtimeClass = mixins.$KernelForV8.$KernelForV8$UndefinedObject.invoke(Object$runtimeClass, enclosingObjects);
		var Kernel$runtimeClass = mixins.$KernelForV8.invoke(Object$runtimeClass, enclosingObjects2);
		
		var Object$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Object.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Class$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Class.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Metaclass$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Metaclass.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Mixin$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Mixin.meta.invoke(Class$runtimeClass, enclosingObjects);
		var UndefinedObject$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$UndefinedObject.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Kernel$class$runtimeClass = mixins.$KernelForV8.meta.invoke(Class$runtimeClass, enclosingObjects2);
		
		Object$runtimeClass.meta = Object$class$runtimeClass;
		Class$runtimeClass.meta = Class$class$runtimeClass;
		Metaclass$runtimeClass.meta = Metaclass$class$runtimeClass;
		Mixin$runtimeClass.meta = Mixin$class$runtimeClass;
		UndefinedObject$runtimeClass.meta = UndefinedObject$class$runtimeClass;
		Kernel$runtimeClass.meta = Kernel$class$runtimeClass;
		
		Object$class$runtimeClass.nonMeta = Object$runtimeClass;
		Class$class$runtimeClass.nonMeta = Class$runtimeClass;
		Metaclass$class$runtimeClass.nonMeta = Metaclass$runtimeClass;
		Mixin$class$runtimeClass.nonMeta = Mixin$runtimeClass;
		UndefinedObject$class$runtimeClass.nonMeta = UndefinedObject$runtimeClass;
		Kernel$class$runtimeClass.nonMeta = Kernel$runtimeClass;
		
		nil = new UndefinedObject$runtimeClass.basicNew();
		
		var Object = new Object$class$runtimeClass.basicNew();
		var Class = new Class$class$runtimeClass.basicNew();
		var Metaclass = new Metaclass$class$runtimeClass.basicNew();
		var Mixin = new Mixin$class$runtimeClass.basicNew();
		var UndefinedObject = new UndefinedObject$class$runtimeClass.basicNew();
		var Kernel = new Kernel$class$runtimeClass.basicNew();
		
		var Object$class = new Metaclass$runtimeClass.basicNew();
		var Class$class = new Metaclass$runtimeClass.basicNew();
		var Metaclass$class = new Metaclass$runtimeClass.basicNew();
		var Mixin$class = new Metaclass$runtimeClass.basicNew();
		var UndefinedObject$class = new Metaclass$runtimeClass.basicNew();
		var Kernel$class = new Metaclass$runtimeClass.basicNew();
		
		Object$class$runtimeClass.newspeakClass = Object$class;
		Class$class$runtimeClass.newspeakClass = Class$class;
		Metaclass$class$runtimeClass.newspeakClass = Metaclass$class;
		Mixin$class$runtimeClass.newspeakClass = Mixin$class;
		UndefinedObject$class$runtimeClass.newspeakClass = UndefinedObject$class;
		Kernel$class$runtimeClass.newspeakClass = Kernel$class;
		
		Object$runtimeClass.newspeakClass = Object;
		Class$runtimeClass.newspeakClass = Class;
		Metaclass$runtimeClass.newspeakClass = Metaclass;
		Mixin$runtimeClass.newspeakClass = Mixin;
		UndefinedObject$runtimeClass.newspeakClass = UndefinedObject;
		Kernel$runtimeClass.newspeakClass = Kernel;
		
		var kernel = Kernel.$usingVmMirror$(this);
		
		//superclass$slot
		Object.$superclass$slot = nil;
		Class.$superclass$slot = Object;
		Metaclass.$superclass$slot = Object;
		Mixin.$superclass$slot = Object;
		UndefinedObject.$superclass$slot = Object;
		Kernel.$superclass$slot = Object;
		
		Object$class.$superclass$slot = Class;
		Class$class.$superclass$slot = Class;
		Metaclass$class.$superclass$slot = Class;
		Mixin$class.$superclass$slot = Class;
		UndefinedObject$class.$superclass$slot = Class;
		Kernel$class.$superclass$slot = Class;
		
		//mixin$slot
		Object.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Object);
		Class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Class);
		Metaclass.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Metaclass);
		Mixin.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Mixin);
		UndefinedObject.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$UndefinedObject);
		Kernel.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8);

		Object$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Object.meta);
		Class$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Class.meta);
		Metaclass$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Metaclass.meta);
		Mixin$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Mixin.meta);
		UndefinedObject$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$UndefinedObject.meta);
		Kernel$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.meta);
		
		//enclosingObject$slot
		Object.$enclosingObject$slot = kernel;
		Class.$enclosingObject$slot = kernel;
		Metaclass.$enclosingObject$slot = kernel;
		Mixin.$enclosingObject$slot = kernel;
		UndefinedObject.$enclosingObject$slot = kernel;
		Kernel.$enclosingObject$slot = nil;
		
		Object$class.$enclosingObject$slot = kernel;
		Class$class.$enclosingObject$slot = kernel;
		Metaclass$class.$enclosingObject$slot = kernel;
		Mixin$class.$enclosingObject$slot = kernel;
		UndefinedObject$class.$enclosingObject$slot = kernel;
		Kernel$class.$enclosingObject$slot = nil;
		
		enclosingObjects[0] = kernel;
		enclosingObjects[1] = nil;
		enclosingObjects2[0] = nil;
		
		//name$slot
		Object.$name$slot = "Object";
		Class.$name$slot = "Class";
		Metaclass.$name$slot = "Metaclass";
		Mixin.$name$slot = "Mixin";
		Kernel.$name$slot = "Kernel";
		
		Object$class.$name$slot = "Object class";
		Class$class.$name$slot = "Class class";
		Metaclass$class.$name$slot = "Metaclass class";
		Mixin$class.$name$slot = "Mixin class";
		Kernel$class.$name$slot = "Kernel class";
		
		//runtimeClass
		Object.runtimeClass = Object$runtimeClass;
		Class.runtimeClass = Class$runtimeClass;
		Metaclass.runtimeClass = Metaclass$runtimeClass;
		Mixin.runtimeClass = Mixin$runtimeClass;
		Kernel.runtimeClass = Kernel$runtimeClass;
		
		Object$class.runtimeClass = Metaclass$runtimeClass;
		Class$class.runtimeClass = Metaclass$runtimeClass;
		Metaclass$class.runtimeClass = Metaclass$runtimeClass;
		Mixin$class.runtimeClass = Metaclass$runtimeClass;
		Kernel$class.runtimeClass = Metaclass$runtimeClass;
		
		//thisClass$slot
		Object$class.$thisClass$slot = Object;
		Class$class.$thisClass$slot = Class;
		Metaclass$class.$thisClass$slot = Metaclass;
		Mixin$class.$thisClass$slot = Mixin;
		Kernel$class.$thisClass$slot = Kernel;
		
		kernel.$KernelForV8$Object$slot = Object;
		kernel.$KernelForV8$Class$slot = Class;
		kernel.$KernelForV8$Metaclass$slot = Metaclass;
		kernel.$KernelForV8$Mixin$slot = Mixin;
		
		return kernel;
	};
	this.kernel = this.createKernel();
	
	this.applyTopLevelMixin = function(runtimeMixin){
		return this.$applyMixin$toSuperclass$withEnclosingObjects$(runtimeMixin, this.kernel._$Object(), [nil]);
	};
	
	this.$applyMixin$toSuperclass$withEnclosingObjects$ = function(runtimeMixin, newspeakSuperclass, enclosingObjects){
		
		var Class = this.kernel.$Class();
		var Metaclass = this.kernel.$Metaclass();
		var Mixin = this.kernel.$Mixin();
		
		var runtimeSuperclass = newspeakSuperclass.runtimeClass;
		var runtimeClass = runtimeMixin.invoke(runtimeSuperclass, enclosingObjects);
		var runtimeMetaclass = runtimeMixin.meta.invoke(Class.runtimeClass, enclosingObjects);
		runtimeClass.meta = runtimeMetaclass;
		runtimeMetaclass.nonMeta = runtimeClass;
		
		var newspeakMetaclass = Metaclass.$new();
		var newspeakClass = new runtimeMetaclass.basicNew();
		
		runtimeClass.newspeakClass = newspeakClass;
		runtimeMetaclass.newspeakClass = newspeakMetaclass;//Class;
		
		newspeakMetaclass.$superclass$slot = Class;
		newspeakMetaclass.$mixin$slot = Mixin.$fromRuntimeMixin$(runtimeMixin.meta);
		newspeakMetaclass.$enclosingObject$slot = enclosingObjects[0];
		newspeakMetaclass.$enclosingObjects$slot = enclosingObjects;
		newspeakMetaclass.$name$slot = runtimeMixin.name + " class";
		newspeakMetaclass.$thisClass$slot = newspeakClass;
		newspeakMetaclass.runtimeClass = runtimeMetaclass;
		
		newspeakClass.$superclass$slot = newspeakSuperclass;
		newspeakClass.$mixin$slot = Mixin.$fromRuntimeMixin$(runtimeMixin);
		newspeakClass.$enclosingObject$slot = enclosingObjects[0];
		newspeakClass.$enclosingObjects$slot = enclosingObjects;
		newspeakClass.$name$slot = runtimeMixin.name;
		newspeakClass.runtimeClass = runtimeClass;

		runtimeMixin.applications.push(runtimeClass);
		return newspeakClass;
	};
	
	var specialCharacters = new Object();
	specialCharacters["plus"] = "+";
	specialCharacters["minus"] = "-";
	specialCharacters["times"] = "*";
	specialCharacters["over"] = "/";
	specialCharacters["back"] = "\\";
	specialCharacters["less"] = "<";
	specialCharacters["greater"] = ">";
	specialCharacters["tilde"] = "~";
	specialCharacters["equal"] = "=";
	specialCharacters["at"] = "@";
	specialCharacters["percent"] = "%";
	specialCharacters["pipe"] = "|";
	specialCharacters["amp"] = "&";
	specialCharacters["question"] = "?";
	specialCharacters["bang"] = "!";
	specialCharacters["comma"] = ",";
	
	this.$unmangleSelector$ = function(s) {
		if(s[0] != "$") return "<jsSelector:"+s+">";
		if(s[s.length-1] == "$")
			// Keyword
			return s.substring(1).replace(/\$/g,":");
		if(s[1] == "$")
			// Binary
			return s.substring(2).split("$").map(function(x) {return specialCharacters[x];}).join("");
		// Unary / qualified
	   	return s.substring(1).replace(/\$/g,"`");
	};
	
	this.$mangleSelector$ = function(s) {
		return "$" + s.replace(/\:/g,"$").replace(/\`/g,"$");
	};
};
'
)
) : (
)
LocalEntry = (
	^super LocalEntry
)
Scope = (
	^super Scope
)
assert: block <[Boolean]> = (
      super assert: block message: 'assertion failed'.
	(* block value ifFalse: [error: 'assertion failed'] *)
)
mixinNameOfClassNamed: className <String> ^ <Symbol> = (
	| simpleNames <Collection[String]> rawNames <Collection[String]> |
	rawNames:: splitFullyQualifiedName: className. 
	rawNames size =1 ifTrue: [^className].
	simpleNames:: rawNames select: [:n <String>  | 
					n size == 0 or: [ n first isLetter ]].
				(* this was isDigit--either add isDigit to core string, or perhaps use between:and: *) 
	assert: [simpleNames size >= 2].
	^(simpleNames inject: '' into: [:sn1 <String>  :sn2 <String> | sn1, syntheticNameSeparator, sn2]) asSymbol
)
mixinSlotNameFor: nestedName <String> = (
	| mixinName <String> |
	mixinName:: mixinNameOfClassNamed: nestedName.
	^mixinName
)
split: aString at: aCharacter = (
	| parts start |
	parts:: List new.
	start:: 1.
	1 to: aString size do:
		[:index |
		(aString at: index) = aCharacter ifTrue:
			[parts add: (aString copyFrom: start to: index - 1).
			start:: index + 1]].
	parts add: (aString copyFrom: start to: aString size).
	^parts
)
splitFullyQualifiedName: fqn = (

	(* Make sure we pass only the first character, so that the code works in image and on JS *)
	^ split: fqn at: syntheticNameSeparator first
)
syntheticNameSeparator ^<String> = (
	^'`'
)
) : (
)
