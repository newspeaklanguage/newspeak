Newspeak3
'Root'
class KernelForPrimordialSoup = (|
private messageLoop <MessageLoop>
private symbolTable <WeakArray[Symbol]>
private symbolTableUsed
|) (
public class Activation _cannotInstantiate = (
(* A reified activation record.

Note this class only contains accessors and the logic needed for unwind-protect and exceptions. The debugger's simulator that is normally implemented in this class in Smalltalks is instead in the mirrors module.
|
sender <Activation | nil>
bci <SmallInteger | nil>
method <Method | nil>
closure <Closure | nil>
receiver <Object>
numTemps <SmallInteger>
<temps>
|
*)
) (
private aboutToReturn: result through: firstUnwindActivation = (
	(* Sent by the VM if a non-local return would cross an unwind-protect activation. *)
	^home return: result
)
public bci = (
	(* :literalmessage: primitive: 57 *)
	halt.
)
public bci: value = (
	(* :literalmessage: primitive: 58 *)
	halt.
)
private cannotReturn: result = (
	(* Sent by the VM if attempting to return to nil sender, or a sender that has already returned. Also triggered if non-local return attempts to return to an activation that can no longer along the chain of senders. *)
	^(CannotReturn result: result) signal
)
public closure = (
	(* :literalmessage: primitive: 61 *)
	halt.
)
public closure: value = (
	(* :literalmessage: primitive: 62 *)
	halt.
)
public findNextUnwindContextUpTo: activation = (
	(* Return the next unwind marked above the receiver, returning nil if there is none.  Search proceeds up to but not including aContext. *)
	| ctx |
	ctx:: self.
	[nil = (ctx:: ctx sender) or: [ctx = activation]]
		whileFalse:
			[ctx isUnwindContext ifTrue: [^ctx]].
	^nil
)
public hasSender: context = (
	(* Answer whether the receiver is strictly above context on the stack. *)

	| s |
	self = context ifTrue: [^false].
	s:: sender.
	[nil = s]
		whileFalse:
			[s = context ifTrue: [^true].
			s:: s sender].
	^false
)
public home ^<Activation> = (
	| a c |
	a:: self.
	[c:: a closure.
	 nil = c] whileFalse:
		[a:: definingActivationOf: c].
	^a
)
public isDead ^<Boolean> = (
	^nil = bci
)
public isUnwindContext ^<Boolean> = (
	^113 = method primitive
)
public method = (
	(* :literalmessage: primitive: 59 *)
	halt.
)
public method: value = (
	(* :literalmessage: primitive: 60 *)
	halt.
)
private nonBooleanReceiver: nonBoolean = (
	(* Sent by the VM if the top of stack is neither true or false when a branch bytecode is reached. *)
	^(NonBooleanReceiver receiver: nonBoolean) signal
)
public outerContext ^<Activation> = (
	(* Squeak compatibility for DebugMapper. *)
	| c = closure. |
	nil = c ifTrue: [^nil].
	^definingActivationOf: c
)
public pop = (
	|
	depth = self size.
	result = self tempAt: depth.
	|
	self size: depth - 1.
	^result
)
public printString ^<String> = (
	| methodMixin receiverMixin result |
	nil = closure ifFalse:
		[^'[] in ', (definingActivationOf: closure) printString].
	methodMixin:: method mixin.
	receiverMixin:: (mixinOf: (classOf: receiver)).
	result:: receiverMixin _name.
	methodMixin = receiverMixin ifFalse:
		[result:: result, '(', methodMixin _name, ')'].
	result:: result, ' ', method selector.
	#doesNotUnderstand: = method selector ifTrue:
		[result:: result, ' #', (tempAt: 1) selector].
	^result
)
public push: value = (
	| newDepth |
	newDepth:: self size + 1.
	self size: newDepth.
	^self tempAt: newDepth put: value
)
public receiver = (
	(* :literalmessage: primitive: 63 *)
	halt.
)
public receiver: value = (
	(* :literalmessage: primitive: 64 *)
	halt.
)
public resume: value = (
	| unwindActivation unwindBlock |
	self isDead ifTrue: [self cannotReturn: value to: self].
	unwindActivation:: currentActivation.
	[unwindActivation:: unwindActivation findNextUnwindContextUpTo: self.
	nil = unwindActivation]
		whileFalse:
			[nil = (unwindActivation tempAt: 2) ifTrue: [
				unwindActivation tempAt: 2 put: true.
				unwindBlock:: unwindActivation tempAt: 1.
				currentActivation terminateTo: unwindActivation.
				unwindBlock value]].
	currentActivation terminateTo: self.
	^value
)
public return: value = (
	nil = sender ifTrue: [^self cannotReturn: value].
	^sender resume: value
)
public sender = (
	(* :literalmessage: primitive: 55 *)
	halt.
)
public sender: value = (
	(* :literalmessage: primitive: 56 *)
	halt.
)
public size = (
	(* :literalmessage: primitive: 67 *)
	halt.
)
public size: newDepth = (
	(* :literalmessage: primitive: 140 *)
	halt.
)
public tempAt: index = (
	(* :literalmessage: primitive: 65 *)
	^(ArgumentError value: index) signal
)
public tempAt: index put: value = (
	(* :literalmessage: primitive: 66 *)
	^(ArgumentError value: index) signal
)
public terminate = (
	(* Make myself unresumable. *)
	sender:: nil.
	bci:: nil.
	(* Match the interpreter's behavior. Note this differs from Cog, which keeps the parameters. *)
	size:: 0.
)
public terminateTo: previousContext = (
	(* Terminate all the Contexts between me and previousContext, if previousContext is on my Context stack. Make previousContext my sender. *)

	| currentContext sendingContext |
	(self hasSender: previousContext) ifTrue: [
		currentContext:: sender.
		[currentContext = previousContext] whileFalse: [
			sendingContext:: currentContext sender.
			currentContext terminate.
			currentContext:: sendingContext]].
	sender:: previousContext
)
public top = (
	^self tempAt: self size
)
) : (
public new ^<Activation> = (
	(* :literalmessage: primitive: 68 *)
	halt.
)
)
public class ArgumentError value: v = Exception (|
	argument = v.
|) (
public printString = (
	^'ArgumentError: ', argument printString
)
) : (
public new = (
	^self value: nil
)
)
public class Behavior = (|
private superclass <Behavior> (* Must be slot 1, known to the VM. *)
private methods <Array[Method]> (* Must be slot 2, known to the VM. *)
private enclosingObject <Object> (* Must be slot 3, known to the VM. *)
private mixin <AbstractMixin> (* Must be slot 4, known to the VM. *)
private classIndex <SmallInteger> (* Must be slot 5, known to the VM. *)
private format <SmallInteger> (* Must be slot 6, known to the VM. *)
|) (
public isKindOfBehavior = (
	^true
)
public mixinApply: superklass = (
	(* :todo: To be subsumed by generalized mixin application support. *)
	^self mixin apply: superklass withName: self name enclosingObject: self enclosingObject.
)
) : (
)
public class Boolean = () (
) : (
)
public class ByteArray _cannotInstantiate = Collection () (
public at: index <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 47 *)
	^(ArgumentError value: index) signal
)
public at: index <Integer> put: value <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 48 *)
	^(ArgumentError value: index) signal
)
public copyByteArrayFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :literalmessage: primitive: 50 *)
	^ArgumentError new signal
)
public copyFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :literalmessage: primitive: 50 *)
	^ArgumentError new signal
)
public copyStringFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :literalmessage: primitive: 121 *)
	^ArgumentError new signal
)
public copyWithSize: newSize <Integer> ^<ByteArray> = (
	|
	newArray = ByteArray new: newSize.
	overlap = size < newSize ifTrue: [size] ifFalse: [newSize].
	|
	^newArray replaceFrom: 1 to: overlap with: self startingAt: 1
)
public do: action <[:Integer]> = (
	1 to: self size do: [:index <Integer> | action value: (self at: index)].
)
public endsWith: suffix <ByteArray | String> ^<Boolean> = (
	(* :literalmessage: primitive: 118 *)
	^(ArgumentError value: suffix) signal
)
public indexOf: substring <ByteArray | String> ^<Integer> = (
	^self indexOf: substring startingAt: 1
)
public indexOf: substring <ByteArray | String> startingAt: index <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 119 *)
	^ArgumentError new signal
)
public isEmpty ^<Boolean> = (
	^0 = self size
)
public isKindOfByteArray ^<Boolean> = (
	^true
)
public lastIndexOf: substring <ByteArray | String> ^<Integer> = (
	^self lastIndexOf: substring startingAt: 1 + self size
)
public lastIndexOf: substring <ByteArray | String> startingAt: index <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 120 *)
	^ArgumentError new signal
)
public replaceFrom: start <Integer> to: stop <Integer> with: replacement <ByteArray | String> startingAt: replacementStart <Integer> = (
	(* :literalmessage: primitive: 79 *)
	^ArgumentError new signal
)
public size ^<Integer> = (
	(* :literalmessage: primitive: 49 *)
	halt.
)
public startsWith: prefix <ByteArray | String> ^<Boolean> = (
	(* :literalmessage: primitive: 117 *)
	^(ArgumentError value: prefix) signal
)
) : (
public new: size <Integer> ^<ByteArray> = (
	(* :literalmessage: primitive: 46 *)
	^(ArgumentError value: size) signal
)
public withAll: bytes <Collection[Integer] | ByteArray | String> ^<ByteArray> = (
	(* :literalmessage: primitive: 122 *)
	| result index |
	result:: ByteArray new: bytes size.
	index:: 1.
	bytes do: [:element <E> | result at: index put: element. index:: 1 + index].
	^result
)
)
class CannotReturn result: r = Exception (|
public result = r.
|) (
public printString ^<String> = (
	^'CannotReturn: ', result printString
)
) : (
)
public class Class = Behavior (|
private nameS <Symbol> (* Must be slot 7, known to the VM for debug printing only. *)
private subclasses <WeakArray>
|) (
protected basicNew = (
	(* Sent by the compiler from factory methods. *)
	(* :literalmessage: primitive: 34 *)
	halt.
)
public isKindOfClass ^ <Boolean> = (
  ^true
)
public name ^<String> = (
	^self nameS
)
public printString ^<String> = (
	^nameS
)
) : (
)
public class ClassMixin = (
(* A class-side mixin is the difference between a metaclass and Class. (In Newspeak metaclasses are direct subclasses of Class, unlike Smalltalk where they are subclasses of the class's superclass's metaclass.) Note that class-side mixins can only introduce additional methods, unlike instance-side mixins which can introduce slots, methods and nested classes. Because of this, module definitions (top-level classes) are always stateless.

Raw mixins are not user accessible. Mixins are implicitly extracted from a class during mixin application. *)
|
public _instanceMixin <InstanceMixin>
public _methods <Array[Method]> (* Must be slot 2, known to the VM. *)
public _enclosingMixin <InstanceMixin | nil> (* Must be slot 3, known to the VM. *)
|) (
public _name ^<String> = (
	^_instanceMixin _name, ' class'
)
public _nestedMixins ^<Array[InstanceMixin]> = (
	^{}
)
public _slots ^<Array[{Symbol. Boolean. Symbol}]> = (
	^{}
)
public isMeta ^<Boolean> = (
	^true
)
) : (
)
public class Closure _cannotInstantiate = () (
public cull: arg1 = (
	0 = numArgs ifTrue: [^self value].
	1 = numArgs ifTrue: [^self value: arg1].
	^numArgsError: 1
)
public cull: arg1 cull: arg2 = (
	0 = numArgs ifTrue: [^self value].
	1 = numArgs ifTrue: [^self value: arg1].
	2 = numArgs ifTrue: [^self value: arg1 value: arg2].
	^numArgsError: 2
)
public cull: arg1 cull: arg2 cull: arg3 = (
	0 = numArgs ifTrue: [^self value].
	1 = numArgs ifTrue: [^self value: arg1].
	2 = numArgs ifTrue: [^self value: arg1 value: arg2].
	3 = numArgs ifTrue: [^self value: arg1 value: arg2 value: arg3].
	^numArgsError: 3
)
public ensure: onUnwind <[]> = (
	(* :literalmessage: primitive: 113 *)
	| complete result |
	result:: self value.
	nil = complete ifTrue:
		[complete:: true.
		onUnwind value].
	^result
)
public isKindOfClosure ^<Boolean> = (
	^true
)
public numArgs ^<Integer> = (
	(* :literalmessage: primitive: 75 *)
	halt.
)
private numArgsError: argsProvided = (
	(* :bogus: *)
	^(ArgumentError value: self) signal
)
public on: exceptionClass <E class> do: catch <[:E]> = (
	(* :literalmessage: primitive: 116 *)
	| handlerActive ::= true. |
	^self value
)
public printString ^<String> = (
	^'[closure] in ', (definingActivationOf: self) printString
)
public repeat = (
	halt.
)
public value = (
	(* :literalmessage: primitive: 90 *)
	self numArgs = 0 ifFalse: [^numArgsError: 0].
	halt.
)
public value: arg1 = (
	(* :literalmessage: primitive: 91 *)
	self numArgs = 1 ifFalse: [^numArgsError: 1].
	halt.
)
public value: arg1 value: arg2 = (
	(* :literalmessage: primitive: 92 *)
	self numArgs = 2 ifFalse: [^numArgsError: 2].
	halt.
)
public value: arg1 value: arg2 value: arg3 = (
	(* :literalmessage: primitive: 93 *)
	self numArgs = 3 ifFalse: [^numArgsError: 3].
	halt.
)
public valueWithArguments: arguments = (
	(* :literalmessage: primitive: 94 *)
	self numArgs = arguments size ifFalse: [^numArgsError: arguments size].
	^self valueWithArgumentsAgain: (Array withAll: arguments)
)
private valueWithArgumentsAgain: arguments = (
	(* :literalmessage: primitive: 94 *)
	self numArgs = arguments size ifFalse: [^numArgsError: arguments size].
	halt.
)
public whileFalse = (
	halt.
)
public whileFalse: action = (
	halt.
)
public whileTrue = (
	halt.
)
public whileTrue: action = (
	halt.
)
) : (
)
public class Collection = () (
public allSatisfy: predicate <[:E | Boolean]> ^<Boolean> = (
	self do: [:element <E> | (predicate value: element) ifFalse: [^false]].
	^true
)
public anySatisfy: predicate <[:E | Boolean]> ^<Boolean> = (
	self do: [:element <E> | (predicate value: element) ifTrue: [^true]].
	^false
)
public collect: transform <[:E | F]> ^<List[F]> = (
	| result <List[E]> |
	result:: self newForCollectUsingAdd: size.
	self do: [:element <E> | result add: (transform value: element)].
	^result
)
public detect: predicate <[:E | Boolean]> ^<E> = (
	^self detect: predicate ifNone: [Error signal: 'No matching element detected']
)
public detect: predicate <[:E | Boolean]> ifNone: onNone <[X def]> ^<E | X> = (
	self do: [:element <E> | (predicate value: element) ifTrue: [^element]].
	^onNone value
)
public do: action <[:E]> = (
	self subclassResponsibility.
)
public do: action <[:E]> separatedBy: betweenAction <[]> = (
	| first <Boolean> ::= true. |
	self do:
		[:element <E> |
		 first ifTrue: [first:: false] ifFalse: [betweenAction value].
		 action value: element].
)
public flatMap: map <[:E | R def]> ^<Collection[R]> = (
	^self flatten collect: map
)
public flatten ^ <Array> = (
	| totalSize <Integer> ::= 0. c <Array> index <Integer> ::= 1. |
	self do: [:e <E> | totalSize:: totalSize + (e isKindOfCollection ifTrue: [e size] ifFalse: [1])].
	c:: Array new: totalSize.
	do: [:e <E> | e isKindOfCollection
					ifTrue: [e do: [:x | c at: index put: x. index:: index + 1]]
					ifFalse: [c at: index put: e. index:: index + 1]
		].
	^c
)
public includes: object <Object> ^<Boolean> = (
	self do: [:element <E> | element = object ifTrue: [^true]].
	^false
)
public inject: initialValue <X> into: foldBlock <[:X def :E | X]> ^<X> = (
	| runningValue <X> ::= initialValue. |
	self do: [:element <E> | runningValue:: foldBlock value: runningValue value: element].
	^runningValue
)
public isEmpty ^<Boolean> = (
	self do: [:ignore | ^false].
	^true
)
public isKindOfCollection ^<Boolean> = (
	^true
)
newForCollectUsingAdd: capacity = (
  subclassResponsibility
)
public noneSatisfy: predicate <[:E | Boolean]> ^<Boolean> = (
	self do: [:element <E> | (predicate value: element) ifTrue: [^false]].
	^true
)
public reduce: mergeFunction <[:(E | X) :E | X def]> ^<X> = (
	^self reduce: mergeFunction ifEmpty: [Error signal: 'Cannot reduce an empty collection' ]
)
public reduce: mergeFunction <[:(E | X) :E | X def]> ifEmpty: onEmpty <[Y def]> ^<E | X | Y> = (
	| first <Boolean> ::= true. runningValue <E | X> |
	self do:
		[:element <E> |
		first
			ifTrue: [runningValue:: element. first:: false]
			ifFalse: [runningValue:: mergeFunction value: runningValue value: element]].
	^first
		ifTrue: [onEmpty value]
		ifFalse: [runningValue]
)
public reject: predicate <[:E | Boolean]> ^<List[E]> = (
	| result <List[E]> |
	result:: self newForCollectUsingAdd: size.
	self do: [:element <E> | (predicate value: element) ifFalse: [result add: element]].
	^result
)
public select: predicate <[:E | Boolean]> ^<List[E]> = (
	| result <List[E]> |
	result:: self newForCollectUsingAdd: size.
	self do: [:element <E> | (predicate value: element) ifTrue: [result add: element]].
	^result
)
public size ^<Integer> = (
	| count ::= 0. |
	self do: [:ignore | count:: count + 1].
	^count
)
) : (
)
public class Ephemeron = (|
public key (* Must be slot 1, known to the VM. *)
public value (* Must be slot 2, known to the VM. *)
public finalizer (* Must be slot 3, known to the VM. *)
(* Must have no other slots. Can be subclassed, but subclasses won't have the ephemeron property. *)
|) (
) : (
)
public class Exception = (|
private signalActivation <Activation>
private handlerActivation <Activation>
public messageText (* squeak compatibility for Minitest *)
|) (
private invokeNextHandler = (
	| activation <Activation> |

	activation:: handlerActivation sender.
	[nil = activation] whileFalse:
		[activation method primitive = 142 ifTrue:
			[returnToSimulationRoot: activation.
			 halt].
		 activation method primitive = 116 ifTrue:
			[(is: (activation tempAt: 1) interestedIn: super class) ifTrue:
				[(activation tempAt: 3) ifTrue:
					[^invokeOnDoHandler: activation]]].
		 activation:: activation sender].

	messageLoop unhandledException: self from: signalActivation sender.
	halt.
)
private invokeOnDoHandler: handler <Activation> = (
	| handlerResult |
	handler tempAt: 3 put: false. (* handlerActive:: false. *)
	handlerActivation:: handler.
	handlerResult:: (handler tempAt: 2) value: self.
	handler tempAt: 3 put: true. (* handlerActive:: true. *)
	(* What if the return is interrupted by unwind-protect? Should we hold off on removing these activations and check if they are dead instead? *)
	signalActivation:: nil.
	handlerActivation:: nil.
	^handler return: handlerResult
)
private is: handlerExceptionClass <Any> interestedIn: signaledExceptionClass <Behavior> = (
	| cls ::= signaledExceptionClass. |
	[nil = cls] whileFalse:
		[(mixinOf: cls) = (mixinOf: handlerExceptionClass) ifTrue: [^true].
		cls:: (superclassOf: cls)].
	^false
)
private jumpTo: activation = (
	(* :literalmessage: primitive: 95 *)
	halt.
)
public pass = (
	nil = handlerActivation ifTrue: [^error].
	invokeNextHandler.
	halt.
)
public printString ^<String> = (
	nil = messageText ifTrue: [^super class name].
	^super class name, ': ', messageText
)
public resume: resumptionValue = (
	| savedSignalActivation = signalActivation. |
	nil = savedSignalActivation ifTrue: [^error].
	signalActivation:: nil.
	handlerActivation:: nil.
	^savedSignalActivation return: resumptionValue
)
public retry = (
	halt. (* Needs test *)
	handlerActivation restart.
	halt.
)
public return: returnValue = (
	| savedHandlerActivation = handlerActivation. |
	nil = handlerActivation ifTrue: [^error].
	signalActivation:: nil.
	handlerActivation:: nil.
	^savedHandlerActivation return: returnValue
)
private returnToSimulationRoot: simulationRoot <Activation> = (
	(simulationRoot tempAt: 1)
		state: #broken;
		suspendedActivation: signalActivation sender.

	(* Note the following alternative doesn't work. Slow stepping will stop
	   after the sender is changed, because it leaves the stepping goal off
       the chain, and overwrite the suspened activation, because we didn't stop
	   at the simulation root.
		currentActivation sender: simulationRoot.
		^self *)

	simulationRoot push: self.
	jumpTo: simulationRoot.
)
public signal = (
	handlerActivation:: signalActivation:: currentActivation.
	invokeNextHandler.
	halt.
)
public signal: message <String> = (
	(* squeak compatibility for Minitest *)
	messageText:: message.
	^self signal
)
) : (
public signal: message <String> = (
	^(self new messageText: message) signal
)
)
public class False _cannotInstantiate = Boolean () (
public & alternative <Boolean> ^<Boolean> = (
	(* Evaluating conjunction. *)
	^false
)
public and: alternative <[Boolean]> ^<Boolean> = (
	(* Non-evaluating conjunction. *)
	^false
)
public asString ^<String> = (
	^'false'
)
public ifFalse: else <[Y def]> ^<nil | Y> = (
	^else value
)
public ifFalse: else <[Y def]> ifTrue: then <[X def]> ^<X | Y> = (
	^else value
)
public ifTrue: then <[X def]> ^<X | nil> = (
	^nil
)
public ifTrue: then <[X def]> ifFalse: else <[Y def]> ^<X | Y> = (
	^else value
)
public not ^<Boolean> = (
	^true
)
public or: alternative <[Boolean]> ^<Boolean> = (
	(* Non-evaluating disjunction. *)
	^alternative value
)
public printString ^<String> = (
	^'false'
)
public | alternative <Boolean> ^<Boolean> = (
	(* Evaluating disjunction. *)
	^alternative
)
) : (
)
public class Float _cannotInstantiate = Number () (
public addFromFraction: left = (
	^left asFloat + self
)
public asFloat ^<Float> = (
	^self
)
public asStringExponential: fractionDigits <Integer> ^<String> = (
	(* :literalmessage: primitive: 109 *)
	^(ArgumentError value: fractionDigits) signal
)
public asStringFixed: fractionDigits <Integer> ^<String> = (
	(* :literalmessage: primitive: 108 *)
	^(ArgumentError value: fractionDigits) signal
)
public asStringPrecision: precision <Integer> ^<String> = (
	(* :literalmessage: primitive: 110 *)
	^(ArgumentError value: precision) signal
)
public ceiling ^<Float> = (
	(* :literalmessage: primitive: 22 *)
	halt.
)
public cos ^<Float> = (
	(* :literalmessage: primitive: 24 *)
	halt.
)
public divideFromFraction: left = (
	^left asFloat / self
)
public exp ^<Float> = (
	(* :literalmessage: primitive: 30 *)
	halt.
)
public floor ^<Float> = (
	(* :literalmessage: primitive: 21 *)
	halt.
)
public hash ^<Integer> = (
	^self asInteger
)
public isFinite ^<Boolean> = (
	halt.
)
public isInfinite ^<Boolean> = (
	halt.
)
public isKindOfFloat ^<Boolean> = (
	^true
)
public isNaN ^<Boolean> = (
	^(self = self) not
)
public ln ^<Float> = (
	(* :literalmessage: primitive: 31 *)
	halt.
)
public log ^<Float> = (
	(* :literalmessage: primitive: 32 *)
	halt.
)
public multiplyFromFraction: left = (
	^left asFloat * self
)
public rounded ^<Float> = (
	(* :literalmessage: primitive: 125 *)
	halt.
)
public sin ^<Float> = (
	(* :literalmessage: primitive: 23 *)
	halt.
)
public sqrt ^<Float> = (
	(* :literalmessage: primitive: 33 *)
	halt.
)
public subtractFromFraction: left = (
	^left asFloat - self
)
public tan ^<Float> = (
	(* :literalmessage: primitive: 25 *)
	halt.
)
) : (
public parse: string <String> ^<Float> = (
	(* :literalmessage: primitive: 132 *)
	^(ArgumentError value: string) signal
)
)
public class Fraction reducedNumerator: num denominator: denom = Number (|
public numerator <Integer> = num.
public denominator <Integer> = denom.
|) (
public * other <Number> ^<Number> = (
	other isKindOfFraction ifFalse: [^other multiplyFromFraction: self].
	^Fraction
		numerator: numerator * other numerator
		denominator: denominator * other denominator
)
public + other <Number> ^<Number> = (
	other isKindOfFraction ifFalse: [^other addFromFraction: self].
	^Fraction
		numerator: (numerator * other denominator) + (other numerator * denominator)
		denominator: denominator * other denominator
)
public - other <Number> ^<Number> = (
	other isKindOfFraction ifFalse: [^other subtractFromFraction: self].
	^Fraction
		numerator: (numerator * other denominator) - (other numerator * denominator)
		denominator: denominator * other denominator
)
public / other <Number> ^<Number> = (
	other isKindOfFraction ifFalse: [^other divideFromFraction: self].
	^Fraction
		numerator: numerator * other denominator
		denominator: denominator * other numerator
)
public < other <Number> ^<Boolean> = (
	other isKindOfInteger ifTrue:
		[^(numerator) < (other * denominator)].
	other isKindOfFraction ifTrue:
		[^(numerator * other denominator) < (other numerator * denominator)].
	other isKindOfFloat ifTrue:
		[^self asFloat < other].
	^(ArgumentError value: other) signal
)
public <= other <Number> ^<Boolean> = (
	other isKindOfInteger ifTrue:
		[^(numerator) <= (other * denominator)].
	other isKindOfFraction ifTrue:
		[^(numerator * other denominator) <= (other numerator * denominator)].
	other isKindOfFloat ifTrue:
		[^self asFloat <= other].
	^(ArgumentError value: other) signal
)
public = other ^<Boolean> = (
	other isKindOfFraction ifFalse: [^false].
	numerator = other numerator ifFalse: [^false].
	^denominator = other denominator
)
public > other <Number> ^<Boolean> = (
	other isKindOfInteger ifTrue:
		[^(numerator) > (other * denominator)].
	other isKindOfFraction ifTrue:
		[^(numerator * other denominator) > (other numerator * denominator)].
	other isKindOfFloat ifTrue:
		[^self asFloat > other].
	^(ArgumentError value: other) signal
)
public >= other <Number> ^<Boolean> = (
	other isKindOfInteger ifTrue:
		[^(numerator) >= (other * denominator)].
	other isKindOfFraction ifTrue:
		[^(numerator * other denominator) >= (other numerator * denominator)].
	other isKindOfFloat ifTrue:
		[^self asFloat >= other].
	^(ArgumentError value: other) signal
)
public addFromNumber: left = (
	^(left * denominator + numerator) / denominator
)
public asFloat ^<Float> = (
	^numerator asFloat / denominator asFloat
)
public asInteger ^<Integer> = (
	^self truncated
)
public asString ^<String> = (
	^'(', numerator asString, '/', denominator asString, ')'
)
public ceiling ^<Integer> = (
	^0 <= numerator
		ifTrue: [1 + self truncated]
		ifFalse: [self truncated]
)
public divideFromNumber: left = (
	^(left * denominator) / numerator
)
public floor ^<Integer> = (
	^numerator // denominator
)
public hash ^<Integer> = (
	(* :todo: This is a poor hash. *)
	^numerator bitXor: denominator
)
public isKindOfFraction ^<Boolean> = (
	^true
)
public multiplyFromNumber: left = (
	^(left * numerator) / denominator
)
public rounded ^<Integer> = (
	^0 <= numerator
		ifTrue: [(2 * numerator + denominator) quo: (2 * denominator)]
		ifFalse: [(2 * numerator - denominator) quo: (2 * denominator)].
)
public subtractFromNumber: left = (
	^(left * denominator - numerator) / denominator
)
public truncated ^<Integer> = (
	^numerator quo: denominator
)
) : (
public numerator: numerator <Integer> denominator: denominator <Integer> ^<Fraction> = (
	(* Invariant: instances of Fraction must always be in reduced form. *)
	| gcd numer denom |
	0 = numerator ifTrue: [^0].
	gcd:: numerator gcd: denominator.
	numer:: numerator // gcd.
	denom:: denominator // gcd.
	0 > denom ifTrue:
		[numer:: 0 - numer.
		 denom:: 0 - denom].
	1 = denom ifTrue: [^numer].
	^Fraction reducedNumerator: numer denominator: denom
)
)
public class IdentityMap new: capacity = (
|
table ::= Array new: capacity.
public size ::= 0.
|
1 to: table size do: [:index | table at: index put: table]
) (
public at: key = (
	| mask index entry |
	mask:: table size - 2.
	index:: ((identityHashOf: key) bitAnd: mask) + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: 1 + index].
	 table = entry] whileFalse:
		[index:: ((index + 2) bitAnd: mask) + 1].

	noSuchKey
)
public at: key ifAbsent: onAbsent = (
	| mask index entry value |
	mask:: table size - 2.
	index:: ((identityHashOf: key) bitAnd: mask) + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: index + 1].
	 table = entry] whileFalse:
		[index:: ((index + 2) bitAnd: mask) + 1].

	^onAbsent value
)
public at: key ifAbsentPut: valueGen = (
	| mask index entry value |
	mask:: table size - 2.
	index:: ((identityHashOf: key) bitAnd: mask) + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: index + 1].
	 table = entry] whileFalse:
		[index:: ((index + 2) bitAnd: mask) + 1].

	value:: valueGen value.
	table at: index put: key.
	table at: index + 1 put: value.
	size:: size + 1.
	(size) > (table size * 3 / 8) ifTrue: [self grow].
	^value
)
public at: key ifAbsentPutVal: value = (
	| mask index entry |
	mask:: table size - 2.
	index:: ((identityHashOf: key) bitAnd: mask) + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^false].
	 table = entry] whileFalse:
		[index:: ((index + 2) bitAnd: mask) + 1].

	table at: index put: key.
	table at: index + 1 put: value.
	size:: size + 1.
	(size) > (table size * 3 / 8) ifTrue: [self grow].
	^true
)
public at: key put: value = (
	(at: key ifAbsentPutVal: value) ifFalse: [duplicateKey].
	^value
)
public at: key putReplace: value = (
	| mask index entry |
	mask:: table size - 2.
	index:: ((identityHashOf: key) bitAnd: mask) + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: index + 1 put: value].
	 table = entry] whileFalse:
		[index:: ((index + 2) bitAnd: mask) + 1].

	noSuchKey
)
public atOrItself: key = (
	| mask index entry |
	mask:: table size - 2.
	index:: ((identityHashOf: key) bitAnd: mask) + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^table at: 1 + index].
	 table = entry] whileFalse:
		[index:: ((index + 2) bitAnd: mask) + 1].

	^key
)
grow = (
	| oldTable newSize mask newTable |
	oldTable:: table.
	newSize:: oldTable size * 2.
	mask:: newSize - 2.
	newTable:: Array new: newSize.
	1 to: newSize do: [:index | newTable at: index put: newTable].

	1 to: oldTable size by: 2 do: [:oldIndex |
		| key |
		key:: oldTable at: oldIndex.
		oldTable = key ifFalse:
			[ | value newIndex |
			 value:: oldTable at: oldIndex + 1.
			 newIndex:: ((identityHashOf: key) bitAnd: mask) + 1.
			 [newTable = (newTable at: newIndex)] whileFalse:
				[newIndex:: (newIndex + 2 bitAnd: mask) + 1].
			 newTable at: newIndex put: key.
			 newTable at: newIndex + 1 put: value]].
	table:: newTable.
)
public includesKey: key = (
	| mask index entry |
	mask:: table size - 2.
	index:: ((identityHashOf: key) bitAnd: mask) + 1.
	[entry:: table at: index.
	 (is: entry identicalTo: key) ifTrue: [^true].
	 table = entry] whileFalse:
		[index:: ((index + 2) bitAnd: mask) + 1].

	^false
)
public keysAndValuesDo: action <[:K :V]> = (
	1 to: table size by: 2 do: [:index |
		| key = table at: index. |
		table = key ifFalse:
			[action value: key value: (table at: 1 + index)]].
)
) : (
public new = (
	^self new: 32
)
)
public class InstanceMixin = (
(* An instance-side mixin is the difference between a (non-meta) class and its superclass: a set of additional methods, slots and nested class declarations. Instance-side mixins always have a paired class-side mixin.

Raw mixins are not user accessible. Mixins are implicitly extracted from a class during mixin application. *)
|
public _name <Symbol>
public _methods <Array[Method]> (* Must be slot 2, known to the VM. *)
public _enclosingMixin <InstanceMixin | nil> (* Must be slot 3, known to the VM. *)
public _slots <Array[{Symbol. Boolean. Symbol}]>
public _nestedMixins <Array[InstanceMixin]>
public _applications <WeakArray>
public _classMixin <ClassMixin>
public _accessModifier <Symbol>
public _primaryFactorySelector <Symbol>
public _headerSource <String>
|) (
public apply: superclass <Class> format: f withName: name <Symbol> enclosingObject: eo <Object> = (
	| newMetaclass <Metaclass> newClass <Class> |
	newMetaclass:: Metaclass new.
	superclassOf: newMetaclass put: Class.
	methodsOf: newMetaclass put: _classMixin _methods. (* Do we need a copy? *)
	enclosingObjectOf: newMetaclass put: eo.
	mixinOf: newMetaclass put: _classMixin.
	formatOf: newMetaclass put: (formatOf: Class).

	newClass:: instantiate: newMetaclass.
	superclassOf: newClass put: superclass.
	methodsOf: newClass put: (methodsWithAccessorsAtOffset: f).
	enclosingObjectOf: newClass put: eo.
	mixinOf: newClass put: self.
	formatOf: newClass put: f + _slots size.
	nameOf: newClass put: name.

	thisClassOf: newMetaclass put: newClass.

	_applications:: toWeakSet: _applications add: newClass.
	nil = superclass ifFalse:
		[subclassesOf: superclass put: (toWeakSet: (subclassesOf: superclass) add: newClass)].

	^newClass
)
public apply: superclass <Class> withName: name <Symbol> enclosingObject: eo <Object> = (
	(isValidSuperclass: superclass) ifFalse: [^(ArgumentError value: superclass) signal].
	^self apply: superclass format: (formatOf: superclass) withName: name enclosingObject: eo
)
public applyTo: superclass <Class> withEnclosingObject: eo <Object> = (
	(* Sent by the compiler in nested class accessors. *)
	^apply: superclass withName: (_name , '`', eo hash printString) enclosingObject: eo
)
public at: nestedMixinName = (
	(* bogus: polymorphic with nested mixins map in Squeak. *)
	_nestedMixins do: [:nestedMixin |
		nestedMixin _name = nestedMixinName ifTrue: [^nestedMixin]].
	^nil
)
public isMeta ^<Boolean> = (
	^false
)
private isValidSuperclass: object = (
	| cls cid |
	cls:: classOf: object.
	Metaclass = cls ifTrue: [^false (* [object] is a metaclass *)].
	cls:: classOf: cls.
	Metaclass = cls ifFalse: [^false (* [object] is an instance *)].
	cid:: slotOf: object at: 5.
	nil = cid ifTrue: [^true].
	^(cid between: 3 and: 13) not
)
private methodsWithAccessorsAtOffset: offset <Integer> ^<MethodDictionary> = (
	| newMethods <MethodDictionary> methodIndex |
	newMethods:: Array new: _methods size.

	methodIndex:: 1.
	1 to: _slots size do: [:i |
		| slotDescriptor name isMutable accessModifier |
		slotDescriptor:: _slots at: i.
		name:: slotDescriptor at: 1.
		isMutable:: slotDescriptor at: 2.
		accessModifier:: slotDescriptor at: 3.

		newMethods at: methodIndex put:
			(Method newGetterForSlot: name at: i + offset accessModifier: accessModifier).
		methodIndex:: methodIndex + 1.
		newMethods at: methodIndex put:
			(Method newInitializerForSlot: name at: i + offset).
		methodIndex:: methodIndex + 1.
		isMutable ifTrue:
			[newMethods at: methodIndex put:
				(Method newSetterForSlot: name at: i + offset accessModifier: accessModifier).
			methodIndex:: methodIndex + 1]].

	_methods do:
		[:method |
		| skip ::= false. |
		1 to: methodIndex - 1 do:
			[:i |
			(newMethods at: i) selector = method selector ifTrue:
				[skip:: true]].
		skip ifFalse:
			[newMethods at: methodIndex put: method.
			methodIndex:: methodIndex + 1]].

	^newMethods
)
public nestedMixins = (
	(* bogus: polymorphic with nested mixins map in Squeak. *)
	^self
)
public printString ^<String> = (
	^_name, ' mixin'
)
private toWeakSet: set add: element = (
	| newSet |
	nil = set ifTrue:
		[newSet:: WeakArray new: 2.
		newSet at: 1 put: element.
		^newSet].
	1 to: set size do:
		[:index |
		nil = (set at: index) ifTrue:
			[set at: index put: element.
			 ^set]].
	^set copyWith: element
)
public value = (
	(* bogus: polymorphic with method class association in Squeak. *)
	^self
)
) : (
)
class Integer = Number () (
public & other <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 16 *)
	^(ArgumentError value: other) signal
)
public / other <Number> ^<Number> = (
	(* :literalmessage: primitive: 4 *)
	other isKindOfInteger ifFalse: [^other divideFromNumber: self].
	0 = other ifTrue: [^(ArgumentError value: other) signal].
	^Fraction numerator: self denominator: other
)
public << other <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 19 *)
	^(ArgumentError value: other) signal
)
public >> other <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 20 *)
	^(ArgumentError value: other) signal
)
public addFromFraction: left = (
	^(left numerator + (self * left denominator)) / left denominator
)
public asInteger ^<Integer> = (
	^self
)
public bitAnd: other <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 16 *)
	^(ArgumentError value: other) signal
)
public bitInvert ^<Integer> = (
	^-1 - self
)
public bitOr: other <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 17 *)
	^(ArgumentError value: other) signal
)
public bitXor: other <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 18 *)
	^(ArgumentError value: other) signal
)
public ceiling ^<Integer> = (
	^self
)
public denominator ^<Integer> = (
	^1
)
public divideFromFraction: left = (
	^left numerator / (left denominator * self)
)
public floor ^<Integer> = (
	^self
)
public gcd: other <Integer> ^<Integer> = (
	| n m |
	n:: self.
	m:: other.
	[n = 0]
		whileFalse:
			[n:: m \\ (m:: n)].
	^m abs
)
public hash ^<Integer> = (
	^self
)
public inverseMod: modulus <Integer> ^<Integer> = (
	halt.
)
public isKindOfFraction ^<Boolean> = (
	^true
)
public isKindOfInteger ^<Boolean> = (
	^true
)
public multiplyFromFraction: left = (
	^(left numerator * self) / left denominator
)
public numerator ^<Integer> = (
	^self
)
public raisedTo: exponent mod: modulus = (
	halt.
)
public rounded ^<Integer> = (
	^self
)
public subtractFromFraction: left = (
	^(left numerator - (self * left denominator)) / left denominator
)
public timesRepeat: action <[]> ^<Integer> = (
	1 to: self do: [:ignore | action value].
)
public | other <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 17 *)
	^(ArgumentError value: other) signal
)
) : (
private digitValue: byte <Integer> ^<Integer> = (
	byte >= 48 ifTrue: [byte <= 57 ifTrue: [^byte - 48]].
	byte >= 65 ifTrue: [byte <= 90 ifTrue: [^byte - 55]].
	byte >= 97 ifTrue: [byte <= 122 ifTrue: [^byte - 87]].
	^37
)
public parse: string <String> ^<Integer> = (
	^self parse: string radix: 10
)
public parse: string <String> radix: radix <Integer> ^<Integer> = (
	| negative start value |
	radix < 2 ifTrue: [^(ArgumentError value: radix) signal].
	radix > 36 ifTrue: [^(ArgumentError value: radix) signal].
	string size = 0 ifTrue: [^(ArgumentError value: string) signal].
	45 = (string at: 1)
		ifTrue:
			[negative:: true.
			 string size < 2 ifTrue: [^(ArgumentError value: string) signal].
			 start:: 2]
		ifFalse:
			[negative:: false.
			 start:: 1].
	value:: 0.
	start to: string size do:
		[:index | | digitValue = self digitValue: (string at: index). |
		digitValue >= radix ifTrue: [^(ArgumentError value: string) signal].
		value:: value * radix + digitValue].
	^negative ifTrue: [0 - value] ifFalse: [value]
)
)
public class LargeInteger _cannotInstantiate = Integer () (
) : (
)
public class MediumInteger _cannotInstantiate = Integer () (
) : (
)
public class Message selector: s arguments: a = (|
public selector <Symbol> = s.
public arguments <Array[Object]> = a.
|) (
public sendEventualTo: receiver = (
	halt.
)
public sendTo: receiver = (
	(* Send a message to the argument according as an ordinary send. *)
	^object: receiver perform: selector with: arguments
)
) : (
)
public class MessageNotUnderstood receiver: r message: m = Exception (|
public receiver <Object> = r.
public message <Message> = m.
|) (
public messageText ^<String> = (
	(* squeak compatibility for Minitest *)
	^self printString
)
public printString ^<String> = (
	^'MessageNotUnderstood: ', (mixinOf: (classOf: receiver)) _name, ' ', message selector
)
) : (
)
public class Metaclass = Behavior (|
private thisClass <Class>
|) (
public name ^<String> = (
	^thisClass name, ' class'
)
public printString ^<String> = (
	^thisClass printString, ' class'
)
) : (
)
public class Method = (|
public header <Integer> (* Must be slot 1, known to the VM. *)
public literals <Array> (* Must be slot 2, known to the VM. *)
public bytecode <ByteArray> (* Must be slot 3, known to the VM. *)
public mixin <AbstractMixin> (* Must be slot 4, known to the VM. *)
public selector <Symbol> (* Must be slot 5, known to the VM. *)
public metadata <String>
|) (
public accessModifier ^<Symbol> = (
	| ac = header >> 28. |
	0 = ac ifTrue: [^#public].
	1 = ac ifTrue: [^#protected].
	2 = ac ifTrue: [^#private].
	halt.
)
public isPrivate ^<Boolean> = (
	^#private = accessModifier
)
public isProtected ^<Boolean> = (
	^#protected = accessModifier
)
public isPublic ^<Boolean> = (
	^#public = accessModifier
)
public isSynthetic ^<Boolean> = (
	^nil = metadata
)
public numArgs ^<Integer> = (
	^(header >> 0) bitAnd: 255
)
public numTemps ^<Integer> = (
	^(header >> 8) bitAnd: 255
)
public primitive ^<Integer> = (
	^(header >> 16) bitAnd: 1023
)
public source = (
	metadata isKindOfDebugInfo ifTrue: [^metadata source].
	^metadata
)
public source: s = (
	(* Can be removed after next bootstrap compiler update. *)
	metadata: s
)
) : (
public headerForAccessModifier: am primitive: prim numArgs: numArgs = (
	| ami |
	#public = am ifTrue: [ami:: 0].
	#protected = am ifTrue: [ami:: 1].
	#private = am ifTrue: [ami:: 2].
	^(ami << 28) | (prim << 16) | (numArgs)
)
public headerForAccessModifier: am primitive: prim numTemps: numTemps numArgs: numArgs = (
	| ami |
	#public = am ifTrue: [ami:: 0].
	#protected = am ifTrue: [ami:: 1].
	#private = am ifTrue: [ami:: 2].
	^(ami << 28) | (prim << 16) | (numTemps << 8) | (numArgs)
)
public newGetterForSlot: name at: index accessModifier: am = (
	| accessor = Method new. |
	accessor header: (headerForAccessModifier: am primitive: 256 + index - 1 numArgs: 0).
	accessor mixin: self. (* The method has no sends, so this is only for debugging. *)
	accessor selector: name.
	^accessor
)
public newInitializerForSlot: name at: index = (
	| accessor = Method new. |
	accessor header: (headerForAccessModifier: #private primitive: 512 + index - 1 numArgs: 1).
	accessor mixin: self. (* The method has no sends, so this is only for debugging. *)
	accessor selector: ('init`', name, ':') asSymbol.
	^accessor
)
public newSetterForSlot: name at: index accessModifier: am = (
	| accessor = Method new. |
	accessor header: (headerForAccessModifier: am primitive: 512 + index - 1 numArgs: 1).
	accessor mixin: self. (* The method has no sends, so this is only for debugging. *)
	accessor selector: (name, ':') asSymbol.
	^accessor
)
)
class NonBooleanReceiver receiver: r = Exception (|
public receiver = r.
|) (
public printString ^<String> = (
	^'NonBooleanReceiver ', receiver printString
)
) : (
)
class Number = () (
public * other <Number> ^<Number> = (
	(* Answer the receiver multiplied by the argument. *)
	(* :literalmessage: primitive: 3 *)
	^other multiplyFromNumber: self
)
public + other <Number> ^<Number> = (
	(* Answer the sum of the receiver and the argument. *)
	(* :literalmessage: primitive: 1 *)
	^other addFromNumber: self
)
public - other <Number> ^<Number> = (
	(*Answer the difference of the argument from the receiver*)
	(* :literalmessage: primitive: 2 *)
	^other subtractFromNumber: self
)
public / other <Number> ^<Number> = (
	(* Answer the receiver divided by the argument.
	 'Exact' division. For integer division see // and quo: *)
	(* :literalmessage: primitive: 4 *)
	^other divideFromNumber: self
)
public // other <Number> ^<Number> = (
	(* Answer the receiver divided by the argument, rounded to nearest integer toward negative infinity.  The remainder of this division is given by \\ *)
	(* :literalmessage: primitive: 5 *)
	^(ArgumentError value: other) signal
)
public < other <Number> ^<Boolean> = (
	(* :literalmessage: primitive: 10 *)
	other isKindOfFraction ifTrue: [^other >= self].
	^(ArgumentError value: other) signal
)
public <= other <Number> ^<Boolean> = (
	(* :literalmessage: primitive: 12 *)
	other isKindOfFraction ifTrue: [^other > self].
	^(ArgumentError value: other) signal
)
public = other <Object> ^<Boolean> = (
	(* :literalmessage: primitive: 9 *)
	^(ArgumentError value: other) signal
)
public > other <Number> ^<Boolean> = (
	(* :literalmessage: primitive: 11 *)
	other isKindOfFraction ifTrue: [^other <= self].
	^(ArgumentError value: other) signal
)
public >= other <Number> ^<Boolean> = (
	(* :literalmessage: primitive: 13 *)
	other isKindOfFraction ifTrue: [^other < self].
	^(ArgumentError value: other) signal
)
public \\ other <Number> ^<Number> = (
	(*Answer the remainder of division rounded to the nearest integer toward negative inifinity.  The quoitent of this division is given by // *)
	(* :literalmessage: primitive: 6 *)
	^(ArgumentError value: other) signal
)
public abs ^<Number> = (
	self < 0 ifTrue: [^self negated].
	^self
)
public asFloat ^<Float> = (
	(* :literalmessage: primitive: 15 *)
	halt.
)
public asInteger ^<Integer> = (
	(* :literalmessage: primitive: 14 *)
	^(ArgumentError value: self) signal
)
public asString ^<String> = (
	(* :literalmessage: primitive: 111 *)
	halt.
)
public between: min <Number> and: max <Number> ^<Boolean> = (
	^self <= max and: [self >= min]
)
public cos ^<Float> = (
	^self asFloat cos
)
public exp ^<Float> = (
	(*Answer e raised to the power of the receiver. *)
	^self asFloat exp
)
public isKindOfFloat ^<Boolean> = (
	^false
)
public isKindOfInteger ^<Boolean> = (
	^false
)
public isKindOfNumber ^<Boolean> = (
	^true
)
public ln ^<Float> = (
	(* Answer the natural logarithm of the receiver. *)
	^self asFloat ln
)
public log ^<Float> = (
	(* Answer the common logarithm of the receiver. *)
	^self asFloat log
)
public max: other <Number> ^<Number> = (
	^self > other ifTrue: [self] ifFalse: [other]
)
public min: other <Number> ^<Number> = (
	^self < other ifTrue: [self] ifFalse: [other]
)
public negated ^<Number> = (
	^0 - self
)
public printString ^<String> = (
	^self asString
)
public quo: other <Number> ^<Number> = (
	(* Answer the receiver divided by the argument, rounded to nearest integer toward zero. The remainder of this division is given by rem: *)
	(* :literalmessage: primitive: 7 *)
	^(ArgumentError value: other) signal
)
public raisedTo: other = (
	halt.
)
public rem: other <Number> ^<Number> = (
	(* Answer the remainder of division rounded to the nearest integer toward zero. The quoitent of this division is given by quo: *)
	(* :literalmessage: primitive: 8 *)
	^(ArgumentError value: other) signal
)
public sin ^<Float> = (
	^self asFloat sin
)
public sqrt ^<Float> = (
	^self asFloat sqrt
)
public tan ^<Float> = (
	^self asFloat tan
)
public to: stop <Number> by: step <Number> do: action <[:Number]> = (
	| current ::= self. |
	[current <= stop] whileTrue: [action value. current:: step + current].

	^nil (* To match the inlined version *)
)
public to: stop <Number> do: action <[:Number]> = (
	| current ::= self. |
	[current <= stop] whileTrue: [action value. current:: 1 + current].

	^nil (* To match the inlined version *)
)
) : (
)
public class Proxy = (
(* Proxy overrides all the public members of Object with protected ones. One can implement a total proxy by subclassing and implementing only #doesNotUnderstand:. *)
) (
protected = other = (
	^super = other
)
protected hash = (
	^super hash
)
protected isNil = (
	^super isNil
)
protected printString = (
	^super printString
)
protected yourself = (
	^super yourself
)
) : (
)
public class SmallInteger _cannotInstantiate = Integer () (
) : (
)
public class Stopwatch = (|
private cumulativeNanos ::= 0.
private startNanos
|) (
public elapsedMicroseconds ^<Integer> = (
	^elapsedNanoseconds quo: 1000
)
public elapsedMilliseconds ^<Integer> = (
	^elapsedNanoseconds quo: 1000000
)
public elapsedNanoseconds ^<Integer> = (
	nil = startNanos ifTrue: [^cumulativeNanos].
	^cumulativeNanos + (currentMonotonicNanos - startNanos)
)
public start = (
	nil = startNanos ifFalse: [^self (* Already running. *)].
	startNanos:: currentMonotonicNanos.
)
public stop = (
	nil = startNanos ifTrue: [^self (* Already stopped. *)].
	cumulativeNanos:: cumulativeNanos + (currentMonotonicNanos - startNanos).
	startNanos:: nil.
)
) : (
)
public class String _cannotInstantiate = () (
public , other <String> ^<String> = (
	(* :literalmessage: primitive: 115 *)
	^(ArgumentError value: other) signal
)
public = other <Object> ^<Boolean> = (
	(* :literalmessage: primitive: 114 *)
	halt.
)
public asString ^<String> = (
	^self
)
public asSymbol ^<String> = (
	(isCanonical: self) ifTrue: [^self].
	^intern: self.
)
public at: index <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 51 *)
	^(ArgumentError value: index) signal
)
public copyByteArrayFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :literalmessage: primitive: 50 *)
	^ArgumentError new signal
)
public copyFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :literalmessage: primitive: 121 *)
	^ArgumentError new signal
)
public copyStringFrom: start <Integer> to: stop <Integer> ^<String> = (
	(* :literalmessage: primitive: 121 *)
	^ArgumentError new signal
)
public do: action <[:Integer]> = (
	1 to: self size do: [:index <Integer> | action value: (self at: index)].
)
public endsWith: suffix <ByteArray | String> ^<Boolean> = (
	(* :literalmessage: primitive: 118 *)
	^(ArgumentError value: suffix) signal
)
public first ^<Integer> = (
	^self at: 1
)
public hash ^<Integer> = (
	(* :literalmessage: primitive: 54 *)
	halt.
)
public indexOf: substring <ByteArray | String> ^<Integer> = (
	^self indexOf: substring startingAt: 1
)
public indexOf: substring <ByteArray | String> startingAt: index <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 119 *)
	^ArgumentError new signal
)
public isEmpty ^<Boolean> = (
	^0 = self size
)
public isKindOfString ^<Boolean> = (
	^true
)
public last ^<Integer> = (
	^self at: self size
)
public lastIndexOf: substring <ByteArray | String> ^<Integer> = (
	^self lastIndexOf: substring startingAt: 1 + self size
)
public lastIndexOf: substring <ByteArray | String> startingAt: index <Integer> ^<Integer> = (
	(* :literalmessage: primitive: 120 *)
	^ArgumentError new signal
)
public out = (
	print: self.
)
public printString ^<String> = (
	^'''', self, ''''
)
public runeAt: index = (
	(* :bogus: *)
	^self at: index
)
public size ^<Integer> = (
	(* :literalmessage: primitive: 53 *)
	halt.
)
public startsWith: prefix <ByteArray | String> ^<Boolean> = (
	(* :literalmessage: primitive: 117 *)
	^(ArgumentError value: prefix) signal
)
) : (
public cr ^ <Instance> = (
  ^with: 13
)
public crlf ^ <Instance> = (
  ^withAll: {13. 10}
)
public fromRune: rune = (
	(* :bogus: *)
	^self with: rune
)
public fromRunes: runes = (
	(* :bogus: *)
	^self withAll: runes
)
public lf ^ <Instance> = (
  ^with: 10
)
public newline ^ <Instance> = (
  ^lf
)
public with: byte <Integer> ^<String> = (
	(* :literalmessage: primitive: 123 *)
	^(ArgumentError value: byte) signal
)
public withAll: bytes <Collection[Integer] | ByteArray | String> ^<String> = (
	(* :literalmessage: primitive: 124 *)
	^self withAllAgain: (ByteArray withAll: bytes)
)
private withAllAgain: bytes <ByteArray> ^<String> = (
	(* :literalmessage: primitive: 124 *)
	halt
)
)
public class StringBuilder new: capacity <Integer> = (|
protected size_ ::= 0.
protected data ::= ByteArray new: capacity.
|) (
public add: bytes <ByteArray | String> = (
	|
	capacity = data size.
	newSize = size_ + bytes size.
	|
	newSize > capacity ifTrue:
		[data:: data copyWithSize: ((capacity >> 1 + capacity) max: newSize)].
	data replaceFrom: 1 + size_ to: newSize with: bytes startingAt: 1.
	size_:: newSize.
	^bytes
)
public addByte: byte <Integer> = (
	|
	capacity = data size.
	newSize = size_ + 1.
	|
	newSize > capacity ifTrue:
		[data:: data copyWithSize: (capacity >> 1 + capacity bitOr: 7)].
	data at: newSize put: byte.
	size_:: newSize.
	^byte
)
public asByteArray ^<ByteArray> = (
	^data copyFrom: 1 to: size_
)
public asString ^<String> = (
	^data copyStringFrom: 1 to: size_
)
public isEmpty ^<Boolean> = (
	^0 = size_
)
public isKindOfStringBuilder ^<Boolean> = (
	^true
)
public size ^<Integer> = (
	^size_
)
public writeln: line = (
	self add: line.
	self addByte: 10. (* Line-feed *)
)
) : (
public new ^<StringBuilder> = (
	^self new: 8
)
)
public class True _cannotInstantiate = Boolean () (
public & alternative <Boolean> ^<Boolean> = (
	(* Evaluating conjunction. *)
	^alternative
)
public and: alternative <[Boolean]> ^<Boolean> = (
	(* Non-evaluating conjunction. *)
	^alternative value
)
public asString ^<String> = (
	^'true'
)
public ifFalse: else <[Y def]> ^<nil | Y> = (
	^nil
)
public ifFalse: else <[Y def]> ifTrue: then <[X def]> ^<X | Y> = (
	^then value
)
public ifTrue: then <[X def]> ^<X | nil> = (
	^then value
)
public ifTrue: then <[X def]> ifFalse: else <[Y def]> ^<X | Y> = (
	^then value
)
public not ^<Boolean> = (
	^false
)
public or: alternative <[Boolean]> ^<Boolean> = (
	(* Non-evaluating disjunction. *)
	^true
)
public printString ^<String> = (
	^'true'
)
public | alternative <Boolean> ^<Boolean> = (
	(* Evaluating disjunction. *)
	^true
)
) : (
)
public class UndefinedObject _cannotInstantiate = () (
public isNil ^<Boolean> = (
	^true
)
public printString ^<String> = (
	^'nil'
)
) : (
)
public class WeakArray _cannotInstantiate = Collection () (
public at: index <Integer> ^<E> = (
	(* :literalmessage: primitive: 43 *)
	^(ArgumentError value: index) signal
)
public at: index <Integer> put: value <E> ^<E> = (
	(* :literalmessage: primitive: 44 *)
	^(ArgumentError value: index) signal
)
public copyWith: newElement <E> ^<WeakArray[E]> = (
	|
	newArray = WeakArray new: 1 + self size.
	|
	1 to: self size do:
		[:index | newArray at: index put: (self at: index)].
	newArray at: newArray size put: newElement.
	^newArray
)
public do: action <[:E]> = (
	1 to: self size do: [:index <Integer> | action value: (self at: index)].
)
public isEmpty ^<Boolean> = (
	^0 = self size
)
public size ^<Integer> = (
	(* :literalmessage: primitive: 45 *)
	halt.
)
) : (
public new: size <Integer> ^<WeakArray[E]> = (
	(* :literalmessage: primitive: 42 *)
	^(ArgumentError value: size) signal
)
)
public class WeakMap = (|
private table ::= Array new: 256. (* A fairly large initial capacity because the expected usage is one per module. *)
private used ::= 0.
|) (
public at: key <K> ^<V> = (
	| mask index entry |
	nil = key ifTrue: [^nil].
	mask:: table size - 1.
	index:: 1 + ((identityHashOf: key) bitAnd: mask).
	entry:: table at: index.
	[nil = entry] whileFalse:
		[(is: entry key identicalTo: key) ifTrue:
			[^entry value].
		index:: 1 + (index bitAnd: mask).
		entry:: table at: index].
	^nil
)
public at: key <K> put: value <V> ^<V> = (
	| mask index entry |
	nil = key ifTrue: [^invalidKey].

	mask:: table size - 1.
	index:: 1 + ((identityHashOf: key) bitAnd: mask).
	entry:: table at: index.

	[nil = entry] whileFalse:
		[(is: entry key identicalTo: key) ifTrue:
			[(* Update existing entry. *)
			entry value: value.
			^value].
		nil = entry key ifTrue:
			[(* Reuse collected entry. *)
			entry key: key.
			entry value: value.
			^value].
		index:: 1 + (index bitAnd: mask).
		entry:: table at: index].

	(* Create new entry. *)
	entry:: Ephemeron new.
	entry key: key.
	entry value: value.
	table at: index put: entry.
	used:: 1 + used.

	(* If >75% full. *)
	used > ((table size >> 2) * 3) ifTrue: [maybeGrow].

	^value
)
public isKindOfWeakMap ^<Boolean> = (
	^true
)
private maybeGrow = (
	| oldTable dead ::= 0. newCapacity newTable mask newUsed ::= 0. |
	oldTable:: table.
	(* Count the number of GC'd entries. If less than half of the table entries are still used, we'll rehash without growing. *)
	1 to: oldTable size do:
		[:index |
		| entry = oldTable at: index. |
		nil = entry ifFalse:
			[nil = entry key ifTrue: [dead:: 1 + dead]]].

	newCapacity:: oldTable size.
	(used - dead) > (newCapacity >> 1) ifTrue:
		[newCapacity:: newCapacity << 1].

	(* ('Rehashing weak map to ', newCapacity printString) out. *)

	newTable:: Array new: newCapacity.
	mask:: newCapacity - 1.

	(* Count live entries as we rehash instead of using (used - dead) because more entries may become dead due to a GC in the middle of rehashing. *)
	1 to: oldTable size do:
		[:oldIndex |
		| entry = oldTable at: oldIndex. |
		nil = entry ifFalse:
			[nil = entry key ifFalse: [
				| newIndex ::= 1 + ((identityHashOf: entry key) bitAnd: mask). |
				[nil = (newTable at: newIndex)] whileFalse:
					[newIndex:: 1 + (newIndex bitAnd: mask)].
				newTable at: newIndex put: entry.
				newUsed:: 1 + newUsed]]].

	table:: newTable.
	used:: newUsed.
)
) : (
)
public class _Array _cannotInstantiate = Collection () (
public , collection = (
	|
	newArray = Array new: self size + collection size.
	offset = self size.
	|
	newArray replaceFrom: 1 to: self size with: self startingAt: 1.
	1 to: collection size do:
		[:index | newArray at: index + offset put: (collection at: index)].
	^newArray
)
public asArray ^<Array[E]> = (
	^self
)
public at: index <Integer> ^<E> = (
	(* :literalmessage: primitive: 39 *)
	^(ArgumentError value: index) signal
)
public at: index <Integer> put: value <E> ^<E> = (
	(* :literalmessage: primitive: 40 *)
	^(ArgumentError value: index) signal
)
public collect: transform <[:E | F]> ^<Array[F]> = (
	| results = Array new: size. |
	1 to: size do:
		[:index |
		results at: index put: (transform value: (self at: index))].
	^results
)
public copy ^<Array[E]> = (
	| newArray = Array new: self size. |
	newArray replaceFrom: 1 to: self size with: self startingAt: 1.
	^newArray
)
public copyFrom: start <integer> to: stop <Integer> ^ <Array[E]> = (
  | cp <Array[E]> |
  cp:: Array new: (stop - start) + 1.
  1 to: cp size do: [:i <Integer> | cp at: i put: (self at: i + start -1)].
  ^cp
)
public copyWith: newElement <E> ^<Array[E]> = (
	|
	newArray = Array new: 1 + self size.
	|
	newArray replaceFrom: 1 to: self size with: self startingAt: 1.
	newArray at: newArray size put: newElement.
	^newArray
)
public copyWithSize: newSize <Integer> ^<Array[E]> = (
	|
	newArray = Array new: newSize.
	overlap = size < newSize ifTrue: [size] ifFalse: [newSize].
	|
	^newArray replaceFrom: 1 to: overlap with: self startingAt: 1
)
public do: action <[:E]> = (
	1 to: self size do: [:index | action value: (self at: index)].
)
public first ^<E> = (
	^self at: 1
)
public indexOf: element <E> ^<Integer> = (
	1 to: self size do: [:index | (self at: index) = element ifTrue: [^index]].
	^0
)
public isEmpty ^<Boolean> = (
	^0 = self size
)
public isKindOfArray ^<Boolean> = (
	^true
)
public keysAndValuesDo: action <[:Integer :E]> = (
	1 to: self size do: [:index | action value: index value: (self at: index)].
)
public last ^<E> = (
	^self at: self size
)
private merge: source into: destination start: start mid: mid stop: stop by: lessOrEqual = (
	| leftCursor rightCursor |
	leftCursor:: start.
	rightCursor:: 1 + mid.
	start to: stop do:
		[:destCursor |
		 leftCursor <= mid ifFalse:
			[^destination replaceFrom: destCursor to: stop with: source startingAt: rightCursor].
		 rightCursor <= stop ifFalse:
			[^destination replaceFrom: destCursor to: stop with: source startingAt: leftCursor].
		 (lessOrEqual value: (source at: leftCursor) value: (source at: rightCursor))
			ifTrue:
				[destination at: destCursor put: (source at: leftCursor).
				 leftCursor:: 1 + leftCursor]
			ifFalse:
				[destination at: destCursor put: (source at: rightCursor).
				 rightCursor:: 1 + rightCursor]].
)
public replaceFrom: start <Integer> to: stop <Integer> with: replacement <Array> startingAt: replacementStart <Integer> = (
	(* :literalmessage: primitive: 80 *)
	^ArgumentError new signal
)
public size ^<Integer> = (
	(* :literalmessage: primitive: 41 *)
	primitiveFailed
)
public sort: lessOrEqual <[:E :E | Boolean]> = (
	self sortFrom: 1 to: self size by: lessOrEqual.
)
private sort: source into: destination from: start to: stop by: lessOrEqual = (
	| mid |
	start >= stop ifTrue: [^self].
	mid:: (start + stop) // 2.
	self sort: destination into: source from: start to: mid by: lessOrEqual.
	self sort: destination into: source from: 1 + mid to: stop by: lessOrEqual.
	self merge: source into: destination start: start mid: mid stop: stop by: lessOrEqual.
)
public sortFrom: start to: stop by: lessOrEqual <[:E :E | Boolean]> = (
	self sort: (self copyWithSize: stop - start + 1) into: self from: start to: stop by: lessOrEqual.
)
) : (
public new: size <Integer> ^<Array[E]> = (
	(* :literalmessage: primitive: 38 *)
	^(ArgumentError value: size) signal
)
public withAll: collection <Collection[E]> ^<Array[E]> = (
	| result index |
	result:: Array new: collection size.
	index:: 1.
	collection do: [:element <E> | result at: index put: element. index:: 1 + index].
	^result
)
)
public class _Object = (
(* Object is the root of the class hierarchy in the Newspeak programming language, and provides behavior common to all objects.

Unlike other systems inspired by Smalltalk, the number of methods in this class is deliberately kept to a minimum. Behavior should only be provided by this class if it should be considered part of the core set of features available to *all* Newspeak programmers.

The security model of the Newspeak programming language is based on capabilities and it is essential that capabilities cannot leak through behavior provided by this class. For example, this class provides no mechanism for accessing instance variables of its instances. Instead such capabilities are provided to the debugger and other tools through mirror based reflection modules.

Object has no instance variables, nor should any be added. Several subclasses of Object have special implementations and the VM on relies on their layout. Adding slots to Object would be fatal.

This class is currently named _Object to break a cycle in the class hierarchy that occurs during the bootstrap from the Squeak implementation. Its superclass is later fixed to nil by magic. *)
) (
public = other <Object> ^<Boolean> = (
	(* Answers whether the receiver is considered equal to 'other'.
	May be overridden by subclasses, and should be overridden if the method 'hash' is overridden.
	This method must implement an equivalence relation, that is, the following must hold:
	* x = x evaluates to true
	* if x = y evaluates to true then y = x must evaluate to true
	* if x = y evaluates to true and y = z evaluates to true then x = z must evaluate to true.
	Furthermore, this method must be consistent with the implementation of hash, that is:
	* if x = y evaluates to true then x hash = y hash must evaluate to true. *)

	(* :literalmessage: primitive: 86 *)
	halt.
)
public == other <Object> ^<Boolean> = (
	(* Answers whether the receiver is considered identical to 'other'.
	May not be overridden by subclasses. *)

	(* :literalmessage: primitive: 86 *)
	halt.
)
protected Array = (
	(* bogus: Should return an object that is not a class so it cannot be subclassed or mixed-in. *)
	^outer KernelForPrimordialSoup _Array
)
protected ByteArray = (
	(* bogus: Should return an object that is not a class so it cannot be subclassed or mixed-in. *)
	^outer KernelForPrimordialSoup ByteArray
)
protected Error = (
	(* squeak compatibility *)
	^outer KernelForPrimordialSoup Exception
)
protected Exception = (
	^outer KernelForPrimordialSoup Exception
)
protected Float = (
	(* bogus: Should return an object that is not a class so it cannot be subclassed or mixed-in. *)
	^outer KernelForPrimordialSoup Float
)
protected Integer = (
	(* bogus: Should return an object that is not a class so it cannot be subclassed or mixed-in. *)
	^outer KernelForPrimordialSoup Integer
)
protected Object = (
	^outer KernelForPrimordialSoup _Object
)
protected String = (
	(* bogus: Should return an object that is not a class so it cannot be subclassed or mixed-in. *)
	^outer KernelForPrimordialSoup String
)
protected assert: blockOrBoolean message: message = (
	#BOGUS.
	blockOrBoolean isKindOfClosure
		ifTrue: [blockOrBoolean value ifFalse: [Exception new signal: message]]
		ifFalse: [blockOrBoolean ifFalse: [Exception new signal: message]].
)
protected class ^<Behavior> = (
	(* Answers the class of the receiver.

	This method is not public to make it easier to separate the authority of an instance from the authority of its class. This is similar to how the flatness of the metaclass heirarchy separates the interface of an object from the interface of its class. *)

	(* :literalmessage: primitive: 85 *)
	halt.
)
protected doesNotUnderstand: message <Message> = (
	(0 = message arguments size and: [message selector startsWith: 'isKindOf']) ifTrue: [^false].

	^(MessageNotUnderstood receiver: self message: message) signal
)
protected halt = (
	(* :literalmessage: primitive: 103 *)
)
public hash ^<Integer> = (
	(* Answers the hash code for the receiver.
	May be overridden by subclasses, and should be overridden if the method '=' is overridden.
	The hash code must obey the requirements set forth in the method '=', that is, the following must hold:
	* if x = y evaluates to true then x hash = y hash must evaluate to true. *)

	(* :literalmessage: primitive: 87 *)
	halt.
)
public identityHash ^<Integer> = (
	(* Answers the hash code for the receiver.
	May not be overridden by subclasses. *)

	(* :literalmessage: primitive: 87 *)
	halt.
)
public isNil ^<Boolean> = (
	^false
)
public out = (
	print:: self printString.
)
public printString ^<String> = (
	(* bogus: should not rely on class not being overridden *)
	^'instance of ', class name
)
public yourself = (
	^self
)
public ~= other <Object> ^<Boolean> = (
	^(self = other) not.
)
) : (
)
public buildObjectStoreWithApplication: app platform: platform symbols: symbols = (
	symbolTable:: symbols.
	messageLoop:: platform actors buildLoopForApplication: app platform: platform.
	^{
		nil.
		false.
		true.
		messageLoop.
		{#+. 1. #-. 1. #<. 1. #>. 1. #<=. 1. #>=. 1. #=. 1. #~=. 1. #*. 1. #/. 1. #\\. 1. #@. 1. #bitShift:. 1. #//. 1. #bitAnd:. 1. #bitOr:. 1. #at:. 1. #at:put:. 2. #size. 0. #next. 0. #nextPut:. 1. #atEnd. 0. #==. 1. #class. 0. #blockCopy:. 1. #value. 0. #value:. 1. #do:. 1. #new. 0. #new:. 1. #x. 0. #y. 0}.
		#doesNotUnderstand:.
		#nonBooleanReceiver:.
		#cannotReturn:.
		#aboutToReturn:through:.
		#unusedBytecode.
		#dispatchMessage:port:.
		#dispatchHandle:status:signals:count:.
		_Array.
		ByteArray.
		String.
		Closure.
		Ephemeron.
		Float.
		LargeInteger.
		MediumInteger.
		Message.
		SmallInteger.
		WeakArray.
		Activation.
		Method.
	}
)
private classOf: object = (
	(* :literalmessage: primitive: 85 *)
	halt.
)
private currentActivation ^<Activation> = (
	(* :literalmessage: primitive: 133 *)
	halt.
)
private currentMonotonicNanos = (
	(* :literalmessage: primitive: 100 *)
	halt.
)
private definingActivationOf: closure <Closure> ^<Activation> = (
	(* :literalmessage: primitive: 71 *)
	halt.
)
private enclosingObjectOf: behavior = (
	^self slotOf: behavior at: 3
)
private enclosingObjectOf: behavior put: value = (
	^self slotOf: behavior at: 3 put: value
)
private formatOf: behavior = (
	^self slotOf: behavior at: 6
)
private formatOf: behavior put: value = (
	^self slotOf: behavior at: 6 put: value
)
public garbageCollect = (
	(* :literalmessage: primitive: 105 *)
	halt.
)
private identityHashOf: a = (
	(* :literalmessage: primitive: 87 *)
	halt.
)
private instantiate: klass = (
	(* :literalmessage: primitive: 34 *)
	halt.
)
private intern: string = (
	| table capacity index reuseIndex symbol |
	nil = symbolTableUsed ifTrue:
		[(* Snapshot starts with a compact array. A hash table would need to be rehashed anyway because every process has a random hash function. *)
		 symbolTableUsed:: symbolTable size.
		 rehashSymbolTable].

	table:: symbolTable.
	capacity:: table size.
	index:: (string hash \\ capacity) + 1.
	[symbol:: table at: index.
	 table = symbol] whileFalse:
		[string = symbol ifTrue: [^symbol].
		 nil = symbol ifTrue: [reuseIndex:: index].
		 index:: (index \\ capacity) + 1].

	setCanonical: string.
	nil = reuseIndex ifFalse: [^table at: reuseIndex put: string].

	table at: index put: string.
	symbolTableUsed:: symbolTableUsed + 1.
	(symbolTableUsed * 4) > (capacity * 3) ifTrue:
		[rehashSymbolTable].
	^string
)
private is: a identicalTo: b = (
	(* :literalmessage: primitive: 86 *)
	halt.
)
private isCanonical: object = (
	(* :literalmessage: primitive: 126 *)
	halt.
)
private methodsOf: behavior = (
	^self slotOf: behavior at: 2
)
private methodsOf: behavior put: value = (
	^self slotOf: behavior at: 2 put: value
)
private mixinOf: behavior = (
	^self slotOf: behavior at: 4
)
private mixinOf: behavior put: value = (
	^self slotOf: behavior at: 4 put: value
)
private nameOf: klass = (
	^self slotOf: klass at: 7
)
private nameOf: klass put: value = (
	^self slotOf: klass at: 7 put: value
)
private object: rcvr perform: sel with: arguments = (
	(* :literalmessage: primitive: 89 *)
	halt.
)
print: message = (
	(* :literalmessage: primitive: 102 *)
)
private rehashSymbolTable = (
	| oldTable dead ::= 0. newCapacity newTable newUsed ::= 0. |
	oldTable:: symbolTable.
	(* Count the number of GC'd entries. If less than half of the table entries are still used, we'll rehash without growing. *)
	1 to: oldTable size do: [:index | nil = (oldTable at: index) ifTrue: [dead:: 1 + dead]].
	newCapacity:: oldTable size.
	(symbolTableUsed - dead) > (newCapacity >> 1) ifTrue:
		[newCapacity:: newCapacity << 1].

	(* ('Rehashing symbol table to ', newCapacity printString) out. *)

	newTable:: WeakArray new: newCapacity.
	1 to: newTable size do: [:index | newTable at: index put: newTable].

	(* Count live entries as we rehash instead of using (used - dead) because more entries may become dead due to a GC in the middle of rehashing. *)
	1 to: oldTable size do:
		[:oldIndex | | symbol newIndex |
		symbol:: oldTable at: oldIndex.
		nil = symbol ifFalse:
			[oldTable = symbol ifFalse:
				[newUsed:: 1 + newUsed.
				 newIndex:: (symbol hash \\ newCapacity) + 1.
				 [newTable = (newTable at: newIndex)] whileFalse:
					[newIndex:: (newIndex \\ newCapacity) + 1].
				 newTable at: newIndex put: symbol]]].

	symbolTable:: newTable.
	symbolTableUsed:: newUsed.
)
private setCanonical: object = (
	(* :literalmessage: primitive: 127 *)
	halt.
)
private slotOf: object at: index = (
	(* :literalmessage: primitive: 35 *)
	halt.
)
private slotOf: object at: index put: value = (
	(* :literalmessage: primitive: 36 *)
	halt.
)
private subclassesOf: klass = (
	^self slotOf: klass at: 8
)
private subclassesOf: klass put: value = (
	^self slotOf: klass at: 8 put: value
)
private superclassOf: behavior = (
	^self slotOf: behavior at: 1
)
private superclassOf: behavior put: value = (
	^self slotOf: behavior at: 1 put: value
)
private thisClassOf: metaclass = (
	^self slotOf: metaclass at: 7
)
private thisClassOf: metaclass put: value = (
	^self slotOf: metaclass at: 7 put: value
)
) : (
)
