Newspeak3
'Root'
class Browsing usingPlatform: p ide: webIde
(* :exemplar: ide browsing *)
= (
(* An IDE for Newspeak on the web.
    Copyright 2016-2017 Google Inc.
    Copyright 2018-2022 Gilad Bracha.
*)
|	(* imports *)
    StringBuilder = p kernel StringBuilder.
    Subject = p hopscotch Subject.
    Presenter = p hopscotch Presenter.	
    SearchFieldFragment = p hopscotch fragments SearchFieldFragment.
    Window = p hopscotch Window.
    Color = p graphics Color.
    Gradient = p hopscotch Gradient.
    List = p collections List.
    Map = p collections Map.
    Set = p collections Set.   
    OrderedMap = [p collections OrderedMap] on: Error do: [:e | Map].
    Exception = p kernel Exception.
    Proxy = p kernel Proxy.
    ActivationMirror = p mirrors ActivationMirror.
    ClassMirror = p mirrors ClassMirror.
    ObjectMirror = p mirrors ObjectMirror.
    ClosureMirror = p mirrors ClosureMirror.    
    Message = p kernel Message.
    ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
    Snapshotter = p operatingSystem = 'emscripten' ifTrue: [p victoryFuel Snapshotter].
    JSObject = p js global at: 'Object'.
    JSArray = p js global at: 'Array'.
    JSMath = p js global at: 'Math'.
    JSPromise = p js global at: 'Promise'.
    Date = p js global at: 'Date'.
    (* module variables *)
    body = (p js global at: 'document') at: 'body'.
    localStorage = (p js global at: 'window') at: 'localStorage'.
    atomicInstaller = p mirrors installer.
    compiler = p mirrors compiler.
    cachedPlatform = p.
    ide = webIde.
    detailAreaRatio = 3 asFloat.
    captionColor = Color h: 240 s: 0.05 asFloat v: 0.9 asFloat.
    cssConverter = cssConversionTable.
    objectViews <Map[Symbol, List[Presenter]]> = OrderedMap new.
    currentWindow<IDEWindow>
    nonExemplarClasses <Set[Symbol]> = Set withAll: {#Number. #Class}.

    (* Style *)    
	styleHeaderPadRight <Float> = 0.0.
    styleButtonSize <Float> = 30.

|

p hopscotch homeSubjectClass: HomeSubject.
initializeObjectViews.
) (
public class AssortedMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* The subject is a collection of MethodSubjects that can come from diverse sources (in the sense that they do not have to belong to the same class). The presenter displays them as a column of expandable method presenters and takes care of reasonably handling the various creation and deletion requests coming from them.   *)
|
	public title ::= 'Assorted Methods'. (* The title to use for the presenter *)
	methodPresenters <List[ExpandableMethodPresenter]> ::= List new.
|) (
addButton = (
  ^nothing
)
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	shouldNotImplement
)
definitionListMenu = (
  	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
public isKindOfAssortedMethodsPresenter ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfAssortedMethodsPresenter
)
listDescription ^ <String> = (
  ^'assorted methods'
)
contentPresenters ^ <List[MethodPresenter]> = (
    | 
    methods <List[MethodSubject]> =  subject elements sort: [
      :m1 <MethodSubject> :m2 <MethodSubject> |
      lexicallyLessOrEqual: m1 name than: m2  name
    ]. 
    | 
	^methods collect: [:each | (each presenter) showClassName: true]
)
elementDescription ^ <String> = (
  ^'methods grouped by some criteria'
)
) : (
)
public class AssortedMethodsSubject onModel: m  <Collection[MethodSubject]> = ProgrammingSubject onModel: m (
  |
  public title ::= 'Assorted Methods'.
  elements_slot <Collection[MethodSubject | LazySlotSubject ]>
  |
) (
public createPresenter = (
	^(AssortedMethodsPresenter onSubject: self) title: title
)
public isKindOfAssortedMethodsSubject ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfAssortedMethodsSubject
)
public methodTemplateText ^ <String> = (
^
'messageSelector = (
)'
)
public methodSubjects ^ <Collection[MethodSubject]> = (
	^model
)
public elements ^<Collection[MethodSubject]> = (
	(* Answer a collection of subjects on individual elements of the collection which is our subject. *)
    elements_slot isNil ifTrue: [
	 elements_slot::  methodSubjects.
     ^elements_slot
     ].
   updateElements.
   ^elements_slot
)
updateElements = (
  |
  obsoleteSubjects <List[MethodSubject]> = List new.
  |
  elements_slot do: [:s <MethodSubject> |
    (methodSubjects includes: s) ifFalse: [obsoleteSubjects add: s].
  ].
  obsoleteSubjects do: [:s <MethodSubject> | elements_slot remove: s].
  methodSubjects do: [:m <MethodSubject> |
    (elements_slot includes: m) ifFalse: [
      elements_slot add: m
      ].
  ].
)
) : (
)
class BasicView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public isKindOfBasicView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfBasicView
)
public title = (
	^'Basic'
)
public definition = (
	^column: {slots. lazySlots}
)
lazySlots = (
    | lss = subject lazySlots. |
    
    lss isEmpty ifTrue: [^nothing].
	^minorHeadingBlock: (column: {
          (label: 'Lazy Slots') bold.
          column:
		    (lss collect:
		    	[:slot <SlotSubject> | slot presenter])
            }
     )
)
slots = (
    | ss = subject slots. |
    
    ss isEmpty ifTrue: [^nothing].    
	^minorHeadingBlock: (column: {
          (label: #Slots) bold.
          column:
		    (ss collect:
		    	[:slot <SlotSubject> | slot presenter])
            }
     )
)
) : (
)
public class BitOfWisdom text: s <String> actionLabel: l <String> actionBlock: b <[]> image: i = (|
	public text <String> = s.
	public image <Image> = i.
	public actionLabel <String> = l.
	public actionBlock <[]> = b.
|) (
) : (
public text: s <String> ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: nil
)
public text: s <String> actionLabel: l <String> actionBlock: b <[]> ^ <BitOfWisdom> = (
	^self
		text: s
		actionLabel: l
		actionBlock: b
		image: nil
)
public text: s image: i ^ <BitOfWisdom> = (        
	^text: s 
        actionLabel: nil 
        actionBlock: nil 
        image: i
)
)
class ClassActionsPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public isKindOfClassActionsPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassActionsPresenter
)
deployAsWebPageWithMirrorBuilders = (
#BOGUS yourself.
 (ide deployment jsPackagerForPlatform: cachedPlatform)
		packageApplicationConfiguration: (ide namespacing Root at: subject name)
		withRuntimeConfiguration: ide deployment RuntimeWithMirrorBuilders
		usingNamespace: ide namespacing Root.
)
deployAsWebPage = (
#BOGUS yourself.
 (ide deployment jsPackagerForPlatform: cachedPlatform)
		packageApplicationConfiguration: (ide namespacing Root at: subject name)
		withRuntimeConfiguration: ide deployment Runtime
		usingNamespace: ide namespacing Root.
)
definition = (
	^(row: {
        testActions.
        mediumBlank.
        deployAction.
        mediumBlank.
        editDeploymentsAction.
        mediumBlank.
        runAppAction.
        })
		mainAxisAlignToEnd.
)
deployAsVictoryFuel = (
	| bytes = subject bytesForVictoryFuel. |
  	ide webFiles downloadFileName: subject name, '.vfuel' fromBytes: bytes.
)
deployAsVictoryFuelWithMirrors = (
      | bytes = subject bytesForVictoryFuelWithMirrors. |
  	ide webFiles downloadFileName: subject name, '.vfuel' fromBytes: bytes.
)
future_deployAction = (
(* Eventually, we'll use the deployment manager for deployment.
    At that point, this method will replace the current #deployAction
    implementation. Alas, this will take a while, as we need to implement
    a general strategy for reconstituting serialized aliens for this to work.
*)
	subject isApplicationConfiguration ifFalse: [^nothing].
	^link: '[deploy]' action: [
			openMenu:: menuWithLabelsAndActions: (
               ide deployment configurations collect: [:dc <DeploymentConfiguration> |
                   {'to ', dc name. 
                   [ide deployment deploy: (ide namespacing Root at: subject name) on: dc]}]
			)
		]
)
respondToRunApp: paused = (
	(* bogus: The subject might not be in the root namespace. *)
	| appConfig manifest platform args thread |
	appConfig:: ide namespacing Root at: subject name.
	manifest:: ide namespacing manifest.
	platform:: cachedPlatform.
	args:: {}.
	thread:: platform mirrors ActivationMirror invokeSuspended:
		[(appConfig packageUsing: manifest) main: AppPlatform new args: args].
	paused ifFalse: [thread resume].
	thread isFulfilled ifFalse:
		[enterSubject:: ide debugging ThreadSubject onModel: thread].
)
respondToRunTests = (
	| thread |
	thread:: cachedPlatform mirrors ActivationMirror invokeSuspended:
		[enterSubject:: subject testingSubject].
    thread resume.
	thread isFulfilled 
       ifFalse:
		[enterSubject:: ide debugging ThreadSubject onModel: thread].
)
respondToShowTests = (
	| thread |
	thread:: cachedPlatform mirrors ActivationMirror invokeSuspended:
		[enterSubject:: subject inactiveTestingSubject].
    thread resume.
	thread isFulfilled 
       ifFalse:
		[enterSubject:: ide debugging ThreadSubject onModel: thread].
)
public testActions = (
	subject isTestConfiguration ifFalse: [^nothing].
	^row: {
		link: '[run tests]' action: [respondToRunTests]. 
		link: '[show tests]' action: [respondToShowTests]}.
)
public runAppAction = (
	subject isApplicationConfiguration ifFalse: [^nothing].
    ^row: {
			link: '[run]' action: [respondToRunApp: false].
			link: '[debug]' action: [respondToRunApp: true].
		}
)
public editDeploymentsAction = (
| DeploymentConfigurationSubject = ide deployment DeploymentConfigurationSubject. |
	subject isApplicationConfiguration ifFalse: [^nothing].
	^link: '[configurations]' action: [
			openMenu:: menuWithLabelsAndActions:
               ((ide deployment configurations) collect: [:dc <DeploymentConfiguration> |
                   {dc name. [enterSubject:: DeploymentConfigurationSubject onModel: dc]}]), 
                {{'Create New Deployment'. [enterSubject:: DeploymentConfigurationSubject onModel: ide deployment defaultConfiguration]}}
		]
)
public deployAction = (
	subject isApplicationConfiguration ifFalse: [^nothing].
	^(link: '[deploy]' action: [
			openMenu:: menuWithLabelsAndActions: {
				{'as VictoryFuel'. [deployAsVictoryFuel]}.
				{'as VictoryFuel with Mirrors'. [deployAsVictoryFuelWithMirrors]}.				
				{'as Web Page'. [deployAsWebPage]}.
				{'as Web Page with Mirror Builders'. [deployAsWebPageWithMirrorBuilders]}.
			}
		]).
)
) : (
)
class ClassEntryPresenter onSubject: s <ClassSubject> = EntryPresenter onSubject: s () (
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
entryActionsMenu = (
	^nothing
)
expandedDefinition = (
	^subject presenter
)
public tag ^ <String> = (
  ^subject name
)
public isKindOfClassEntryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassEntryPresenter
)
collapsedDefinition = (
	^row1: {
        defaultBlank.
		(image: ide images classIcon)
            height: styleButtonSize.
        defaultBlank.
		accessIndicator.
        defaultBlank.
		link: subject name action: [enterSubject:: ClassSubject onDeclaration: subject classMirror].
	} row2: {
		(row: {deferred: [(label: subject classCommentSummary)
			smallFont;
			color: secondaryTextColor]})
				compressibility: 1.
		filler
			compressibility: 0.

		(ClassActionsPresenter onSubject: subject) elasticity: 1.
		mediumBlank.
		entryActionsMenu.
	}
)
) : (
)
class ClassFactoryPresenter onSubject: s <ClassFactorySubject> = MethodPresenter onSubject: s (
(* Present the factory method, colorized. *)
 | toggle <ToggleComposer>  public showClassName <Boolean> ::= false. |
) (
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
	 ]
)
colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeHeader: s fromClass: subject classMirror via: (colorizingBlockFor: cm)
)
definition = (
	toggle:: collapsed: [collapsedDefinition]
			 expanded: [expandedDefinition].
	^toggle
)
public isKindOfClassFactoryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassFactoryPresenter
)
nestingInformationLine ^ <Fragment> = (
	| enclosingClasses rowElements |
	enclosingClasses:: subject enclosingClasses.
	rowElements:: List new.
	enclosingClasses do:
		[:each |
		rowElements add: ((label: ' in ') color: tertiaryTextColor).
		rowElements add: (linkToBrowseEnclosingClass: each)].
	^row: rowElements asArray
)
editorDefinition = (
	| 
	src = crToLf: subject classHeaderSource. 
	editor = codeMirror: src. 
	|
	editor 
		changeResponse: changeResponse;
        cancelResponse: cancelResponse;
		acceptResponse: acceptResponse.
	colorizeHeaderSource: src withEditor: editor.
	^editor
)
cancelResponse ^ <[:CodeMirrorFragment]> = (
	^[:ed <CodeMirrorFragment> |
        ed text: subject classHeaderSource.
		colorizeHeaderSource: (crToLf: subject classHeaderSource) withEditor: ed.
		ed leaveEditState.
	 ]
)
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <ClassDeclarationBuilder> = subject classMirror asBuilder. |
		updateGUI: [
			[b header source: ed textBeingAccepted.
			ide installFromBuilders: {b}.
			colorizeHeaderSource: (crToLf: ed textBeingAccepted)  withEditor: ed.
			ed leaveEditState] on: Error do:  [:ex <Exception> | ed showMessage: ex printString] .
		].
		ed editor focus.
	]
)
slotList ^ <Fragment> = (
  | sl |
	^column: {
           (sl:: subject classMirror instanceSide slots) size > 0
		   ifTrue: [
			column: {
				(label: 'Slots')
                    bold.
				smallBlank.
				row: {
					(column: (sl collect: [:ea <SlotDeclarationMirror> | 
						row: {
                            defaultBlank.
							accessIndicator: ea accessModifier. 
                            defaultBlank.
							label: ea name.
						}
					])) elasticity: 1.
				}
			}.
		] ifFalse: [nothing].
		}
)
collapsedDefinition ^ <Fragment> = (
  ^column: {
      helpSection.
      headerDefinition.
      label: subject classCommentSummary.
      mediumBlank.
	slotList.
	}
)
expandedDefinition = (
  ^column: {
      helpSection.
      headerDefinition.
	  editorDefinition.
	}
)
headerDefinition ^ <Fragment> = (
  ^row: {
      defaultBlank.
      accessIndicator.
      defaultBlank.
      (link: subject name action: [toggle toggle]) color: actionLinkColor.
	showClassName
			ifTrue: [nestingInformationLine]
			ifFalse: [nothing].
	filler.
    (* Disabled for now. The story is a bit more complex for factory debugging.
    deferred: [debugButton].
    smallBlank.*)
	dropDownMenu: [messagesMenu] image: ide images itemReferencesImage.
    smallBlank.
    helpButton.
    smallBlank.
	dropDownMenu: [methodMenuFor: subject name]
   }.
)
helpText = (
  | 
  mapping = Map new. 
  menuImage = Utilities uriForIconNamed: #hsDropdownImage. 
  referenceImage = Utilities uriForIconNamed: #itemReferencesImage.
  exemplarHeaderDescription = 
    hasExemplars 
      ifTrue: ['<li><div class="hopscotchDebugMethodButton"> </div> Opens a debugger on an invocation of the method, with the arguments given by the method exemplar.</li>'] ifFalse: [''].
  menuDescription = 
    hasExemplars 
      ifTrue: ['deleting the method, inspecting this presenter or opening an evaluator.'] ifFalse: ['deleting the method or inspecting this presenter.'].
  editorEvaluatorDescription = 
    hasExemplars 
      ifTrue: ['<br>The editor is also an evaluator. See it''s help section for more details.'] ifFalse: [''].
  |
  mapping 
    at: #hopscotchAccessIndicator put: accessIndicator;  
    at: #hopscotchMethodMenuButton put: (dropDownMenu: [methodMenu]);
    at: #hopscotchDebugMethodButton put: debugButton;    
    at: #hopscotchMethodReferencesButton put: (dropDownMenu: [messagesMenu] image: ide images itemReferencesImage);
    at: #hopscotchHelpButton put: helpButton.
    
  ^ampleforth: 'This is a class factory method presenter. It can be either expanded or collapsed. In the collapsed state,  the factory header is shown. 
  <br><br>From left to right, the factory header displays: 
  <ul>
  <li><div class="hopscotchAccessIndicator"></div> The factory''s access modifier. It is always green, as Newspeak primary factories are public by definition.</li>
  <li>The factory method selector.</li>', exemplarHeaderDescription, 
  '<li><div class="hopscotchMethodReferencesButton"> </div> Allows you to find senders and implementors of the factory method''s selector and of its slot accessors.</li>
  <li><div class="hopscotchHelpButton"> </div> Shows this help message.</li>
  <li><div class="hopscotchMethodMenuButton"> </div> Opens a menu of additional operations, such as ', menuDescription, '</li>
  </ul>
  Below the header we see the first sentence of the class comment, and below that a list of the classes'' slots. Each slot is prefixed by its access modifier. The color of the access modifier indicates whether the slot is public (green), protected (yellow) or private (red).
  <br><br>
  When the factory method presenter is expanded, an editor pane containing the factory source is displayed underneath the header. You can edit the source, allowing you change the factory name, the superclass clauses, and  to add, remove or modify slot declarations and any other factory code. Once the code is changed, indicators appear at the top right corner of the editor pane. You can accept the changes by pressing, or revert back to the original by pressing . You can also accept changes by pressing Cmd-return (on mac) or Ctl-return (on Linux or Windows).
  ', editorEvaluatorDescription
  mapping: mapping
)
) : (
)
class ClassFactorySubject onClassModel: m <ClassModel> = MethodSubject onMethodModel: m (
) (
public accessModifier ^ <Symbol> = (
	^#public
)
public classCommentSummary ^ <String> = (
	|
	fullComment <String> = classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
classCommentText ^<String> = (
	| comment = classMirror header classComment. |
	nil = comment ifTrue: [^''].
	^comment
)
public classDeclaration ^ <ClassDeclarationMirror> = (
  ^classMirror
)
public classHeaderSource = (
	^classMirror header source
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model klass
)
public createPresenter ^ <ClassFactoryPresenter> = (
	^ClassFactoryPresenter onSubject: self
)
public delete = (
	Error signal: 'cannot delete primary class factory'
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfClassFactorySubject
)
public messages   ^ <List[Symbol]> = (
  | result <List[Symbol]> = List new. |
  #BOGUS yourself. 
  classMirror instanceSide slots do: [:slot <SlotDeclarationMirror> |
	result add: slot name.
	slot isMutable ifTrue: [result add: slot name, ':']
	].
(*TODO: extract messages from factory. 
 *)
  ^result
)
public name ^ <Symbol> = (
 ^classMirror primaryFactorySelector
)
public isKindOfClassFactorySubject ^ <Boolean> = (
  ^true
)
public metadata ^ <Map[String, String]> = (
  ^classMirror header metadata
)
public primaryFactorySelector ^ <Symbol> = (
  ^classMirror primaryFactorySelector
)
public source ^ <String> = (
	^classHeaderSource
)
public enclosingClassScope ^ <ObjectMirror | Nil> = (
  (* Produce an object that will serve as the enclosing scope when debugging the factory live *)
  | enclosing <ObjectMirror> = enclosingScope. |
  #BOGUS.
  enclosing isNil ifTrue: [^nil].
  enclosing getClass enclosingObject reflectee isNil ifTrue: [(* return ide scope *) ^hiddenWorkspace].
  ^enclosing getClass enclosingObject 
)
public enclosingScope ^ <ObjectMirror> = (
  #BOGUS.
)
) : (
public onModel: m <ClassDeclarationMirror> = (
  ^onClassModel: (ClassModel declaration: m exemplar: nil)
)
)
class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
  |
  public lazySlotsPresenter <LazySlotGroupPresenter>  
  public nestedClassesPresenter <NestedClassGroupPresenter>
  public instanceMethodsPresenter <MethodGroupPresenter>
  public classMethodsPresenter <MethodGroupPresenter>
  classActionsPresenter <ClassActionsPresenter>
  |
) (
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event>  |
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
	  ]
)
classActionsMenu = (
	^menuWithLabelsAndActions: {
	 	{'Save to File'. [respondToSave]}.
		 #separator.
		{'Inspect Mirror'. [inspectObject: subject classMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
		#separator.
		{'Delete'. [respondToDelete]}.
	}
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
classNameAndContainmentDefinition ^ <Fragment> = (
	^column: {
		classNameAndHierarchySummary.
		preambleLine.
		label: subject classCommentSummary.
	}
)
classSourceDefinition = (
	| src = crToLf: subject classHeaderSource. editor =  codeMirror: src. |
	editor 
		changeResponse: changeResponse;
		acceptResponse: acceptResponse.
		colorizeHeaderSource: src withEditor: editor.
	^editor
)
colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeHeader: s fromClass: subject classMirror via: (colorizingBlockFor: cm)
)
expandedHeadingDefinition ^ <Fragment> = (
  ^column: {
      classNameAndHierarchySummary.
      (ClassFactorySubject onModel: subject classMirror) presenter
   }
)
headingDefinition ^ <Fragment> = (
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [classNameAndHierarchySummary].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
initializerDefinition ^ <Fragment> = (
	^nothing
)
inspectSelf ^ <Fragment> = (
	^row: {
		filler. 
		link: 'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]
	}
)
public isKindOfClassPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassPresenter
)
minorClassHeadingBlock: body = (
	^(padded: body with: {10. 5. styleHeaderPadRight. 5.})
		color: minorClassHeadingColor
)
minorClassHeadingColor = (
	^Gradient
		from: (Color h: 240 s: 0.02 v: 0.94)
		to: (Color h: 240 s: 0.02 v: 0.9)
)
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble <String> equalIndex <Integer> prefix <String> suffix <String> |
	preamble:: subject classMirror header preamble.
	equalIndex:: preamble indexOf: "=".
	equalIndex = 0
		ifTrue:
			[prefix:: preamble.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1).
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)].
	^suffix isEmpty
		ifTrue:
			[label: prefix]
		ifFalse:
			[row: {
				label: prefix, ' = '.
				link: suffix action: [respondToBrowseSuperclass]
				}]
)
respondToDelete = (
	| enclosing = subject enclosingClassSubject. |
	updateGUI: [
    	subject deleteClass.
		enclosing isNil
    		ifFalse: [enterSubject: enclosing]
        	ifTrue: [enterSubject: NamespaceSubject new]
        ]
)
respondToSave = (
	ide webFiles downloadFileName: subject name, '.ns' fromString: subject compilationUnitSource. 
)
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <ClassDeclarationBuilder> = subject classMirror asBuilder. |
		(*('ed text:', ed textBeingAccepted) out.*)
		b header source: ed textBeingAccepted.
		ide  installFromBuilders: {b}.
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed leaveEditState.
		]
)
nestedClass: cdm <ClassDeclarationMirror> = (
	^collapsed: [row: {
                    defaultBlank.
					accessIndicator.
					defaultBlank.
					link: cdm simpleName action: [enterSubject:: ClassSubject onDeclaration: cdm]
					}
				]
	expanded: [(ClassSubject onModel: cdm) presenter]
)
public definition ^ <Fragment> = (
        classActionsPresenter:: (ClassActionsPresenter onSubject: subject) elasticity: 1.
	^column: {
        helpSection.
		headingDefinition.
		lazySlotsPresenter:: subject lazySlotsSubject presenter.       
		nestedClassesPresenter:: subject nestedClassesSubject presenter.
		instanceMethodsPresenter:: subject methodsSubject presenter.
		classMethodsPresenter:: subject classMethodsSubject presenter.
	}
)
classNameAndHierarchySummary = (
	| parts <List[Fragment]> |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^column: {
		row: {
			smallBlank.
			(image: ide images classIcon)
                 height: styleButtonSize.
			smallBlank.
			row: parts.
			filler.
            classActionsPresenter.
			smallBlank.
			itemReferencesButtonWithAction: [browseSelector: subject name].
			smallBlank.
			saveButtonWithAction: [respondToSave].
			smallBlank.
			refreshButton.			
			smallBlank.
            helpButton.
			smallBlank.
			dropDownMenu: [classActionsMenu].
		}
	}
)
helpText ^ <Fragment> = (
  | 
  mapping = Map new. 
  menuImage = Utilities uriForIconNamed: #hsDropdownImage. 
  referenceImage = Utilities uriForIconNamed: #itemReferencesImage.
  classActions <ClassActionsPresenter> = classActionsPresenter. 
  appActionsHelp <String> = 
    subject isApplicationConfiguration ifTrue: [
        mapping
            at: #classDeployAction put: classActions deployAction;
            at: #classEditDeploymentsAction put: classActions editDeploymentsAction;
            at: #classRunAppAction put: classActions runAppAction.
            'Next, because this is a application configuration class,  come links for managing application configurations
            <ul>
            <li><div class = "classDeployAction"></div>Bring up a menu of options for deploying this application configuration</li>
            <li><div class = "classEditDeploymentsAction"></div>Add or modify deployment options.</li>
            <li><div class = "classRunAppAction"></div>Run or debug the app.</li>
            </ul>'
    ] ifFalse: [''].
    testActionsHelp <String> =
      subject isTestConfiguration ifTrue: [
        mapping
            at: #classTestActions put: classActions testActions.
            ' Next, because this is a test configuration class,  come links <div class = "classTestActions"></div>for running or displaying the tests for this test configuration.'
    ] ifFalse: [''].   
  |
  subject isApplicationConfiguration ifTrue: [
  ] ifFalse: [].
  mapping
    at: #classTestActions put: classActions testActions;  
    at: #classDeployAction put: classActions deployAction;
    at: #classEditDeploymentsAction put: classActions editDeploymentsAction;
    at: #classRunAppAction put: classActions runAppAction;    
    at: #hopscotchClassActionsMenuButton put: (dropDownMenu: [classActionsMenu]);
    at: #hopscotchClassReferencesButton put: (itemReferencesButtonWithAction: [browseSelector: subject name]);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchRefreshButton put: refreshButton;
    at: #hopscotchSaveButton put: (saveButtonWithAction: [respondToSave]).

  ^ampleforth: 'A class presenter provides a structured view of a class. The first line tells you the class name and what classes, if any, it is nested in. ', appActionsHelp, testActionsHelp, ' The class presenter also provides the following buttons:
  <ul>
  <li> <div class="hopscotchClassReferencesButton"> </div>Allows you to find references to it. </li>
  <li><div class="hopscotchSaveButton"> </div> Downloads it (i.e., saves it to a file)
   .</li>
 <li><div class="hopscotchRefreshButton"> </div> Refreshes the display</li>
    <li><div class="hopscotchHelpButton"> </div> Shows this help message.</li>
   <li> <div class="hopscotchClassActionsMenuButton"> </div> Opens a menu of additional operations, such as deleting the class or inspecting this presenter or a mirror on this class declaration.</ul> <br>
  The line below provides access to the class'' primary factory. You can access senders and implementers of the factory and the slots it defines via  <img src="', referenceImage , '" alt="" width="30" height="30">, or access the menu via <img src="', menuImage, '" alt="" width="30" height="30">. <br>
  The following three sections manage nested classes, instance and class methods respectively. '  mapping: mapping
)
) : (
)
public class ClassSubject onClassModel: m <ClassModel> = ProgrammingSubject onModel: m (
  | 
  public exemplar <ObjectMirror> ::= classModel exemplar.
  lazySlotsSubject_slot  <LazySlotGroupSubject>  
  nestedClassesSubject_slot  <NestedClassGroupSubject>
  methodsSubject_slot  <MethodGroupSubject>
  classMethodsSubject_slot  <MethodGroupSubject>
  objectSubject_slot <ObjectSubject>
  |
) (
public accessModifier = (
	^classMirror accessModifier
)
public classCommentSummary ^ <String> = (
	|
	fullComment <String> = classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
public classCommentText ^<String> = (
	| comment = classMirror header classComment. |
	nil = comment ifTrue: [^''].
	^comment
)
public classHeaderSource = (
	^classMirror header source
)
public isApplicationConfiguration ^ <Boolean> = (
  ^isTopLevel and: [
	classMirror primaryFactorySelector = #packageUsing: or: [
		classMirror classSide methods includesMirrorNamed: #packageUsing:
		]
	]
)
public isKindOfClassSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfClassSubject
)
public testingSubject = (
	#NAMESPACEBOGUS.
	^ide minitestUI TestingInProgressSubject
		onConfiguration: (ide namespacing Root at: name)
		platform: cachedPlatform
		minitest: ide minitest
)
public title = (
	^name
)
public runApp = (
	| appDef <Class> app <Object> |
	appDef:: ide namespacing Root at: name.
	app:: appDef packageUsing: ide namespacing manifest.
	app main: cachedPlatform args: {}
)
public bytesForVictoryFuel ^ <ByteArray> = (
	^bytesForVictoryFuelWithRuntime: ide psoupDeploymentRuntime
)
public bytesForVictoryFuelWithMirrors ^ <ByteArray> = (
	^bytesForVictoryFuelWithRuntime: ide psoupWithMirrorsDeploymentRuntime
)
public bytesForVictoryFuelWithRuntime: runtimeClass ^ <ByteArray> = (
	| appDef <Class> =  ide namespacing Root at: name. |
	^ide deployment PSoupPackager packageApplicationConfiguration: appDef withRuntimeConfiguration: runtimeClass  usingNamespace: ide namespacing Root
)
public compilationUnitSource ^ <String> = (
  isTopLevel ifTrue: [
	^compilationUnitFromSource: classMirror source
	].
  ^classMirror source
)
public inactiveTestingSubject = (
	#NAMESPACEBOGUS.
	^ide minitestUI TestingOutcomeSubject
		onConfiguration: (ide namespacing Root at: name)
		platform: cachedPlatform
		minitest: ide minitest
)
public isTestConfiguration = (
  ^isTopLevel and: [
	classMirror primaryFactorySelector = #packageTestsUsing: or: [
		classMirror classSide methods includesMirrorNamed: #packageTestsUsing:
		]
	]
)
public createPresenter = (
	^chosenPresenter
)
objectSubject ^ <ObjectSubject> = (
  objectSubject_slot isNil ifTrue: [
     objectSubject_slot:: ObjectSubject onModel: exemplar.
  ].
  ^objectSubject_slot
)
public isTopLevel = (
	^nil = classMirror enclosingClass
)
public name = (
	^classMirror name
)
public classMethodsSubject ^ <MethodGroupSubject> = (
   classMethodsSubject_slot isNil ifTrue: [
     | methodsModel <MirrorGroupModel> = 
       MirrorGroupModel mirrorGroup: classMirror classSide methods ofMixin: classMirror classSide exemplar: exemplar. 
     |   
	 classMethodsSubject_slot:: MethodGroupSubject onModel: methodsModel
    ].
   ^classMethodsSubject_slot
)
public methodsSubject ^ <MethodGroupSubject> = (
   methodsSubject_slot isNil ifTrue: [
     | methodsModel <MirrorGroupModel> = 
       MirrorGroupModel mirrorGroup: classMirror instanceSide methods ofMixin: classMirror instanceSide exemplar: exemplar. 
     |    
	 methodsSubject_slot:: 	MethodGroupSubject onModel: methodsModel
    ].
   ^methodsSubject_slot
)
public nestedClassesSubject ^ <NestedClassGroupSubject> = (
   nestedClassesSubject_slot isNil ifTrue: [
     | nestedClassesModel <MirrorGroupModel> = 
       MirrorGroupModel mirrorGroup: classMirror instanceSide ofMixin: classMirror instanceSide exemplar: exemplar. 
     |
	 nestedClassesSubject_slot:: NestedClassGroupSubject onModel: nestedClassesModel
    ].
   ^nestedClassesSubject_slot
)
public classModel ^ <ClassModel> = (
  ^model
)
public classMirror ^ <ClassDeclarationMirror> = (
	^classModel klass
)
public enclosingClassSubject ^ <ClassSubject> = (
	^isTopLevel ifFalse: [ClassSubject onDeclaration: classMirror enclosingClass]
)
public enclosingClassSubjects ^ <List[ClassSubject]> = (
	| them = List new. c |
	c:: classMirror.
	[c isNil] whileFalse: [them add: (ClassSubject onDeclaration: c). c:: c enclosingClass].
	^them
)
chosenPresenter ^ <ObjectPresenter | ClassPresenter> = (
  exemplar isNil ifFalse: [^objectSubject presenter].
  exemplar:: computeExemplarFor: classMirror enclosing: classModel enclosing.
(* (*  Can't happen, as we no longer return a thread from #computeExemplarFor:enclosing *)
  exemplar isKindOfThreadMirror ifTrue: [
    ('Error in exemplar evaluation for ', title) out.
    ^ClassPresenter onSubject: self.
  ].*)
  exemplar isNil ifTrue: [
     nil ~= (classMirror header metadata at: #exemplar ifAbsent: [])
        ifTrue: [('Error in exemplar evaluation for ', title) out].
    ^ClassPresenter onSubject: self.
  ].
  classModel exemplar: exemplar.
  ^objectSubject presenter openClass: true; yourself
)
public lazySlotsSubject ^ <LazySlotGroupSubject> = (
   lazySlotsSubject_slot isNil ifTrue: [
     | lazySlotsModel <MirrorGroupModel> = 
       MirrorGroupModel mirrorGroup: classMirror instanceSide lazySlots ofMixin: classMirror instanceSide exemplar: exemplar. 
     |    
	 lazySlotsSubject_slot:: 	LazySlotGroupSubject onModel: lazySlotsModel
    ].
   ^lazySlotsSubject_slot
)
public deleteClass = (
	| builder |
	nil = classMirror enclosingClass ifTrue: [
    		^deleteTopLevelClassNamed: name.
    	].
	builder:: classMirror enclosingClass asBuilder.
	builder instanceSide nestedClasses removeMirrorNamed: classMirror name.
	ide installFromBuilders: {builder}
)
) : (
public fromModel: cm <ClassModel> ^ <Instance> = (
  ^onClassModel: cm
)
public onDeclaration: cd <ClassDeclarationMirror> ^ <Instance> = (
  ^onClassModel: (ClassModel declaration: cd exemplar: nil)
)
public onModel: cm <ClassModel> ^ <Instance> = (
  ^onClassModel: cm
)
)
public class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* 
DefinitionListPresenter is an abstract superclass of presenters that displays helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added. 
*)

| 
stateSlot <DefinitionListPresenterState> 
contentListSlot <ToggleList>
|
) (
addButton = (
  ^addButtonWithAction: [updateGUI: [respondToAdd]].
)
public addNewItemTemplate = (
	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)

	subclassResponsibility
)
public collapseAll = (
	(* Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	contentList childrenDo: [:each <ToggleComposer> | each collapse]
)
contentList = (
   contentListSlot isNil ifTrue: [
	contentListSlot:: toggleList: contentPresenters
	].
  ^contentListSlot.
)
definitionListMenu = (
  subclassResponsibility
)
public expandAll = (
	(* Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	contentList childrenDo: [:each <ToggleComposer> | each expand]
)
public isKindOfDefinitionListPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfDefinitionListPresenter
)
respondToAdd = (
  addNewItemTemplate
)
public state = (
  stateSlot isNil ifTrue: [stateSlot:: DefinitionListPresenterState new].
  ^stateSlot
)
public title = (
  subclassResponsibility
)
updateVisualsFromSameKind: oldPresenter <Self> ^ <Alien[Element]> = (
  stateSlot:: oldPresenter state.
  substanceSlot:: nil.
  ensureSubstance.
  ^super updateVisualsFromSameKind: oldPresenter
)
definition ^ <Fragment> = (
	^column: {
       helpSection.
		minorHeadingBlock: (
			row: {
				(label: title)
                    bold.
				defaultBlank.
				addButton.
				filler.               
				expandButtonWithAction: [expandAll].
				defaultBlank.
				collapseButtonWithAction: [collapseAll].
				defaultBlank.
				refreshButton.
				defaultBlank.
                helpButton.
				defaultBlank.                 
				dropDownMenu: [definitionListMenu].								
				}
			).
		state prefixHolder.
		contentList.		
	}
)
listDescription ^ <String> = (
  subclassResponsibility
)
elementDescription ^ <String> = (
  subclassResponsibility
)
menuOperationsHelp ^ <String> = (
  ^'inspecting this presenter'
)
helpText = (
  | mapping = Map new. |
  mapping 
    at: #hopscotchAddButton put: addButton;
    at: #hopscotchExpandAllButton put: (expandButtonWithAction: [expandAll]);
    at: #hopscotchCollapseAllButton put: (collapseButtonWithAction: [collapseAll]);
    at: #definitionListMenuButton put: (dropDownMenu: [definitionListMenu]);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchRefreshButton put: refreshButton.
  
  ^ampleforth: 'This is a ', listDescription, ' presenter.  It lists the ', elementDescription, '.
  The elements of the list are collapsed by default. You can toggle each element individually. The list also provides the following buttons:
  <ul>
  ', buttonListHelp, '  
  </ul>
  ' mapping: mapping
)
buttonListHelp ^ <String> = (
  ^'  <li> <div class="hopscotchAddButton"> </div>Add an element to the list.</li>
  <li> <div class="hopscotchExpandAllButton"> </div>Expands all elements of the list.</li>
  <li> <div class="hopscotchCollapseAllButton"> </div>Collapses all elements of the list.</li>
  <li> <div class="hopscotchRefreshButton"> </div> Refreshes the list (just in case of UI bugs).</li>
  <li> <div class="hopscotchHelpButton"> </div> Shows this help message.</li>
  <li> <div class="definitionListMenuButton"> </div> Opens a menu of additional operations, ', menuOperationsHelp, '.</li>'
)
) : (
)
public class DefinitionListPresenterState = (
  | 
  prefixes <List[DefinitionTemplate]> = List new. 
  prefixPresenter = PrefixPresenter new.
  public prefixHolder <HolderComposer> = prefixPresenter holder: fragmentForPrefixes. 
  |
) (
class PrefixPresenter = Presenter onSubject: nil (
(*
A trick/hack to give the enclosing object access to the fragment factories it needs.
The only way to create fragments outside the Hopscotch module is via the factories inherited from Presenter.
DefinitionListPresenterState is not a presenter, and yet it manufactures bits of presentation. Hence, we create
this presenter class, which publicizes the required inherited factories. Each instance of DefinitionListPresenterState has a single instance of this class,
which it uses to access the needed factories.
*)
) (
public column: ds  <List[Fragment]> ^ <ColumnComposer>  = (
  ^super column: ds
)
public holder: c <Fragment> ^ <HolderComposer> = (
  ^super holder: c
)
public isKindOfPrefixPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfPrefixPresenter
)
) : (
)
public addPrefix: p <DefinitionTemplate> = (
  prefixes add: p.
  updatePrefixes.
)
fragmentForPrefixes ^ <Fragment> = (
  ^prefixPresenter column: prefixes
)
public isKindOfDefinitionListPresenterState ^ <Boolean> = (
  ^true
)
public removePrefix: p <DefinitionTemplate>  = (
  prefixes remove: p.
  updatePrefixes.
)
updatePrefixes = (
  prefixHolder isNil ifFalse: [prefixHolder content: fragmentForPrefixes]
)
) : (
)
public class DefinitionListSubject onModel: m = Subject onModel: m (
(* DefinitionListSubject manages helper ''transient'' subjects, for example a method list which can at times include presenters for methods being added or residue presenters of removed methods. *)
| 
public prefixes <List[Fragment]> = List new.
public content <List[Subject]>  = List new. 
|
) (
public createPresenter ^ <DefinitionListPresenter> = (
  ^DefinitionListPresenter onSubject: self.
)
public isKindOfDefinitionListSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfDefinitionListSubject
)
) : (
)
public class DefinitionTemplate
   caption: c <String>
   initialText: t <String | Text>
   colorizerBlock: cb <[:String :CodeMirrorFragment]>
   acceptResponse: onAccept <[DefinitionTemplate]>
   cancelResponse: onCancel <[DefinitionTemplate]>
 = ProgrammingPresenter onSubject: nil (
 (* A template for a nested definition such as a method or nested class, that may be added to a DefinitionList. *)
 |
	public caption = c.
	public initialText = t.
	public initiallyInEditState ::= true.
	public acceptResponse = onAccept.
	public cancelResponse = onCancel.
	public editor
	public colorizerBlock = cb.
|) (
public = other <Object>^ <Boolean> = (
  other isKindOfDefinitionTemplate ifFalse: [^false].
  ^other text = text
)
definition ^ <Fragment> = (
	^(row: {
		mediumBlank.
		elastic:
			(column: {
				smallBlank.
				label: caption.
				editorDefinition.
				mediumBlank.
 			}).
		smallBlank.
		}) color: (Gradient from: (Color h: 100 s: 0.3 v: 0.9) to: (Color h: 100 s: 0.3 v: 0.8))
)
editorDefinition ^ <Fragment> = (
	editor:: (codeMirror: initialText)
	(*	acceptLabelText: 'save';
		cancelLabelText: 'cancel';*)
		acceptResponse: [acceptResponse value: self];
		changeResponse: [:cm <CodeMirrorFragment> :event <Event>  | colorizerBlock value: cm textBeingAccepted value: cm];
		cancelResponse: [cancelResponse value: self].
	initiallyInEditState ifTrue: [editor updateEditState].
	colorizerBlock value: initialText value: editor.
	^editor
)
public hash ^ <Integer> = (
  ^text hash
)
public isKindOfDefinitionTemplate ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfDefinitionTemplate
)
public tag ^ <String> = (
  ^printString
)
public text = (
	^editor textBeingAccepted
)
) : (
)
public class EntryPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public collapse = (
	substance collapse
)
definition = (
	^collapsed: [collapsedDefinition] expanded: [expandedDefinition]
)
public expand = (
	substance expand
)
public isKindOfEntryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfEntryPresenter
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.
	}
)
) : (
)
public class EvaluationViewState onModel: m <ObjectMirror | ActivationMirror> = (
(* An evaluator maintains a list of results of prior evaluations. *)
  | 
  public mirror <ObjectMirror | ActivationMirror> = m. 
  results_slot <List[ThreadMirror]> ::= List new. 
  lastEvalWasLive <Boolean> ::= false. 
  public isLive <Boolean> ::= false.
  |
) (
public isKindOfEvaluationViewState ^ <Boolean> = (
  ^true
)
public results  ^  <List[ThreadMirror]> = (
  ^results_slot
)
public evaluate: e <String> ^ <ThreadMirror>  = (
  lastEvalWasLive:: false.
  ^results_slot add: ([mirror evaluate: e] on: Error do: [:ce | ce])
)
public evaluateLive: e <String> ^ <ThreadMirror>  = (
  | result = [mirror evaluate: e] on: Error do: [:ce | ce]. |
  ^lastEvalWasLive ifTrue: [
	(e isEmpty not and: [e last = '.' last]) ifTrue: [lastEvalWasLive:: false].
	results_slot at: results_slot size put: result.
	]  ifFalse: [lastEvalWasLive:: e last  ~= '.' last. results_slot add: result]
)
public = another <Object> ^<Boolean> = (
	^(another isKindOfEvaluationViewState) and:
		[mirror = another mirror]
)
public hash ^<Integer> = (
	^self class hash bitXor: mirror hash
)
public clear = (
  results do: [:t | t isKindOfThreadMirror ifTrue: [(t isBroken or: [t isSuspended])  ifTrue: [t terminate]]].
  lastEvalWasLive:: false.
  results_slot:: List new
)
) : (
)
class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
aboutSystemDefinition = (
	^(link: 'About this system' action: [respondToAboutSystem]) smallFont.
)
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter'. [respondToInspectPresenter]}.
	}
)
column1: definitions1 column2: definitions2 column3: definitions3 = (
	^row: {
		(column: definitions1) width: 0 elasticity: 1.
		(column: definitions2) width: 0 elasticity: 1.
		(column: definitions3) width: 0 elasticity: 1.
	}
)
didYouKnow = (
	| wisdom |
	wisdom:: subject randomBitOfWisdom.
	nil = wisdom actionLabel ifFalse:
		[^textAndActionWisdom: wisdom].
	nil = wisdom image ifFalse:
		[^textAndImageWisdom: wisdom].
	^textDisplay: wisdom text
)
public isKindOfHomePresenter ^ <Boolean> = (
  ^true
)
navigateToNamespace = (
	enterSubject:: NamespaceSubject new.
)
navigateToWorkspaces = (
	enterSubject:: ide theWorkspaceManager AllWorkspacesSubject new.
)
respondToAboutSystem = (
	alert: 'WebIDEApp version 0.1984'
)
textAndActionWisdom: wisdom = (
	^column: {
		textDisplay: wisdom text.
		(link: wisdom actionLabel action: wisdom actionBlock) smallFont
	}
)
textAndImageWisdom: wisdom = (
	^row: {
		(image: wisdom image)
           height: styleButtonSize.
		mediumBlank.
		elastic:
			(textDisplay: wisdom text).
	}
)
definition = (
	^column: {
		helpSection.
		majorHeadingBlock: (
			row: {
				(label: 'Navigation')
                    bold.
				filler.
				helpButton.
				dropDownMenu: [actionsMenu].				
			}
		).
		mediumBlank.

		indentedBlock:
			(column1: {
				link: 'Newspeak Source' action: [navigateToNamespace].
			}
			column2: {
				link: 'Workspaces' action: [navigateToWorkspaces].
			}
			column3: {
			}).
		mediumBlank.

(*		majorHeadingBlock: (label: 'Recently Visited' asText allBold).
		mediumBlank.
		indentedBlock:
			(holder: [recentStuffDefinition]).
		largeBlank.*)

		majorHeadingBlock: (label: 'Did you know?') bold.
		mediumBlank.

		indentedBlock:
			(holder: [didYouKnow]).
		mediumBlank.
		indentedBlock: aboutSystemDefinition.
	}
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfHomePresenter
)
public helpText ^<Fragment> = (
  | goldenIcon = Utilities uriForIconNamed: #languageNewspeak3. |
  ^html: 'This is the home page.<br><br>
The home page includes links to a variety of useful places, like the IDE''s root namespace, which lists all top level classes, and the workspace manager, where you can evaluate code.<br>
The <img src=''',  goldenIcon, ''' alt="" width="18" height="30"> icons represent Newspeak3, which is the currently operational dialect of Newspeak.'
)
) : (
)
public class HomeSubject onModel: m (* :exemplar: HomeSubject new *) = ProgrammingSubject onModel: m (
(* The Home screen is stateful.  The state is simply whether the
    help text is displayed or not. 
 *)
) (
public = anotherSubject <Subject> ^ <Boolean> = (
	(* As there is just one possible logical home of the system, all subjects representing it are considered equal. *)
	^anotherSubject isKindOfHomeSubject
)
public isKindOfHomeSubject ^ <Boolean> = (
	^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfHomeSubject
)
public randomBitOfWisdom = (
	| bits = bitsOfWisdom. |
	^(bits at: (JSMath random * bits size) floor asInteger + 1) value
)
public hash ^<Integer> = (
	^self class hash
)
public createPresenter = (
	^HomePresenter onSubject: self
)
public title = (
	^'Newspeak Home'
)
bitsOfWisdom = (
	(* This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random. *)
	^{
	[BitOfWisdom
		text: 'This is the "expand all" button which appears in headers of expandable item groups.'
		image: ide images expandImage].

	[BitOfWisdom
		text: 'This is the "collapse all" button which appears in headers of expandable item groups.'
		image: ide images collapseImage].

	[BitOfWisdom
		text: 'This is the "add" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'
		image: ide images addImage].

(* (*Untrue. Also not the right thing to do *)
	[BitOfWisdom
		text: 'Expressions evaluated in debuggers and inspectors can access a workspace via the name _. This allows you to bypass modularity during development and access values you forgot to import, e.g. _ collections List.']. *)

	[BitOfWisdom
		text: 'This icon identifies Newspeak classes.'
		image: ide images classIcon].

	[BitOfWisdom
		text: 'This icon identifies namespaces.'
		image: ide images classPresenterIcon].

	[BitOfWisdom
		text: 'War is peace. Freedom is slavery. Ignorance is strength.'].
	}
)
) : (
public new = (
	^onModel: nil
)
)
class IntegerView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public definition = (
	^column: {
		label: 'binary' radix: 2.
		label: 'octal' radix: 8.
		label: 'decimal' radix: 10.
		label: 'hex' radix: 16.
	}
)
public isKindOfIntegerView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfIntegerView
)
label: label radix: radix = (
	^row: {
		smallBlank.
		(label: label)
			width: 0 elasticity: 1.
		smallBlank.
		(label: (subject objectMirror reflectee asStringRadix: radix))
			width: 0 elasticity: detailAreaRatio.
	}
)
) : (
)
class KeysAndValuesView title: t onSubject: s = ProgrammingPresenter onSubject: s (
	|
	public title <String> = t.
	|
) (
public definition = (
	^column:
		(subject keysAndValues collect:
			[:slot <SlotSubject> | slot presenter])
)
public isKindOfKeysAndValuesView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfKeysAndValuesView
)
updateVisualsFromSameKind: oldFragment <KeysAndValuesView> ^ <Alien[Element]> = (
  subject keysAndValues do: [:slot <SlotSubject> | 
    | oldSlotPresenter <SlotPresenter>  = findSlotMatching: slot in: oldFragment. |
    oldSlotPresenter isNil  ifFalse: [slot presenter updateVisualsFrom: oldSlotPresenter]
  ].
  ^replaceVisual: oldFragment visual with: visual
)
findSlotMatching: slot <SlotSubject> in: oldFragment <KeysAndValuesView> ^ <SlotPresenter> = (
   ^oldFragment substance definitions detect: [:def <SlotPresenter> | def subject = slot] ifNone: [].
)
) : (
public onSubject: s = (
  ^title: s classMirror mixin name onSubject: s
)
)
class LazySlotGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, an NSLazySlotGroup, as a column of presenters for the lazy slots in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS lazy slots goes here. *)
| groupedByCategory <Boolean> ::=false. |
) (
public deleteLazySlotInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	updateGUI: [
		subject deleteLazySlotWithSubject: presenter subject.
		successResponse value
		]
)
public title = (
  ^' Lazy slots'
)
listDescription ^ <String> = (
  ^' Lazy slots'
)
elementDescription ^ <String> = (
  ^'Lazy slots of the surrounding class'
)
public addNewItemTemplate = (
	(* Handle a user's request to create a new lazy slot by displaying a new lazy slot template. *)
	addNewItemTemplate: subject lazySlotTemplateText
)
public addNewItemTemplate: src = (
	(* Handle a user's request to create a new lazy slot by displaying a new lazy slot template. *)

	| template prefixState <DefinitionListPresenterState> = state. |
	template:: DefinitionTemplate
		caption: 'Adding new lazy slot:'
		initialText: src
		colorizerBlock:
			[:text <String> :cm <CodeMirrorFragment> | subject colorizeSource: text editor: cm]
		acceptResponse:
			[:ed | createNewLazySlotFromTemplate: template]
		cancelResponse:
			[:ed | updateGUI: [prefixState removePrefix: template]].
	updateGUI: [prefixState addPrefix: template]
)
createNewLazySlotFromTemplate: template <DefinitionTemplate> = (
| prefixState <DefinitionListPresenterState> = state. |
	subject
		compileSource: template text
		ifSuccess:
			[:newSlot <LazySlotMirror> |
			prefixState removePrefix: template.
			updateGUI: []
			]
		ifFailure:
			[:message | template editor showMessage: message]
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^LazySlotPresenter
)
) : (
)
public class LazySlotGroupSubject onModel: m <MirrorGroupModel[LazySlotMirror]> = MirrorGroupSubject onModel: m (
(* Represents the collection of lazy slots of a Newspeak class. Holds onto the mirror group for the lazy slots. *)
) (
elementFor: m <Mirror> = (
	^elementModelClass mirror: m exemplar: exemplar
)
public createPresenter = (
	^LazySlotGroupPresenter onSubject: self
)
elementSubjectClass ^ <MethodSubject class> = (
	^LazySlotSubject
)
public isKindOfLazySlotGroupSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfLazySlotGroupSubject
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^List withAll: definingMixin lazySlots
)
elementModelClass ^ <LazySlotModel class> = (
	^LazySlotModel
)
public colorizeSource: source <String> editor: cm <CodeMirrorFragment> ^ <TextFragment> = (
	^ide colorizer
		colorizeLazySlot: source
		fromClass: definingMixin declaration
		via: (colorizingBlockFor: cm)
)
public compileSource: source <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <LazySlotBuilder> newMirror <LazySlotMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder lazySlots addFromSource: source.
	ide  installFromBuilders: {builder declaration}.
	newMirror:: definingMixin lazySlots findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public lazySlotTemplateText ^ <String> = (
^
'lazy slotName = expression.'
)
public deleteLazySlotWithSubject: lazySlotSubject <LazySlotSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder lazySlots removeMirrorNamed: lazySlotSubject selector.
	ide installFromBuilders: {builder declaration}
)
) : (
)
class MethodGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)
| groupedByCategory <Boolean> ::=false. |
) (
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	addNewItemTemplate: subject methodTemplateText
)
createNewMethodFromTemplate: template <DefinitionTemplate> = (
| prefixState <DefinitionListPresenterState> = state. |
	subject
		compileSource: template text
		ifSuccess:
			[:newMethod <MethodMirror> |
			|
			(* newSubject <MethodSubject> = MethodSubject onModel: newMethod.
			newPresenter <MethodPresenter> = createPresenterForSubject: newSubject.*)
			(*newToggle <ToggleComposer> = newPresenter visual; substance.*)
			|

			prefixState removePrefix: template.
			updateGUI: []
			]
		ifFailure:
			[:message | template editor showMessage: message]
)
public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	updateGUI: [
		subject deleteMethodWithSubject: presenter subject.
		successResponse value
		]
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^MethodPresenter
)
public title = (
  | side = subject definingMixin isMeta ifTrue: ['Class'] ifFalse: ['Instance'].|
  ^side, ' Methods'
)
public addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template prefixState <DefinitionListPresenterState> = state. |
	template:: DefinitionTemplate
		caption: 'Adding new method:'
		initialText: src
		colorizerBlock:
			[:text <String> :cm <CodeMirrorFragment> | subject colorizeSource: text editor: cm]
		acceptResponse:
			[:ed | createNewMethodFromTemplate: template]
		cancelResponse:
			[:ed | updateGUI: [prefixState removePrefix: template]].
	updateGUI: [prefixState addPrefix: template]
)
listDescription ^ <String> = (
  | side = subject definingMixin isMeta ifTrue: ['class'] ifFalse: ['instance'].|
  ^side, ' methods'
)
elementDescription ^ <String> = (
  | side = subject definingMixin isMeta ifTrue: ['class'] ifFalse: ['instance'].|
  ^side, ' methods of the surrounding class'
)
) : (
)
public class MethodGroupSubject onModel: m <MirrorGroupModel[MethodMirror]> = MirrorGroupSubject onModel: m (
(* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)
) (
elementFor: m <Mirror> = (
	^elementModelClass mirror: m exemplar: exemplar
)
public colorizeSource: source <String> editor: cm <CodeMirrorFragment> ^ <TextFragment> = (
	^ide colorizer
		colorizeMethod: source
		fromClass: definingMixin declaration
		via: (colorizingBlockFor: cm)
)
public createPresenter = (
	^MethodGroupPresenter onSubject: self
)
elementSubjectClass ^ <MethodSubject class> = (
	^MethodSubject
)
public isKindOfMethodGroupSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfMethodGroupSubject
)
public methodTemplateText ^ <String> = (
^
'messageSelector = (
)'
)
public compileSource: source <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <MethodBuilder> newMirror <MethodMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder methods addFromSource: source.
	ide  installFromBuilders: {builder declaration}.
	newMirror:: definingMixin methods findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public deleteMethodWithSubject: methodSubject <MethodSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder methods removeMirrorNamed: methodSubject selector.
	ide installFromBuilders: {builder declaration}
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^List withAll: definingMixin methods
)
elementModelClass ^ <MethodModel class> = (
	^MethodModel
)
) : (
)
public class LazySlotPresenter onSubject: s <LazySlotSubject> = ProgrammingPresenter onSubject: s (
	(* A presenter for a single lazy slot. *)
	|
	public showClassName ::= false.
	|
) (
public collapse = (
	^substance collapse
)
public expand = (
	^substance expand
)
messagesMenu = (
	| messagesAndActions messageItems classItems |
	messagesAndActions:: List new.
	messagesAndActions add:
		{subject name. [browseSelector: subject name]}.
	messageItems:: referencesMenuMessageItems.
	messageItems isEmpty not ifTrue:
		[messagesAndActions
			add: #separator;
			addAll: messageItems].
	^menuWithLabelsAndActions: messagesAndActions
)
nestingInfo = (
		^showClassName
			ifTrue: [nestingInformationLine]
			ifFalse: [nothing].
)
nestingInformationLine = (
	| enclosingClasses rowElements |
	enclosingClasses:: subject enclosingClasses.
	rowElements:: List new.
	enclosingClasses do:
		[:each |
		rowElements add: ((label: ' in ') color: tertiaryTextColor).
		rowElements add: (linkToBrowseEnclosingClass: each)].
	^row: rowElements asArray
)
public tag ^ <String> = (
  ^subject name
)
errorDisplay: msg <String> ^ <Fragment> = (
  ^row: {label: msg. button: 'Clear' action: [subject errorMessages remove: msg] }
)
errorMessages ^ <Array[Fragment]> = (
  ^(subject errorMessages collect: [:msg <String> |
       errorDisplay: msg
    ]) asArray.
)
editorDefinition  ^ <CodeMirrorFragment | EvaluatorPresenter> = (
 ^hasExemplars ifTrue: [evaluatorDefinition] ifFalse: [codeMirrorDefinition]
)
public enclosingObjectPresenter ^ <ObjectPresenter | Nil>  = (
  | candidate <Fragment>  ::= parent. |
  [candidate isNil or: [candidate isKindOfIDEWindow or: [candidate isKindOfObjectPresenter]]] 
    whileFalse: [candidate:: candidate parent].
  candidate isNil ifTrue: [^nil].
  candidate isKindOfIDEWindow ifTrue: [^nil].
  subject methodMirror definingMixin name = candidate subject classMirror mixin name
    ifFalse: [^nil].
  ^candidate
)
enclosingClassPresenter ^ <ClassPresenter | Nil>  = (
  | candidate <Fragment>  ::= parent. |
  [candidate isKindOfIDEWindow or: [candidate isKindOfClassPresenter]] whileFalse: [candidate:: candidate parent].
  ^candidate isKindOfIDEWindow ifFalse: [candidate]
)
debugButton ^ <ButtonFragment> = (
  hasExemplars ifFalse: [^nothing].
  subject exemplars size = 1 ifTrue: [
    ^button: 'Debug' action: [debugExemplar: subject exemplars first]
  ] ifFalse: [   | messagesAndActions = List new. |
      subject exemplars do: [:ex <String> | 
      	messagesAndActions add:
		{ex. [debugExemplar: ex]}.
      ].
      ^dropDownMenu: [menuWithLabelsAndActions: messagesAndActions]
  ]
)
hasExemplars ^ <Boolean> = (
  subject exemplars isEmpty ifTrue: [^false].
  (* If we have an enclosing object defined, we can proceed *)
  subject enclosingScope isNil ifTrue: [^false].
  ^true
)
evaluatorDefinition ^ <EvaluatorPresenter> = (
 subject threadForExemplar: subject exemplar.
 ^subject evaluator presenter.
)
linkToBrowseEnclosingClass: klass <ClassDeclarationMirror> = (
	^(link: klass simpleName
		action: [enterSubject:: ClassSubject onDeclaration: klass])
		color: secondaryTextColor
)
public isKindOfLazySlotPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfLazySlotPresenter
)
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^ [:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject slotMirror definingMixin asBuilder. |
		updateGUI: [
			[b lazySlots addFromSource: ed textBeingAccepted.
			ide  installFromBuilders: {b declaration}.
			colorizeLazySlotSource: (crToLf: ed textBeingAccepted) withEditor: ed.
			ed leaveEditState] on: Error do:  [:ex <Exception> | ed showMessage: ex printString]
			].
		ed editor focus.
		]
)
colorizeLazySlotSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeLazySlot: s fromClass: subject classDeclaration via: (colorizingBlockFor: cm)
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		colorizeLazySlotSource: (crToLf: ed textBeingAccepted) withEditor: ed.
	 ]
)
codeMirrorDefinition  ^ <CodeMirrorFragment> = (
  |  src = crToLf: subject source. cm = codeMirror: src. |
  cm changeResponse: changeResponse; 
        cancelResponse: cancelResponse;
        acceptResponse: acceptResponse.
  colorizeLazySlotSource: src withEditor: cm.
  ^cm
)
debugExemplar: e <String> (* :exemplar1: debugExemplar: 'definition' *) = (
   | 
   thread <ThreadMirror | Error> = subject threadForExemplar: e. 
   |
   thread isKindOfThreadMirror 
     ifTrue: [enterSubject:: ide debugging ThreadSubject onModel: thread]
     ifFalse: [alert: 'internal IDE failure in LazySlotPresenter>>debugExemplar: ', thread printString].
)
respondToAddSlotWorkspace = (
  subject threadForExemplar: subject exemplar.
  updateGUI: [subject addSlotWorkspace]
)
public definition ^ <Fragment> = (
	| toggle |
	toggle::
		collapsed: [slotHeader: [toggle expand]]
		expanded: [
			column: {
			slotHeader: [toggle collapse].
			editorDefinition.
            column: errorMessages.
            subject hasSlotWorkspace 
               ifTrue: [subject workspace presenter]
               ifFalse: [nothing].
		}].
	^toggle
)
slotHeader: toggleBlock <[]> ^ <Fragment> = (
  ^row: {
			accessIndicator.
			defaultBlank.
			(link: subject name action: toggleBlock) color: actionLinkColor.
		      nestingInfo.
	            filler.
                deferred: [debugButton].
                smallBlank.
	            dropDownMenu: [messagesMenu] image: ide images itemReferencesImage.
	            smallBlank.
	            dropDownMenu: [slotMenuFor: subject name]
			}
)
slotMenuFor: slotName <String> = (
  | 
    labelsAndActions ::= {
        {'Delete #', slotName. [updateGUI: [subject delete]]}.
		#separator.
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}.
    |
    hasExemplars ifTrue: [labelsAndActions:: labelsAndActions,  {#separator. {'Add Evaluator'. [respondToAddSlotWorkspace]}}].
	^menuWithLabelsAndActions: labelsAndActions
)
cancelResponse ^ <[:CodeMirrorFragment]> = (
	^[:ed <CodeMirrorFragment> |
        ed text: subject source.
		colorizeLazySlotSource: (crToLf: subject source) withEditor: ed.
		ed leaveEditState.
	 ]
)
referencesMenuMessageItems = (
	| 
    items = List new.
    sortedMessages
    |
	sortedMessages:: subject messages sort: [:m1 :m2 | 
       lexicallyLessOrEqual: m1 than: m2
     ].
	sortedMessages do:
		[:selector |
		selector == subject name ifFalse:
			[items add:
				{selector copyFrom: 1 to: (64 min: selector size). [browseSelector: selector]}]].
	^items
)
) : (
)
public class LazySlotSubject onLazySlotModel: mm <LazySlotModel | ClassModel> = Subject onModel: mm (
(* Manages the UI for a lazy slot. *)
| 
public errorMessages <Set[String]> = Set new. 
public exemplars <List[String]> = computeExemplars.  
public exemplar <String>
evaluator_slot <EvaluationSubject>
workspace_slot <EvaluationSubject>
public threadMap <Map[Symbol, ThreadMirror| Error]> = Map new.
|
) (
public createPresenter ^ <Presenter> = (
	^LazySlotPresenter onSubject: self
)
public enclosingClasses ^ <List[ClassDeclarationMirror]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| 
	classes <List[ClassDeclarationMirror]> = List new.
	currentClass <ClassDeclarationMirror> ::= classDeclaration.
	|
	[currentClass isNil]
		whileFalse: [
			classes add: currentClass.
			currentClass:: currentClass enclosingClass
			].
	^classes
)
public messages   ^ <List[Symbol]> = (
  ^slotMirror selectors
)
public source ^ <String> = (
	^slotMirror source
)
public clearErrors = (
  errorMessages removeAll: errorMessages
)
public delete = (
	| b <MixinBuilder> = slotMirror definingMixin asBuilder. |
	b lazySlots removeMirrorNamed: slotMirror name.
	ide installFromBuilders: {b declaration}
)
public compileSource: src <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <LazySlotBuilder> newMirror <LazySlotMirror> |
	builder:: slotMirror definingMixin asBuilder.
	newBuilder:: builder lazySlots addFromSource: src.
	ide installFromBuilders: {builder declaration}.
	newMirror:: definingMixin lazySlots findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public isKindOfLazySlotSubject ^ <Boolean> = (
  ^true
)
public workspace = (
  workspace_slot isNil ifTrue: [
    | 
    activationMirror = (threadMap at: exemplar) suspendedActivation. 
    evalState = EvaluationViewState onModel: activationMirror.
   |
   workspace_slot:: EvaluatorSubject onModel: evalState.
  workspace_slot initialSource: ''.
  ].
  ^workspace_slot
)
computeExemplars ^ <List[String]> = (
  | 
  keys <Collection[String]> = metadata keys select: [:k <String> | k startsWith: 'exemplar']. 
  es <List[String]> = List new. 
  |
  keys do: [:k <String> |  es add: (metadata at: k)].  
  exemplar:: es isEmpty 
    ifTrue: [(Utilities isInstantiableUnarySelector: name) ifTrue: [es add: name]]
    ifFalse: [es first].
  ^es
)
public threadForExemplar: e <String> ^ <ThreadMirror | Error> (* :exemplar1: threadForExemplar: 'definition' *) = (
   | 
   thread <ThreadMirror | Error> = threadMap at: e asSymbol ifAbsentPut: [processExemplar: e]. 
   |
   ^thread
)
public metadata ^ <Map[String, String]> = (
  ^slotMirror metadata
)
public accessModifier ^ <Symbol> = (
	^slotMirror accessModifier
)
public classDeclaration ^ <ClassDeclarationMirror> = (
	^slotMirror definingMixin declaration
)
public slotModel ^ <LazySlotModel | ClassModel> = (
  ^model
)
public processExemplar: e <String> ^ <ThreadMirror> (* :exemplar1: processExemplar: 'definition' *) = (
   | 
   ast =  (compiler parser parseExpression: e) statements first.
   selector = ast message selector.
   hasSelector = selector = slotMirror name.
   args <List[Object]> = ast message arguments collect: [:a <ExprAST> |  
     | argThread <ThreadMirror> = enclosingScope evaluate: (e copyFrom: a start to: a end). |
     argThread isBroken ifTrue: [currentWindow enterSubject: (ide debugging ThreadSubject onModel: argThread)].
     argThread result reflectee.
     ].
   thread <ThreadMirror> = 
     selector = slotMirror name 
       ifTrue: [enclosingScope sendSuspended: selector with: args]
       ifFalse: [enclosingScope evaluate: e]. 
   |
   thread isBroken ifTrue: [currentWindow enterSubject: (ide debugging ThreadSubject onModel: thread)].
   ^thread
)
public addSlotWorkspace = (
   workspace
)
public enclosingScope ^ <ObjectMirror | Nil> = (
  | mirror <ObjectMirror | Nil> =  slotModel exemplar. |
  mirror isNil ifFalse: [^mirror].
  (* If no exemplar known, use the exemplar of the enclosing class *)
  ^computeExemplarFor: classDeclaration enclosing: nil
)
public hasSlotWorkspace ^ <Boolean>  = (
  ^workspace_slot isNil not
)
public mirror ^ <LazySlotMirror> = (
	^model mirror
)
public name ^ <Symbol> = (
	^slotMirror name
)
public slotMirror ^ <LazySlotMirror> = (
	^slotModel slotMirror
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfLazySlotSubject
)
public evaluator = (
  evaluator_slot isNil ifTrue: [
    | 
    activationMirror = (threadMap at: exemplar) suspendedActivation. 
    evalState = EvaluationViewState onModel: activationMirror.
   |
   evaluator_slot:: LazySlotEvaluatorSubject onModel: evalState.
   evaluator_slot initialSource: source.
  ].
  ^evaluator_slot
)
) : (
public fromModel: lsm <LazySlotModel> ^ <Instance> = (
  ^onLazySlotModel: lsm
)
public onModel: m <LazySlotMirror | ClassDeclarationMirror> = (
  ^onLazySlotModel: (LazySlotModel slot: m exemplar: nil)
)
)
public class MethodPresenter onSubject: s <MethodSubject> = ProgrammingPresenter onSubject: s (
	(* A presenter for a single method. *)
	|
	public showClassName ::= false.
    public mustBeExpanded ::= false.
	|
) (
colorizeMethodSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeMethod: s fromClass: subject classDeclaration via: (colorizingBlockFor: cm)
)
messagesMenu = (
	| messagesAndActions messageItems classItems |
	messagesAndActions:: List new.
	messagesAndActions add:
		{subject name. [browseSelector: subject name]}.
	messageItems:: referencesMenuMessageItems.
	messageItems isEmpty not ifTrue:
		[messagesAndActions
			add: #separator;
			addAll: messageItems].
	^menuWithLabelsAndActions: messagesAndActions
)
public isKindOfMethodPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfMethodPresenter
)
nestingInfo = (
		^showClassName
			ifTrue: [nestingInformationLine]
			ifFalse: [nothing].
)
nestingInformationLine = (
	| enclosingClasses rowElements |
	enclosingClasses:: subject enclosingClasses.
	rowElements:: List new.
	enclosingClasses do:
		[:each |
		rowElements add: ((label: ' in ') color: tertiaryTextColor).
		rowElements add: (linkToBrowseEnclosingClass: each)].
	^row: rowElements asArray
)
public tag ^ <String> = (
  ^subject name
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
	 ]
)
cancelResponse ^ <[:CodeMirrorFragment]> = (
	^[:ed <CodeMirrorFragment> |
        ed text: subject source.
		colorizeMethodSource: (crToLf: subject source) withEditor: ed.
		ed leaveEditState.
	 ]
)
errorDisplay: msg <String> ^ <Fragment> = (
  ^row: {label: msg. button: 'Clear' action: [subject errorMessages remove: msg] }
)
errorMessages ^ <Array[Fragment]> = (
  ^(subject errorMessages collect: [:msg <String> |
       errorDisplay: msg
    ]) asArray.
)
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^ [:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		updateGUI: [
			[b methods addFromSource: ed textBeingAccepted.
			ide  installFromBuilders: {b declaration}.
			colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
			ed leaveEditState] on: Error do:  [:ex <Exception> | ed showMessage: ex printString]
			].
		ed editor focus.
		]
)
codeMirrorDefinition  ^ <CodeMirrorFragment> = (
  |  src = crToLf: subject source. cm = codeMirror: src. |
  cm changeResponse: changeResponse; 
        cancelResponse: cancelResponse;
        acceptResponse: acceptResponse.
  colorizeMethodSource: src withEditor: cm.
  ^cm
)
editorDefinition  ^ <CodeMirrorFragment | EvaluatorPresenter> = (
 ^hasExemplars ifTrue: [evaluatorDefinition] ifFalse: [codeMirrorDefinition]
)
methodMenuFor: methodName <String> = (
  | 
    labelsAndActions ::= {
        {'Delete #', methodName. [updateGUI: [subject delete]]}.
		#separator.
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}.
    |
    hasExemplars ifTrue: [labelsAndActions:: labelsAndActions,  {#separator. {'Add Evaluator'. [respondToAddMethodWorkspace]}}].
	^menuWithLabelsAndActions: labelsAndActions
)
public enclosingObjectPresenter ^ <ObjectPresenter | Nil>  = (
  | candidate <Fragment>  ::= parent. |
  [candidate isNil or: [candidate isKindOfIDEWindow or: [candidate isKindOfObjectPresenter]]] 
    whileFalse: [candidate:: candidate parent].
  candidate isNil ifTrue: [^nil].
  candidate isKindOfIDEWindow ifTrue: [^nil].
  subject methodMirror definingMixin name = candidate subject classMirror mixin name
    ifFalse: [^nil].
  ^candidate
)
enclosingClassPresenter ^ <ClassPresenter | Nil>  = (
  | candidate <Fragment>  ::= parent. |
  [candidate isKindOfIDEWindow or: [candidate isKindOfClassPresenter]] whileFalse: [candidate:: candidate parent].
  ^candidate isKindOfIDEWindow ifFalse: [candidate]
)
debugButton ^ <ButtonFragment> = (
  hasExemplars ifFalse: [^nothing].
  subject exemplars size = 1 ifTrue: [
    ^button: 'Debug' action: [debugExemplar: subject exemplars first]
  ] ifFalse: [   | messagesAndActions = List new. |
      subject exemplars do: [:ex <String> | 
      	messagesAndActions add:
		{ex. [debugExemplar: ex]}.
      ].
      ^dropDownMenu: [menuWithLabelsAndActions: messagesAndActions]
  ]
)
hasExemplars ^ <Boolean> = (
  subject exemplars isEmpty ifTrue: [^false].
  (* If we have an enclosing object defined, we can proceed *)
  subject enclosingScope isNil ifTrue: [^false].
  ^true
)
evaluatorDefinition ^ <EvaluatorPresenter> = (
 subject threadForExemplar: subject exemplar.
 ^subject evaluator presenter.
)
respondToAddMethodWorkspace = (
  subject threadForExemplar: subject exemplar.
  updateGUI: [subject addMethodWorkspace]
)
debugExemplar: e <String> (* :exemplar1: debugExemplar: 'definition' *) = (
   | 
   thread <ThreadMirror | Error> = subject threadForExemplar: e. 
   |
   thread isKindOfThreadMirror 
     ifTrue: [enterSubject:: ide debugging ThreadSubject onModel: thread]
     ifFalse: [alert: 'internal IDE failure in MethodPresenter>>debugExemplar: ', thread printString].
)
linkToBrowseEnclosingClass: klass <ClassDeclarationMirror> = (
	^(link: klass simpleName
		action: [enterSubject:: ClassSubject onDeclaration: klass])
		color: secondaryTextColor
)
referencesMenuMessageItems = (
	| 
    items = List new.
    sortedMessages
    |
	sortedMessages:: subject messages sort: [:m1 :m2 | 
       lexicallyLessOrEqual: m1 than: m2
     ].
	sortedMessages do:
		[:selector |
		selector == subject name ifFalse:
			[items add:
				{selector copyFrom: 1 to: (64 min: selector size). [browseSelector: selector]}]].
	^items
)
methodHeader: toggleBlock <[]> ^ <Fragment> = (
  ^column: {
     helpSection.
      row: {
			accessIndicator.
			defaultBlank.
			(link: subject name action: toggleBlock) color: actionLinkColor.
		      nestingInfo.
	            filler.
                deferred: [debugButton].
                smallBlank.
	            dropDownMenu: [messagesMenu] image: ide images itemReferencesImage.
	            smallBlank.
                helpButton.
                smallBlank.
	            dropDownMenu: [methodMenuFor: subject name]
			}
          }
)
helpText = (
  | 
  mapping = Map new. 
  menuImage = Utilities uriForIconNamed: #hsDropdownImage. 
  referenceImage = Utilities uriForIconNamed: #itemReferencesImage.
  exemplarHeaderDescription = 
    hasExemplars 
      ifTrue: ['<li><div class="hopscotchDebugMethodButton"> </div> Opens a debugger on an invocation of the method, with the arguments given by the method exemplar.</li>'] ifFalse: [''].
  editorEvaluatorDescription = 
    hasExemplars 
      ifTrue: ['<br>The editor is also an evaluator. See it''s help section for more details.'] ifFalse: [''].
  |
  mapping 
    at: #hopscotchAccessIndicator put: accessIndicator;  
    at: #hopscotchMethodMenuButton put: (dropDownMenu: [methodMenu]);
    at: #hopscotchDebugMethodButton put: debugButton;    
    at: #hopscotchMethodReferencesButton put: (dropDownMenu: [messagesMenu] image: ide images itemReferencesImage);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchMethodMenuButton put: (dropDownMenu: [methodMenuFor: subject name]).
    
  ^ampleforth: 'This is a method presenter. A method presenter can be either expanded or collapsed. In the collapsed state, only the method header is shown. 
  <br><br>From left to right, the method header displays: 
  <ul>
  <li><div class="hopscotchAccessIndicator"></div> The method''s access modifier. The color of the access modifier indicates whether the method is public (green), protected (yellow) or private (red).</li>
  <li>The method selector</li>', exemplarHeaderDescription, 
  '<li><div class="hopscotchMethodReferencesButton"> </div> Allows you to find senders and implementors of the method''s selector and all messages sent within the method.</li>
  <li><div class="hopscotchHelpButton"> </div> Shows this help message.</li>
  <li><div class="hopscotchMethodMenuButton"> </div> Opens a menu of additional operations, such as ', menuHelp, '.</li>
  </ul>
  When the method presenter is expanded, an editor pane containing the method source is displayed underneath the header. You can edit the method. Once the code is changed, indicators appear at the top right corner of the editor pane. You can accept the changes by pressing, or revert back to the original by pressing . You can also accept changes by pressing Cmd-return (on mac) or Ctl-return (on Linux or Windows).
  ', editorEvaluatorDescription
  mapping: mapping
)
menuHelp ^ <String> = (
  ^hasExemplars 
      ifTrue: ['deleting the method, inspecting this presenter or opening an evaluator'] ifFalse: ['deleting the method or inspecting this presenter'].
)
public definition ^ <Fragment> = (
	| toggle |
	toggle::
		collapsed: [methodHeader: [toggle expand]]
		expanded: [
			column: {
			methodHeader: [toggle collapse].
			editorDefinition.
            column: errorMessages.
            subject hasMethodWorkspace 
               ifTrue: [subject workspace presenter]
               ifFalse: [nothing].
		}]
        initiallyExpanded: mustBeExpanded.
	^toggle
)
public expand = (
    mustBeExpanded: true.
	^substance expand
)
public collapse = (
    mustBeExpanded: false.
	^substance collapse
)
public initiallyExpanded = (
  mustBeExpanded: true
)
) : (
)
public class MethodSubject onMethodModel: mm <MethodModel | ClassModel> = Subject onModel: mm (
(* Manages the UI for a method. *)
| 
public errorMessages <Set[String]> = Set new. 
public exemplars <List[String]> = computeExemplars.  
public exemplar <String>
evaluator_slot <EvaluationSubject>
workspace_slot <EvaluationSubject>
public threadMap <Map[Symbol, ThreadMirror| Error]> = Map new.
|
) (
public createPresenter ^ <Presenter> = (
	^MethodPresenter onSubject: self
)
public enclosingClasses ^ <List[ClassDeclarationMirror]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| 
	classes <List[ClassDeclarationMirror]> = List new.
	currentClass <ClassDeclarationMirror> ::= classDeclaration.
	|
	[currentClass isNil]
		whileFalse: [
			classes add: currentClass.
			currentClass:: currentClass enclosingClass
			].
	^classes
)
public messages   ^ <List[Symbol]> = (
  ^methodMirror selectors
)
public name ^ <Symbol> = (
	^methodMirror name
)
public source ^ <String> = (
	^methodMirror source
)
public clearErrors = (
  errorMessages removeAll: errorMessages
)
public delete = (
	| b <MixinBuilder> = methodMirror definingMixin asBuilder. |
	b methods removeMirrorNamed: methodMirror name.
	ide installFromBuilders: {b declaration}
)
public compileSource: src <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <MethodBuilder> newMirror <MethodMirror> |
	builder:: methodMirror definingMixin asBuilder.
	newBuilder:: builder methods addFromSource: src.
	ide installFromBuilders: {builder declaration}.
	newMirror:: definingMixin methods findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public isKindOfMethodSubject ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfMethodSubject
)
public evaluator = (
  evaluator_slot isNil ifTrue: [
    | 
    activationMirror = (threadMap at: exemplar) suspendedActivation. 
    evalState = EvaluationViewState onModel: activationMirror.
   |
   evaluator_slot:: MethodEvaluatorSubject onModel: evalState.
   evaluator_slot initialSource: source.
  ].
  ^evaluator_slot
)
public addMethodWorkspace = (
   workspace
)
public hasMethodWorkspace ^ <Boolean>  = (
  ^workspace_slot isNil not
)
public workspace = (
  workspace_slot isNil ifTrue: [
    | 
    activationMirror = (threadMap at: exemplar) suspendedActivation. 
    evalState = EvaluationViewState onModel: activationMirror.
   |
   workspace_slot:: EvaluatorSubject onModel: evalState.
  workspace_slot initialSource: ''.
  ].
  ^workspace_slot
)
public threadForExemplar: e <String> ^ <ThreadMirror | Error> (* :exemplar1: threadForExemplar: 'definition' *) = (
   | 
   thread <ThreadMirror | Error> = threadMap at: e asSymbol ifAbsentPut: [processExemplar: e]. 
   |
   ^thread
)
public mirror ^ <MethodMirror> = (
	^model mirror
)
public enclosingScope ^ <ObjectMirror | Nil> = (
  (* Produce an object that will serve as the enclosing scope when displaying the method live *)
  ^mirror definingMixin isMeta ifTrue: [enclosingClassScope]  ifFalse: [enclosingInstanceScope]
)
public metadata ^ <Map[String, String]> = (
  ^methodMirror metadata
)
public accessModifier ^ <Symbol> = (
	^methodMirror accessModifier
)
public classDeclaration ^ <ClassDeclarationMirror> = (
	^methodMirror definingMixin declaration
)
public methodModel ^ <MethodModel | ClassModel> = (
  ^model
)
public methodMirror ^ <MethodMirror> = (
	^methodModel methodMirror
)
public enclosingInstanceScope ^ <ObjectMirror | Nil> = (
  | mirror <ObjectMirror | Nil> =  methodModel exemplar. |
  mirror isNil ifFalse: [^mirror].
  (* If no exemplar known, use the exemplar of the enclosing class *)
  ^computeExemplarFor: classDeclaration enclosing: nil
)
public processExemplar: e <String> ^ <ThreadMirror> (* :exemplar1: processExemplar: 'definition' *) = (
   | 
   ast =  (compiler parser parseExpression: e) statements first.
   selector = ast message selector.
   hasSelector = selector = methodMirror name.
   args <List[Object]> = ast message arguments collect: [:a <ExprAST> |  
     | argThread <ThreadMirror> = enclosingScope evaluate: (e copyFrom: a start to: a end). |
     argThread isBroken ifTrue: [currentWindow enterSubject: (ide debugging ThreadSubject onModel: argThread)].
     argThread result reflectee.
     ].
   thread <ThreadMirror> = 
     selector = methodMirror name 
       ifTrue: [enclosingScope sendSuspended: selector with: args]
       ifFalse: [enclosingScope evaluate: e]. 
   |
   thread isBroken ifTrue: [currentWindow enterSubject: (ide debugging ThreadSubject onModel: thread)].
   ^thread
)
computeExemplars ^ <List[String]> = (
  | 
  keys <Collection[String]> = metadata keys select: [:k <String> | k startsWith: 'exemplar']. 
  es <List[String]> = List new. 
  |
  (metadata includesKey: 'no_exemplars') ifTrue: [^es].
  keys do: [:k <String> |  es add: (metadata at: k)].  
  exemplar:: es isEmpty 
    ifTrue: [(Utilities isInstantiableUnarySelector: name) ifTrue: [es add: name]]
    ifFalse: [es first].
  ^es
)
public enclosingClassScope ^ <ObjectMirror | Nil> = (
  | mirror <ObjectMirror | Nil> =  methodModel exemplar. |
  mirror isNil ifFalse: [^(mirror evaluate: #class) result].
  (* If no exemplar known, use the class object of the exemplar of the enclosing class, if any *)
  ^[((computeExemplarFor: classDeclaration enclosing: nil) evaluate: #class) result]
       on: Error do: [:e | ('Noclass exemplar for method ', name, ' in class ', classDeclaration name, ' ', e printString) out. ^nil].
)
) : (
public onModel: m <MethodMirror | ClassDeclarationMirror> = (
  ^onMethodModel: (MethodModel method: m exemplar: nil)
)
public fromModel: mm <MethodModel> ^ <Instance> = (
  ^onMethodModel: mm
)
)
class MirrorGroupPresenter onSubject: s <Subject> = DefinitionListPresenter onSubject: s (
) (
createPresenterForSubject: aSubject <Subject> ^ <ProgrammingPresenter> = (
	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)
	nil = elementPresenterClass ifTrue: [^aSubject presenter].
	^elementPresenterClass onSubject: aSubject
)
definitionListMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	(* A subclass must redefine this to define the class of presenter it will be using. *)
	subclassResponsibility
)
contentPresenters ^ <Collection[ProgrammingPresenter]> = (
	^(subject elements collect:
		[:each <Subject> | createPresenterForSubject: each]) 
        sort: [:p1 <ProgrammingPresenter> :p2 <ProgrammingPresenter> | 
            lexicallyLessOrEqual: p1 subject name than: p2 subject name
          ]
)
) : (
)
class MirrorGroupSubject onModel: m <MirrorGroupModel> = ProgrammingSubject onModel: m (
	| elements_slot <Collection[Subject]> |
) (
public exemplar = (
  ^model exemplar
)
public definingMixin ^ <MixinMirror> = (^ model definingMixin)
elementSubjectClass = (
	(* Answer the class of the subjects we create on individual elements of our subject group. *)
	subclassResponsibility
)
public isKindOfMirrorGroupSubject ^ <Boolean> = (
  ^true
)
public mirrorGroup ^ <MirrorGroup> = (
	^model mirrorGroup
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^subclassResponsibility
)
elementModelClass = (
	(* Answer the class of the models we create for individual elements of our subject group. *)
	subclassResponsibility
)
public elements ^<Collection[Subject]> = (
	(* Answer a collection of subjects on individual elements of the group which is our subject. *)
    elements_slot isNil ifTrue: [
	 elements_slot::  modelMirrorCollection collect: [:each | elementSubjectClass fromModel: (elementFor: each)].
     ^elements_slot
     ].
   updateElements.
   ^elements_slot
)
elementFor: m <Mirror> = (
	^subclassResponsibility
)
updateElements = (
  |
  subjectMirrors <List[Mirror]> = elements_slot collect: [:e <Subject> |
    e model mirror
  ].
  obsoleteSubjects <List[Subject]> = List new.
  |
  elements_slot do: [:s <Subject> |
    (modelMirrorCollection includes: s model mirror) ifFalse: [obsoleteSubjects add: s].
  ].
  obsoleteSubjects do: [:s <Subject> | elements_slot remove: s].
  modelMirrorCollection do: [:m <Mirror> |
    (subjectMirrors includes: m) ifFalse: [
      elements_slot add: (elementSubjectClass fromModel: (elementFor: m))
      ].
  ].
)
) : (
)
class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (
) (
class ClassEntryPresenter onSubject: s <ClassSubject> = outer Browsing ClassEntryPresenter onSubject: s () (
accessIndicator = (
	^nothing
)
entryActionsMenu = (
	^dropDownMenu: [entryActionsMenuFor: subject name].
)
) : (
)
class NamespaceEntryPresenter onSubject: s = EntryPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
        defaultBlank.
		(image: ide images classPresenterIcon)
            height: styleButtonSize.
		defaultBlank.
		row: {link: subject key action: [
			(*ide defaultPopularityRecord
			rememberNamespaceVisit: subject key. (* Should be the namespace itself, but non-strings break the home page. *)*)
			enterSubject:: subject refreshmentSubject]}.
	} row2: {
		(label: subject summaryText)
				smallFont;
				compressibility: 1;
				color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject key]
	}.
)
expandedDefinition = (
	^subject presenter
)
public tag ^ <String> = (
  ^subject key
)
) : (
)
class ValueEntryPresenter onSubject: s = EntryPresenter onSubject: s (|
	public key
|) (
collapsedDefinition = (
	^row1: {
        defaultBlank.
		(image: ide images classUnknownIcon)
            height: styleButtonSize.
		defaultBlank.
		link: key action: [enterSubject:: subject].
	} row2: {
		(label: subject title)
			smallFont;
			compressibility: 1;
			color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: key]
	}
)
definition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^collapsed: [collapsedDefinition]
	expanded: [subject presenter selfCaption: key]
)
expandedDefinition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^subject presenter selfCaption: key
)
public isKindOfValueEntryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfValueEntryPresenter
)
public tag ^ <String> = (
  ^key
)
) : (
)
class DocumentEntryPresenter onSubject: s <ObjectSubject> = EntryPresenter onSubject: s (
) (
public isKindOfDocumentEntryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfDocumentEntryPresenter
)
public tag ^ <String> = (
  ^(subject evaluate: #name) result reflectee
)
documentSubject = ( (* should be cached *)
  ^ide documents DocumentSubject onModel: subject objectMirror reflectee
)
expandedDefinition = (
	^subject presenter
)
collapsedDefinition = (
	^row1: {
         defaultBlank.
        (image: ide images ampleforthDocument)
            height: styleButtonSize.
         defaultBlank.         
         row: {link: tag action: [enterSubject:: subject]}
         }
       row2: {
         filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: tag]}
)
) : (
)
acceptNewClassDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[updateGUI: [prefixState removePrefix: aTemplate]]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
addButton = (
		^(*subject namespace isKindOfCategoryNamespace
				ifTrue: [*)addButtonWithMenu: [addCategoryMenu](*]
				ifFalse: [addButtonWithAction: [respondToAddForRoot]]*).
)
contentList ^ <PresenterList> = (
	^zebra: super contentList
)
contentPresenters ^ <List[Presenter]> = (
	| lexicalOrder <[:Symbol :Symbol | Boolean]> |
	lexicalOrder:: [:a <Symbol> :b <Symbol> |
		lexicallyLessOrEqual: a than: b
	].
	^(subject namespace keys asArray sort: lexicalOrder) collect: [:key | presenterForEntryAt: key]
)
definitionListMenu = (
  ^namespaceMenu
)
entryActionsMenuFor: key = (
	^menuWithLabelsAndActions: {
		{'Remove ', key. [updateGUI: [ide namespacing removeKey: key.]]}.
	}
)
public isKindOfNamespacePresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfNamespacePresenter
)
respondToAddForRoot = (
	openMenuWithLabelsAndActions: {
		{'Add Namespace'. [addNamespaceTemplate]}.
	}
)
respondToAddImage = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key form |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		form:: PNGReadWriter formFromFileNamed: fn.
		subject namespace at: key asSymbol put: form.
	].
)
respondToAddText = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key text |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		text:: ((MultiByteFileStream oldFileNamed: fn)
			converter: (TextConverter newForEncoding: 'utf8')) contents.
		subject namespace at: key asSymbol put: text.
	].
)
public tag ^ <String> = (
  ^title
)
public title = (
  ^subject key (*asText allBold*)
)
respondToCompileFiles = (
   multipleFileChooser chooseFileList: [:fl | 
	    subject compileFiles:  fl
		ifSuccess:
			[updateGUI: []]
		ifFailure:
			[:msg | alert: msg. nil]
	]
)
listDescription ^ <String> = (
  ^'namespace'
)
addClassTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock:
				[:text <String> :cm <CodeMirrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]])].
)
addNamespaceTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new namespace:'
			initialText: 'NewNamespace'
			colorizerBlock:
				[:text <String> :cm <CodeMirrorFragment> | ]
			acceptResponse:
				[:template | acceptNewNamespaceDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]])].
)
addDocumentTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new document named:'
			initialText: 'MyDocument'
			colorizerBlock:
				[:text <String> :cm <CodeMirrorFragment> | ]
			acceptResponse:
				[:template | acceptNewDocumentDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]])].
)
addCategoryMenu = (
	^ {
		{'Add Class'. [addClassTemplate]}.
		{ 'Add Namespace'. [addNamespaceTemplate]}.
        { 'Add Document'. [addDocumentTemplate]}.
		(*{'Add Image From File'. [respondToAddImage].}.
		{'Add Text From File'. [respondToAddText]}.
		 'Add Value' -> [Error signal: 'Unimplemented']. *)
	}
)
presenterForEntryAt: key <Symbol> ^ <EntryPresenter> = (
	| 
    entry = subject namespace at: key. 
    s <Subject> = subject namespaceSubjects at: key.
    |
	entry isKindOfBehavior
		ifTrue: [^ClassEntryPresenter onSubject: s].

	entry isKindOfNamespace
		ifTrue: [^NamespaceEntryPresenter onSubject: s].
        
	entry isKindOfDocument
		ifTrue: [^DocumentEntryPresenter onSubject: s].    

	^(ValueEntryPresenter onSubject: s) key: key
)
respondToLoadDocuments = (
   multipleFileChooser chooseFileList: [:fl | 
	    subject loadDocuments:  fl
		ifSuccess:
			[updateGUI: []]
		ifFailure:
			[:msg | alert: msg. nil]
	]
)
namespaceMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}.
		#separator.
		{'Compile File(s)'. [respondToCompileFiles]}.
		{'Load Document(s)'. [respondToLoadDocuments]}        
	}
)
elementDescription ^ <String> = (
  ^'names at either the IDE top level (Root) namespace or of an enclosed namespace'
)
buttonListHelp  ^<String>= (
^'<li><div class = "addButton"></div> The add button, which brings up a menu of options to add an element to the namespace. One can add a class, a namespace or a document.</li>
', super buttonListHelp
)
acceptNewDocumentDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addDocumentNamed: aTemplate text
		ifSuccess:
			[updateGUI: [prefixState removePrefix: aTemplate]]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
acceptNewNamespaceDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addNamespaceFromDefinition: aTemplate text
		ifSuccess:
			[updateGUI: [prefixState removePrefix: aTemplate]]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
) : (
)
public class NamespaceSubject onModel: m <Map[Symbol, Object]> key: k <Symbol> = ProgrammingSubject onModel: m (
|
	public key = k.
    namespaceSubjects_slot
|
ide namespacing refreshCategoryNamespaces
) (
public = other ^<Boolean> = (
	^other isKindOfNamespaceSubject
		and: [namespace = other namespace
		and: [key = other key]].
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
	|
	slot1
	slot2
	|
) ()'
)
public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment>  = (
	^ide colorizer
		colorizeClassDeclaration: source
		fromClass: nil
		via: (colorizingBlockFor: cm)
)
public createPresenter ^ <NamespacePresenter> = (
	^NamespacePresenter onSubject: self
)
public hash ^<Integer> = (
	^model hash bitXor: key hash
)
public isKindOfNamespaceSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfNamespaceSubject
)
public namespace ^ <Map[Symbol, Object]> = (
	^self model
)
public refreshmentSubject = (
	^self class onModel: model key: key
)
public summaryText = (
	| sb = StringBuilder new. |
	namespace keys
		do: [:k | sb add: k]
		separatedBy: [sb add: ', '].
	^sb asString
)
public title ^<String> = (
	^key
)
public compileFiles: fs <List[Alien[File]]> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:List[String]]> = (
  | ps <List[Alien[Promise[[String]]]]>  = JSArray new: fs size. |
  1 to: fs size do: [:i <Integer> | ps at: i - 1 put: (fs at: i) text].
  (JSPromise all: ps) then: [:sources <JSArray[String]> |
	  [|  mixins <List[MixinMirror]> bs <List[ClassDeclarationBuilder]> = List new: fs size. |
	  0 to: fs size - 1 do: [:i <Integer> |
          bs add: (ClassDeclarationBuilder fromUnitSource: (sources at: i))
		  ].
        mixins:: ide installFromBuilders: bs into: namespace.
        mixins do: [:m <MixinMirror> | namespace at: m name ifAbsent: [namespace at: m name put: m declaration applyToObject reflectee]].
        successBlock value.] on: Error do:  [:ex | failureBlock value: ex printString]
	] onError: [:ex | failureBlock value: ex printString].
)
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| builder <ClassDeclarationBuilder> klass |
	[builder:: ClassDeclarationBuilder fromSource: definition]
		on: Error
		do: [:ex | ^failureBlock value: ex printString].
	(namespace includesKey: builder name) ifTrue:
		[^failureBlock value: 'A class named ', builder name, ' already exists in this namespace'].
	klass:: (ide installFromBuilders: {builder}) first declaration applyToObject.
	namespace at: klass mixin name put: klass reflectee.
	successBlock value
)
public namespaceSubjects ^ <Map[Symbol, Subject]> = (
  namespaceSubjects_slot isNil ifTrue: [
      namespaceSubjects_slot:: Map new.
      namespace keysAndValuesDo: [:k :v |
         namespaceSubjects_slot at: k put: (subjectFor: v key: k)
      ]
  ].
  updateNamespace.
  ^namespaceSubjects_slot
)
subjectFor: entry key: k <Symbol> ^ <Subject> = (
  	entry isKindOfBehavior
		ifTrue: [^ClassSubject onDeclaration: (ClassMirror reflecting: entry) mixin declaration].

	entry isKindOfNamespace
		ifTrue: [^NamespaceSubject onModel: entry key: k].

	^presenter objectSubjectFor: entry
)
updateNamespace = (
  |
  obsoleteSubjectKeys <List[Symbol]> = List new.
  |
  namespaceSubjects_slot keys do: [:k <Symbol> |
    (namespace includesKey: k) ifFalse: [obsoleteSubjectKeys add: k].
  ].
  obsoleteSubjectKeys do: [:k <Symbol> | namespaceSubjects_slot removeKey: k].
  namespace keysAndValuesDo: [:k <Symbol> :v  |
    (namespaceSubjects_slot includesKey: k) ifFalse: [
      namespaceSubjects_slot at: k  put: (subjectFor: v key: k)
      ].
  ].
)
public loadDocuments: fs <List[Alien[File]]> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:List[String]]> = (
  | ps <List[Alien[Promise[[String]]]]>  = JSArray new: fs size. fns <Array[String]> = Array new: fs size.  |
1 to: fs size do: [:i <Integer> |
  | file <Alien[File]> = fs at: i. |
  ps at: i - 1 put: file text.
  fns at: i put: (file at: #name)
  ].
  (JSPromise all: ps) then: [:sources <JSArray[String]> |
	  [| bs <List[Document]> = List new: fs size. |
	  0 to: fs size - 1 do: [:i <Integer> |
         | fn = (fns at: i+1).  dn = fn copyFrom: 1 to: (fn indexOf: '.') - 1. |
          bs add: (ide documents freshDocumentWithContents: (sources at: i))
		  ].
        bs do: [:b <Document> | namespace at: b name put: b].
        successBlock value.] on: Error do:  [:ex | failureBlock value: 'Failure: ', ex printString]
	] onError: [:ex | failureBlock value: 'Error: ', ex printString].
)
public addNamespaceFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| selector <Symbol> = definition asSymbol. |
	(*model = ide namespacing Categories ifFalse: (* ? *)
		[Error signal: 'Not supported yet, only categories for now.'].*)
	(namespace includesKey: selector) ifTrue:
		[^failureBlock value: 'A class named ', definition, ' already exists in this namespace'].
	(* ide namespacing categoryNamespace: selector.*)
	namespace at: selector put: (ide namespacing freshNamespace).
	successBlock value
)
public addDocumentNamed: n <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| docName <Symbol> = n asSymbol. |
	(namespace includesKey: docName) ifTrue:
		[^failureBlock value: 'An entry named ', n, ' already exists in this namespace'].
	[namespace at: docName put: (ide documents freshDocumentNamed: docName)] on: Error do: [:e |  ^failureBlock value: 'Document name must be a valid Newspeak identifier'].
	successBlock value
)
) : (
public new = (
	#NAMESPACEBOGUS.
	^self onModel: ide namespacing Root key: 'Root'
)
)
class NestedClassGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, a NestedClassGroupSubject, as a column of presenters for the nested classes in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS nested classes goes here. *)
) (
public deleteClassInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteClassWithSubject: presenter subject.
	successResponse value
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^ClassEntryPresenter
)
public title = (
  ^'Classes'
)
public addNewItemTemplate = (
   addNewItemTemplate: subject classTemplateText
)
public addNewItemTemplate: src <String> = (
	(* Handle a user's request to create a new nested class by displaying a new class template
      based on src. *)
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [ prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: src
			colorizerBlock:
				[:text <String> :cm <CodeMirrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]]).
			]
)
listDescription ^ <String> = (
  ^'nested class'
)
elementDescription ^ <String> = (
  ^'nested classes of the surrounding class'
)
acceptNewClassDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[:newClass <ClassDeclarationMirror> |
			updateGUI: [
				prefixState removePrefix: aTemplate
				]
			]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
) : (
)
public class NestedClassGroupSubject onModel: m <MirrorGroupModel[ClassDeclarationMirror]> = MirrorGroupSubject onModel: m (
(* Represents the collection of nested classes of a Newspeak class. Holds onto the mirror group for the classes. *)
) (
elementFor: m <Mirror> = (
	^ClassModel declaration: m exemplar: nil enclosing: exemplar
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
	|
	slot1
	slot2
	|
) ()'
)
public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment> = (
	^ide colorizer
		colorizeClassDeclaration: source
		fromClass: definingMixin declaration
		via: (colorizingBlockFor: cm)
)
public createPresenter = (
	^NestedClassGroupPresenter onSubject: self
)
elementSubjectClass ^ <ClassSubject class> = (
	^ClassSubject
)
public isKindOfNestedClassGroupSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfNestedClassGroupSubject
)
public addClassFromDefinition: source <String> ifSuccess: successBlock <[:ClassDeclarationMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <ClassDeclarationBuilder> newMirror <ClassDeclarationMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder nestedClasses addFromSource: source.
	ide installFromBuilders: {builder declaration}.
	newMirror:: definingMixin nestedClasses findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public deleteClassWithSubject: classSubject <ClassSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder nestedClasses removeMirrorNamed: classSubject name.
	ide installFromBuilders: {builder declaration}
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^List withAll: definingMixin nestedClasses
)
elementModelClass ^ <ClassModel class> = (
	^ClassModel
)
) : (
)
class ObjectPresenter onSubject: s = ProgrammingPresenter onSubject: s  (
	|
	public selfCaption ::= 'self'.
    public openClass <Boolean> ::= false.
    classPresenter <ClassPresenter>
	|
) (
captionBar: body = (
	^(padded: body with: {5. 5. styleHeaderPadRight. 5}) color: captionColor
)
enclosingInfoLine = (
	^row: {
		(label: 'enclosingObject')
			width: 0 elasticity: 1.
		(link: subject enclosingObjectName action: [navigateToEnclosingObject])
			width: 0 elasticity: detailAreaRatio.
	}
)
public isKindOfObjectPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfObjectPresenter
)
navigateToClass = (
	enterSubject: subject classSubject.
)
navigateToEnclosingObject = (
inspectObjectMirror: subject classMirror enclosingObject
)
navigateToSelf = (
	enterSubject: subject
)
respondToInspectMirror = (
	inspectObject: subject objectMirror.
)
public title = (
	^'Inspector on ', subject title
)
selfInfoLine = (
	^row: {
		(label: selfCaption) 
            bold
            width: 0 
            elasticity: 1.
		(row: {
			(link: subject title action: [navigateToSelf]) compressibility: 1.
			filler compressibility: 0.
			mediumBlank.
            helpButton.
			dropDownMenu: [actionsMenu].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public definition = (
	^column: {
        helpSection.
		captionBar: (column: {
			selfInfoLine.
			enclosingInfoLine.
			classInfoLine.
			smallBlank.
			subject evaluator presenter
		}).
		objectDetails.
	}
)
classInfoLine = (
		^row: {classExpansionLink}
)
availableObjectViews  ^ <List[Presenter]> = (
(* Return a list of presenters that are available for the object we
are presenting. *)
   | 
   (* The list of available viewers we'll return *)
   viewClasses <Set[Presenter class]> = List new.
   (* A set of viewers already in the result, so we avoid duplicates *)
   alreadySeen <Set[Presenter]> = Set new. 
   |

  (* traverse all views, prioritizing by kind *)
   objectViews keysAndValuesDo: [:k <Symbol>  :v <List[Presenter]> |
     | supported <Boolean> = (subject evaluate: k) result reflectee. |
     (* if the object is of kind k, add the views for k *)
     supported ifTrue: [
        v do: [:vu <Presenter> | (* eliminate duplicates before adding vu *)
	               (alreadySeen includes: vu) ifFalse: [
                     viewClasses add: vu.
                     alreadySeen add: vu
                   ]
                 ]
     ]
   ].
   
   (* We always support the default view *)
   viewClasses add: BasicView.
   (* compute presenters for this object based on the identified classes *)
   ^viewClasses collect: [:v <Presenter class> | v onSubject: subject]
)
objectDetails = (
	| views = availableObjectViews. currentView switchers |
	views size = 1 ifTrue: [^views first].
	currentView:: holder: ( 
      subject preferredViewName isNil 
        ifTrue: [
          subject  preferredViewName: views first title.
	  views first
          ] ifFalse: [views detect: [:v | v title = subject preferredViewName] ifNone: [views first]]).
	switchers:: List new.
	views do:
		[:view |
		 switchers add: mediumBlank.
		 switchers add: ((link: '[', view title, ']' action: [subject preferredViewName: view title. currentView content: view]) color: actionLinkColor)].
	^column: {
		row: switchers.
		currentView.
	}
)
classExpansionLink = (
  ^(collapsed: [row: {(label: 'class')
			width: 0 elasticity: 1.
            (link: subject className action: [navigateToClass])
               width: 0 elasticity: detailAreaRatio.
            }]
      expanded: [column: {
            row: {filler. (label: 'class') bold. filler}.
            classPresenter:: (ClassPresenter onSubject: subject classSubject) elasticity: detailAreaRatio. 
            }
            ]
      initiallyExpanded: openClass)
			width: 0 elasticity: detailAreaRatio.
)
public instanceMethodsPresenter ^ <MethodGroupPresenter> = (
  ^classPresenter  isNil ifFalse: [classPresenter instanceMethodsPresenter]
)
public classMethodsPresenter ^ <MethodGroupPresenter> = (
  ^classPresenter  isNil ifFalse: [classPresenter classMethodsPresenter]
)
public lazySlotsPresenter ^ <MethodGroupPresenter> = (
  ^classPresenter  isNil ifFalse: [classPresenter lazySlotsPresenter]
)
public nestedClassesPresenter ^ <NestedClassGroupPresenter> = (
  ^classPresenter  isNil ifFalse: [classPresenter nestedClassesPresenter]
)
helpText ^ <Fragment> = (
  | mapping = Map new. |
  mapping 
    at: #classExpander put: classExpansionLink.
  
  ^ampleforth: 'This is an object presenter (aka  inspector).  At the top you''ll see its description, a link to the object''s enclosing object, and an expandable link to its class: <div class="classExpander"> </div> Expanding it in place allows you to see the class in the context of the instance, which can be very handy.
  <br><br>
  You can enter and evaluate Newspeak expressions in the evaluator pane below the class link/expanded class. See the evaluator''s help section for details. Below the evaluator you will typically see the slots of the object listed; this the basic view of objects. Some objects, such as integers or strings, have customized views. An object can have multiple views (and you can define new views as well). If there are multiple views, tab links appear underneath the results list, and you can select between them.
' mapping: mapping
)
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Mirror'. [respondToInspectMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
        {'Make DoIt Button'. [subject evaluator presenter respondToMakeButton]}.
	}
)
) : (
)
public class ObjectSubject onModel: m <ObjectMirror> evaluator: e <EvaluationViewState> 
(* :exemplar: ObjectSubject onModel: (ObjectMirror reflecting: self) *)
= ProgrammingSubject onModel: m (
  | 
  public evaluator <EvaluatorSubject> = EvaluatorSubject onModel: e. 
  slotMap <Map[Symbol, SlotSubject]> ::= Map new.
  lazySlotMap <Map[Symbol, SlotSubject]> ::= Map new.
  public preferredViewName <String>
  classSubject_slot <ClassSubject>
  |
) (
public = another <Object> ^<Boolean> = (
	^(another isKindOfObjectSubject) and:
		[objectMirror = another objectMirror]
)
public classMirror ^<ClassMirror> = (
	^model getClass
)
public className ^<String> = (
	^classMirror mixin name
)
computeSlots = (
  | 
  newMap <Map[Symbol, SlotSubject]> = Map new.
  slotList<List[SlotSubject]> =   classMirror slots collect: [:slot <SlotDeclarationMirror> |  
	newMap at: slot name put: (slotSubjectFor: slot)
	].
  |
  slotMap:: newMap.
  ^slotList
)
public createPresenter = (
	^ObjectPresenter onSubject: self
)
public enclosingObjectName = (
	^classMirror enclosingObject reflectee printString
)
public evaluate: expression <String> ^<ThreadMirror> = (
	(* The IDE provides ambient access to the platform object during development. *)
	| scope <Map[Symbol, ObjectMirror]> = Map new. |
	scope at: #_ put: (ObjectMirror reflecting: cachedPlatform).
	^objectMirror evaluate: expression with: scope
)
public hash ^<Integer> = (
	^self class hash bitXor: objectMirror hash
)
public isKindOfObjectSubject = (
  ^true
)
public isModelKindOfArray ^<Boolean> = (
	^classMirror = (ClassMirror reflecting: Array)
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfObjectSubject
)
public objectMirror ^<ObjectMIrror> = (
	^model
)
public slots ^ <Sequence[SlotSubject]> = (
	(* Arrays have slots that aren't defined by their class. *)
	(* :todo: Push this down to `ObjectMirror slots` because which classes this applies to is implementation specific. *)
	isModelKindOfArray ifTrue:
		[^computeArraySlots].
      ^computeSlots.
)
public title = (
	^objectMirror reflectee printString
)
slotSubjectForKey: k <Object> withValue: v <Object> ^ <SlotSubject> = (
  | 
  name = 'at: ', k printString.
  val <ObjectMirror> = ObjectMirror reflecting: v. 
  entry <SlotSubject> ::= slotMap at: name ifAbsentPut: [
    SlotSubject name: name value: val
    ].
  |
  val = entry objectMirror ifFalse: [
    entry:: slotMap at: name put: (SlotSubject name: name value: val)
    ].
  ^entry
)
public keysAndValues ^<Collection[SlotSubject]> = (
	| result |
	result:: List new: objectMirror reflectee size.
	objectMirror reflectee keysAndValuesDo:
		[:key :value | result add:
			(slotSubjectForKey: key printString
				withValue: value)].	
	^result
)
allMixinsOf: c <ClassMirror> ^ <List[MixinMirror]> = (
  (* Return mirrors on all mixins of c, in superclass chain order,  subclasses first *)
  c isNil ifTrue: [^List new].
  ^(allMixinsOf: c superclass) addFirst: c mixin; yourself
)
kindOfSelectorsForMixin: mixinMirror <MixinMirror> ^ <List[String]> = (
(* Get the isKindOf selectors of mixinMirror. If there are several, make sure that one specific to the mixin,
    if defined,  is placed first in the result.
*)
  | 
  result = (mixinMirror methods select: [:m <MethodMirror> |
      (1 = (m name indexOf: 'isKindOf'))
    ]) collect: [:m <MethodMirror> | m name].
    mostSpecific = 'isKindOf', mixinMirror name.
 |
 result remove: mostSpecific ifAbsent: [].
 result addFirst: mostSpecific asSymbol.
 ^result   
)
public kindOfSelectors  ^ <List[String]> = (
(*
  Produce a list of the isKindOf selectors of the class of the model's reflectee,
  in superclass chain order,  subclasses first. If any mixin in the chain has several,
  those are ordered among themselves by kindOfSelectorsForMixin.
*)
 | result <List[String]> = List new. |
 (allMixinsOf: classMirror) do: [:m <MixinMirror> |
        (kindOfSelectorsForMixin: m) do: [:s <Symbol> | 
          ((Message selector: s arguments: {}) sendTo: objectMirror reflectee) ifTrue: [result add: s]
        ]
    ].
  ^result
)
public classSubject ^ <ClassSubject> = (
    classSubject_slot isNil ifTrue: [
      classSubject_slot:: ClassSubject onClassModel: (ClassModel declaration: classMirror mixin declaration exemplar: objectMirror)
    ].
	^classSubject_slot
)
computeLazySlots = (
  | 
  newMap <Map[Symbol, SlotSubject]> = Map new.
  slotList<List[SlotSubject]> =   classMirror lazySlots collect: [:slot <LazySlotMirror> |  
	newMap at: slot name put: (lazySlotSubjectFor: slot)
	].
  |
  lazySlotMap:: newMap.
  ^slotList
)
lazySlotSubjectFor: slot <LazySlotMirror> ^ <SlotSubject> = (
  | 
  val <ObjectMirror> = objectMirror getLazySlot: slot name. 
  entry <SlotSubject> ::= lazySlotMap at: slot name ifAbsent: [
    SlotSubject name: slot name value: val
    ].
  |
  val = entry objectMirror ifFalse: [
    entry:: SlotSubject name: slot name value: val
    ].
  ^entry
)
lazySlotSubjectForKey: k <Object> withValue: v <Object> ^ <SlotSubject> = (
  | 
  name = 'at: ', k printString.
  val <ObjectMirror> = ObjectMirror reflecting: v. 
  entry <SlotSubject> ::= lazySlotMap at: name ifAbsentPut: [
    SlotSubject name: name value: val
    ].
  |
  val = entry objectMirror ifFalse: [
    entry:: slotMap at: name put: (SlotSubject name: name value: val)
    ].
  ^entry
)
public lazySlots = (
  ^computeLazySlots
)
arraySlotSubjectFor: index <Integer> ^ <IndexSlotSubject> = (
  | 
  name =  index asString. 
  entry <IndexSlotSubject> ::= slotMap at: name ifAbsent: [
    IndexedSlotSubject index: index ofObject: objectMirror
    ].
  |
  ^entry
)
arraySlotSubjectFor: index <Integer> value: val <ObjectMirror> = (
  | 
  name =  index asString. 
  entry <SlotSubject> ::= slotMap at: name ifAbsent: [
    IndexedSlotSubject index: index ofObject: objectMirror
    ].
  |
  val = entry slotValueMirror ifFalse: [
    entry:: IndexedSlotSubject index: index ofObject: objectMirror
    ].
  ^entry
)
computeArraySlots = (
  | 
  array = objectMirror reflectee.
  variableLengthSlots = Array new: array size.
  newMap <Map[Symbol, IndexSlotSubject]> = Map new.
  |
  1 to: array size do: [:index | | slot <IndexSlotSubject> |
	      slot:: arraySlotSubjectFor: index value: (ObjectMirror reflecting: (array at: index)).
	      newMap at: slot name put: slot.
		variableLengthSlots at: index put: slot
		].
				
  slotMap:: newMap.
  ^variableLengthSlots
)
slotSubjectFor: slot <SlotDeclarationMirror> ^ <SlotSubject> = (
  | 
  val <ObjectMirror> = objectMirror getSlot: slot name. 
  entry <SlotSubject> ::= slotMap at: slot name ifAbsent: [
    ObjectSlotSubject name: slot name ofObject: objectMirror
    ].
  |
  val = entry objectMirror ifFalse: [
    entry:: ObjectSlotSubject name: slot name ofObject: objectMirror
    ].
  ^entry
)
) : (
public onModel: m  = (
  ^onModel: m evaluator: (EvaluationViewState onModel: m)
)
public onEvaluator: e <EvaluationViewState>  = (
  ^onModel: e mirror evaluator: e
)
)
public class ProgrammingPresenter onSubject: s <Subject> = Presenter onSubject: s (
(* Common superclass for presenters of programming constructs. *)
) (
actionLinkColor = (
	^Color black
)
addButtonWithAction: aBlock = (
	^(imageButton: ide images addImage action: aBlock)
        height: styleButtonSize
)
addButtonWithMenu: menu = (
	^dropDownMenu: menu image: ide images addImage
)
browseSelector: selector = (
	enterSubject: (SelectorSubject onModel: selector)
)
collapseButtonWithAction: aBlock = (
	^(imageButton: ide images collapseImage action: aBlock)
        height: styleButtonSize
)
expandButtonWithAction: aBlock = (
	^(imageButton: ide images expandImage action: aBlock)
        height: styleButtonSize
)
indentedBlock: body = (
	^column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		}
)
inspectObject: object <Object> = (
	enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: object).
)
inspectObjectMirror: object <ObjectMirror> = (
	enterSubject:: ObjectSubject onModel: object.
)
itemReferencesButtonWithAction: aBlock = (
	^(imageButton: ide images itemReferencesImage action: aBlock)
        height: styleButtonSize
)
saveButtonWithAction: aBlock = (
	^(imageButton: ide images downloadImage action: aBlock)
        height: styleButtonSize
)
defaultBlank = (
	^blank: 3
)
largeBlank = (
	^blank: 20
)
majorHeadingBlock: body = (
	^(padded: body with: {10. 10. styleHeaderPadRight. 10.})
	color: majorHeadingColor
)
majorHeadingColor = (
	(* This color is used for major definitions such as class headings. *)
	^Gradient
		from: (Color h: 240 s: 0.05 v: 0.92)
		to: (Color h: 240 s: 0.05 v: 0.86)
)
minorHeadingBlock: body = (
	^(padded: body with: {10. 5. styleHeaderPadRight. 5.})
		color: minorHeadingColor
)
minorHeadingColor = (
	^Gradient
		from: (Color h: 240 s: 0.02 v: 0.94)
		to: (Color h: 240 s: 0.02 v: 0.9)
)
public objectSubjectFor: anObject = (
	^objectSubjectForMirror: (ObjectMirror reflecting: anObject)
)
objectSubjectForMirror: objectMirror <ObjectMirror> = (
	^ObjectSubject onModel: objectMirror
)
refreshButton = (
	^(imageButton: ide images refreshImage action: [shell refresh])
        height: styleButtonSize
)
respondToInspectPresenter = (
	inspectObject: self.
)
secondaryTextColor ^ <Color> = (
	^Color gray: 0.6
)
tertiaryTextColor = (
	^Color gray: 0.8
)
linkToBrowseSelector: selector = (    
    ^row: {
        defaultBlank.
	    link: selector action: [browseSelector: selector]
    }
)
linkToBrowseNamespace: ns key: key = (
	^row: {
        defaultBlank.
		(image: ide images classPresenterIcon)
            height: styleButtonSize.
		defaultBlank.
		link: key
		action: [enterSubject:: NamespaceSubject onModel: ns key: key]}.
)
linkToBrowseClass: aClass = (
    ^row: {
        defaultBlank.
	    link: aClass name action: [browseClass: aClass]
    }
)
accessIndicator: am <String> ^ <StaticImageFragment> = (
  ^(image: (iconForAccessModifier: am))
                                height: styleButtonSize
)
iconForAccessModifier: am <String> ^ <Alien[Image]> = (
	#private = am ifTrue: [^ide images privateAccessImage].
	#protected = am ifTrue: [^ide images protectedAccessImage].
	^ide images publicAccessImage
)
accessIndicator ^ <StaticImageFragment> = (
  ^accessIndicator: subject accessModifier
)
browseClass: klass <Behavior | ClassDeclarationMirror> = (
  | decl <ClassDeclarationMirror> = klass isKindOfClassDeclarationMirror ifTrue: [klass] ifFalse: [(ClassMirror reflecting: klass) mixin declaration]. |
	enterSubject:: ClassSubject onDeclaration: decl.
)
browseMixinMirror: mixin <MixinMirror> = (
	enterSubject:: ClassSubject onDeclaration: mixin declaration.
)
browseDocument: doc <Document | ObjectMirror> = (
  | m <ObjectMirror> = doc isKindOfObjectMirror ifTrue: [doc] ifFalse: [ObjectMirror reflecting: doc]. |
	enterSubject:: ObjectSubject onModel: m.
)
) : (
)
public class SelectorPresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
definition = (
^column: {
		implementorsPart.
		sendersPart
	}
)
public isKindOfSelectorPresenter ^ <Boolean> = (
  ^true
)
isMyKind: other <Subject> ^ <Boolean> = (
  ^other isKindOfSelectorPresenter
)
implementorsPart = (
	^partNamed: 'implementors' model: subject implementorList presenter
)
partNamed: t <String> model: m ^ <AssortedMethodListPresenter> = (
	^column: {
		majorHeadingBlock: (
				row: {
					label: subject selector.
					smallBlank.
					label: t.
				}).
		mediumBlank.
		row: {
				mediumBlank.
				elastic: m.
			}.
		mediumBlank.
		}
	)
sendersPart = (
	^partNamed: 'senders' model: subject senderList presenter
	)
) : (
)
public class SelectorSubject onModel: m = Subject onModel: m asSymbol (
(* Holds onto a selector (a Symbol) and retrieves its senders and implementors. *)
  |
   implementorList_slot <AssortedMethodsSubject>
   senderList_slot <AssortedMethodsSubject>
  |
) (
public createPresenter = (
	^SelectorPresenter onSubject: self
)
public isKindOfSelectorSubject ^ <Boolean> = (
  ^true
)
isMyKind: other <Subject> ^ <Boolean> = (
  ^other isKindOfSelectorSubject
)
public selector = (
	^model
)
public title = (
	^selector printString
)
public senderList ^ <AssortedMethodsSubject> = (
  senderList_slot isNil ifTrue: [
    senderList_slot:: AssortedMethodsSubject onModel: senderSubjects
  ].
  updateSenders.
  ^senderList_slot
)
public implementorList ^ <AssortedMethodsSubject> = (
  implementorList_slot isNil ifTrue: [
    implementorList_slot:: AssortedMethodsSubject onModel: implementorSubjects
  ].
  updateImplementors.
  ^implementorList_slot
)
elementSubjectForModel: m <MethodModel | ClassModel> ^ <MethodSubject | LazySlotSubject | ClassFactorySubject>  = (
  ^m isKindOfMethodModel ifTrue: [MethodSubject onMethodModel: m] 
				ifFalse: [
                  m isKindOfClassModel 
                     ifTrue: [ClassFactorySubject onClassModel: m]
                      ifFalse: [LazySlotSubject onLazySlotModel: m]
                  ]
)
public senderSubjects ^ <Collection[MethodSubject | LazySlotSubject | ClassFactorySubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^senders collect: [:each <MethodModel | LazySlotModel | ClassModel> |
			elementSubjectForModel: each
            ]
)
implementors ^ <List[MethodModel | LazySlotModel | ClassModel]> = (
	(* Answer a collection of implementors of our selector (as MethodReferences). *)
  	| results <List[MethodModel | LazySlotModel | ClassModel]> = List new. |
	systemScope implementorsOf: selector do: [:mirror <MethodMirror | LazySlotMirror | ClassDeclarationMirror>  | 
		results add: (
          mirror isKindOfMethodMirror 
                ifTrue: [MethodModel method: mirror exemplar: nil] 
				ifFalse: [mirror isKindOfClassDeclarationMirror 
                                 ifTrue: [ClassModel declaration: mirror exemplar: nil]
                                 ifFalse: [LazySlotModel slot: mirror exemplar: nil]
                             ]
                )
		].
	^results
)
senders ^ <List[MethodModel | LazySlotModel | ClassModel]> = (
	(* Answer a collection of senders of our selector (as MethodReferences). *)
  	| results <List[MethodModel | LazySlotModel | ClassModel]> = List new. |
	systemScope sendersOf: selector do: [:mirror <MethodMirror | LazySlotMirror | ClassDeclarationMirror> | 
		results add: (
          mirror isKindOfMethodMirror 
                ifTrue: [MethodModel method: mirror exemplar: nil] 
				ifFalse: [mirror isKindOfClassDeclarationMirror 
                                 ifTrue: [ClassModel declaration: mirror exemplar: nil]
                                 ifFalse: [LazySlotModel slot: mirror exemplar: nil]
                             ]
                )
		].
	^results
)
public implementorSubjects ^ <Collection[MethodSubject | LazySlotSubject | ClassFactorySubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^implementors collect: [:each <MethodModel | LazySlotModel | ClassModel> |
			elementSubjectForModel: each
            ]
)
updateImplementors = (
  |
  subjectModels <List[MethodModel | ClassModel]> = implementorList_slot model collect: [:e <MethodSubject | LazySlotSubject | ClassFactorySubject> | e model].
  obsoleteSubjects <List[MethodSubject | ClassFactorySubject]> = List new.
  |
  implementorList_slot model do: [:s <Subject> |
    (implementors includes: s model) ifFalse: [obsoleteSubjects add: s].
  ].
  obsoleteSubjects do: [:s <MethodSubject | LazySlotSubject | ClassFactorySubject> | implementorList_slot model remove: s].
  implementors do: [:m <MethodModel | LazySlotModel | ClassModel> |
    (subjectModels includes: m) ifFalse: [
      implementorList_slot model add: (elementSubjectForModel: m)
      ].
  ].
)
updateSenders = (
  |
  subjectModels <List[MethodModel | ClassModel]> = senderList_slot model collect: [:e <MethodSubject | LazySlotSubject | ClassFactorySubject> | e model].
  obsoleteSubjects <List[MethodSubject | ClassFactorySubject]> = List new.
  |
  senderList_slot model do: [:s <Subject> |
    (senders includes: s model) ifFalse: [obsoleteSubjects add: s].
  ].
  obsoleteSubjects do: [:s <MethodSubject | LazySlotSubject | ClassFactorySubject> | senderList_slot model remove: s].
  senders do: [:m <MethodModel | LazySlotModel |ClassModel> |
    (subjectModels includes: m) ifFalse: [
      senderList_slot model add: (elementSubjectForModel: m)
      ].
  ].
)
) : (
)
public class SlotPresenter onSubject: s <SlotSubject> = ProgrammingPresenter onSubject: s (
  | editorFragment |
) (
details ^<Fragment> = (
	^subject objectSubject presenter selfCaption: subject name
)
public isKindOfSlotPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfSlotPresenter
)
public setValue: expression <String> ifFail: failBlock = (
	subject setValue: expression ifCompilerError: failBlock ifError: failBlock value.
	refresh.
)
caption ^<Fragment> = (
	^row: {        
		(link: subject name action: [substance toggle])
			width: 0 elasticity: 1;
			color: actionLinkColor.
		smallBlank.
		(link: subject reflecteePrintString action: [inspectObjectMirror: subject slotValueMirror])
			width: 0 elasticity: detailAreaRatio.
	}
)
public definition ^<Fragment> = (
	^collapsed: [caption] expanded: [expandedDefinition]
)
public refresh = (
  details refresh.
  super refresh
)
setValue: expression <String> = (
(* so the issue is that this UI is now presenting, but SlotSubject has no access to the object it would modify.
It's just an accessor and a value stored, which isn't enough given that some slots may not have setters; we need it to have reflective access to the object holding the slot, which might be a list/map/array or an activation or lazy or the result of a thread.
So all these must create slot subjects with the right info and behavior before this can work.
*)
	subject
		setValue: expression
		ifCompilerError: [:msg | ^editorFragment editor showMessage: msg]
		ifError: [:thread <ThreadMirror> | enterSubject:: ide debugging ThreadSubject onModel: thread].
	editorFragment editor leaveEditState.
)
expandedDefinition ^ <Fragment> = (
	editorFragment:: (DefinitionTemplate
        caption: 'Set value for slot ', subject name
		initialText: 'new value for ', subject name
        colorizerBlock: [:text <String> :cm <CodeMirrorFragment> | ]
		acceptResponse: [:t | updateGUI: [setValue: t text asString]. refresh]
		cancelResponse: [:t | t editor defaultCancelResponse])
		initiallyInEditState: false.
	^column: {
		editorFragment.
		details.
	}
)
) : (
)
public class SlotSubject name: n value: v = Subject onModel: v (
	|
	public name = n.
	|
) (
public createPresenter = (
	^SlotPresenter onSubject: self
)
public hash ^ <Integer> = (
  ^model hash bitXor: name hash
)
public isKindOfSlotSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfSlotSubject
)
public objectMirror ^<ObjectMirror> = (
	^model
)
public = other <Object> ^ <Boolean> = (
  other isKindOfSlotSubject ifFalse: [^false].
  ^model = other model and: [name = other name].
)
public setValue: expression <String> ifCompilerError: compileFailBlock ifError: failBlock = (
	| 
    evalThread <ThreadMirror>
    |
	evalThread::
		[objectMirror evaluate: expression with: Map new]
          on: Error do: [:ce | compileFailBlock value: ce printString]. (* object scope? debugger? *)
              
	evalThread  isBroken (* so for runtime errors, the block should take a thread so it can open a debugger on it *)
       ifTrue: [failBlock value: thread] 
       ifFalse: [objectMirror setSlot: name to: evalThread result]
)
public slotValueMirror ^<ObjectMirror> = (
	^model
)
public reflecteePrintString = (
	^slotValueMirror reflectee printString
)
public objectSubject ^ <ObjectSubject> = (^ObjectSubject onModel: slotValueMirror)
) : (
)
class StringView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public definition = (
	| cm |
	cm:: codeMirror: subject objectMirror reflectee.
	cm readOnly: true.
	^column: {
		cm
	}
)
public isKindOfStringView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfStringView
)
) : (
)
public class EvaluatorPresenter onSubject: s <ObjectSubject | ActivationSubject> = ProgrammingPresenter onSubject: s (
| cm <CodeMirrorFragment> |
) (
deadChangeResponse = (
    ^[:editor <CodeMirrorFragment>  | 
        | src <String> =  editor textBeingAccepted. |
        ide colorizer colorizeDoIt: src fromClass: nil via: (colorizingBlockFor: editor).
        editor isInEditState: true.
        editor editor focus.
    ].
)
linkForCompileError: error <Exception> = (
	^column: {
		(link: error printString action:
			[inspectObjectMirror: (ObjectMirror reflecting: error)])
				color: (Color r: 1 g: 0 b: 0).
	}
)
linkForError: thread <ThreadMirror> = (
	^column: {
		(link: thread result reflectee printString action:
			[enterSubject:: ide debugging ThreadSubject onModel: thread])
				color: (Color r: 1 g: 0 b: 0).
	}
)
linkForEvaluation: r ^ <Fragment> = (
  r isKindOfError ifTrue: [:e | ^linkForCompileError: e].
  r isFulfilled ifTrue: [^linkForResult: r].
  r isBroken ifTrue: [^linkForError: r]. 
 'result is neither error nor fulfilled nor broken!' out.
)
linkForResult: r ^ <Fragment> = (
	^column: {
		(link: r result reflectee printString action:
			[enterSubject:: ObjectSubject onModel: r result]).
	}
)
linkForThread: thread <ThreadMirror> ^ <Fragment> = (
	thread isFulfilled ifTrue: [^linkForResult: thread].
	thread isBroken ifTrue: [^linkForError: thread].
	^nothing
)
public isKindOfEvaluatorPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfEvaluatorPresenter
)
definition = (
  ^definitionForEvaluator
)
changeResponse = (
  ^subject isLive ifTrue: [liveChangeResponse] ifFalse: [deadChangeResponse]
)
results ^ <List[Fragment]> = (
    ^subject results collect: [:r | 
        r isKindOfThreadMirror 
            ifTrue: [linkForThread: r] 
            ifFalse: [linkForCompileError: r]
        ]
)
editorDefinition ^ <CodeMirrorFragment> = (
	| initialSource |
	initialSource:: subject initialSource.
	cm:: (codeMirror: initialSource) 
        changeResponse: changeResponse;
        evaluateResponse: evaluateResponse;
		useEditControls: false.

	(* ide colorizer colorizeDoIt: initialSource fromClass: nil via: (colorizingBlockFor: cm).*)
	^cm
)
public clearResultsButton ^ <Fragment> = (
    ^(imageButton: ide images clearImage 
            action: [updateGUI: [subject clear]]) 
            height: styleButtonSize
)
public invertEvalStatusButton ^ <ButtonFragment> = (
  ^subject isLive ifTrue: [
	 button: 'Suspend Live Evaluation' action: [updateGUI: [subject isLive: false]]
	 ] ifFalse: [ button: 'Start Live Evaluation' action: [updateGUI: [subject isLive: true]]]
)
public makeDoItButton ^ <ButtonFragment> = (
  ^button: 'Make DoIt Button' action: [respondToMakeButton]
)
definitionForEvaluator = (
    | items <List[Fragment]> = results. |
	^column: {
         helpSection.
         row: {
	             evaluateSelectionButton.
                 mediumBlank.
	             invertEvalStatusButton.
                 mediumBlank.
	             makeDoItButton. 
                 mediumBlank.
                 helpButton.
	      }.
		 editorDefinition.
         row: {
            (column: items) elasticity: 1.
            items isEmpty
                ifTrue: [smallBlank]
                ifFalse: [clearResultsButton].
         }.		
	}
)
helpText = (
  | mapping = Map new. |
  mapping 
    at: #evaluateSelectionButton put: evaluateSelectionButton;
    at: #invertEvalStatusButton put: invertEvalStatusButton;
    at: #MakeSelectionADoItButton put: makeDoItButton.
  
  ^ampleforth: 'This is an evaluator.  You can enter and evaluate Newspeak expressions in the pane below. The expressions are evaluated in a <i>scope</i>. If this evaluator is immediately contained in an object presenter, the scope is that of the object being presented.  If the evaluator is a part of an activation presenter, the scope is that of the activation; if it is part of a method presenter, the scope is that of the an activation of the method''s exemplar. <br><br>
 Shift-Return evaluates the currently selected text; if no text is selected, the current line (i.e., the line where the cursor is) is evaluated. You can also initiate evaluation of any selected text by pressing: <div class = "evaluateSelectionButton"></div> which is located above the editor on the left. 
  <br><br>
The editor can also evaluate at every keystroke; you can toggle this behavior using <div class = "invertEvalStatusButton"></div>
also located above the editor (note: this doesn''t work in methods yet).
<br><br>
Evaluation results, if any, are displayed below the editor pane. Each result is a link; clicking on it takes you an object inspector on the result.  You can clear the results list by pressing the clear button to its right: <div class="hopscotchClearResultsButton"> </div>
<br>
If  there are no results to display, the  results list area is blank.<br><br>
If you find you want to repeatedly re-evaluate some code, and selecting it or using the keyboard prove too burdensome, you can convert the code into a button.
Simply select the code in question, and then press <div class="MakeSelectionADoItButton"> </div> which will be the rightmost button above the evaluator.' mapping: mapping
)
evaluateResponse ^ <[:CodeMirrorFragment]> = (
    ^[:ed <CodeMirrorFragment>  | 
        | src <String> ::=  ed editor getSelection. |
        src isEmpty ifTrue: [
            src:: ed currentLine.
        ].
        src isEmpty ifFalse: [
            updateGUI: [ 
                subject evaluate: src withoutNbsp.                 
            ].
            ed visual focus.
        ].
    ].
)
public evaluateSelectionButton ^ <ButtonFragment> = (
  ^button: 'Evaluate Selection' action: [updateGUI: [subject evaluate: cm editor getSelection withoutNbsp]]
)
liveChangeResponse = (
  ^[:editor <CodeMirrorFragment>  | | src <String> =  editor textBeingAccepted. |
	updateGUI: [
		subject evaluateLive: src withoutNbsp.
		ide colorizer colorizeDoIt: src fromClass: nil via: (colorizingBlockFor: editor).
		editor isInEditState: true.
    ].
	editor editor focus.
   ].
)
public respondToMakeButton = (
        | 
        src <String> ::=  cm editor getSelection. 
        defaultTitle <String> ::= 'Do it!'.
        title <String>
        |

        (*title:: prompt: 'Enter the button title' input: defaultTitle.
        title isEmpty ifTrue: [ title:: defaultTitle ].*)

        src isEmpty ifTrue: [
            |
            line = cm currentLine.
            lineNumber = cm currentLineNumber.
            start = JSObject new.
            end = JSObject new.
            |            
            src:: line.
            start 
                at: 'line' put: lineNumber;
                at: 'ch' put: 0.
            end 
                at: 'line' put: lineNumber;
                at: 'ch' put: src size.
                
            cm editor setSelection: start end: end.
        ].
        src isEmpty ifFalse: [
            | 
            button <ButtonFragment> = button: src action: [ 
               updateGUI: [subject evaluate: src withoutNbsp]].
            |
            cm replace: button.         
            cm editor focus.
        ].
)
) : (
)
public class SearchResultsSubject onModel: searchTerm <String> = ProgrammingSubject onModel: searchTerm (
	|
	includeSynthetics <Boolean> = (searchTerm indexOf: "`") isNil not.
	public searchSuggestions <List[Symbol]> = Set new. (* hack *)
    selectorSubjects_slot  <List[SelectorSubject]>
    classSubjects_slot  <List[ClassSubject]>
	|    
) (
public createPresenter = (
	^SearchResultsPresenter onSubject: self
)
public title = (
	^'Search for "', model, '"'
)
properlySorted: selectors <Collection[String]> = (
	| lower <List[String]>  upper <List[String]> |
	lower:: List new: selectors size.
	upper:: List new: selectors size // 2.
	selectors do:
		[:each <String> |
		each first isUppercase
			ifTrue: [upper add: each ]
			ifFalse: [lower add: each]].
      lower sort:  [:a :b | a key < b key].
      upper sort:  [:a :b | a key < b key].
	^lower asArray, upper 
)
public isKindOfSearchResultsSubject ^ <Boolean> = (
  ^true
)
createSuggestions = (
	| foundNoResults <Boolean> names <Set[String]> |

	foundNoResults:: true.
	classMatches isEmpty ifFalse: [foundNoResults:: false].
	selectorMatches isEmpty ifFalse: [foundNoResults:: false].
	namespaceMatches isEmpty ifFalse: [foundNoResults:: false].
	foundNoResults ifFalse: [searchSuggestions:: Set new. ^self].
    searchSuggestions:: Set new. ^self (* hack *)
	(*names:: Set new: 200.
	systemScope allClassesDo: [:each <ClassDeclarationMirror> | 
      names add: (each simpleName)
      ].
	searchSuggestions:: (model correctAgainst: names).*)
)
addMatchesOfPatterns: ps <Array[String]> inNamespace: ns <Namespace> to: collected <Set[Association[String, Namespace]]> = (
	ns keysAndValuesDo:
		[:k :v |
        v isKindOfNamespace ifTrue: [
          addMatchesOfPatterns: ps inNamespace: v to: collected.
		  ps do:
			[:pattern <String> | 
              (pattern: pattern match: k) ifTrue:
				[collected add: {k. v}]]]].
)
searchPatterns ^ <Array[String]> = (
	(* Produce a collection of the specific search pattern to use. The model is the raw input provided by the user and may include multiple patterns. *)
	| parts <Array[String]> |
	parts:: {model} (*findTokens: ';' - forget about multiple patterns for now*).
	parts:: parts collect: [:each <String> | each withBlanksTrimmed].
	parts:: parts select: [:each <String> | each isEmpty not].
	(*parts:: parts collect:
		[:each <String> |
		((each indexOf: "*") ~= 0 or: [(each indexOf: "#") ~= 0])
			ifTrue: [each]
			ifFalse: [(pattern: '"*"' match: each)
					ifTrue: [each copyFrom: 2 to: each size - 1]
					ifFalse: ['*', each, '*']]].*)
	^parts
)
findWildcardsIn: p <String> ^ <List[Integer]> = (
(* Return an ordered list of indices in p where the wildcard indicator, *, appears.*)
  | index <Integer> ::= 1. wildcardIndices = List new. nextIndex |
  p isEmpty ifTrue: [^wildcardIndices].
  [index <= p size] whileTrue: [
     (* if not found, we get 0 *)
     nextIndex:: p indexOf: '*' startingAt: index. 
     (* If no wildcard found, set index so we exist the loop; otherwise, add the position we found
         (nextIndex) and increment index so we continue looking at the rest the the pattern p *)
     index:: nextIndex = 0 ifFalse: [wildcardIndices add: nextIndex. nextIndex + 1] ifTrue:  [p size  + 1].
  ].
  ^wildcardIndices.
)
prepareSegments: p <String> ^ <List[Integer]> = (
(* Return a list of segment markers in p, i.e., indices that immediately precede or follow
    wildcard-free substrings p. This amounts to the position of wildcards,
    plus markers for imaginary wildcards before and after p.
*)
| wildcardIndices <List[Integer]> = findWildcardsIn: p. |
  wildcardIndices isEmpty ifTrue: [^List withAll: {0.  p size + 1}]. (* no wildcards found *)
  wildcardIndices first = 1 ifFalse: [wildcardIndices addFirst: 0].
  wildcardIndices last = p size ifFalse: [wildcardIndices add: p size  + 1].
  ^wildcardIndices
)
pattern: p <String> match: s <String>  ^ <Boolean> = (
  | 
  index <Integer> ::= 1.
  nextIndex 
  segmentMarkers = prepareSegments: p. 
  segments <List[String]> ::= List new.
  isFirst <Boolean> ::= true.
  res
  |
  (* collect the wild-card free strings - those prior to, between, or after wildcards *)
  segmentMarkers reduce: [:i <Integer> :j <Integer> |
     segments add: (p copyStringFrom: i + 1 to: j - 1).
     j
  ].
  (* eliminate effects of adjacent wildcards *)
  segments:: segments select: [:seg | seg isEmpty not]. 
  segments do: [:seg <String> |
    nextIndex:: s indexOf: seg startingAt: index.
    nextIndex = 0 ifTrue: [^false].
    isFirst ifTrue: [
      isFirst:: false.
      (*unless there's a wildcard at the start of the pattern, 
      the first segment needs to start at the beginning of s *)      
      (nextIndex = 1 or: [segmentMarkers first = 1]) ifFalse: [^false] 
      ].
    index:: nextIndex + seg size.
  ].
(* If the last segment doesn't extend to the end of s, the pattern must end with a wildcard *)
  ^index > s size or: [segmentMarkers last = p size].
)
isMyKind:  s <Subject> ^ <Boolean> = (
  ^s isKindOfSearchResultsSubject
)
public selectorMatches ^ <Array[String]> = (
	| collected <Set[String]> patterns <Array[String]> |
	collected:: Set new: 20.
    patterns:: searchPatterns. (* compute once *)
    systemScope allSelectorsDo: [:sel <String> |
	  patterns do:
	    [:each <String> |
		  (pattern: each match: sel) ifTrue: [collected add: sel].
        ].
    ].
	includeSynthetics ifFalse:
		[collected removeAllSuchThat: [:each | (each indexOf: "`") ~= 0].
		collected removeAllSuchThat: [:each | (each indexOf: " ") ~= 0]].
	^collected asArray sort: [:a :b | lexicallyLessOrEqual: a than: b]
)
public namespaceMatches ^ <Array[Association[String, Namespace]]> = (
	| 
    collected <Set[Association[String, Namespace]]> = Set new: 20.
    patterns <Array[String]> = searchPatterns.
    root = ide namespacing Root. 
    |
    addMatchesOfPatterns: patterns inNamespace: root to: collected.
	^collected asArray sort: [:a :b | lexicallyLessOrEqual: a first than: b first]
)
public classMatches ^ <Array[ClassDeclarationMirror]> = (
	| collected <Set[ClassDeclarationMirror]> patterns <Array[String]> |
	collected:: Set new: 20.
	patterns:: searchPatterns. (* compute once *)
	systemScope allClassesDo:
		[:cls <ClassDeclarationMirror> |
		patterns do:
			[:pattern | (pattern: pattern match: cls simpleName) ifTrue: [collected add: cls]]].
	^collected asArray sort:
		[:a :b | lexicallyLessOrEqual: a simpleName than: b simpleName]
)
public selectorSubjects ^ <List[SelectorSubject]>  = (
	(* Answer a collection of subjects on individual selectors the search has found. *)
    selectorSubjects_slot isNil ifTrue: [
	 selectorSubjects_slot::  List withAll: (selectorMatches collect: [:each <Symbol> | SelectorSubject onModel: each]).
     ^selectorSubjects_slot
     ].
   updateSelectors.
   ^selectorSubjects_slot
)
updateSelectors = (
  |
  subjectNames <List[Symbol]> = selectorSubjects_slot collect: [:e <SelectorSubject> | e model].
  matches <Array[Symbol]> = selectorMatches.
  obsoleteSubjects <List[SelectorSubject]> = List new.
  |
  selectorSubjects_slot do: [:s <SelectorSubject> |
    (matches includes: s model) ifFalse: [obsoleteSubjects add: s].
  ].
  obsoleteSubjects do: [:s <SelectorSubject> | selectorSubjects_slot remove: s].
  matches do: [:m <Symbol> |
    (subjectNames includes: m) ifFalse: [
      selectorSubjects_slot add: (SelectorSubject onModel: m)
      ].
  ].
)
public classSubjects ^ <List[ClassSubject]>  = (
	(* Answer a collection of subjects on individual classes the search has found. *)
    classSubjects_slot isNil ifTrue: [
	 classSubjects_slot::  List withAll: (classMatches collect: [:each <ClassDeclarationMirror> | ClassSubject onDeclaration: each]).
     ^classSubjects_slot
     ].
   updateClasses.
   ^classSubjects_slot
)
updateClasses = (
  |
  subjectMirrors <List[ClassDeclarationMirror]> = classSubjects_slot collect: [:e <ClassSubject> | e model].
  matches <Array[ClassDeclarationMirror]> = classMatches.
  obsoleteSubjects <List[ClassSubject]> = List new.
  |
  classSubjects_slot do: [:s <ClassSubject> |
    (matches includes: s model) ifFalse: [obsoleteSubjects add: s].
  ].
  obsoleteSubjects do: [:s <ClassSubject> | classSubjects_slot remove: s].
  matches do: [:m <ClassDeclarationMirror> |
    (subjectMirrors includes: m) ifFalse: [
      classSubjects_slot add: (ClassSubject onDeclaration: m)
      ].
  ].
)
) : (
)
class SearchResultsPresenter onSubject:s = ProgrammingPresenter onSubject: s (
) (
class ClassSectionPresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
public isKindOfClassSectionPresenter ^ <Boolean> = (
  ^true
)
classSectionResultsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}
)
definition = (
  ^column: {
       helpSection.
       minorHeadingBlock: (row: { 
         label: 'Classes'. 
         filler.
         refreshButton. 
         smallBlank.
         helpButton. 
         smallBlank.
         dropDownMenu: [classSectionResultsMenu]
         }
       ).
       indentedBlock: (column: classSearchResults)
     }
)
helpText = (
  | 
  menuImage = Utilities uriForIconNamed: #hsDropdownImage. 
  mapping = Map new. 
  |
  mapping 
    at: #classSectionMenuButton put: (dropDownMenu: [classSectionResultsMenu]);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchRefreshButton put: refreshButton.
  ^ampleforth: 'This section shows the classes found by the enclosing search presenter. For each class found, a toggle is displayed. Initially, the toggle is collapsed, and only shows a link to the class. The toogle can be expanded to show the class in place.
  <ul>
    <li><div class="hopscotchRefreshButton"> </div> Refreshes the display of the classes.</li>  
    <li><div class="hopscotchHelpButton"> </div> Shows this help message.</li>
   <li> <div class="classSectionMenuButton"> </div> Opens a menu of additional operations, such as inspecting this presenter.
   </ul> <br>'
   mapping: mapping
)
) : (
public new = (
  ^onSubject: nil
)
)
class NamespaceSectionPresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
public isKindOfNamespaceSectionPresenter ^ <Boolean> = (
  ^true
)
namespaceSectionResultsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}
)
definition = (
  ^column: {
       helpSection.
       minorHeadingBlock: (row: { 
         label: 'Namespaces'. 
         filler.
         refreshButton. 
         smallBlank.
         helpButton. 
         smallBlank.
         dropDownMenu: [namespaceSectionResultsMenu]
         }
       ).
       indentedBlock: (column: namespaceSearchResults)
     }
)
helpText = (
  | 
  menuImage = Utilities uriForIconNamed: #hsDropdownImage. 
  mapping = Map new. 
  |
  mapping 
    at: #namespaceSectionMenuButton put: (dropDownMenu: [classSectionResultsMenu]);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchRefreshButton put: refreshButton.
  ^ampleforth: 'This section shows the namespaces found by the enclosing search presenter. Each listed entry is a link to the actual namespace.
  <ul>
    <li><div class="hopscotchRefreshButton"> </div> Refreshes the display of the namespaces.</li>  
    <li><div class="hopscotchHelpButton"> </div> Shows this help message.</li>
   <li> <div class="namespaceSectionMenuButton"> </div> Opens a menu of additional operations, such as inspecting this presenter.
   </ul> <br>'
   mapping: mapping
)
) : (
public new = (
  ^onSubject: nil
)
)
class SelectorSectionPresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
public isKindOfSelectorSectionPresenter ^ <Boolean> = (
  ^true
)
selectorSectionResultsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}
)
definition = (
  ^column: {
       helpSection.
       minorHeadingBlock: (row: { 
         label: 'Selectors'. 
         filler.
         refreshButton. 
         smallBlank.
         helpButton. 
         smallBlank.
         dropDownMenu: [selectorSectionResultsMenu]
         }
       ).
       indentedBlock: (column: selectorSearchResults)
     }
)
helpText = (
  | 
  menuImage = Utilities uriForIconNamed: #hsDropdownImage. 
  mapping = Map new. 
  |
  mapping 
    at: #selectorSectionMenuButton put: (dropDownMenu: [classSectionResultsMenu]);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchRefreshButton put: refreshButton.
  ^ampleforth: 'This section shows the selectors found by the enclosing search presenter. For each selector found, a toggle is displayed. Initially, the toggle is collapsed, and only shows the selector. The toggle expands to show two sections: one listing implementers of the selector, and one listing senders of the selector.
  <ul>
    <li><div class="hopscotchRefreshButton"> </div> Refreshes the display of the selectors.</li>  
    <li><div class="hopscotchHelpButton"> </div> Shows this help message.</li>
   <li> <div class="selectorSectionMenuButton"> </div> Opens a menu of additional operations, such as inspecting this presenter.
   </ul> <br>'
   mapping: mapping
)
) : (
public new = (
  ^onSubject: nil
)
)
searchSuggestions = (
	^incrementalList: [:s |
		subject searchSuggestions do: [:suggestion |
			s nextPut:
				(link: suggestion
				action: [ enterSubject: (SearchResultsSubject onModel: suggestion)])]].
)
isMyKind:  f <Fragment> ^ <Boolean> = (
  ^f isKindOfSearchResultsPresenter
)
public isKindOfSearchResultsPresenter ^ <Boolean> = (
  ^true
)
searchResultsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}
)
sectionWithHeader: theHeader andContents: theContents = (
^ column: {minorHeadingBlock: (label: theHeader). indentedBlock: (column: theContents). }
)
namespaceSearchResults  ^ <Array[Fragment]> = (
	^subject namespaceMatches collect: [:assoc <{String. Namespace}> |
			  linkToBrowseNamespace: assoc last key: assoc first
            ]
)
searchFeedback = (
 subject searchSuggestions isEmpty
	ifTrue: [^ nothing]
	ifFalse: [
		^sectionWithHeader: 'Did you mean?' andContents: searchSuggestions.
	].
)
definition = (
	^column: {
       helpSection.
        row: {filler. helpButton. mediumBlank. dropDownMenu: [searchResultsMenu]}.
		( deferred: [searchFeedback]).
		( initially: (label: 'Searching namespaces') deferred: [namespacesSection] ).
        ( initially: (label: 'Searching classes') deferred: [classesSection] ).
		( initially: (label: 'Searching selectors') deferred: [selectorsSection] ).
		}
)
selectorSearchResults  ^ <Array[Fragment]> = (
	^subject selectorSubjects collect: [:each <SelectorSubject> |
				  collapsed: (linkToBrowseSelector: each model)
				  expanded: [each presenter]
                ]
)
classSearchResults ^ <Array[Fragment]> = (
^subject classSubjects collect:
			[:each <ClassSubject> | 
				collapsed: (linkToBrowseClass: each model klass)
				expanded: [each presenter]
            ]
)
helpText = (
  | 
  menuImage = Utilities uriForIconNamed: #hsDropdownImage. 
  mapping = Map new. 
  |
  mapping 
    at: #searchResultsMenuButton put: (dropDownMenu: [searchResultsMenu]);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchRefreshButton put: refreshButton.
  ^ampleforth: 'This is a search results presenter.  It shows occurrences of a search pattern in the code loaded into the IDE. Results will be grouped into separate sections for classes, namespaces and selectors. Sections are only displayed if they contain results. If there are no results at all, the area below will be blank.
  <ul>
    <li>div class="hopscotchRefreshButton"> </div> Refreshes the display.</li>
    <li><div class="hopscotchHelpButton"> </div> Shows this help message.</li>
   <li> <div class="searchResultsMenuButton"> </div> Opens a menu of additional operations, such as inspecting this presenter.
   </ul> <br>'
   mapping: mapping
)
classesSection = (
	^subject classSubjects isEmpty
		ifTrue: [nothing]
		ifFalse: [ClassSectionPresenter new]
)
selectorsSection = (
	^subject selectorSubjects isEmpty
		ifTrue: [nothing]
		ifFalse: [SelectorSectionPresenter new]
)
namespacesSection = (
	^subject namespaceMatches isEmpty
		ifTrue: [nothing]
		ifFalse: [NamespaceSectionPresenter new].
)
) : (
)
public class EvaluatorSubject onModel: e <EvaluationViewState> = Subject onModel: e  (
  | initialSource_slot  <String> |
) (
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfEvaluatorSubject
)
public isKindOfEvaluatorSubject ^ <Boolean> = (
  ^true
)
public results  ^  <List[ThreadMirror]> = (
  ^model results
)
public evaluate: e <String> ^ <ThreadMirror>  = (
  ^model evaluate: e
)
public evaluateLive: e <String> ^ <ThreadMirror>  = (
  ^model evaluateLive: e
)
public clear = (
  model clear
)
public isLive ^ <Boolean> = (
  ^model isLive
)
public isLive: b <Boolean> = (
  ^model isLive: b
)
public createPresenter ^ <EvaluatorPresenter> = (
  ^EvaluatorPresenter onSubject: self
)
public initialSource: s  <String> = (
  initialSource_slot:: s
)
public initialSource ^ <String> = (
  initialSource_slot isNil ifTrue: [^'
  
  
   '].
  ^initialSource_slot
)
) : (
)
public class IDEWindow into: b openSubject: s <Subject> (* :exemplar: currentWindow *) = Window into: b openSubject: s (
) (
class ToolbarPresenter = super ToolbarPresenter (
  | textView <SearchFieldFragment> |
) (
find = (
  find: textView textBeingAccepted
)
find: s <String> = (
  enterSubject: (SearchResultsSubject onModel: s)
)
searchField ^ <Fragment> = (
    textView:: SearchFieldFragment new.
    textView acceptResponse: [:editor | find: editor textBeingAccepted].
    ^textView
)
saveAll = (
    ^imageButton: ide images saveImage action: [saveSources] size: styleButtonSize
)
toolbarItems ^ <Array[Fragment]>  = (
 ^super toolbarItems, {saveAll. smallBlank. searchField}
)
helpText = (
  | 
  findImage = Utilities uriForIconNamed: #findImage.
  mapping = Map new. 
  |
  mapping 
    at: #hopscotchSearchBar put: searchField; 
    at: #hopscotchHistoryButton put: historyButton;
    at: #hopscotchHomeButton put: homeButton;
    at: #hopscotchRefreshButton put: refreshButton;
    at: #hopscotchHelpButton put: helpButton; 
    at: #hopscotchCloseHelpButton put: closeHelpButton;
    at: #hopscotchSaveAllButton put: saveAll.
  ^ampleforth: 'At the top right of the IDE window you find:
  <br>
  <ul>
  <li><div class="hopscotchHistoryButton"> </div>The history button shows you a list of all the presenters visited in the current session.</li>
  <li><div class="hopscotchHomeButton"> </div>The home button takes you to the home page.</li>  
  <li><div class="hopscotchRefreshButton"> </div> Refreshes the display. The same icon is used for refreshing individual presenters everywhere in the system.</li> 
  <li><div class="hopscotchHelpButton"> </div> Shows this help message. This icon is used by presenters throughout the system to show help.</li>    
  <li><div class="hopscotchSaveAllButton"> </div> Saves the current IDE contents to a file. <b>Beware! The button in the help is live!</b></li> 
  <li><div class="hopscotchSearchBar"> </div> The search bar allow you to search for classes, methods and namespaces defined in the system. You can use wildcards in search terms. Pressing return or clicking on the search icon (<img src=''', findImage, ''' alt="" width="18" height="30">) triggers the search.</li>  
  </ul>
  If you are running in the web browser, use the browser''s navigation controls to go back and forth between presenters. If you are running locally, you''ll find arrows at the top right. These will work very much like in a  web browser.
  <br><br>
      You can close the help section by pressing <div class = "hopscotchCloseHelpButton"></div>, a convention is used in all help sections.
  '
  mapping: mapping
)
) : (
)
public isKindOfIDEWindow ^ <Boolean> = (
  ^true
)
) : (
public openSubject: s = (
	^into: body openSubject: s
)
)
class SetView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public title ^ <String> = (
  ^'Set'
)
public isKindOfSetView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfSetView
)
public definition = (
	^column: (
         (subject objectMirror reflectee collect: [:e <Object> | 
           link: e printString action: [enterSubject: (ObjectSubject onModel: (ObjectMirror reflecting: e))]]) 
         asArray
         )
)
) : (
)
class ImageView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public isKindOfImageView ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfImageView
)
public definition ^ <Fragment> = (
    ^(image: subject model reflectee) 
        height: styleButtonSize
)
) : (
)
public class Utilities = (
) (
) : (
public lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (
  ^outer Browsing lexicallyLessOrEqual: a than: b
)
public uriForIconNamed: iconName <String> ^ <String> = (
  ^((ide namespacing manifest Icons) at: iconName) at: #src
)
public isBinarySelector: s <String> ^ <Boolean> = (
(* should do only called with selectors; not valid for arbitrary strings *)
  | firstChar = s runeAt: 1. |
  (* selector doesn't start with A-Z or a-z *)
  ^((65 <= firstChar and: [90 >= firstChar]) or: [97 <= firstChar and: [122 >= firstChar]]) not
)
public isKeywordSelector: s <String> ^ <Boolean> = (
(* should do only called with selectors; not valid for arbitrary strings *)
  ^(s indexOf: ':') > 0
)
public isUnarySelector: s <String> ^ <Boolean> = (
(* should do only called with selectors; not valid for arbitrary strings *)
  ^(isKeywordSelector: s) not and: [(isBinarySelector: s) not]
)
public safelyRun: block <[]> ifFulfilled: successBlock <[:ThreadMirror]> = (
  	safelyRun: block ifFulfilled: successBlock ifBroken: [enterSubject:: ide debugging ThreadSubject onModel: thread].    
)
public safelyRun: block <[]> ifFulfilled: successBlock <[:ThreadMirror]>  ifBroken: failBlock <[:ThreadMirror]> = (
  	| thread <ThreadMirror> |
	thread:: cachedPlatform mirrors ActivationMirror invokeSuspended: block.
    thread resume.
	thread isFulfilled 
       ifTrue: [successBlock value: thread]
       ifFalse: [failBlock value: thread].    
)
public safelyRun: block <[T def]> ^ <T> = (
  	safelyRun: block ifFulfilled: [:thread | ^thread result]   
)
public updateSubjects: subjectAccessor <[List[Subject]]> fromModel: modelAccessor <[List[Object]]> subjectFactory: subjectFactory <Subject class> = (
  |
  subjectModels <List[Object]> = subjectAccessor value collect: [:e <Subject> | e model].
  modelCollection <Collection[Object]> = modelAccessor value.
  obsoleteSubjects <List[Subject]> = List new.
  |
  subjectAccessor value do: [:s <Subject> |
    (modelCollection includes: s model) ifFalse: [obsoleteSubjects add: s].
  ].
  obsoleteSubjects do: [:s <Subject> | subjectAccessor value remove: s].
  modelCollection do: [:m  |
    (subjectModels includes: m) ifFalse: [
      subjectAccessor value add: (subjectFactory onModel: m)
      ].
  ].
)
public isInstantiableUnarySelector: s <String> ^ <Boolean> = (
  ^(isUnarySelector: s) and: [ s~= #_cannotInstantiate]
)
public enterSubject: s = (
  currentWindow enterSubject: s
)
)
public class ProgrammingSubject onModel: m = Subject onModel: m (
) (
public isKindOfProgrammingSubject ^ <Boolean> = (
  ^true
)
) : (
)
class ClosureView onSubject: s = ProgrammingPresenter onSubject: s (
  | closureMirror <ClosureMirror> = ClosureMirror reflecting: subject objectMirror reflectee. |
) (
isMyKind: other ^ <Boolean> = (
  ^other isKindOfClosureView
)
public isKindOfClosureView ^ <Boolean> = (
  ^true
)
public definition = (
    | vitality <String> = closureMirror isDead ifTrue: ['dead'] ifFalse: ['live']. |
	^column: {
        label: 'Closure from ', vitality, ' activation'.
		label: closureMirror definingMethod source.        
        collapsed: [link: 'receiver' action: [enterSubject: (ObjectSubject onModel: closureMirror receiver)]]
        expanded: [(ObjectSubject onModel: closureMirror receiver) presenter].
        collapsed: [link: 'defining method' action: [enterSubject: (MethodSubject onMethodModel: (MethodModel method: closureMirror definingMethod exemplar: nil))]]
        expanded: [(MethodSubject onModel: closureMirror definingMethod) presenter].
	}
)
) : (
)
class AppPlatform = Proxy (
  | public hopscotch = HopscotchProxy new. |
) (
class HopscotchProxy = Proxy (
) (
public class Window  = (
) (
) : (
public openSubject: s  = (
  currentWindow enterSubject: s 
)
)
public doesNotUnderstand: message <Message> = (
  ^message sendTo: cachedPlatform hopscotch
)
public HopscotchWindow = (
  ^Window
)
) : (
)
public doesNotUnderstand: message <Message> = (
  ^message sendTo: cachedPlatform 
)
) : (
)
class MethodEvaluatorPresenter onSubject: s = EvaluatorPresenter onSubject: s (
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^ [:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject method definingMixin asBuilder. |
		updateGUI: [
			[b methods addFromSource: ed textBeingAccepted.
			ide  installFromBuilders: {b declaration}.
			ide colorizer colorizeMethod: (crToLf: ed textBeingAccepted) fromClass: subject method definingMixin declaration via: (colorizingBlockFor: ed).
			ed leaveEditState] on: Error do:  [:ex <Exception> | ed showMessage: ex printString]
			].
		ed editor focus.
		]
)
editorDefinition ^ <CodeMirrorFragment> = (
	| initialSource |
	initialSource:: subject initialSource.
	cm:: (codeMirror: initialSource) 
        acceptResponse: acceptResponse;
        changeResponse: changeResponse;
        cancelResponse: cancelResponse;
        evaluateResponse: evaluateResponse;
		useEditControls: true.

	ide colorizer colorizeMethod: initialSource fromClass: subject method definingMixin declaration via: (colorizingBlockFor: cm).
	^cm
)
cancelResponse ^ <[:CodeMirrorFragment]> = (
	^[:ed <CodeMirrorFragment> |
        ed text: subject method source.
		ide colorizer colorizeMethod: (crToLf: subject method source) fromClass: subject method definingMixin declaration via: (colorizingBlockFor: ed).
		ed leaveEditState.
	 ]
)
deadChangeResponse ^ <[:CodeMirrorFragment :Event]> = (  
    ^[:ed <CodeMirrorFragment>  | 
        ide colorizer colorizeMethod: (crToLf: ed textBeingAccepted) fromClass: subject method definingMixin declaration via: (colorizingBlockFor: ed).
        ed updateEditState.
        ed editor focus.
    ].     
)
public isKindOfMethodEvaluatorPresenter ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfMethodEvaluatorPresenter
)
liveChangeResponse = (
  ^[:ed <CodeMirrorFragment>  | | src <String> =  ed textBeingAccepted. |
	updateGUI: [
		subject evaluateLive: src withoutNbsp.
		ide colorizer colorizeMethod: (crToLf: ed textBeingAccepted) fromClass: subject method definingMixin declaration via: (colorizingBlockFor: ed).
		ed updateEditState.
    ].
	ed editor focus.
   ].
)
) : (
)
class MethodEvaluatorSubject onModel: m  = EvaluatorSubject onModel: m (

) (
public createPresenter = (
  ^MethodEvaluatorPresenter onSubject: self
)
public classDeclaration ^ <ClassDeclarationMirror> = (
  ^method definingMixin declaration
)
public activationMirror ^ <ActivationMirror> = (
    ^model mirror
)
public method ^ <MethodMirror> = (
  ^activationMirror method
)
public isKindOfMethodEvaluatorSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfMethodEvaluatorSubject
)
) : (
)
class JSAlienView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public isKindOfJSAlienView ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfJSAlienView
)
jsAlien ^ <Alien> = (
  ^subject model reflectee
)
propertyNames ^ <List[String]> = (
  |
  ownProperties <Alien[Array[String]]> = JSObject getOwnPropertyNames: jsAlien.
  result <List[String]>  = List new.
  |
  1 to: (ownProperties at: #length) do: [:i <Integer> |
    result add: (ownProperties at: i)
  ].
  ^result
)
properties ^ <List[Fragment]> = (
  | result <List[Fragment]> = List new. |
  propertyNames with: propertyValues do: [:pn <String> :pv <Alien> |
     result add: (row: { 
           (
             (pv isKindOfJSAlien and: [pv isUndefined]) ifFalse: [
                link: pn action: [enterSubject: (ObjectSubject onModel: (ObjectMirror reflecting: pv))]
              ] ifTrue: [label: 'undefined']
           ). 
           mediumBlank.
           label: ([pv printString] on: Error do: [:e | e printString])
         }
       )
  ].
  ^result
)
public definition ^ <Fragment> = (
(* Make the entries expandable? Show the prototype? *)
#TODO.
  ^column: {
      row: {
        (label: 'Prototype: ') bold. 
        link: '[[Prototype]]' action: [
          enterSubject: (ObjectSubject onModel: (ObjectMirror reflecting: (JSObject getPrototypeOf: jsAlien)))
          ]
      }.
      column: properties
      }
)
propertyValues ^ <List[Alien | String]> = (
  ^propertyNames collect: [:p <String> | 
     [jsAlien at: p] on: Error do: [:e | e messageText]
     ]
)
) : (
)
public class ClassModel declaration: cd <ClassDeclarationMirror> exemplar: e <ObjectMirror | Nil> enclosing: o <ObjectMirror | Nil>  
(* :exemplar: 
[| om = ObjectMirror reflecting: self. | ClassModel declaration: om getClass mixin declaration exemplar: om] value  
*)
= (
(*
In an exemplar based system, the model for a class includes both a class declaration, #klass, and a live instance, #exemplar. This class represents such a model.
*)
	|
	public klass <ClassDeclarationMirror> = cd.
        public exemplar <ObjectMirror | Nil> ::= e.
        enclosing_slot <ObjectMirror | Nil> ::= e isNil ifTrue: [o].
	|
    assert: [cd isKindOfClassDeclarationMirror] message: 'ClassModel built upon another ClassModel?!'.
) (
public enclosing = ( 
    enclosing_slot isNil ifTrue: [
      exemplar isNil ifFalse: [
        enclosing_slot:: exemplar enclosingObject.
	].
    ].
    ^enclosing_slot
)
public = other ^ <Boolean> = (
  other isKindOfClassModel ifFalse: [^false].
  ^klass = other klass and: [exemplar = other exemplar].
)
public hash ^ <Integer> = (
  ^klass hash bitXor: exemplar hash
)
public isKindOfClassModel ^ <Boolean>  = (
  ^true
)
public name  = (
  ^klass name
)
public primaryFactorySelector ^ <Symbol> = (
  ^klass primaryFactorySelector
)
public classMirror ^ <ClassDeclarationMirror> = (
  ^klass
)
public mirror ^ <ClassDeclarationMirror> = (
  ^klass
)
) : (
public declaration: cd <ClassDeclarationMirror> exemplar: e <ObjectMirror | Nil> = (
  ^declaration: cd exemplar: e enclosing: nil
)
public declaration: cd <ClassDeclarationMirror> ^ <Instance> = (
  ^declaration: cd exemplar: nil
)
public mirror: m <MethodMirror> exemplar: e <Object | Nil> = (
  ^declaration: m exemplar: e
)
)
class MixinModel declaration: m <MixinMirror> exemplar: e <ObjectMirror | Nil>
(*  :exemplar1: MixinModel exemplar: (ObjectMirror reflecting: self) *)
(*  :exemplar2: MixinModel declaration: (ObjectMirror reflecting: self) getClass mixin exemplar: nil *)
= (
(*
In an exemplar based system, the model for a mixin includes both a mixin mirror, and a live instance, #exemplar. This class represents such a model.
*)
	|
	public mixin <MixinMirror> = m.
	public exemplar <ObjectMirror> = e.
	|
) (
public hash ^ <Integer> = (
  ^mixin hash bitXor: exemplar hash
)
public isKindOfMixinModel ^ <Boolean> = (
  ^true
)
public = other ^ <Boolean> = (
  other isKindOfMixinModel ifFalse: [^false].
  ^mixin = other mixin and: [exemplar = other exemplar].
)
) : (
public exemplar: e <ObjectMirror> ^ <Instance> (*  :exemplar: exemplar: (ObjectMirror reflecting: self) *) = (
  ^declaration: e getClass mixin exemplar: e
)
)
class MirrorGroupModel mirrorGroup: ms <MirrorGroup> ofMixin: m exemplar: e <ObjectMirror | Nil> = (
(*
In an exemplar based system, the model for a mirror group includes both a mirror group giving a list of mirrors, and a live instance, #exemplar, of the class to which the they belong. This class represents such a model.
*)
	|
	public mirrorGroup <MixinModel> = ms.
    public definingMixin = m.
	public exemplar <ObjectMirror | Nil> = e.
	|
) (
public isKindOfMirrorGroupModel ^ <Boolean>  = (
  ^true
)
public = other ^ <Boolean> = (
  other isKindOfMirrorGroupModel ifFalse: [^false].
  ^mirrorGroup = other mirrorGroup and: [definingMixin = other definingMixin and: [exemplar = other exemplar]].
)
public hash ^ <Integer> = (
  ^(mirrorGroup hash bitXor: definingMixin hash) bitXor: exemplar hash
)
) : (
)
public class MethodModel method: m <MethodMirror> exemplar: e <Object | Nil> 
(*  :exemplar: 
[| om = ObjectMirror reflecting: self. | MethodModel method: (om getClass methods findMirrorNamed: #hash) exemplar: om] value 
*)
= (
	|
	public methodMirror <MethodMirror> = m.
	public exemplar <Object | Nil> = e.
	|
) (
public = other ^ <Boolean> = (
  other isKindOfMethodModel ifFalse: [^false].
  ^methodMirror = other methodMirror and: [exemplar = other exemplar]
)
public hash ^ <Integer> = (
  ^methodMirror hash bitXor: exemplar hash
)
public isKindOfMethodModel ^ <Boolean> = (
  ^true
)
public mirror ^ <MethodMirror> = (
  ^methodMirror
)
) : (
public mirror: m <MethodMirror> exemplar: e <Object | Nil> = (
  ^method: m exemplar: e
)
)
public class LazySlotModel slot: m <LazySlotMirror> exemplar: e <Object | Nil> 
(*  :exemplar: 
[| om = ObjectMirror reflecting: self. | LazySlotModel slot: (om getClass lazySlots findMirrorNamed: #hash) exemplar: om] value 
*)
= (
	|
	public slotMirror <LazySlotMirror> = m.
	public exemplar <Object | Nil> = e.
	|
) (
public isKindOfLazySlotModel ^ <Boolean> = (
  ^true
)
public = other ^ <Boolean> = (
  other isKindOfLazySlotModel ifFalse: [^false].
  ^slotMirror = other slotMirror and: [exemplar = other exemplar]
)
public hash ^ <Integer> = (
  ^slotMirror hash bitXor: exemplar hash
)
public mirror ^ <LazySlotMirror> = (
  ^slotMirror
)
) : (
public mirror: m <LazySlotMirror> exemplar: e <Object | Nil> = (
  ^slot: m exemplar: e
)
)
class LazySlotEvaluatorPresenter onSubject: s = EvaluatorPresenter onSubject: s (
) (
editorDefinition ^ <CodeMirrorFragment> = (
	| initialSource |
	initialSource:: subject initialSource.
	cm:: (codeMirror: initialSource) 
        acceptResponse: acceptResponse;
        changeResponse: changeResponse;
        cancelResponse: cancelResponse;
        evaluateResponse: evaluateResponse;
		useEditControls: true.

	ide colorizer colorizeMethod: initialSource fromClass: subject method definingMixin declaration via: (colorizingBlockFor: cm).
	^cm
)
cancelResponse ^ <[:CodeMirrorFragment]> = (
	^[:ed <CodeMirrorFragment> |
        ed text: subject method source.
		ide colorizer colorizeLazySlot: (crToLf: subject method source) fromClass: subject method definingMixin declaration via: (colorizingBlockFor: ed).
		ed leaveEditState.
	 ]
)
deadChangeResponse ^ <[:CodeMirrorFragment :Event]> = (  
    ^[:ed <CodeMirrorFragment>  | 
        ide colorizer colorizeLazySlot: (crToLf: ed textBeingAccepted) fromClass: subject method definingMixin declaration via: (colorizingBlockFor: ed).
        ed updateEditState.
        ed editor focus.
    ].     
)
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^ [:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject method definingMixin asBuilder. |
		updateGUI: [
			[b lazySlots addFromSource: ed textBeingAccepted.
			ide  installFromBuilders: {b declaration}.
			ide colorizer colorizeLazySlot: (crToLf: ed textBeingAccepted) fromClass: subject method definingMixin declaration via: (colorizingBlockFor: ed).
			ed leaveEditState] on: Error do:  [:ex <Exception> | ed showMessage: ex printString]
			].
		ed editor focus.
		]
)
public isKindOfLazySlotEvaluatorPresenter ^ <Boolean> = (
  ^true
)
isMyKind: other  ^ <Boolean> = (
  ^other isKindOfLazySlotEvaluatorPresenter
)
liveChangeResponse = (
  ^[:ed <CodeMirrorFragment>  | | src <String> =  ed textBeingAccepted. |
	updateGUI: [
		subject evaluateLive: src withoutNbsp.
		ide colorizer colorizeLazySlot: (crToLf: ed textBeingAccepted) fromClass: subject method definingMixin declaration via: (colorizingBlockFor: ed).
		ed updateEditState.
    ].
	ed editor focus.
   ].
)
) : (
)
class LazySlotEvaluatorSubject onModel: m  = EvaluatorSubject onModel: m (

) (
public createPresenter = (
  ^LazySlotEvaluatorPresenter onSubject: self
)
public classDeclaration ^ <ClassDeclarationMirror> = (
  ^method definingMixin declaration
)
public activationMirror ^ <ActivationMirror> = (
    ^model mirror
)
public method ^ <MethodMirror> = (
  ^activationMirror method
)
public isKindOfLazySlotEvaluatorSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfLazySlotEvaluatorSubject
)
) : (
)
class ObjectSlotSubject name: n <String> ofObject: v <ActivationMirror> = SlotSubject name: n value: v (
) (
public isKindOfObjectSlotSubject ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfObjectSlotSubject
)
public slotValueMirror ^<ObjectMirror> = (
	^objectMirror getSlot: name
)
public setValue: expression <String> ifCompilerError: compileFailBlock ifError: failBlock = (
	| 
    evalThread <ThreadMirror>
    |
	evalThread::
		[objectMirror evaluate: expression with: Map new]
          on: Error do: [:ce <Error> | compileFailBlock value: ce printString].
              
	evalThread  isBroken (* so for runtime errors, the block should take a thread so it can open a debugger on it *)
       ifTrue: [failBlock value: evalThread] 
       ifFalse: [objectMirror setSlot: name to: evalThread result reflectee]
)
) : (
)
class IndexedSlotSubject index: n <Integer> ofObject: v <ObjectMirror> = SlotSubject name: n printString value: v (
  | public index <Integer> = n. |
) (
public isKindOfIndexedSlotSubject ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfIndexedSlotSubject
)
public slotValueMirror = (
  ^ObjectMirror reflecting: (objectMirror reflectee at: index)
)
public setValue: expression <String> ifCompilerError: compileFailBlock ifError: failBlock = (
	| 
    evalThread <ThreadMirror>
    |
	evalThread::
		[objectMirror evaluate: 'at: ', index printString, 'put: ', expression with: Map new]
          on: Error do: [:ce | compileFailBlock value: ce printString].
              
	evalThread  isBroken (* so for runtime errors, the block should take a thread so it can open a debugger on it *)
       ifTrue: [failBlock value: evalThread] 
)
) : (
)
colorizingBlockFor: cm <CodeMirrorFragment> = (
      cm resetStyles.
	^[:r | | style <Alien[JSObject]> = JSObject new. |
	style at: 'css' put: (cssFor: r kind).
	cm style: style from: r start to: r end]
)
cssFor: k <Symbol> ^ <String> = (
        ^cssConverter at: k ifAbsent: [ 'color:Black; font-family: serif']
)
systemScope = (
	^ide namespacing systemScope.
)
public addViews: vs <List[Presenter]>  for: interface <String> = (
  | key =  'isKindOf', interface. entry = objectViews at: key ifAbsent: []. |
  objectViews at: interface put: (entry isNil 
    ifTrue: [vs]
    ifFalse: [entry, vs ]
    ).
)
saveSources = (
   localStorage setItem:  #lastSaved to: (localStorage getItem: #backup).
   localStorage setItem: #lastSavedTime to: ide incrementedVersion.
)
public launch: s <Subject> inWindow: w <HopscotchShell> = (
  currentWindow:: w openSubject: s (*(RegisterDebugger onSubject: s)*).
)
public HopscotchWindow = (
  ^Window
)
deleteTopLevelClassNamed: cname <Symbol> = (
  | backup <Map[Symbol, Object] | Nil> |
  ide namespacing removeKey:  cname.
  backup:: ide json decode: ([localStorage getItem: 'backup'] on: Error do: [:e | ^self]).
  backup isNil ifTrue: [^self].
  backup removeKey: cname ifAbsent: [^self].
  localStorage setItem: 'backup' to: (ide json encode: backup).
  localStorage setItem: #lastBackupTime to: ide incrementedVersion.  
)
hiddenWorkspace ^ <ObjectMirror> = (
  ^ObjectMirror reflecting: ide theWorkspaceManager Workspace new
)
computeExemplarFor: classMirror  <ClassDeclarationMirror> enclosing: enclosingObject <ObjectMirror | Nil>  ^ <ObjectMirror | ThreadMirror | Nil>  = (
(* Compute an exemplar for the class declaration represented by classMirror; if enclosingObject is not nil, use it as the enclosing object, otherwise try and compute one. *)
  |  
  exemplarPossible =     (* some classes cannot be instantiated *)
    (nonExemplarClasses includes: classMirror name) ifTrue: [^nil].
  enclosing <ClassDeclarationMirror> = classMirror enclosingClass.
  objectMirror <ObjectMirror | Nil> = enclosingObject isNil 
    ifTrue: [computeEnclosingExemplarFrom: enclosing] 
    ifFalse: [enclosingObject]. 
  |
  ^objectMirror isNil ifFalse: [computeExemplarFor: classMirror within: objectMirror].
)
computeEnclosingExemplarFrom: enclosing  <ClassDeclarationMirror> ^ <ObjectMirror | Nil> = (
  ^enclosing isNil 
      ifTrue: [hiddenWorkspace] 
      ifFalse: [| result = computeExemplarFor: enclosing enclosing: nil. | result isNil ifFalse: [result]]. 
)
lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> 
(* :exemplar1: lexicallyLessOrEqual: 'abc' than: 'def' *)
(* :exemplar2: lexicallyLessOrEqual: 'def' than: 'abc' *)
(* :exemplar3: lexicallyLessOrEqual: 'ab' than: 'def' *)
(* :exemplar4: lexicallyLessOrEqual: 'de' than: 'def' *)
(* :exemplar5: lexicallyLessOrEqual: 'abc' than: 'abc' *)
= (
    (* We should normalize the case, so upper case stuff does not appear first *)

	| length = a size min: b size. |
	('a' at: 1) isKindOfInteger ifTrue: 
		[1 to: length do:
			[:index |
			 (a at: index) < (b at: index) ifTrue: [^true].
			 (a at: index) > (b at: index) ifTrue: [^false]].
		^a size <= b size].

	1 to: length do:
		[:index |
		 (a runeAt: index) < (b runeAt: index) ifTrue: [^true].
		 (a runeAt: index) > (b runeAt: index) ifTrue: [^false]].
	^a size <= b size
)
public compilationUnitFromSource: src <String> ^ <String> 
(*  :exemplar: compilationUnitFromSource: 'class Foo = ( | x = 0. |) (twiceX = (^2*x))' *)
= (
	^'Newspeak3', String newline,  'Root' printString, String newline, src
)
crToLf: string 
(* :exemplar:
crToLf: 'abc
or
def '
*)
= (
	('a' at: 1) isKindOfInteger
		ifTrue:
			[ | bytes = ByteArray withAll: string. |
			1 to: bytes size do: [:index | (bytes at: index) = 13 ifTrue: [bytes at: index put: 10]].
			^bytes asString]
		ifFalse:
			[ | cr = String fromRune: 13. lf = String fromRune: 10. |
			^string replaceAll: cr with: lf]
)
computeExemplarFor: classMirror  <ClassDeclarationMirror> within: objectMirror <ObjectMirror>  ^ <ObjectMirror | Nil>  = (
(* Compute an exemplar for the class declaration represented by classMirror, within the enclosing object given by objectMirror. *)
  |  
  thread <ThreadMirror> = objectMirror evaluate: (
    classMirror header metadata at: #exemplar ifAbsent: [
	|
	factorySelector <Symbol> = classMirror primaryFactorySelector.
	exemplarString <String> = exemplarForFactory: factorySelector.  
    |
     (exemplarString isNil not)
        ifTrue: [classMirror simpleName, exemplarString]
        ifFalse: [^nil]
        ]
    ).
  |
  thread isFulfilled ifTrue: [^thread result].
  thread isBroken ifTrue: [^nil].
  shouldNotHappen.
)
cssConversionTable ^ <Map[Symbol, String]> = (
(* compute a mapping from 'kinds', which are symbols denoting logical categories of code, to CSS properties used to colorize them*)
	|
	redBoldUnderlined <String> = 'color:Red; font-weight:bold; text-decoration: underline'.
	redUnderlined <String> = 'color:Red; text-decoration: underline'.
	orangeBoldUnderlined <String> = 'color:Orange; font-weight:bold; text-decoration: underline'.
	underlined <String> = 'text-decoration: underline'.
	gray <String> = 'color:Gray'.
	blue <String> = 'color:Blue'.
	grayBold <String> = 'color:Gray; font-weight:bold'.
	blackBold <String> = 'color:Black; font-weight:bold'.
	blueBold <String> = 'color:Blue; font-weight:bold'.
	magentaBold <String> = 'color:Magenta; font-weight:bold'.
	bold <String> = 'font-weight:bold'.
	|
      ^Map new
		at: #error put: redBoldUnderlined;
		at: #undefinedUnary put: redUnderlined;
		at: #undefinedBinary put: redUnderlined;
		at: #undefinedKeyword put: redUnderlined;
		at: #shadowingTempVar put: orangeBoldUnderlined;
		at: #obsoleteMessage put: orangeBoldUnderlined;
		at: #whitespaceWarning put: orangeBoldUnderlined;
		at: #incompleteUnary put: underlined;
		at: #incompleteBinary put: underlined;
		at: #incompleteKeyword put: underlined;
		at: #self put: gray;
		at: #super put: gray;
		at: #outer put: gray;
		at: #true put: gray;
		at: #false put: gray;
		at: #nil put: gray;
		at: #string put: gray;
		at: #symbol put: gray;
		at: #number put: gray;
		at: #character put: gray;
		at: #public put: gray;
		at: #protected put: gray;
		at: #private put: gray;
		at: #lazy put: gray;        
		at: #tempVar put: grayBold;
		at: #blockTempVar put: grayBold;
		at: #blockPatternArg put: grayBold;
		at: #patternArg put: grayBold;
		at: #slotDecl put: grayBold;
		at: #patternTempVar put: grayBold;
		at: #methodTempBar put: blackBold;
		at: #leftParenthesis put: blackBold;
		at: #rightParenthesis put: blackBold;
		at: #leftParenthesis3 put: blackBold;
		at: #rightParenthesis3 put: blackBold;
		at: #leftParenthesis6 put: blackBold;
		at: #rightParenthesis6 put: blackBold;
		at: #blockStart put: blackBold;
		at: #blockEnd put: blackBold;
		at: #blockStart3 put: blackBold;
		at: #blockEnd3 put: blackBold;
		at: #blockStart6 put: blackBold;
		at: #blockEnd6 put: blackBold;
		at: #leftBrace put: blackBold;
		at: #rightBrace put: blackBold;
		at: #leftBrace3 put: blackBold;
		at: #rightBrace3 put: blackBold;
		at: #leftBrace6 put: blackBold;
		at: #rightBrace6 put: blackBold;
		at: #messagePatternDecl put: bold;
		at: #class put: gray;
		at: #className put: bold;
		at: #comment put: blue;
		at: #type put: blueBold;
		at: #return put: blueBold;
		at: #leftParenthesis1 put: blueBold;
		at: #rightParenthesis1 put: blueBold;
		at: #leftParenthesis4 put: blueBold;
		at: #rightParenthesis4 put: blueBold;
		at: #leftParenthesis7 put: blueBold;
		at: #rightParenthesis7 put: blueBold;
		at: #blockStart1 put: blueBold;
		at: #blockEnd1 put: blueBold;
		at: #blockStart4 put: blueBold;
		at: #blockEnd4 put: blueBold;
		at: #blockStart7 put: blueBold;
		at: #blockEnd7 put: blueBold;
		at: #leftBrace1 put: blueBold;
		at: #rightBrace1 put: blueBold;
		at: #leftBrace4 put: blueBold;
		at: #rightBrace4 put: blueBold;
		at: #leftBrace7 put: blueBold;
		at: #rightBrace7 put: blueBold;
		at: #leftParenthesis2 put: magentaBold;
		at: #rightParenthesis2 put: magentaBold;
		at: #leftParenthesis5 put: magentaBold;
		at: #rightParenthesis5 put: magentaBold;
		at: #blockStart2 put: magentaBold;
		at: #blockEnd2 put: magentaBold;
		at: #blockStart5 put: magentaBold;
		at: #blockEnd5 put: magentaBold;
		at: #leftBrace2 put: magentaBold;
		at: #rightBrace2 put: magentaBold;
		at: #leftBrace5 put: magentaBold;
		at: #rightBrace5 put: magentaBold;
		yourself
)
initializeObjectViews = (
(*
Set up custom views for various types. 

This needs to be generalized. One shouldn't need to edit the IDE to set up custom views. 
*)
  objectViews 
    at: 'isKindOfInteger' put: {IntegerView};
    at: 'isKindOfArray' put: {};
    at: 'isKindOfString' put: {StringView};
    at: 'isKindOfList' put: {KeysAndValuesView};
    at: 'isKindOfMap' put: {KeysAndValuesView};
    at: 'isKindOfSet' put: {SetView};
    at: 'isKindOfImage' put: {ImageView. JSAlienView};
    at: 'isKindOfClosure' put: {ClosureView} ;
    at: 'isKindOfJSAlien' put: {JSAlienView}   
)
public addObjectViews: vs <{Presenter}> forKind: k <String> = (
  objectViews at: k put: vs
)
exemplarForFactory: factorySelector <Symbol> ^ <String | Nil>  
(*  :exemplar1 : exemplarForFactory: #new *)
(*  :exemplar2 : exemplarForFactory: #foo *)
(*  :exemplar3 : exemplarForFactory: #try:finally: *)
= (
  (Utilities isInstantiableUnarySelector: factorySelector) ifTrue: [^' ', factorySelector].
  factorySelector = #usingPlatform: ifTrue: [^' usingPlatform: platform'].
  factorySelector = #packageUsing: ifTrue: [^' packageUsing: ide namespacing manifest'].  
  factorySelector = #packageTestsUsing: ifTrue: [^' packageTestsUsing: ide namespacing manifest'].
  factorySelector = #usingPlatform:testFramework: ifTrue: [^' usingPlatform: platform testFramework: ide minitest'].
  factorySelector = #usingPlatform:ide: ifTrue: [^' usingPlatform: platform ide: ide'].  
  ^nil
)
) : (
)
