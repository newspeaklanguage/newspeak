Newspeak3
'HopscotchIDE'
class NewspeakColorization usingPlatform: p = (|
private Color = p graphics Color.
private Map = p collections Map.
private List = p collections List.
private TypedNS3Grammar = p mirrors grammar TypedNS3Grammar.

private ImplementationBase = p squeak ImplementationBase.
private TextColor = p squeak TextColor.
private TextEmphasis = p squeak TextEmphasis.
|) (
public class NS3BrowserColorizer = NS3Colorizer (|
	coloredText
|) (
applyColor: kind from: start to: end = (
	(* Hacked up to roughly match the table in SHTextStylerST80 newsqueakStyleTable.
	The advantage is that this code is not dependent on Shout *)

	({#error. #undefinedUnary. #undefinedKeyword. #undefinedBinary} includes: kind) ifTrue:
		[coloredText addAttribute: TextColor red from: start to: end.
		 coloredText addAttribute: TextEmphasis underlined from: start to: end.
		 ^self].

	({#shadowingTempVar. #obsoleteMessage. #whitespaceWarning} includes: kind) ifTrue:
		[coloredText addAttribute: TextEmphasis bold from: start to: end.
		 coloredText addAttribute: (TextColor color: Color orange) from: start to: end.
		 coloredText addAttribute: TextEmphasis underlined from: start to: end.
		 ^self].

	({#incompleteKeyword. #incompleteBinary. #incompleteUnary} includes: kind) ifTrue:
		[coloredText addAttribute: TextEmphasis underlined from: start to: end.
		 ^self].

	({#self. #super. #outer. #true. #false. #nil. #string. #symbol. #stringSymbol. #number. #character. #protected. #private. #public } includes: kind) ifTrue:
		[coloredText addAttribute: TextColor gray from: start to: end.
		 ^self].

	({#tempVar. #blockTempVar. #blockPatternArg. #patternArg. #patternTempVar} includes: kind) ifTrue:
		[coloredText addAttribute: TextEmphasis bold from: start to: end.
		 coloredText addAttribute: TextColor gray from: start to: end.
		 ^self].

	({#methodTempBar. #leftParenthesis. #rightParenthesis.  #leftParenthesis3. #rightParenthesis3.  #leftParenthesis6. #rightParenthesis6. #blockStart. #blockEnd.  #blockStart3. #blockEnd3.  #blockStart6. #blockEnd6.  #leftBrace. #rightBrace.  #leftBrace3. #rightBrace3.  #leftBrace6. #rightBrace6} includes: kind) ifTrue:
		[coloredText addAttribute: TextEmphasis bold from: start to: end.
		 coloredText addAttribute: TextColor black from: start to: end.
		 ^self].

	#slotDecl = kind ifTrue:
		[coloredText addAttribute: TextEmphasis bold from: start to: end.
		 coloredText addAttribute: TextColor gray from: start to: end.
		 ^self].

	({#messagePatternDecl. #className} includes: kind) ifTrue:
		[coloredText addAttribute: TextEmphasis bold from: start to: end.
		 ^self].

	kind = #comment ifTrue:
		[coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
		^self].

	({#type. #return. #leftParenthesis1. #rightParenthesis1. #leftParenthesis4. #rightParenthesis4. #leftParenthesis7. #rightParenthesis7. #blockStart1. #blockEnd1. #blockStart4. #blockEnd4.  #blockStart7. #blockEnd7. #leftBrace1. #rightBrace1.  #leftBrace4. #rightBrace4.  #leftBrace7. #rightBrace7} includes: kind) ifTrue:
		[coloredText addAttribute: TextEmphasis bold from: start to: end.
		 coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
		 ^self].

	({#leftParenthesis2. #rightParenthesis2. #leftParenthesis5. #rightParenthesis5.   #blockStart2. #blockEnd2.  #blockStart5. #blockEnd5.  #leftBrace2. #rightBrace2.  #leftBrace5. #rightBrace5 } includes: kind) ifTrue:
		[coloredText addAttribute: TextEmphasis bold from: start to: end.
		 coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
		 ^self].
)
applyRanges = (
	rangeMap do: [:blk | blk value ].
	^coloredText
)
noteRange: kind from: start to: end = (
	(* The range 0..size is degenerate and leads to errors in Squeak 5.0 Morphic layout of paragraphs. *)
	rangeMap add: [ applyColor: kind from: (start max: 1) to: end ].
)
public parseText: s <String> fromClass: c <Class> usingSelector: selector <Symbol> ^<Text> = (
	| parser |
	inputSize:: s size.
	klass:: c.
	bracketDepth:: 0.
	braceDepth:: 0.
	parenDepth:: 0.
	rangeMap:: List new.
	cachedScopeStack: nil.

	coloredText:: s asText.

	parser:: (perform: selector), eoi.
	parser parseString: s ifError: [:msg :pos |
		noteRange: #error from: pos to: inputSize.
		^applyRanges ].
	^applyRanges
)
) : (
)
class NS3Colorizer = TypedNS3Grammar (|
	cachedScopeStack
	klass
	rangeMap
	inputSize
	startComment
	braceDepth
	bracketDepth
	parenDepth
	isFirst ::= true.
|) (
accessModifier = (
	^super accessModifier wrapper: [:mod :ws |
		noteRange: mod value asSymbol from: mod start to: mod end.
		mod]
)
beginComment = (
	^(TokenizingParser withSubparser: super beginComment) wrap:
		[:t | self noteRange: #unfinishedComment from: t start to: self inputSize. t].
)
binaryMsgPattern = (
	^super binaryMsgPattern wrapper:
		[:sel <Token> :p <Tuple[Token, Token]> |
		self pushScope.
		self currentScope at: p first value put: #parameter.
		self noteRange: #messagePatternDecl from: sel start to: sel end.
		self noteRange: #patternArg from: p first start to: p first end].
)
binarySelector = (
	^super binarySelector wrap:
		[:t | | kind |
		kind:: selector: t value
			ifDefined: [#binary]
			ifIncomplete: [#incompleteBinary]
			ifUndefined: [#undefinedBinary]
			ifObsolete: [#obsoleteMessage].
		self noteRange: kind from: t start to: t end.
		t].
)
block = (
	^super block wrapper:
		[:lb :params :cb :rb |
		params isNil ifFalse: [params isEmpty ifFalse: [self popScope]].
		{lb. params. cb. rb}]
)
blockParameter = (
	^super blockParameter wrapper:
		[:cn :sd | (* blockParameter ::= colon, slotDecl *)
		| kind |
		checkBlockParameter: sd first.
		kind:: (symbolInScope: sd first value) ifTrue: [#shadowingTempVar] ifFalse: [#blockPatternArg].
		noteRange: kind from: sd first start to: sd first end.
		sd]
)
blockParameters = (
	^super blockParameters wrapper:
		[:ps :vb | self pushScope.
		ps do: [:p | self currentScope at: p first value put: #parameter].
		{ps. vb}]
)
braceLevelString = (
	^self braceDepth = 1 ifTrue: [''] ifFalse: [self braceDepth printString]
)
bracketLevelString = (
	^self bracketDepth = 1 ifTrue: [''] ifFalse: [self bracketDepth printString]
)
characterConstant = (
	^super characterConstant wrap:
		[:t | self noteRange: #'$' from: t start to: t end. t].
)
checkBlockParameter: sd <Token> = (
	(coloredText string runeAt: sd start - 1) = 58 ifTrue: [^self].
	self noteRange: #whitespaceWarning from: sd start - 1 to: sd start -1
)
checkKeyword: kwd <Token> = (
	kwd end >= inputSize ifTrue: [^self].
	(coloredText string runeAt: kwd end + 1) <= 32 ifTrue: [^self].
	self noteRange: #whitespaceWarning from: kwd start to: kwd end
)
public classHeader = (
	^super classHeader
		wrap:
			[:tokens |
			(tokens at: 9) = nil ifFalse:
				[ | decs |
					decs:: (tokens at: 9) size = 3 ifTrue: [
						((tokens at: 9) at: 2) ] ifFalse: [(tokens at: 9) at: 3].

					decs
					do: [:each | noteRange: #slotDecl from: (each at: 2) first start to: (each at: 2) first end ] ].
			tokens ]
)
public codeBody = (
	^super codeBody wrapper:
		[:litMsg :tmps :stmts |
		tmps isNil ifFalse: [tmps isEmpty ifFalse: [self popScope]].
		{tmps. stmts}]
)
comment = (
	^super comment wrap:
		[:token | self noteRange: #comment from: token start to: token end].
)
currentScope = (
	self assert: [self scopeStack isEmpty not] message: 'Scope underflow'.
	^self scopeStack last
)
decreaseBraceLevel = (
	self braceDepth: (self braceDepth - 1) \\ 7.
)
decreaseBracketLevel = (
	self bracketDepth: (self bracketDepth - 1) \\ 7.
)
decreaseParenLevel = (
	self parenDepth: (self parenDepth - 1) \\ 7.
)
endComment = (
	^(TokenizingParser withSubparser: super endComment) wrap:
		[:t | self rangeMap removeLast. t].
)
extendedCanUnderstand: sel = (
	| k |
	k: klass.
	[k isNil] whileFalse:
		[(k canUnderstand: sel) ifTrue: [^true].
		 k: k enclosingClass].

	klass mixin applications do: [:any | ^any canUnderstand: sel].
	^Object canUnderstand: sel
)
increaseBraceLevel = (
	self braceDepth: (self braceDepth + 1) \\ 7.
)
increaseBracketLevel = (
	self bracketDepth: (self bracketDepth + 1) \\ 7.
)
increaseParenLevel = (
	self parenDepth: (self parenDepth + 1) \\ 7.
)
keywordHereSend = (
	^super keywordHereSend wrap:
		[:kws | | sel kind |
		sel:: String streamContents:
			[:s |
			kws do: [:kwd |
				self rangeMap removeLast.
				s nextPutAll: kwd first value]].
		kind:: symbol: sel
			ifInScope: [#instVar]
			ifNotInScope: [#undefinedKeyword]
			ifObsolete: [#obsoleteMessage].
		kws do:
			[:kwp | self noteRange: kind from: kwp first start to: kwp first end]]
)
keywordMsg = (
	^super keywordMsg wrapper:
		[:esend :kws |
		| sel kind |
		kws do: [:kwp | checkKeyword: (kwp at: 1)].

		sel:: (kws inject: '' into: [:s :kwp | s, (kwp at: 1) value]) asString.
		kind:: selector: sel
			ifDefined: [#keyword]
			ifIncomplete: [#incompleteKeyword]
			ifUndefined: [#undefinedKeyword]
			ifObsolete: [#obsoleteMessage].
		kws do: [:kwp | self noteRange: kind from: kwp first start to: kwp first end]].
)
keywordMsgPattern = (
	^super keywordMsgPattern wrap:
		[:kws |
		pushScope.
		kws do: [:kwp | | kind |
			kind:: (symbolInScope: kwp last first value)
				ifTrue: [#shadowingTempVar]
				ifFalse: [#patternArg].
			currentScope at: kwp last first value put: #parameter.
			noteRange: #messagePatternDecl from: kwp first start to: kwp first end.
			noteRange: kind from: kwp last first start to: kwp last first end]]
)
lbracket = (
	^super lbracket wrap:
		[:t |
		| range |
		self increaseBracketLevel.
		range:: ('blockStart', self bracketLevelString) asSymbol.
		self noteRange: range from: t start to: t end.
		t]
)
lcurly = (
	^super lcurly wrap:
		[:t | | range |
		self increaseBraceLevel.
		range:: ('leftBrace', self braceLevelString) asSymbol.
		self noteRange: range from: t start to: t end.
		t]
)
lparen = (
	^super lparen wrap:
		[:t | | range |
		self increaseParenLevel.
		range:: ('leftParenthesis', self parenLevelString) asSymbol.
		self noteRange: range from: t start to: t end.
		t]
)
method = (
	| res |
	self pushScope.
	res:: super method.
	self popScope.
	^res
)
nestedClassDecl = (
	^super nestedClassDecl wrap:
		[:tokens | (* accessModifier opt, classDeclaration*)
		noteRange: #className from: ((tokens last) at: 2) start to: ((tokens last) at: 2) end.
		tokens]
)
number = (
	^super number wrap:
		[:t | self noteRange: #number from: t start to: t end. t].
)
parenLevelString = (
	^self parenDepth = 1 ifTrue: [''] ifFalse: [self parenDepth printString]
)
pattern = (
	^super pattern wrap:
		[:tpl |
		self noteRange: #string from: (tpl at: 1) start to: (tpl at: 3) end.
		tpl at: 2]
)
popScope = (
	self scopeStack removeLast
)
pushScope = (
	self scopeStack addLast: Map new
)
rbracket = (
	^super rbracket wrap:
		[:t |
		| range |
		range:: ('blockEnd', self bracketLevelString) asSymbol.
		self decreaseBracketLevel.
		self noteRange: range from: t start to: t end.
		t]
)
rcurly = (
	^super rcurly wrap:
		[:t | | range |
		range:: ('rightBrace', self braceLevelString) asSymbol.
		self decreaseBraceLevel.
		self noteRange: range from: t start to: t end.
		t]
)
returnStatement = (
	^super returnStatement wrapper:
		[:h <Token> :expr :od <Token> |
		self noteRange: #return from: h start to: h end.
		expr].
)
returnType = (
	^super returnType wrapper:
		[:h <Token> :t | self noteRange: #type from: h start to: h end. t]
)
rparen = (
	^super rparen wrap:
		[:t | | range |
		range:: ('rightParenthesis', self parenLevelString) asSymbol.
		self decreaseParenLevel.
		self noteRange: range from: t start to: t end.
		t]
)
scopeStack = (
	(* deal with forwarding reference *)
	cachedScopeStack isCollection
		ifFalse: [cachedScopeStack:: List new].
	^cachedScopeStack
)
selector: sel ifDefined: definedAction ifIncomplete: incompleteAction ifUndefined: undefinedAction ifObsolete: obsoleteAction = (
	({#isKindOf:. #out. #halt. #inspect. #flag:. #instVarAt:. #isMemberOf:. #~. #!=} includes: sel) ifTrue: [^obsoleteAction value].
	Symbol hasInterned: sel ifTrue: [:s | ^definedAction value].
	(Symbol thatStartsCaseSensitive: sel skipping: nil) isNil
		ifTrue: [^incompleteAction value]
		ifFalse: [^undefinedAction value]
)
semicolon = (
	^super semicolon wrap:
		[:t | self noteRange: #cascadeSeparator from: t start to: t end. t].
)
setterKeyword = (
	^super setterKeyword wrap: [:skw <Token> | | kind |
		checkKeyword: skw.
		kind:: (self symbolInScope: (skw value copyUpToLast: ":"))
			ifTrue: [#instVar]
			ifFalse: [#undefinedKeyword].
		self noteRange: kind from: skw  start to: skw end.
		skw]
)
slotDef = (
	^super slotDef wrap:
		[:tokens | | sd kind |
		sd:: (tokens at: 2) first.
		noteRange: #slotDecl from: sd start to: sd end.
		(* isFirst ifTrue: [pushScope. isFirst: false]. *)
		tokens]
)
slotName = (
	^super slotName wrap:
		[:n <Token> | | kind |
		kind:: ({'self'. 'super'. 'outer'. 'true'. 'false'. 'nil'} includes: n value)
			ifTrue: [n value asSymbol]
	        ifFalse: [symbol: n value
				ifInScope: [#instVar]
				ifNotInScope: [#undefinedUnary]
				ifObsolete: [#obsoleteMessage]].
		noteRange: kind from: n start to: n end.
		n]
)
string = (
	^super string wrap:
		[:t | self noteRange: #string from: t start to: t end. t]
)
symbol: aString <String> ifInScope: inScopeAction ifNotInScope: notInScopeAction ifObsolete: obsoleteAction = (
	scopeStack do: [:s | (s includesKey: aString) ifTrue: [^inScopeAction value]].
	Symbol hasInterned: aString ifTrue: [:sel <Symbol> |
		scopeStack do: [:s | (s includesKey: sel) ifTrue: [^inScopeAction value]].
		(extendedCanUnderstand: sel) ifTrue: [
			(ImplementationBase canUnderstand: sel)
				ifTrue: [^obsoleteAction value]
				ifFalse: [^inScopeAction value]]].
	^notInScopeAction value
)
symbolConstant = (
	^super symbolConstant wrapper:
		[:p <Token> :s |
		self noteRange: #symbol from: p start to: s end.
		s].
)
symbolInScope: aString <String> ^ <Boolean> = (
	scopeStack do: [:s | (s includesKey: aString) ifTrue: [^true]].
	^Symbol hasInterned: aString ifTrue: [:sel <Symbol> |
		scopeStack do: [:s | (s includesKey: sel) ifTrue: [^true]].
		(extendedCanUnderstand: sel) ifTrue: [^true].
		^false]
)
tempSlotDef = (
	^super slotDef wrap: [:tokens | | sd kind |
		sd:: (tokens at: 2) first.
		noteRange: #slotDecl from: sd start to: sd end.

		isFirst ifTrue: [pushScope. isFirst: false].

		kind:: (symbolInScope: sd value) ifTrue: [#shadowingTempVar] ifFalse: [#tempVar].
		currentScope at: sd value put: #temporary.
		currentScope at: sd value, ':' put: #temporary.
		noteRange: kind from: sd start to: sd end.

		tokens]
)
temporaries = (
	|
	tempSlotDefs = tempSlotDef star.
 	tempSeqSlotDecls = vbar, tempSlotDefs, vbar.
 	tempSimSlotDecls = vbar, vbar, tempSlotDefs, vbar, vbar.
 	tempSlotDecls = tempSimSlotDecls | tempSeqSlotDecls.
	|

	^tempSlotDecls wrap:
		[:parts | | vb1 vb2 vds vb3 vb4 |
		parts size = 3
			ifTrue:
				[vb1:: parts at: 1.
				vb2:: vb1.
				vds:: parts at: 2.
				vb3:: parts at: 3.
				vb4:: vb3]
			ifFalse:
				[vb1:: parts at: 1.
			vb2:: parts at: 2.
			vds:: parts at: 3.
			vb3:: parts at: 4.
			vb4:: parts at: 5].

		isFirst: true.
		noteRange: #methodTempBar from: vb1 start to: vb2 end.
		noteRange: #methodTempBar from: vb3 start to: vb4 end.
		vds]
)
type = (
	^super type wrapper:
		[:lb :te :rb | self noteRange: #type from: lb start to: rb end. te]
)
unaryMsgPattern = (
	^super unaryMsgPattern wrap:
		[:sel <Symbol> |
		self noteRange: #messagePatternDecl from: sel start to: sel end.
		sel].
)
unarySelector = (
	^super unarySelector wrap:
		[:t | | kind |
		kind:: selector: t value
			ifDefined: [#unary]
			ifIncomplete: [#incompleteUnary]
			ifUndefined: [#undefinedUnary]
			ifObsolete: [#obsoleteMessage].
		self noteRange: kind from: t start to: t end.
		t].
)
variableName = (
	^super variableName wrap:
		[:n <Token> |
		n value = 'self' ifTrue: [self noteRange: #self from: n start to: n end]
		ifFalse: [n value = 'super' ifTrue: [self noteRange: #super from: n start to: n end]
		ifFalse: [n value = 'true' ifTrue: [self noteRange: #true from: n start to: n end]
		ifFalse: [n value = 'false' ifTrue: [self noteRange: #false from: n start to: n end]
		ifFalse: [n value = 'nil' ifTrue: [self noteRange: #nil from: n start to: n end]
		ifFalse: []]]]].
		n]
)
) : (
)
) : (
)
