Newspeak3
'Hopscotch'
class HopscotchForHTML5 usingPlatform: p runtime: r = (
(* Hopscotch is Newspeak's UI framework. This version is implemented on top of HTML and CSS. 

Copyright Google Inc. 2012 -2017
*)|	
	private Color = p graphics Color.	
	private Context = p graphics Context.	
	private Timer = p actors Timer.	
	private List = p collections List.	
	private Map = p collections Map.	
	private TextBlock = p text TextBlock.	
	private TextProperties = p text TextProperties.
	private TextString = p text TextString.	
	private window = p aliens global.
	private document = window at: 'document'.
	private body = document at: 'body'.	
	private history = window at: 'history'.		
	sharedNavigationHistory	
	embeddedWindowMap = Map new.	
	sharedBackButtonListener
	currentHopscotchWindow		
	private accept16px = r accept16px.	
	private cancel16px = r cancel16px.	

	private disclosureClosedImage = r disclosureClosedImage.	
	private disclosureTransitionImage = r disclosureTransitionImage.
	private disclosureOpenImage = r disclosureOpenImage.	
	public dropDownImage = r dropDownImage.
	public dropDownOutImage = r dropDownOutImage.
	public dropDownOverImage = r dropDownOverImage.
		
	private deferredContentQueue = List new.	
	public core = self. (* Polymorphic with HopscotchForBrazil *)	
	public fragments = self. (* Polymorphic with HopscotchForBrazil *)
	|) (
class BlankFragment = LeafFragment (|
|) (
createVisual = (
	^document createElement: 'div'
)
) : (
)
class ButtonFragment label: l action: a = LeafFragment (|
	label = l.
	action = a.
|) (
createVisual = (
	^(document createElement: 'button')
		appendChild: (document createTextNode: label);
		at: 'onclick' put: [action value. false];
		yourself
)
) : (
)
class CanvasFragment withExtent: e = LeafFragment (|
private alien = document createElement: 'canvas'.
|alien at: 'width' put: e x.
alien at: 'height' put: e y.
(alien at: 'style') at: 'position' put: 'relative') (
public context = (
	^Context on: (alien getContext: '2d')
)
createVisual = (
	^alien
)
public keyDownAction: onKeyPressed <[:String]> = (
	(* The canvas element itself doesn't seem to get key events. *)
	body
		addEventListener: 'keydown'
		with: [:e | onKeyPressed value: (String fromCharCode: (e at: 'keyCode'))]
)
public mouseDownAction: onMouseDown <[:Point]> = (
	alien
		addEventListener: 'mousedown'
		with: [:e | onMouseDown value: (e at: 'offsetX') @ (e at: 'offsetY')].
)
public mouseMovedAction: onMouseMoved <[:Point]> = (
	alien
		addEventListener: 'mousemove'
		with: [:e | onMouseMoved value: (e at: 'offsetX') @ (e at: 'offsetY')].
)
) : (
)
class ColorDecorator color: c <Color> = Decorator (
(* Describe the class in this comment. *)| color <Color> = c.  |) (
public decorate: aVisual = (
	color applyToStyle: (aVisual at: 'style').
	^aVisual
)
) : (
)
class ColumnComposer definitions: fs <List[Fragment]> = SequenceComposer definitions: fs (|
|) (
flexDirection ^ <String> = (
	^'column'
)
) : (
)
class Composer = Fragment () (
) : (
)
public class Decorator = (
(* A Decorator is attached to a fragment and is called by the fragment to change the various attributes of the Brazil visual created by the fragment itself. *)) (
public decorate: aVisual = (
	(* Change properties of aVisual or wrap it into a new visual that applies whatever decorating we represent to aVisual. Answer aVisual or the new visual. *)
	subclassResponsibility
)
) : (
)
class DeferredContentComposer initialContent: ic contentSource: cs = Composer (|
	initialContent <Fragment> = ic.
	contentSource <[Fragment]> = cs.
|) (
createVisual = (
	| div initialVisual |
	div:: document createElement: 'div'.
	initialVisual:: initialContent visual.
	div appendChild: initialVisual.
	deferAction: [
		| deferredFragment = contentSource value. |
		deferredFragment parent: self.
		(* replace: new with: old due to stupid DOM argument ordering *)
		div replaceChild: deferredFragment visual with: initialVisual].
	^div
)
) : (
)
class DropDownMenuFragment menu: ms = ImageButtonFragment images: {dropDownImage. dropDownOverImage. dropDownOutImage} (|
	menuSupplier <[Tuple[Symbol | Tuple[String, []]]]> = ms. (* Skip formal menu structure for now*)
	menuActive <Boolean> ::= false.
|action:: []) (
computeContent ^ <Alien[Div]> = (
      |  dropDownContent = document createElement: 'div'. |	
		(dropDownContent at: 'style')
	      at: 'color' put: 'black';
	      at: 'backgroundColor' put: 'lightgray';
	      at: 'position' put: 'absolute';
	      at: 'padding-left' put: '6px';
	      at: 'padding-right' put: '10px';	
		at: 'border-radius' put: '5px';  
		at: 'box-shadow' put: '5px 5px 5px darkgrey';    
	      at: 'display' put: 'none'.
	menuSupplier value do: [:menuItem <MenuItem | Symbol> |
		| itemContent  <Alien[Element]> |
		itemContent:: contentFor: menuItem within: dropDownContent.
		dropDownContent appendChild: itemContent.
		].
	^dropDownContent.
)
contentFor: menuItem < MenuItem | Symbol>  within: dropDownContent ^ <Alien[Element]> = (
	| entry |
	menuItem = #separator ifTrue: [^document createElement: 'hr'].
	entry:: document createElement: 'div'.
	entry at: 'textContent' put: menuItem first.
	entry
		addEventListener: 'mouseover' action: [(entry at: 'style') at:  'background-color' put: 'darkgrey'];
	      addEventListener: 'mouseout' action: [(entry at: 'style') at: 'background-color' put: 'lightgrey'];
		addEventListener: 'click' action: [menuItem last value].
	^entry
)
createVisual ^ <Alien[Element]> = (
      |  
      dropDown = document createElement: 'div'. 
	dropDownButton = super createVisual. 
	|
	(dropDownButton at: 'style')
		at: 'position' put: 'relative';
		at: 'display' put: 'inline-block';
		at: 'cursor' put: 'pointer'.
	dropDown addEventListener: 'click' action: [toggleContent].
	dropDown appendChild: dropDownButton.
	^dropDown.	
)
removeContent ^ <Alien[Element]> = (
	^visual removeChild: (visual at: 'lastChild')
)
toggleContent = (
	menuActive ifTrue: [removeContent] ifFalse: [updateContent].
	menuActive:: menuActive not.
)
updateContent ^ <Alien[Element]> = (
	| menuContent |
	menuContent:: computeContent.
	(menuContent at: 'style') at:  'display' put: 'block'.
	visual appendChild:  menuContent.
	^menuContent
)
) : (
)
public class EmbeddedHopscotchWindow into: container openSubject: s = HopscotchShell (|  localNavigator = LocalNavigationHistory new. |container appendChild: contentHolder.
  enterSubject: s) (
public displayPresenter: p <Presenter> = (
	super displayPresenter: p.
	(* Not a full-page app: don't update document title. *)
)
public enterPresenter: p <Presenter> = ( 
      currentHopscotchWindow:: self.
      embeddedWindowMap at: p ifAbsentPut: [self].
      localNavigator visit: p.
	super enterPresenter: p
)
public enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (
      embeddedWindowMap at: snippet presenter ifAbsentPut: [self].
	enterSubject: s.
)
public goBack = (
	localNavigator goBack.
	displayPresenter: localNavigator current.
)
listenForBackButton = (
	nil = sharedBackButtonListener ifFalse: [^self. (* Already listening. *)].
	sharedBackButtonListener:: 
		[:event <Alien[Event]> | 
		| p <Presenter> = navigator presenterFor: (event at: 'state').  
		priorWindow = embeddedWindowMap at: p. |
		currentHopscotchWindow goBack. (* might be better to enterPresenter:? *)
		currentHopscotchWindow:: priorWindow].
	window at: 'onpopstate' put: sharedBackButtonListener.
)
navigationHistory = (
	^sharedNavigator
)
) : (
public openSubject: s = (
	^into: body openSubject: s
)
)
class Fragment = (|
	visualX
	public parent
	public size ::= nil.
	public expansibility ::= 0. 
	public compressibility ::= 0. 
	decorators
	|) (
public addDecorator: newDecorator <Decorator> = (
	(* The argument is added last to the collection of our decorators, meaning it will be applied after all the other decorators we might have. *)
	decorators
		ifNil: [decorators:: List with: newDecorator]
		ifNotNil: [decorators addLast: newDecorator]
)
createVisual = (
	subclassResponsibility
)
public decorate: aVisual = (
	(* The argument is a visual freshly created by the #createVisual or #createViewportWithVisual method. If we have any decorators attached, apply them now to arrive at the final decorated visual. *)
	| decorated |
	decorated:: aVisual.
	decorators ifNotNil:
		[decorators do: [:each | decorated:: each decorate: decorated]].
	^decorated
)
public elasticity: x = (
	expansibility: x.
	compressibility: x.
)
public hasVisual = (
	^visualX isNil not
)
public refresh = (

	(* Fragments that dynamically retrieve their information should reimplement this to update their visuals accordingly. *)

	childrenDo: [:each | each refresh]
)
public shell = (
	^parent isNil
		ifTrue: [Error signal: 'hierarchy not installed in a shell :',  printString]
		ifFalse: [parent shell]
)
public visual = (
	visualX isNil ifTrue: [visualX:: decorate: createVisual].
	^visualX
)
public width: w elasticity: e= (
	size: w.
	expansibility: e.
	compressibility: e.
)
) : (
)
public class Gradient from: a to: b = (|
	topColor = a.
	bottomColor = b.
|) (
public applyToStyle: style = (
	| value |
	value:: '(top,', topColor asCSSString, ',', bottomColor asCSSString, ')'.
	style setProperty: 'background-image' to: '-webkit-linear-gradient', value.
	style setProperty: 'background-image' to: '-moz-linear-gradient', value.
)
) : (
)
class HolderComposer withContent: definition = Composer (|
	contentSource ::= definition.
	actualContent
|) (
public childrenDo: aBlock = (
	actualContent ifNotNil: aBlock
)
public content ^<Fragment> = (
	actualContent isNil ifTrue: 
		[actualContent:: contentSource value.
		actualContent parent: self].
	^actualContent
)
public content: fragment = (
	fragment parent: self.
	hasVisual ifTrue:
		[ | oldContent newContent |
		oldContent:: actualContent.
		newContent:: actualContent:: fragment.
		(* replace: new with: old due to stupid DOM argument ordering *)
		visual replaceChild: newContent visual with: oldContent visual]
	ifFalse: [actualContent:: fragment]
)
createVisual = (
	| div |
	div:: document createElement: 'div'.
	div appendChild: content visual.
	^div
)
public refresh = (
	(contentSource isClosure and: [hasVisual])
		ifTrue:
			[ | oldContent newContent |
			oldContent:: actualContent.
			actualContent:: nil.
			newContent:: content.
			(* replace: new with: old due to stupid DOM argument ordering *)
			visual replaceChild: newContent visual with: oldContent visual]
		ifFalse:
			[actualContent refresh].
)
) : (
)
class HopscotchShell = (|
	navigator = navigationHistory.
	currentPresenterX
	contentHolder = document createElement: 'div'.
|listenForBackButton) (
public childrenDo: aBlock = (
	aBlock value: currentPresenter
)
public currentPresenter = (
	^currentPresenterX
)
public displayPresenter: p = (
	(* TODO: noticeX events *)
	p parent: self.
	contentHolder hasChildNodes
		ifTrue: [contentHolder replaceChild: p visual from: (contentHolder at: 'firstChild')]
		ifFalse: [contentHolder appendChild: p visual]
)
public enterPresenter: p = (
	(* TODO: Hopscotch History stuff *)
	
	(((document at: 'location') at: 'protocol') = 'file:') 
		ifFalse: [history pushState: (navigator idFor: p) title: p title].
	displayPresenter: p
)
public enterSubject: s <Subject> = (
	self enterPresenter: s presenter
)
listenForBackButton = (
	window at: 'onpopstate' put: [:e | userBack: e]
)
navigationHistory = (
	^NavigationHistory new
)
public shell = (
	^self
)
userBack: e = (
	| p <Presenter> = navigator presenterFor: (e at: 'state'). |
	displayPresenter: p
)
) : (
)
public class HopscotchWindow into: container openSubject: s = HopscotchShell (container appendChild: contentHolder.
	enterSubject: s) (
public displayPresenter: p = (
	super displayPresenter: p.
	document at: 'title' put: p title.
)
) : (
public openSubject: s = (
	^into: body openSubject: s
)
)
class HyperlinkFragment label: l action: a = LeafFragment (|
	label = l.
	action = a.
	public color ::= Color r: 0 g: 0 b: 1.
|) (
createVisual = (
	| anchor |
	anchor:: document createElement: 'a'.
	anchor at: 'href' put: '#'.
	anchor appendChild: (document createTextNode: label).
	anchor at: 'onclick' put: [action value. false].
	(anchor at: 'style')
		at: 'textDecoration' put: 'none'; (* No underline *)
		at: 'overflow' put: 'hidden';
		setProperty: 'white-space' to: 'nowrap'.
	color isNil ifFalse:
		[(anchor at: 'style') setProperty: 'color' to: color asCSSString].
	^anchor
)
public smallFont = (
  (visual at: 'style') at: 'font-size' put: 'smaller'
)
) : (
)
class HyperlinkImageFragment image: i action: a = LeafFragment (|
	image = i.
	action = a.
|) (
createVisual = (
	| img |
	img:: image cloneNode: false (* Not deep *).
	img at: 'onclick' put: [action value. false].
	^img
)
) : (
)
class ImageButtonFragment images: imageArray <Array[Image]> = LeafFragment (
(* A button displayed as an image; or an image that acts as a button. *)|
	public action <[]>
	stateImages <Array[Image]> = imageArray, (Array new: 3 withAll: nil).
	(* Appending three nils so that we can always send #at: with an index between 1 and 4 and expect it not to fail. *)
|) (
createVisual ^ <Visual> = (
	| img |
	img:: (stateImages at: 1) cloneNode: false (* Not deep *).
	img at: 'onclick' put: [action value. false].
	^img
)
) : (
)
class LeafFragment = Fragment () (
public childrenDo: aBlock = (
	(* No children. *)
)
) : (
)
class LocalNavigationHistory = (
(* LocalNavigationHistory is a richly structured collection that maintains a web browser-like history of ''visits''. Visits are arbitrary objects. NavigationHistory makes no assumptions about visits other than that they can be compared using #=.

The important attributes of a history are: the ''current'' visit, the ''past'', the ''future'' and ''allVisits''. A history starts off empty. To visit an object, send the #visit: message to the history with the object as the argument. This makes the object the ''current'' object of the history.

The ''past'' is a queue of visits that used to be the current (most recently current object last). Sending the #goBack message makes the most recently current object from the past the current again, while the current object becomes the first member of the ''future'' queue. Sending the #goForward message reverses the process. Visiting an object other than the first element of the ''future'' queue erases the future queue.

All visits visited by a history are remembered in the ''allVisits'' set. This set is never emptied, other than on an explicit request.

A history can optionally be configured with a transientTestBlock. The test block is applied to visits to determine whether they are transient or not. Transient visits are not recorded in the ''past'' and ''future'' queues and in the ''allVisits'' set. By default all visits are considered to be non-transient.
*)|
	currentVisitSlot
	public allVisits <List>
	public past <List>
	public future <List>
	public transientTestBlock <[:Object | Boolean]> ::= [:element | false].
|erase) (
public current ^ <Object> = (
	^currentVisitSlot
)
public do: aBlock = (
	(* Do the current visit separately if transient because it's not among allVisits. *)
	(isTransient: currentVisitSlot) ifTrue:
		[aBlock value: currentVisitSlot].
	allVisits do: aBlock
)
public equalVisitOr: anObject ^ <Object> = (
	(* Return a visit from the history equal to the argument, or the argument itself if there is no equal visit in the history. *)
	^allVisits detect: [:some | some = anObject] ifNone: [anObject]
)
public erase = (
	currentVisitSlot:: nil.
	allVisits:: List new.
	erasePast.
	eraseFuture.	
)
public eraseEntry: anObject = (
	allVisits remove: anObject.
	past remove: anObject ifAbsent: [].
	future remove: anObject ifAbsent: []. (* can it ever be in the future list? *)
)
eraseFuture = (
	future:: List new.
)
erasePast = (
	past:: List new.
)
public goBack = (
	isPastEmpty ifFalse:
		[(isTransient: currentVisitSlot) ifFalse:
			[future addFirst: currentVisitSlot].
		currentVisitSlot:: past removeLast]	
)
public goForward = (
	isFutureEmpty ifFalse:
		[(isTransient: currentVisitSlot) ifFalse:
			[past addLast: currentVisitSlot].
		currentVisitSlot:: future removeFirst]	
)
public goToFutureItem: anObject = (
	[currentVisitSlot = anObject or: [isFutureEmpty]]
		whileFalse: [goForward]
)
public goToPastItem: anObject = (
	[currentVisitSlot = anObject or: [isPastEmpty]]
		whileFalse: [goBack]
)
includesVisit: anObject ^ <Boolean> = (
	^allVisits includes: anObject
)
isEmpty ^ <Boolean> = (
	^allVisits isEmpty
)
public isFutureEmpty ^ <Boolean> = (
	^future isEmpty
)
public isPastEmpty ^ <Boolean> = (
	^past isEmpty
)
isTransient: anObject ^ <Boolean> = (
	^transientTestBlock value: anObject
)
next ^ <Object> = (
	(* Answer the closest visit from the future. Fail if the future is empty. *)
	^future first
)
previous ^ <Object> = (
	(* Answer the most recent visit from the past. Fail if the past is empty. *)
	^past last
)
replace: anObject with: replacement = (
	(* Replace all references to anObject that we have with references to 'replacement'. *)
	allVisits remove: anObject ifAbsent: [].
	(isTransient: replacement) ifFalse: [allVisits add: replacement].
	currentVisitSlot = anObject ifTrue: [currentVisitSlot:: replacement].
	past keysAndValuesDo:
		[:index :each | each = anObject ifTrue: [past at: index put: replacement]].
	future keysAndValuesDo:
		[:index :each | each = anObject ifTrue: [future at: index put: replacement]]
)
public replaceCurrentWith: anObject = (
	self replace: currentVisitSlot with: anObject
)
public visit: anObject = (
	(* Make the argument the current object of the history. The prior current object becomes the last object of the 'past' queue. The 'future' queue is erased, unless the visit is equal to the first element of the future. *)
	currentVisitSlot = anObject ifTrue: [^self].
	(currentVisitSlot notNil and: [(isTransient: currentVisitSlot) not]) ifTrue:
		[past addLast: currentVisitSlot].
	currentVisitSlot:: anObject.
	(isTransient: anObject) ifFalse:
		[allVisits 
			remove: anObject ifAbsent: [];
			add: anObject].
	future isEmpty not ifTrue:
		[future first = currentVisitSlot
			ifTrue: [future removeFirst]
			ifFalse: [eraseFuture]].
)
) : (
)
class NavigationHistory = (| nextId ::= 1. ids <Map[Presenter, Integer]> = Map new. |) (
public idFor: x <Presenter> ^ <Integer> = (
	^ids at: x ifAbsentPut: [nextId:: nextId + 1]
)
public presenterFor: x <Integer> ^ <Presenter> = (
	^ids keyAtValue: x
)
) : (
)
class PaddedFrameComposer content: c offsets: o = Composer (|
	content = c.
	offsets = o.
	public color
|) (
public childrenDo: aBlock = (
	content ifNotNil: aBlock
)
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style')
		at: 'paddingLeft' put: (offsets at: 1) printString, 'px';
		at: 'paddingTop' put: (offsets at: 2) printString, 'px';
		at: 'paddingRight' put: (offsets at: 3) printString, 'px';
		at: 'paddingBottom' put: (offsets at: 4) printString, 'px'.
	color isNil ifFalse: [color applyToStyle: (div at: 'style')].
	content parent: self.
	div appendChild: content visual.
	^div
)
) : (
)
public class Presenter onSubject: aSubject <Subject> = Fragment (|
subject <Subject> ::= aSubject.
substanceSlot <Fragment>
|) (
alert: text = (
	window alert: text
)
blank: size = (
	^BlankFragment new size: size
)
button: label <String> action: block <[]>= (
	^ButtonFragment label: label action: block
)
canvas: extent <Point> = (
	^CanvasFragment withExtent: extent
)
public childrenDo: aBlock = (
	substanceSlot ifNotNil: [:it | aBlock value: it]
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> ^<Fragment> = (
	^collapsed: collapsed expanded: expanded initiallyExpanded: false
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> initiallyExpanded: flag <Boolean>
^<Fragment> = (
	^ToggleComposer
		collapsedDefinition: collapsed
		expandedDefinition: expanded
		initiallyExpanded: flag
)
column: definitions <List[Fragment]> ^ <ColumnComposer>= (
	^ColumnComposer definitions: definitions
)
createVisual ^ <Alien[HTMLElement]> = (
(*	| substance = definition. |
	substance parent: self.
	^substance visual *)
	ensureSubstance.
	^substanceSlot visual
)
deferred: contentSource <[Fragment]> ^<Fragment> = (
	^DeferredContentComposer initialContent: nothing contentSource: contentSource
)
public definition ^<Fragment> = (
	subclassResponsibility
)
dropDownMenu: menu <[Menu]> ^ <DropDownMenuFragment> = (
	^DropDownMenuFragment menu: menu
)
ensureSubstance = (
	substanceSlot ifNil:
		[substanceSlot:: self definition.
		substanceSlot parent: self.
		noticeSubstanceCreation]
)
enterSubject: s = (
	(* TODO: use sendUp and open a new window if undelivered *)
	^shell enterSubject: s
)
enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (
	(* TODO: use sendUp and open a new window if undelivered *)
	^shell enterSubject: s fromSnippet: snippet
)
expanded: expanded <[Fragment]> collapsed: collapsed <[Fragment]> ^<Fragment> = (
	^collapsed: collapsed expanded: expanded initiallyExpanded: true
)
filler = (
	^BlankFragment new expansibility: 1; compressibility: 1
)
holder: definition <[Fragment]> = (
	^HolderComposer withContent: definition
)
image: image = (
	^StaticImageFragment image: image
)
imageButton: images <Array[Image]> action: block <[]> = (
	^(ImageButtonFragment images: images)
		action: block
)
initially: initialContent <Fragment> deferred: contentSource <[Fragment]> ^<Fragment> = (
	^DeferredContentComposer initialContent: initialContent contentSource: contentSource
)
label: label <String> = (
	^StaticLabelFragment text: label
)
link: label <String> action: block <[]> = (
	^HyperlinkFragment label: label action: block
)
linkImage: image action: block = (
	^HyperlinkImageFragment image: image action: block
)
list ^ <PresenterList> = (
	^PresenterList new
)
list: presenterSource <Sequence[Presenter] | [Sequence[Presenter]]> ^ <PresenterList> = (
	^PresenterList new presenterSource: presenterSource
)
mediumBlank = (
	^blank: 10
)
menuWithLabelsAndActions: labelsAndActions <Tuple[Symbol | Tuple[String, []]]> ^ <Menu> = (
| menu |

^labelsAndActions
(*	menu:: Menu forVisual: visual. 
	labelsAndActions do:
		[:each |
		menu add: (#separator = each
			ifTrue: [SeparatorItem new]
			ifFalse: [MenuItem key: nil label: each key action: each value])].
	^menun*)
)
nothing = (
	^BlankFragment new
)
noticeSubstanceCreation = (

	(* Received after the #definition method of the receiver has been invoked and the result remembered as its substance. The substance hasn't been asked to create a visual yet. *)
)
openMenu: aMenu = (
(* so the issue here is to actually open a menu that was not in the tree before? *)
	aMenu openIn: visual desktop
)
openMenuWithLabelsAndActions: labelsAndActions = (
	openMenu: (menuWithLabelsAndActions: labelsAndActions)
)
padded: definition with: offsets = (
	^PaddedFrameComposer content: definition offsets: offsets
)
row: definitions = (
	^RowComposer definitions: definitions
)
substance ^ <Fragment> = (
	ensureSubstance. 
	^substanceSlot
)
text: t <Text> = (
| subfragments <Collection[Fragment]> |
	t isKindOfTextString ifTrue: [^TextStringFragment onText: t].
	subfragments:: t textUnits collect: [:u <Text> | text: u].
	^TextBlockFragment onText: t subfragments: subfragments.
)
textDisplay: string = (
	^TextDisplayFragment text: string
)
textField: initialText onAccept: blk = (
(* experimental *)
	 ^fragments TextEditorFragment new 
            text: initialText; 
            acceptResponse: blk (*[: editor | blk valueWithPossibleArgument: editor. editor defaultAcceptResponse] *)
)
textString: string <String> = (
	^TextStringFragment forString: string
)
textString: string <String> properties: tps <TextProperties> = (
	^TextStringFragment forString: string properties: tps
)
public title ^<String> = (
	^subject title
)
zebra: sequence <Sequence[Fragment]> ^ <Sequence[Fragment]> = (
	sequence addDecorator: ZebraDecorator lighterColorFirst.
	^sequence
)
) : (
)
class PresenterList = Fragment (
(* PresenterList is a fragment that manages a sequence of Presenters, displaying them as a column. The interesting functionality it provides beyond that is updating itself intelligently when receiving a new sequence of presenters to display. New presenters equal (as determined by #=) to those currently displayed remain displayed as before, with any state they had unaffected even if their order in the list has changed.

The presenters can be given to the list either as a collection or as a niladic block that evaluates to a collection. In the latter case, a PresenterList will re-evaluate the block and update itself from the result each time it receives the #refresh message.

Slots:

presenterSourceX. The presenters to display or the block providing them, as given to this instance when it was created.

presentersX. If presenterSourceX is a collection, this slot holds the same object as presenterSourceX. It it is the block, it holds the last result produced by the block.
*)| 
	presenterSourceX <Sequence[Presenter] | [Sequence[Presenter]]> ::= List new.
	presentersX  <Sequence[Presenter]>
|) (
public add: aPresenter <Presenter> = (
	(* Append the argument to the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)
	(presenters includes: aPresenter) ifTrue:
		[presenters remove: aPresenter].
	presenters:: presenters copyWith: aPresenter
)
public add: aPresenter <Presenter> afterIndex: index <Integer> = (
	| newList |
	newList:: presenters copy.
	newList add: aPresenter afterIndex: index.
	presenters: newList.
)
public addAll: additionalPresenters <{Presenter}> = (
	presenters: presenters, additionalPresenters
)
public addFirst: aPresenter <Presenter> = (

	(* Add the argument at the beginning of the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)

	(presenters includes: aPresenter) ifTrue:
		[presenters remove: aPresenter].
	presenters:: {aPresenter}, presenters.
)
public childrenDo: aBlock = (
	presentersX ifNotNil: [:they | they do: aBlock]
)
public color: aColor = (
	addDecorator::
		ColorDecorator new color: aColor
)
createVisual = (
   | column = ColumnComposer definitions: presenters. |
	column parent: self.
	^column visual
)
public detectPresenter: aBlock = (
	^presentersX detect: aBlock
)
public detectPresenter: aBlock ifNone: noneBlock = (
	^presentersX detect: aBlock ifNone: noneBlock
)
findFirst: aBlock = (
	(* Answer the index of my first element for which aBlock evaluates as true. *)
	^presentersX findFirst: aBlock
)
findLast: aBlock = (
	(* Answer the index of my last element for which aBlock evaluates as true. *)
	^presentersX findLast: aBlock
)
public presenterSource: niladicValuable <Sequence[Presenter] | [Sequence[Presenter]]> = (
	presenterSourceX:: niladicValuable.
	presentersX ifNotNil: [refreshPresenterList]
)
public presenters ^ <Sequence[Presenter]> = (

	(* Return the presenters we are currently showing, pulling them from the source if needed. *)

	presentersX == nil ifTrue:
		[setPresenters: presenterSourceX value].
	^presentersX
)
public presenters: newPresenterList <Sequence[Presenter]> = (


	self presenterSource: newPresenterList
)
public refresh = (


	| newPresenters |
	newPresenters:: refreshPresenterList asSet.
	presenters do:
		[:each |
		(newPresenters includes: each) ifFalse: [each refresh]]
)
refreshPresenterList = (

	(* Make it so that the displayed presenters match those provided by the source. For a list initialized with a presenter collection, this only does anything non-trivial when the instance is brand new. For a list initialized with a block, this re-evaluates the block and updates the list. *)

	^setPresenters: presenterSourceX value
)
refreshPresenters = (


	presenters do: [:each | each refresh]
)
public remove: aPresenter = (
	presenters:: presenters copyWithout: aPresenter
)
public removeAt: index <Integer> = (
	| copy |
	copy:: presenters copy.
	copy removeAt: index.
	presenters:: copy.
)
replaceChild: aFragment with: anotherFragment = (


	| index newPresenters |
	(presentersX includes: aFragment) ifTrue:
		[index:: presenters indexOf: aFragment.
		newPresenters:: presenters copy.
		newPresenters at: index put: anotherFragment.
		^presenters: newPresenters].
	error: 'the fragment is not a child'
)
public setPresenters: newPresenterList <Sequence[Presenter]> = (

	(* This is the workhorse of intelligent updates: massage the argument presenters into the currently displayed list, making sure that if there is an element of newPresenterList equal to a currently displayed presenter, we continue using the current presenter. *)

	| currentPresenters oldPresentersAndIndices removedPresenters removedIndices addedPresenters newFinalList |
	currentPresenters:: presentersX ifNil: [List new].
	oldPresentersAndIndices:: Map new: currentPresenters size.
	currentPresenters keysAndValuesDo:
		[:index :each | oldPresentersAndIndices at: each put: index].
	addedPresenters:: List new: newPresenterList size.
	newFinalList:: List new: newPresenterList size.
	
	newPresenterList do:
		[:each | | oldIndex |
		oldIndex:: oldPresentersAndIndices at: each ifAbsent: [nil].
		oldIndex notNil 
			ifTrue: (* reusing a presenter we already have for this subject *)
				[newFinalList add: (presenters at: oldIndex).
				oldPresentersAndIndices removeKey: each]
			ifFalse:
				[newFinalList add: each.
				addedPresenters add: each]].

	removedPresenters:: oldPresentersAndIndices keys.
	removedIndices:: (1 to: currentPresenters size) select:
		[:index | removedPresenters includes: (currentPresenters at: index)].
	
	presentersX:: newFinalList.
	addedPresenters do: [:each <Presenter> | each parent: self].
	hasVisual ifTrue: [updateColumn].
	(*	[updateColumn: visualX
		 removingIndices: removedIndices 
		 addingPresenters: addedPresenters].*)
	^addedPresenters
)
updateColumn = (
   | newVisual = createVisual. |
  (visual at: 'parentElement') replaceChild: newVisual with: visual.
(* Note: this really means replace visual with newVisual; JS takes the args in wrong order *)
  visualX: newVisual
)
updateColumn: column removingIndices: indices addingPresenters: newPresenters = (


	indices asSortedList reverseDo:
		[:each | column removeAt: each].
	newPresenters do:
		[:each | column add: each visual].
	column reorder:
		(presenters collect: [:each | each visual])
)
) : (
)
class RowComposer definitions: fs <List[Fragment]> = SequenceComposer definitions: fs (|
|) (
flexDirection = (
	^'row'
)
) : (
)
class SequenceComposer definitions: fs <List[Fragment]> = Composer (|
	definitions <List[Fragment]> = fs.
	public color <Color>
|) (
public childrenDo: aBlock = (
	definitions do: aBlock
)
createVisual ^ <Alien[HTMLElement]> = (
	| container  <Alien[HTMLElement]> |
	container:: document createElement: 'div'.
	(container at: 'style')
		at: 'overflow' put: 'hidden';
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex';
		at: '-webkit-flex-direction' put: flexDirection;
		setProperty: 'flex-direction' to: flexDirection.
	color isNil ifFalse: 
		[color applyToStyle: (container at: 'style')].
	definitions do: [:fragment <Fragment> |
		| cell <Alien[HTMLElement]> |
		fragment parent: self.
		cell:: document createElement: 'div'.
		cell appendChild: fragment visual.
		(cell at: 'style')
			at: '-webkit-flex-grow' put: fragment expansibility;
			setProperty: 'flex-grow' to: fragment expansibility;
			at: '-webkit-flex-shrink' put: fragment compressibility;
			setProperty: 'flex-shrink' to: fragment compressibility.
		fragment size isNil ifFalse:
			[(cell at: 'style') 
				at: 'flexBasis' put: fragment size printString, 'px';
				at: '-webkit-flex-basis' put: fragment size printString, 'px'].
		container appendChild: cell].
	^container
)
) : (
)
class StaticImageFragment image: i = LeafFragment (|
	image = i.
|) (
createVisual = (
	^image cloneNode: false (* Not deep *)
)
) : (
)
class StaticLabelFragment text: t = LeafFragment (|
	text = t.
	public color
|) (
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style') 
		at: 'overflow' put: 'hidden';
		setProperty: 'white-space' to: 'pre'.
	div at: 'textContent' put: text.
	color isNil ifFalse:
		[(div at: 'style') setProperty: 'color' to: color asCSSString].
	^div
)
public smallFont = (
  (visual at: 'style') at: 'font-size' put: 'smaller'
)
) : (
)
public class Subject onModel: aModel = (|
	protected model ::= aModel.
	protected presenterX <Presenter>
|) (
public createPresenter ^<Presenter> = (
	subclassResponsibility
)
public presenter ^<Presenter> = (
	presenterX isNil ifTrue: [presenterX:: createPresenter].
	^presenterX
)
public title ^<String> = (
	^self printString
)
) : (
)
class TextBlockFragment onText: t <Text> subfragments: sfs <List[Fragment]> = TextFragment onText: t (
(* A fragment representing a compound text . *)| subfragments <List[Fragment]> = sfs. |) (
createVisual = (
	| span = document createElement: 'span'. |
	text textProperties applyTo: span.
	subfragments do: [:u | 
		span insertAdjacentElement: 'beforeEnd' into: u visual
		].
	^span
)
public cursorPosition ^ <Integer> = (
  | 
  ca
  sel = window getSelection. 
  focusNode
  sum <Integer> ::= 0.
  |
  sel isNil ifFalse: [ (*BOGUS: assumes the block is a flat collection of TextStringFragments*)
	focusNode:: sel at: 'focusNode'.
	ca:: (sel getRangeAt: 0) at: 'commonAncestorContainer'.
	subfragments do: [:sf <Fragment> | 
		(sf visual at: 'firstChild') = focusNode ifTrue: [^sum + sf cursorPosition].
            sum:: sum + (sf visual at: 'textContent') size.
		].
    ].
  ^nil
)
public cursorPosition: position <Integer> = (
	| sum <Integer> ::= 0. |
(*BOGUS: assumes the block is a flat collection of TextStringFragments*)
	subfragments do: [:subfragment <Fragment>  | | index <Integer> |
		index:: position  - sum.
		sum:: sum + (subfragment visual at: 'textContent') size.
		position <= sum ifTrue: [subfragment cursorPosition: index. ^self].
		].
)
public isKindOfTextBlockFragment ^ <Boolean> = (
	^true
)
) : (
)
class TextDisplayFragment text: t = LeafFragment (|
	textX ::= t.
|) (
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style') setProperty: 'white-space' to: 'pre-wrap'.
	div at: 'textContent' put: textX.
	^div
)
public smallFont = (
  (visual at: 'style') at: 'font-size' put: 'smaller'
)
public text = (
	^textX
)
public text: newText = (
	textX: newText.
	hasVisual ifTrue: [visual at: 'textContent' put: textX]
)
) : (
)
public class TextEditorFragment = LeafFragment (|
	textX <TextFragment | String> ::= ''.
	counterfactualBarX 
	editorX <Div>
	public textBeingAccepted <String>
	isInEditState ::= false.
	public changeResponse <[TextEditorFragment]>
	public acceptResponse <[TextEditorFragment]>
	public cancelResponse <[TextEditorFragment]>
	public oldText <TextFragment | String>
|) (
controlBarColor = (
	^Color r: 0.95 g: 0.792 b: 0.475
)
createVisual = (
	| frame editorWrapper accept cancel |
	frame:: document createElement: 'div'.
	(frame at: 'style')
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex'.
	editorX:: document createElement: 'div'.
	editorX at: 'contentEditable' put: 'true'.
	(editorX at: 'style')
		at: 'borderStyle' put: 'solid';
		at: 'borderWidth' put: '1px';
		at: 'borderColor' put: 'gray';
		setProperty: 'background-color' to: 'white';
		at: 'flex' put: 1;
		at: '-webkit-flex' put: 1;
		at: '-moz-flex' put: 1;
		setProperty: 'white-space' to: 'pre-wrap';
		at: 'display' put: 'block'.
		setText: textX.
	(* editorX at: 'textContent' put: textX.*)
	editorX addEventListener: 'input' with: [:event | respondToChange: event].
	counterfactualBarX:: document createElement: 'span'.
	(counterfactualBarX at: 'style')
		at: 'backgroundColor' put: controlBarColor asCSSString;
		at: 'flex' put: 'none';
		at: '-webkit-flex' put: 'none';
		at: '-moz-flex' put: 'none'.
	accept:: document createElement: 'img'.
	accept at: 'src' put: (accept16px yourself at: 'src').
	(accept at: 'style') at: 'margin' put: '3px'.
	accept at: 'onclick' put: [:event | respondToAccept: event].
	cancel:: document createElement: 'img'.
	cancel at: 'src' put: (cancel16px yourself at: 'src').
	(cancel at: 'style') at: 'margin' put: '3px'.
	cancel at: 'onclick' put: [respondToCancel].
	counterfactualBarX appendChild: accept.
	counterfactualBarX appendChild: cancel.
	frame appendChild: editorX.
	(* frame appendChild: counterfactualBarX. *)
	^frame
)
public cursorPosition ^ <Integer> = (
(* BOGUS. This leads to quirks when cutting and pasting. We really need to get the selection from the browser and identify 
the cursor position based on that. But so far that hasn't worked. And we have issues with inserting newlines.
*)
	| 
	oldString <String>
	newString <String>
	bound <Integer>
	offset <Integer> ::= 0. 
	|
	oldString::  textX text string.
	newString:: textBeingAccepted.
	bound:: newString size min: oldString size.
	offset:: -1 max: (newString size - oldString size -1).
	('old: ', oldString) out.
	('new: ', newString) out.
	1 to: bound do: [:i <Integer> |
		(oldString at: i) = (newString at: i) ifFalse: [^i + offset]
		].
	^newString size
)
public defaultAcceptResponse = (
	setVisualText:  textBeingAccepted.
	leaveEditState
)
defaultCancelResponse = (
	setVisualText: textX.
	leaveEditState
)
defaultChangeResponse = (
	enterEditState
)
public enterEditState = (
	isInEditState ifFalse:
		[visual appendChild: counterfactualBarX.
		isInEditState:: true].
	visual scrollIntoView: true (* alignWithTop *).
)
public leaveEditState = (
	isInEditState ifTrue:
		[visualX removeChild: counterfactualBarX.
		isInEditState:: false.
		(*removeMessages*)]
)
reconstructText ^ <String>= (
  (* compute the text string from the DOM. This is necessary since the textContent attribute does not accurately reflect
      newlines, as these are sometimes implied by div and br nodes. *)
  | 
  children <Alien[HTMLCollection]> = editorX at: 'children'.  
  numberOfChildren = children at: 'length'.
  result <String> 
  |
      result:: ''.
	0 to: numberOfChildren - 1 do: [:i <Integer> | result:: result, (reconstructTextForNode: (children item: i))].
	^result
)
reconstructTextForNode: n <Alien[Node]> ^ <String>= (
  (* compute the text string from the DOM. This is necessary since the textContent attribute does not accurately reflect
      newlines, as these are sometimes implied by div and br nodes. *)
  | 
  children <Alien[HTMLCollection]> = n at: 'children'.  
  numberOfChildren = children at: 'length'.
  result <String> 
  |
	result:: ''.
	numberOfChildren = 0  ifTrue: [result:: n at: 'textContent'].
	0 to: numberOfChildren - 1 do: [:i <Integer> | result:: result, (reconstructTextForNode: (children item: i))].
	({'P'. 'BR'. 'DIV'} includes: (n at: 'tagName') ) ifTrue: [(n at: 'tagName') out. result:: result, String cr].
	^result.
)
respondToAccept: event <Alien[Event]> = (
	textBeingAccepted:: editorX at: 'textContent' (*withSqueakLineEndings*).
	acceptResponse 
		ifNil: [defaultAcceptResponse]
		ifNotNil: [acceptResponse cull: self cull: event]
)
respondToCancel = (
	(*confirm: 'Confirm Cancel' ifConfirmed:
		[*)cancelResponse 
			ifNil: [defaultCancelResponse]
			ifNotNil: [cancelResponse cull: self](*]*)
)
respondToChange: event <Alien[Event]> = (
	textBeingAccepted:: reconstructText (*editorX at: 'textContent'.*).
	('reconstructed text: ', reconstructText) out.
	changeResponse 
		ifNil: [defaultChangeResponse]
		ifNotNil: [changeResponse cull: self cull: event]
)
public setCursor = (
	| sum <Integer> ::= 0. cp <Integer> = cursorPosition. |
	cp out.
	textX cursorPosition: 5.
	(* textX elementaryTextUnits do: [:u <TextString> | (*textX is a fragment or a string, has no elementary text units*)
		sum:: sum + u string size.
		cp < sum ifTrue: [^setCursor: u to: cp]
		]*)
)
public setCursor: position <Integer> = (
	| sum <Integer> ::= 0. |
	position out.
	textX cursorPosition: position.
)
setText: t <TextFragment | String>  = (
   t isString 
	ifTrue: [editorX at: 'textContent' put: t]
	ifFalse: [ | children = List new. |
		oldText isKindOfString ifFalse: [
			(editorX at: 'childNodes') forEach: [:n | children add: n].
			children do: [:n | editorX removeChild: n].
			].
		editorX appendChild: t visual
		]	
)
setVisualText: aText = (
	hasVisual ifTrue: [setText: aText]
)
public text = (
	^textX
)
public text: t = (
      oldText:: textX.
	textX: t.
	setVisualText: textX.
)
public updateCursor = (
	| sum <Integer> ::= 0. cp <Integer> = textX cursorPosition. |
	textX cursorPosition: cp.
)
) : (
)
class TextFragment onText: t <Text> = Fragment (
(*Abstract supertype of all texts.*)|
	public text <Text> = t.
|) (
public cursorPosition: position <Integer> = (
	subclassResponsibility
)
public isKindOfTextFragment ^ <Boolean> = (
	^true
)
) : (
)
class TextStringFragment onText: t <Text> = TextFragment onText: t (
(*A formatted string.*)) (
public createVisual = (
	| span = document createElement: 'span'. |
	text textProperties applyTo: span.
	span at: 'textContent' put: text string.
	^span
)
public cursorPosition ^ <Integer> = (
  | sel = window getSelection. |
  sel isNil ifFalse: [
	(*(visual at: 'firstChild') = (sel at: 'focusNode') ifTrue: [*)
		^(sel getRangeAt: 0) at: 'endOffset'
		(*]*)
    ].
  'textStringFragment cursorPosition is nil!' out.
  ^nil
)
public cursorPosition: position <Integer> = (

  |  textNode = visual at: 'firstChild'. range = document createRange. |

  range setStart: textNode to: position;
            setEnd: textNode to: position.
  window getSelection removeAllRanges; addRange: range
)
public isKindOfTextStringFragment ^ <Boolean>= (
	^true
)
) : (
public forString: s <String> ^ <Instance> = (
	^onText: (TextString forString: s properties:  TextProperties new)
)
public forString: s <String> properties: tps <TextProperties> ^<Instance> = (
	^onText: (TextString forString: s properties:  tps)
)
)
class ToggleComposer collapsedDefinition: collapsed <[Fragment]>
 expandedDefinition: expanded <[Fragment]>
 initiallyExpanded: flag <Boolean> = Composer (|
expandedDefinition <[Fragment]> = expanded.
collapsedDefinition <[Fragment]> = collapsed.
isExpanded <Boolean>  ::= flag.
expandedPresenter <Fragment>
collapsedPresenter <Fragment>
contentHolder
toggleWidget
|) (
public childrenDo: aBlock = (
	collapsedPresenter notNil ifTrue:
		[aBlock value: collapsedPresenter].
	expandedPresenter notNil ifTrue:
		[aBlock value: expandedPresenter].
)
public collapse = (
	installCollapsedPresenter
)
createVisual = (
	| toggleDiv div |
	contentHolder:: document createElement: 'div'.
	
	toggleDiv:: document createElement: 'div'.
	toggleWidget:: document createElement: 'img'.
	toggleWidget at: 'onclick' put: [userToggle].
	toggleDiv appendChild: toggleWidget.
	
	(contentHolder at: 'style') 
		at: '-webkit-flex-grow' put: 1;
		setProperty: 'flex-grow' to: 1;
		at: '-webkit-flex-shrink' put: 1;
		setProperty: 'flex-shrink' to: 1.
	(toggleDiv at: 'style') 
		at: '-webkit-flex-grow' put: 0;
		setProperty: 'flex-grow' to: 0;
		at: '-webkit-flex-shrink' put: 0;
		setProperty: 'flex-shrink' to: 0;
		at: 'paddingTop' put: '2px';
		at: 'paddingRight' put: '3px'.
	toggleWidget at: 'align' put: 'top'.
	
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
		
	div:: document createElement: 'div'.
	(div at: 'style')
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex';
		at: '-webkit-flex-direction' put: 'row';
		setProperty: 'flex-direction' to: 'row'.
	div appendChild: toggleDiv.
	div appendChild: contentHolder.
	^div
)
public expand = (
	installExpandedPresenter
)
installCollapsedPresenter = (
	collapsedPresenter isNil ifTrue: 
		[collapsedPresenter:: collapsedDefinition value.
		collapsedPresenter parent: self].
	installContentVisual: collapsedPresenter visual.
	toggleWidget at: 'src' put: (disclosureClosedImage at: 'src').
)
installContentVisual: newVisual = (
	contentHolder hasChildNodes
		ifTrue:
			[ | oldVisual = contentHolder at: 'firstChild'. |
			contentHolder replaceChild: newVisual with: oldVisual]
		ifFalse: [contentHolder appendChild: newVisual].
)
installExpandedPresenter = (
	expandedPresenter isNil ifTrue:
		[expandedPresenter:: expandedDefinition value.
		expandedPresenter parent: self].
	installContentVisual: expandedPresenter visual.
	toggleWidget at: 'src' put: (disclosureOpenImage at: 'src').
)
userToggle = (
	isExpanded:: isExpanded not.
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
)
) : (
)
public class ZebraDecorator firstColor: color1 secondColor: color2 = Decorator (|
	firstColor::= color1.
	secondColor::= color2.
	sequenceDefinition
|) (
public decorate: aVisual = (
| odd <Boolean> ::= false.  children = (aVisual at: 'children'). |
	0 to: (children at: 'length') - 1 do:
		[:index | | each = children item: index. c <Color> |
		c:: odd ifTrue: [firstColor] ifFalse: [secondColor].
		assert: [c isNil not] message: ['nil color!'].
		c applyToStyle: (each at: 'style').
		odd:: odd not.
		].
	^aVisual
)
) : (
public darkerColorFirst = (
	^self firstColor: (Color gray: 0.97) secondColor: Color white
)
public lighterColorFirst = (
	^self firstColor: Color white secondColor: (Color gray: 0.97)
)
)
deferAction: action = (
	deferredContentQueue add: action.
	deferredContentQueue size = 1 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
)
nextDeferredAction = (
	| action = deferredContentQueue removeFirst. |
	deferredContentQueue size > 0 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
	action value.
)
nextFrameDo: action = (
	(* Our goal is to run the argument after images have been loaded and rendered. window.requestAnimationFrame runs the callback *before* the next frame. We register another callback in the callback so the first deferred action runs *after* the next frame. We register *that* callback in another RAF callback to let new images added from a deferred block load and render before the next deferred block runs. RAF is also a relative new feature, so simply schedule a timer if it is not available. *)
	(window at: 'requestAnimationFrame') isUndefined
		ifTrue: [Timer after: 200 do: action]
		ifFalse: [window requestAnimationFrame: [
					window requestAnimationFrame: [
						window requestAnimationFrame: action]]].
)
sharedNavigator ^ <NavigationHistory> = (
	sharedNavigationHistory ifNil:[
		sharedNavigationHistory:: NavigationHistory new.
		].
	^sharedNavigationHistory
)
) : (
)
