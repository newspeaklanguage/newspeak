Newspeak3
'NS2PrimordialSoup'
class NewspeakPredictiveParsing usingPlatform: platform asts: asts = (
(* A predictive LL(3) parser for Newspeak.

Faster than the CombinatorialParsing-based parser, and can be modified without requiring a platform reset.

Brazil 1021 -> 50ms.
NewspeakCompilation  250 -> 16ms.

Todo:
 - Parse types according to the spec'd grammar. Currently we diet parse for a closing >.
 - Accept class declarations without bodies.
 - Attach better source positions for synthetic parts like the default superclass clause.
 - Separate the AST building from the parsing, something like the parser calling various #acceptFoo methods that subclasses should implement. Then add the colorizing and source mirror subclasses. *)
|
	private List = platform collections List.

	private BinaryTypeOpAST = asts BinaryTypeOpAST.
	private BlockAST = asts BlockAST.
	private BlockTypeAST = asts BlockTypeAST.
	private CascadedSendAST = asts CascadedSendAST.
	private CharacterAST = asts CharacterAST.
	private ClassBodyAST = asts ClassBodyAST.
	private ClassDeclarationAST = asts ClassDeclarationAST.
	private ClassHeaderAST = asts ClassHeaderAST.
	private ClassPrefixAST = asts ClassPrefixAST.
	private CodeBodyAST = asts CodeBodyAST.
	private ImmutableSlotDefAST = asts ImmutableSlotDefAST.
	private InitializerAST = asts InitializerAST.
	private MessageAST = asts MessageAST.
	private MessagePatternAST = asts MessagePatternAST.
	private MethodAST = asts MethodAST.
	private MixinApplicationClassAST = asts MixinApplicationClassAST.
	private MutableSlotDefAST = asts MutableSlotDefAST.
	private ParameterizedTypeAST = asts ParameterizedTypeAST.	
	private UnresolvedSendAST = asts UnresolvedSendAST.
	private NumberAST = asts NumberAST.
	private ReturnStatAST = asts ReturnStatAST.
	private SetterSendAST = asts SetterSendAST.
	private SideAST = asts SideAST.
	private StringAST = asts StringAST.
	private SymbolAST = asts SymbolAST.
	private TupleAST = asts TupleAST.
	private TypeIdAST = asts TypeIdAST.
	private UnaryTypeOpAST = asts UnaryTypeOpAST.
	private VarDeclAST = asts VarDeclAST.
	private VariableAST = asts VariableAST.
|) (
public class CommonParser = () (
public parseClassDeclaration: input <String> = (
	^(Parser for: input) advanceToken parseClassDeclarationEnd
)
public parseCompilationUnit: input <String> = (
	^(Parser for: input) advanceToken parseCompilationUnit
)
public parseExpression: input <String> = (
	^(Parser for: input) advanceToken parseDoItExpressionEnd
)
public parseMethodDeclaration: input <String> = (
	^(Parser for: input) advanceToken parseMethodDeclarationEnd
)
) : (
)
class ParseError message: m position: p = Error (
	|
	message <String> = m.
	position <Integer> = p.
	|
) (
public printString = (
	^'ParseError: ' , message , ' at position ' , position asString
)
) : (
)
public class Parser for: string = Scanner for: string (
(* A recursive descent parser for Newspeak that looks up to 3 token ahead. *)
|
	protected implicitReceiver = VariableAST new name: #'@here'.
|) (
defaultClassSide = (
	^SideAST new
		nestedClasses: {};
		methods: {}
)
defaultConstructorPattern = (
	^MessagePatternAST new selector: #new parameters: {}; start: 1; end: 1
)
defaultSuperclassClause = (
	^UnresolvedSendAST new
		receiver:
			(UnresolvedSendAST new
				receiver: implicitReceiver;
				message: (MessageAST new send: #Object with: {}; start: 1; end: 1);
				start: 1; end: 1);
		message:
			(MessageAST new send: #new with: {}; start: 1; end: 1); start: 1; end: 1
)
expected: expectedKind = (
	^(ParseError message: 'expected ' , expectedKind position: tokenStart) signal
)
public parseAccessModifierOpt = (
	tokenKind = #identifier ifTrue:
		[tokenValue = #public ifTrue: [advanceToken. ^#public].
		 tokenValue = #protected ifTrue: [advanceToken. ^#protected].
		 tokenValue = #private ifTrue: [advanceToken. ^#private]].
	^#protected
)
public parseBinaryExpression = (
	(* binaryExpression = unaryExpression, binaryMsg star. *)
	| result message |

	result:: parseUnaryExpression.

	[peekHasBinaryMessage] whileTrue:
		[message:: parseBinaryMessage.
		 result:: UnresolvedSendAST new
			to: result send: message;
			start: result start; end: message end].

	^result
)
public parseBinaryMessage = (
	(* binaryMsg = eventualSendOperator opt, binarySelector, unaryExpression. *)
	| messageStart isEventual selector argument |

	messageStart:: tokenStart.
	isEventual:: tokenKind = #'<-:'.
	isEventual ifTrue: [advanceToken].

	tokenKind = #binary ifFalse: [expected: 'binary selector'].
	selector:: tokenValue.
	advanceToken.
	argument:: parseUnaryExpression.

	^MessageAST new
		send: selector asSymbol with: {argument};
		isEventual: isEventual;
		start: messageStart; end: argument end
)
public parseBinaryMessagePattern = (
	(* 	binaryMsgPattern = binarySelector, slotDecl. *)
	| patternStart selector parameter pattern returnType |

	tokenKind = #binary ifFalse: [expected: 'binary selector'].
	patternStart:: tokenStart.
	selector:: tokenValue asSymbol.
	advanceToken.

	parameter:: parseParameterDeclaration.

	tokenKind = #'^' ifTrue: [returnType:: parseReturnType].

	^MessagePatternAST new
		selector: selector parameters: {parameter};
		returnType: returnType;
		start: patternStart; end: parameter end (* bogus *)
)
public parseBlockReturnType = (
       (* blockReturnType = typeExpr *)
       ^parseTypeExpr
)
public parseCascadedMessage = (
	tokenKind = #';' ifFalse: [expected: 'semicolon'].
	advanceToken.
	peekHasUnaryMessage ifTrue: [^parseUnaryMessage].
	peekHasBinaryMessage ifTrue: [^parseBinaryMessage].
	peekHasKeywordMessage ifTrue: [^parseKeywordMessage].
	expected: 'message'.
)
public parseCascadedMessageExpression = (
	| result message |
	result:: parseKeywordExpression.
	result isKindOfSendNode ifFalse: [^result].
	result receiver = implicitReceiver ifTrue: [^result].

	[tokenKind = #';'] whileTrue:
		[message:: parseCascadedMessage.
		 result:: CascadedSendAST new
			to: result cascade: message;
			start: message start; end: message end].

	^result
)
public parseClassDeclaration = (
	(* classDeclaration = classHeader, sideDecl, classSideDecl opt *)

	| declStart header instanceSide classSide declEnd |
	declStart:: tokenStart.
	header:: parseClassHeader.
	instanceSide:: parseInstanceSide.
	tokenKind = #':'
		ifTrue: [classSide:: parseClassSide]
		ifFalse: [classSide:: defaultClassSide].

	^ClassDeclarationAST new
		header: header;
		instanceSide: instanceSide;
		classSide: classSide;
		start: declStart; end: 0
)
public parseClassDeclarationEnd = (
	| result = parseClassDeclaration. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseClassHeader = (
	(* classHeader =
		(accessModifier opt, (tokenFromSymbol: #class), identifier, messagePattern, equalSign,
		superclassClause opt, lparen, classComment opt,
		slotDecls opt, initExprs,  rparen) |
		(accessModifier opt, (tokenFromSymbol: #class), identifier, empty, equalSign,
		superclassClause opt, lparen, classComment opt,
		slotDecls opt,  initExprs, rparen). *)

	| declStart am name constructor superclassCall comment tempsBody inits declEnd x y |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.

	(tokenKind = #identifier and: [tokenValue = 'class']) ifFalse: [expected: 'class'].
	advanceToken.

	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	name:: tokenValue.
	advanceToken.

	(* Cheat: skipping binary message pattern. *)
	(tokenKind = #identifier or: [tokenKind = #keyword])
		ifTrue: [constructor:: parseMessagePattern]
		ifFalse: [constructor:: defaultConstructorPattern].

	(tokenKind = #binary and: [tokenValue = '=']) ifFalse: [expected: '='].
	advanceToken.

	tokenKind = #identifier
		ifTrue: [superclassCall:: parseSuperclassClause]
		ifFalse: [superclassCall:: defaultSuperclassClause].

	tokenKind = #'(' ifFalse: [expected: '('].
	comment:: keepComment.
	advanceToken.

	tempsBody:: parseTemporariesOpt.

	inits:: parseInitExpressions.

	tokenKind = #')' ifFalse: [expected: ')'].
	declEnd:: tokenEnd.
	advanceToken.

	^ClassHeaderAST new
		name: name asSymbol;
		constructor: constructor;
		superclassName: superclassCall receiver message selector;
		superclassCall: superclassCall receiver;
		superConstructorCall: superclassCall message;
		slots: tempsBody temporaries;
		isSeq: tempsBody isSeq;
		initExprs: inits;
		category: 'Unclassified';
		classComment: (Token value: comment);
		inheritanceChain: {superclassCall};
		accessModifier: am;
		start: declStart; end: declEnd
)
public parseClassHeaderForName = (
	(* classHeader =
		(accessModifier opt, (tokenFromSymbol: #class), identifier, messagePattern, equalSign,
		superclassClause opt, lparen, classComment opt,
		slotDecls opt, initExprs,  rparen) |
		(accessModifier opt, (tokenFromSymbol: #class), identifier, empty, equalSign,
		superclassClause opt, lparen, classComment opt,
		slotDecls opt,  initExprs, rparen). *)

	| declStart am name constructor superclassCall comment tempsBody inits declEnd x y |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.

	(tokenKind = #identifier and: [tokenValue = 'class']) ifFalse: [expected: 'class'].
	advanceToken.

	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	^(Token value: tokenValue)
		start: tokenStart;
		end: tokenEnd.
)
public parseClassSide = (
	(* classSideDecl = colon, lparen, category star, rparen. *)

	| methods = List new. |

	(tokenKind = #':') ifFalse: [expected: ':'].
	advanceToken.

	(tokenKind = #'(') ifFalse: [expected: '('].
	advanceToken.

	[tokenKind = #')'] whileFalse:
		[methods add: parseMethodDeclaration].

	advanceToken. (* Consume ) *)

	^SideAST new
		transientSlots: {};
		nestedClasses: {};
		methods: methods
)
public parseClosure = (
	(* block = lbracket, blockParameters opt, codeBody, rbracket. *)
	| closureStart closureEnd parameters = List new. body |

	tokenKind = #'[' ifFalse: [expected: '['].
	closureStart:: tokenStart.
	advanceToken.

	tokenKind = #':' ifTrue:
		[[tokenKind = #':' ifFalse: [expected: ':'].
		  advanceToken.
		  parameters add: parseParameterDeclaration.
		  tokenKind = #binary and: [tokenValue = '|']] whileFalse.
		  advanceToken].

	body:: parseCodeBody.
	body parameters: parameters.

	tokenKind = #']' ifFalse: [expected: ']'].
	closureEnd:: tokenEnd.
	advanceToken.

	^BlockAST new
		body: body;
		start: closureStart;
		end: closureEnd
)
public parseCodeBody = (
	(* codeBody = (literalMessageComment | comment | whitespace) star, temporaries opt, statements. *)
	| body statements |
	body:: parseTemporariesOpt.
	body statements: parseStatements.
	^body
)
public parseCompilationUnit = (
	(* compilationUnit = languageId, toplevelClass, eoi. *)
	| category result |
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	advanceToken.

	tokenKind = #string ifFalse: [expected: 'string'].
	category:: tokenValue.
	advanceToken.

	result:: parseClassDeclaration.
	result category: category asSymbol.

	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseDoItExpressionEnd = (
	| result = parseCodeBody. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseExpression = (
	(* expression = setterKeyword star, sendExpression. *)
	| setterMessages = List new. result |
	[tokenKind = #setter] whileTrue:
		[setterMessages add:
			(MessageAST new
				send: tokenValue asSymbol with: nil;
				start: tokenStart; end: tokenEnd).
		 advanceToken].

	result:: parseSendExpression.
	setterMessages size to: 1 by: -1 do:
		[:index | | setterMessage = setterMessages at: index. |
		setterMessage arguments: {result}.
		setterMessage end: result end.
		result:: SetterSendAST
			to: implicitReceiver
			send: setterMessage
			start: setterMessage start
			end: setterMessage end].
	^result
)
public parseInitExpressions = (
	(* initExprs = expression starSeparatedOrTerminatedBy: dot. *)
	| statements = List new. |

	[(* ~FIRST(EXPRESSION) *)
	 tokenKind = #'^' ifTrue: [^statements].
	 tokenKind = #']' ifTrue: [^statements].
	 tokenKind = #')' ifTrue: [^statements].
	 tokenKind = #'}' ifTrue: [^statements].
	 tokenKind = #'.' ifTrue: [^statements].
	 tokenKind = #':' ifTrue: [^statements].
	 tokenKind = #';' ifTrue: [^statements].
	 tokenKind = #binary ifTrue: [^statements].
	 tokenKind = #end ifTrue: [^statements].

	 statements add: parseExpression.
	 tokenKind = #'.' ifTrue: [advanceToken]] repeat.
)
public parseInstanceSide = (
	(* sideDecl = lparen, classDecl star, category star, rparen. *)

	| nestedClasses = List new. methods = List new. member |

	(tokenKind = #'(') ifFalse: [expected: '('].
	advanceToken.

	[peekHasClassDeclaration] whileTrue:
		[nestedClasses add: parseClassDeclaration].

	[tokenKind = #')'] whileFalse:
		[methods add: parseMethodDeclaration].

	advanceToken. (* Consume ) *)

	^SideAST new
		transientSlots: {};
		nestedClasses: nestedClasses;
		methods: methods
)
public parseKeywordExpression = (
	(* keywordExpression = binaryExpression, keywordMsg opt. *)
	| result message |

	result:: parseBinaryExpression.

	peekHasKeywordMessage ifFalse: [^result].

	message:: parseKeywordMessage.
	^UnresolvedSendAST new
		to: result send: message;
		start: result start; end: message end
)
public parseKeywordHereSend = (
	(* keywordHereSend = keywordMsg. *)
	| message |
	message:: parseKeywordMessage.
	^UnresolvedSendAST new
		to: implicitReceiver send: message;
		start: message start; end: message end
)
public parseKeywordMessage = (
	(* keywordMsg = eventualSendOperator opt, (keyword, binaryExpression) plus. *)
	| messageStart isEventual selector arguments = List new. |

	messageStart:: tokenStart.
	isEventual:: tokenKind = #'<-:'.
	isEventual ifTrue: [advanceToken].

	tokenKind = #keyword ifFalse: [expected: 'keyword'].
	selector:: tokenValue.
	advanceToken.
	arguments add: parseBinaryExpression.

	[tokenKind = #keyword] whileTrue:
		[selector:: selector, tokenValue.
		 advanceToken.
		 arguments add: parseBinaryExpression].

	^MessageAST new
		send: selector asSymbol with: arguments asArray;
		isEventual: isEventual;
		start: messageStart; end: arguments last end
)
public parseKeywordMessagePattern = (
	(* keywordMsgPattern = (keyword, slotDecl) plus. *)
	| patternStart selector parameters = List new. returnType |

	tokenKind = #keyword ifFalse: [expected: 'keyword'].
	patternStart:: tokenStart.
	selector:: tokenValue.
	advanceToken.
	parameters add: parseParameterDeclaration.

	[tokenKind = #keyword] whileTrue:
		[selector:: selector, tokenValue.
		 advanceToken.
		 parameters add: parseParameterDeclaration].

	tokenKind = #'^' ifTrue: [returnType:: parseReturnType].

	^MessagePatternAST new
		selector: selector asSymbol parameters: parameters asArray;
		returnType: returnType;
		start: patternStart; end: parameters last end
)
public parseLiteral = (
	(* literal = pattern | number | symbolConstant | characterConstant | string | tuple. *)
	| n |

	tokenKind = #number ifTrue:
		[n:: NumberAST new
			value: tokenValue;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].

	tokenKind = #binary ifTrue:
		[tokenValue = '-' ifTrue: [
			advanceToken.
			tokenKind = 'number' ifFalse: [expected: 'number'].
			n:: NumberAST new
				value: tokenValue * -1;
				start: tokenStart; end: tokenEnd.
		 	advanceToken.
		 	^n]].

	tokenKind = #symbol ifTrue:
		[n:: SymbolAST new
			value: tokenValue asSymbol;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].

	tokenKind = #string ifTrue:
		[n:: StringAST new
			value: tokenValue asSymbol;
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].

	tokenKind = #character ifTrue:
		[n:: CharacterAST new
			value: ("a" = 'a' ifTrue: [tokenValue asSymbol] ifFalse: [tokenValue]);
			start: tokenStart; end: tokenEnd.
		 advanceToken.
		 ^n].

	tokenKind = #'{' ifTrue:
		[^parseTuple].

	expected: 'literal'
)
public parseLiteralMessageCommentOpt = (
	[ | comment subparser pragmas = List new. pragma |
	[skipWhitespace.
	 comment:: keepComment.
	 nil = comment] whileFalse:
		[subparser:: Parser for: comment.
		 pragma:: subparser advanceToken parseLiteralMessageOpt.
		 nil = pragma ifFalse: [pragmas add: pragma]].
	pragmas isEmpty ifTrue: [^nil].
	^pragmas] on: Error do: [:e | ^nil].
)
public parseLiteralMessageOpt = (
	(* : literalmessage : unaryMessage | (keyword, literal)+ *)
	| selector arguments |
	tokenKind = #':' ifFalse: [^nil].
	advanceToken.
	tokenKind = #keyword ifFalse: [^nil].
	tokenValue = 'literalmessage:' ifFalse: [^nil].
	advanceToken.
	tokenKind = 'identifier' ifTrue:
		[^MessageAST new send: tokenValue asSymbol with: {}].

	selector:: ''.
	arguments:: List new.
	[tokenKind = #end] whileFalse:
		[tokenKind = #keyword ifFalse: [^nil].
		 selector:: selector, tokenValue.
		 advanceToken.
		 arguments add: parseLiteral].

	arguments isEmpty ifTrue: [^nil].
	^MessageAST new send: selector asSymbol with: arguments asArray
)
public parseMessagePattern = (
	(* messagePattern = unaryMsgPattern | binaryMsgPattern | keywordMsgPattern. *)

	tokenKind = #identifier ifTrue:
		[^parseUnaryMessagePattern].
	tokenKind = #binary ifTrue:
		[^parseBinaryMessagePattern].
	tokenKind = #keyword ifTrue:
		[^parseKeywordMessagePattern].

	expected: 'message pattern'.
)
public parseMethodDeclaration = (
	(* methodDecl = accessModifier opt, messagePattern, equalSign, lparen, codeBody, rparen. *)
	| declStart am pattern pragmas body declEnd |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.

	pattern:: parseMessagePattern.

	(tokenKind = #binary and: [tokenValue = '=']) ifFalse: [expected: '='].
	advanceToken.

	(tokenKind = #'(') ifFalse: [expected: '('].
	pragmas:: parseLiteralMessageCommentOpt.
	advanceToken.

	body:: parseCodeBody.
	body literalMessages: pragmas.

	(tokenKind = #')') ifFalse: [expected: ')'].
	declEnd:: tokenEnd.
	advanceToken.

	body parameters: pattern parameters. (* asList? *)
	^MethodAST new
		pattern: pattern body: body accessModifier: am;
		start: declStart; end: declEnd
)
public parseMethodDeclarationEnd = (
	| result = parseMethodDeclaration. |
	tokenKind = #end ifFalse: [expected: 'end of input'].
	^result
)
public parseParameterDeclaration = (
	| varStart varEnd varName type result |
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	varStart:: tokenStart.
	varEnd:: tokenEnd.
	varName:: tokenValue asSymbol.
	advanceToken.

	(tokenKind = #binary and: [tokenValue = '<']) ifTrue:
		[type:: parseType].

	^(VarDeclAST name: varName type: type)
		start: varStart; end: varEnd.
)
public parseParenthesizedExpression = (
	(* parenthesizedExpression = lparen, expression, rparen. *)
	| start result |
	tokenKind = #'(' ifFalse: [expected: '('].
	start:: tokenStart.
	advanceToken.
	result:: parseExpression.
	tokenKind = #')' ifFalse: [expected: ')'].
	result start: start.
	result end: tokenEnd.
	advanceToken.
	^result
)
public parseParenthesizedTypeExpression = (
       (* parenthesizedTypeExpression = lparen, typeExpr, rparen *)
	| start result |
	tokenKind = #'(' ifFalse: [expected: '('].
	start:: tokenStart.
	advanceToken.
	result:: parseTypeExpr.
	tokenKind = #')' ifFalse: [expected: ')'].
	result start: start.
	result end: tokenEnd.
	advanceToken.
	^result
)
public parsePrimary = (
	(* primary = slotName | literal | block | parenthesizedExpression. *)
	| send |

	tokenKind = #identifier ifTrue:
		[send:: unaryImplicitReceiverSend.
		 advanceToken.
		^send].

	tokenKind = #'[' ifTrue:
		[^parseClosure].

	tokenKind = #'(' ifTrue:
		[^parseParenthesizedExpression].

	^parseLiteral
)
public parseReturnStatement = (
	(* returnStatement = hat, expression, dot opt. *)
	| statementStart expression |
	tokenKind = #'^' ifFalse: [expected: '^'].
	statementStart:: tokenStart.
	advanceToken.
	expression:: parseExpression.
	tokenKind = '.' ifTrue: [advanceToken].
	^ReturnStatAST new
		expression: expression;
		start: statementStart; end: expression end
)
public parseReturnType = (
	tokenKind = '^' ifFalse: [expected: '^'].
	advanceToken.
	^parseType
)
public parseSendExpression = (
	(* sendExpression = keywordHereSend | cascadedMessageExpression. *)
	peekHasKeywordMessage ifTrue: [^parseKeywordHereSend].
	^parseCascadedMessageExpression
)
public parseSlotDeclaration = (
	(* slotDef = accessModifier opt, slotDecl,
		(((tokenFromSymbol: #=) | (tokenFromSymbol: #'::=')), expression, dot) opt. *)
	| declStart am varStart varEnd varName type var init |
	declStart:: tokenStart.
	am:: parseAccessModifierOpt.
	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	varStart:: tokenStart.
	varEnd:: tokenEnd.
	varName:: tokenValue asSymbol.
	advanceToken.
	(tokenKind = #binary and: [tokenValue = '<']) ifTrue:
		[type: parseType].
	var:: (VarDeclAST name: varName type: type)
		start: varStart; end: varEnd.

	tokenKind = #'::=' ifTrue:
		[advanceToken.
		 init:: parseSlotInitializer.
		 ^MutableSlotDefAST new
			accessModifier: am;
			slotDecl: var;
			initializer: init;
			start: declStart; end: init end].

	(tokenKind = #binary and: [tokenValue = '=']) ifTrue:
		[advanceToken.
		 init:: parseSlotInitializer.
		 ^ImmutableSlotDefAST new
			accessModifier: am;
			slotDecl: var;
			initializer: init;
			start: declStart; end: init end].

	^MutableSlotDefAST new
		accessModifier: am;
		slotDecl: var;
		initializer: nil;
		start: declStart; end: tokenEnd
)
public parseSlotInitializer = (
	(* slotDef = accessModifier opt, slotDecl,
		(((tokenFromSymbol: #=) | (tokenFromSymbol: #'::=')), expression, dot) opt. *)
	| result |
	result:: parseExpression.
	tokenKind = #'.' ifFalse: [expected: '.'].
	advanceToken.
	^result
)
public parseStatements = (
	(*
	furtherStatements = dot, statements.
	statementSequence = expression, furtherStatements  opt.
 	statements = returnStatement | statementSequence | empty.
	*)
	| statements = List new. |

	[tokenKind = #'^' ifTrue:
		[statements add: parseReturnStatement.
		 ^statements].

	 (* ~FIRST(EXPRESSION) *)
	 tokenKind = #']' ifTrue: [^statements].
	 tokenKind = #')' ifTrue: [^statements].
	 tokenKind = #'}' ifTrue: [^statements].
	 tokenKind = #'.' ifTrue: [^statements].
	 tokenKind = #':' ifTrue: [^statements].
	 tokenKind = #';' ifTrue: [^statements].
	 tokenKind = #end ifTrue: [^statements].

	 statements add: parseExpression.
	 tokenKind = #'.' ifTrue: [advanceToken]] repeat.
)
public parseSuperclassClause = (
	(* superclassClause = superclassPrefix opt, identifier, message opt.
		outerReceiver = (tokenFromSymbol: #outer), identifier.
		superclassPrefix = outerReceiver | (tokenFromSymbol: #self) | (tokenFromSymbol: #super).
	*)
	| clauseStart sc clauseEnd |

	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	clauseStart:: tokenStart.

	({'self'. 'super'. 'outer'} includes: tokenValue)
		ifFalse: [sc:: implicitReceiver]
		ifTrue:
			[sc:: VariableAST new name: tokenValue asSymbol; start: tokenStart; end: tokenEnd.
			 advanceToken.
			 sc name = #outer ifTrue:
				[tokenKind = #identifier ifFalse: [expected: 'identifier'].
				 sc:: UnresolvedSendAST new
					receiver: sc;
					message:
						(MessageAST new
							send: tokenValue asSymbol with: {};
							start: tokenStart; end: tokenEnd);
	                         start: clauseStart; end: tokenEnd.
				 advanceToken]].

	tokenKind = #identifier ifFalse: [expected: 'identifier'].
	sc:: UnresolvedSendAST new
		receiver: sc;
		message:
			(MessageAST new
				send: tokenValue asSymbol with: {};
				start: tokenStart; end: tokenEnd);
		start: clauseStart; end: tokenEnd.
	clauseEnd:: tokenEnd.
	advanceToken.

	^UnresolvedSendAST new
		receiver: sc;
		message: parseSuperclassMessage;
		start: clauseStart; end: clauseEnd
)
public parseSuperclassMessage = (
	tokenKind = #identifier ifTrue: [^parseUnaryMessage].
	tokenKind = #binary ifTrue: [^parseBinaryMessage].
	tokenKind = #keyword ifTrue: [^parseKeywordMessage].
	^MessageAST new send: #new with: {}; start: 1; end: 1
)
public parseTemporariesOpt = (
	| temps = List new. body |
	body:: CodeBodyAST new.
	body isSeq: true.
	body temporaries: temps.

	(* Also allow |||| as empty simultaneous slot declarations? *)

	(tokenKind = #binary and: [tokenValue = '||']) ifTrue:
		[advanceToken.
		 tokenKind = #identifier ifFalse: [^body].
		 body isSeq: false.
		 [tokenKind = #binary and: [tokenValue = '||']] whileFalse:
			[temps add: parseSlotDeclaration].
		 advanceToken. (* || *)
		 ^body].

	(tokenKind = #binary and: [tokenValue = '|']) ifTrue:
		[advanceToken.
		[tokenKind = #binary and: [tokenValue = '|']] whileFalse:
			[temps add: parseSlotDeclaration].
		 advanceToken. (* | *)
		 ^body].

	^body (* No temporaries. *)
)
public parseTuple = (
	(* tuple = lcurly, (expression starSeparatedOrTerminatedBy: dot), rcurly. *)
	| tupleStart tupleEnd elements = List new. |

	tokenKind = #'{' ifFalse: [expected: '{'].
	tupleStart:: tokenStart.
	advanceToken.

	[tokenKind = #'}'] whileFalse:
		[elements add: parseExpression.
		 tokenKind = #'.' ifTrue: [advanceToken]].

	tupleEnd:: tokenEnd.
	advanceToken. (* Consume } *)

	^TupleAST new elements: elements; start: tupleStart; end: tupleEnd
)
public parseUnaryExpression = (
	(* unaryExpression = primary, unaryMsg star. *)
	| result message |

	result:: parsePrimary.

	[peekHasUnaryMessage] whileTrue:
		[message:: parseUnaryMessage.
		 result:: UnresolvedSendAST new
			to: result send: message;
			start: result start; end: message end].

	^result
)
public parseUnaryMessage = (
	(* unaryMsg = eventualSendOperator opt, unarySelector. *)
	| messageStart isEventual message |

	messageStart:: tokenStart.
	isEventual:: tokenKind = #'<-:'.
	isEventual ifTrue: [advanceToken].

	tokenKind = #identifier ifFalse: [expected: 'unary selector'].

	message:: MessageAST new
		send: tokenValue asSymbol with: {};
		isEventual: isEventual;
		start: messageStart; end: tokenEnd.
	advanceToken.
	^message
)
public parseUnaryMessagePattern = (
	(* unaryMsgPattern = unarySelector. *)
	| pattern |

	tokenKind = #identifier ifFalse: [expected: 'unary selector'].

	pattern:: MessagePatternAST new
		selector: tokenValue asSymbol parameters: {};
		start: tokenStart; end: tokenEnd.
	advanceToken.

	tokenKind = #'^' ifTrue: [pattern returnType: parseReturnType].

	^pattern
)
peekHasAccessModifier = (
	(* LL(1) *)
	tokenKind = #identifier ifFalse: [^false].
	tokenValue = #public ifTrue: [^true].
	tokenValue = #protected ifTrue: [^true].
	tokenValue = #private ifTrue: [^true].
	^false
)
peekHasBinaryMessage = (
	(* LL(2) *)
	| context result |
	tokenKind = #binary ifTrue: [^true].
	tokenKind = #'<-:' ifFalse: [^false].

	(* Unlikely *)
	context:: saveContext.
	advanceToken. (* Consume <-: *)
	result:: tokenKind = #binary.
	restoreContext: context.
	^result
)
peekHasClassDeclaration = (
	(* LL(3) *)
	(* classHeader = (accessModifier opt, (tokenFromSymbol: #class), identifier, ... *)

	| context = saveContext. |
	peekHasAccessModifier ifTrue: [advanceToken].

	(tokenKind = #identifier and: [tokenValue = 'class']) ifFalse:
		[restoreContext: context.
		 ^false].
	advanceToken.

	tokenKind = #identifier ifFalse:
		[restoreContext: context.
		 ^false].

	restoreContext: context.
	^true
)
peekHasKeywordMessage = (
	(* LL(2) *)
	| context result |
	tokenKind = #keyword ifTrue: [^true].
	tokenKind = #'<-:' ifFalse: [^false].

	(* Unlikely *)
	context:: saveContext.
	advanceToken. (* Consume <-: *)
	result:: tokenKind = #keyword.
	restoreContext: context.
	^result
)
peekHasUnaryMessage = (
	(* LL(2) *)
	| context result |
	tokenKind = #identifier ifTrue: [^true].
	tokenKind = #'<-:' ifFalse: [^false].

	(* Unlikely *)
	context:: saveContext.
	advanceToken. (* Consume <-: *)
	result:: tokenKind = #identifier.
	restoreContext: context.
	^result
)
unaryImplicitReceiverSend = (
	| selector = tokenValue asSymbol. message |
	selector = #self ifFalse:
		[selector = #super ifFalse:
			[selector = #outer ifFalse:
				[message:: MessageAST new
					send: selector with: {};
					start: tokenStart; end: tokenEnd.
				^UnresolvedSendAST new
					to: implicitReceiver send: message;
	                	start: tokenStart; end: tokenEnd]]].

	^VariableAST new name: selector; start: tokenStart; end: tokenEnd.
)
public parseTypeTerm = (
       (* typeTerm = typeFactor, identifier star *)
       | tfactor = parseTypeFactor. operators = List new. end |
       end:: tfactor end.
       [tokenKind = #identifier] whileTrue: [
         operators add: tokenValue.
	 end:: tokenEnd.
	 advanceToken.
       ].
       ^operators inject: tfactor into: [:te <TypeExpression> :op |
	   UnaryTypeOpAST new operand: te; operator: op;
	                     start: te start; end: end
	   ]
)
public parseTupleType = (
       (* tupleType = lcurly, (typeExpr starSeparatedBy: dot), rcurly *)
       | tupleTypeStart  tupleTypeEnd elements = List new. |
       tokenKind = #'{' ifFalse: [expected: '{'].
	tupleTypeStart:: tokenStart.
	advanceToken.
	[tokenKind = #'}'] whileFalse:
		[elements add: parseTypeExpr.
		 tokenKind = #'.' ifTrue: [advanceToken]].

	tupleTypeEnd:: tokenEnd.
	advanceToken. (* Consume } *)
	^ParameterizedTypeAST new generic: (TypeIdAST new name: #Tuple);
	                                     arguments: elements;
	                                     start: tupleTypeStart;
	                                     end: tupleTypeEnd
)
public parseTypeFactor = (
       (* typeFactor = typePrimary | blockType | tupleType | parenthesizedTypeExpression *)
       tokenKind = #identifier ifTrue: [^parseTypePrimary].
       tokenKind = #'[' ifTrue: [^parseBlockType].
       tokenKind = #'{' ifTrue: [^parseTupleType].
       tokenKind = #'(' ifTrue: [^parseParenthesizedTypeExpression].
       expected: 'identifier or [ or { or ('.  
)
public parseTypeExpr = (
       (* typeExpr = typeTerm, ((vbar | semicolon | slash), typeExpr) *)
       | tterm = parseTypeTerm. texp op |
       ((tokenKind = #binary and: [tokenValue = '|']) or: [tokenKind = #';' or: [tokenKind = #'/']]) 
          ifTrue: [
	       op = tokenValue.
	       advanceToken.
	       texp:: parseTypeExpr.
	      ^BinaryTypeOpAST new leftOperand: tterm;
	                         operator: op;
	                         rightOperand: texp;
	                         start: tterm start;
	                         end: texp end
	     ].
	  ^tterm
)
public parseBlockArgType = (
       (* blockArgType = colon, typeTerm *)
       tokenKind = #':' ifTrue: [
         advanceToken.
	    ^parseTypeTerm
       ].
       expected: ':'
)
public parseTypeArguments = (
       (* typeArguments = lbracket, (typeExpr plusSeparatedBy: comma), rbracket *)
       | tas = List new. |
       tokenKind = #'[' ifFalse: [expected: '['].
       advanceToken.
       tas add: parseTypeExpr.
       [tokenKind = #binary and: [tokenValue = ',']] whileTrue: [
	     advanceToken.
         tas add: parseTypeExpr.
       ].
       ^tas
)
public parseNonEmptyBlockArgList = (
       (* nonEmptyBlockArgList = blockArgType plus, (vbar, blockReturnType) opt *)
       | bargs = List new. |
       bargs add: parseBlockArgType.
       [tokenKind = #':'] whileTrue: [
         bargs add: parseBlockArgType.
       ].
       (tokenKind = #binary and: [tokenValue = '|']) ifTrue: [
         advanceToken.
	     bargs add: parseBlockReturnType.
       ] ifFalse: [bargs add: (TypeIdAST new name: #Object)].
       ^bargs
)
public parseTypePrimary = (
       (* typePrimary = identifier, typeArguments opt *)
       | tid  tas start end |
       tokenKind = #identifier ifFalse: [expected: 'identifier'].
       tid:: TypeIdAST new name: tokenValue; start: tokenStart; end: tokenEnd.
       start:: tokenStart.
       advanceToken.
       tokenKind = #'[' ifFalse: [^tid].
       tas:: parseTypeArguments.
       tokenKind = #']' ifFalse: [expected: ']'].
       end: tokenEnd.
       advanceToken.
       ^ParameterizedTypeAST new generic: tid;
	                         arguments: tas;
	                         start: start;
	                         end: end
)
public parseType = (
    | type |

    (tokenKind = #binary and: [tokenValue = '<']) ifFalse: [expected: '<'].
    advanceToken.
    type:: parseTypeExpr.
    (tokenKind = #binary and: [tokenValue = '>']) ifTrue: [
          advanceToken. 
          ^type
        ].
    expected: '>'
)
public parseBlockType = (
       (* blockType = lbracket, (nonEmptyBlockArgList | blockReturnType opt), rbracket *)
       | blockStart blockEnd blockArgs ::= List new. blockReturn |
      tokenKind = #'[' ifFalse: [expected: '['].
      blockStart:: tokenStart.
      advanceToken.
      tokenKind = #':'
        ifTrue: [blockArgs:: parseNonEmptyBlockArgList. blockReturn:: blockArgs last]
        ifFalse: [
	  (tokenKind = #identifier or: [
	  tokenKind = #'[' or: [
	  tokenKind = #'{' or: [
	  tokenKind = #'(']]]) ifTrue: [
	    blockReturn:: parseBlockReturnType
	    ]
	  ]. 
      tokenKind = #']' ifFalse: [expected: ']'].
      blockEnd:: tokenEnd.
      advanceToken.
      blockArgs isEmpty ifFalse: [blockArgs removeLast].
      ^(BlockTypeAST formals: blockArgs  return: blockReturn)
        start: blockStart; end: blockEnd
)
) : (
)
public class Scanner for: string = (
(* Turns Newspeak source into a stream of tokens.

The current token is available via #tokenKind, #tokenValue, #tokenStart, and #tokenEnd.

Frequency of Newspeak tokens:

#identifier 137832
#keyword 57744
#binary 54283
#'.' 25339
#'(' 23920
#')' 23920
#'[' 12090
#']' 12090
#'^' 11228
#number 10767
#string 6080
#setter 5520
#':' 5172
#';' 2253
#symbol 2015
#'{' 1477
#'}' 1477
#character 500
#'::=' 497
#'<-:' 161

*)
|
	private input <String> = string.
	private size <Integer> = string size.
	private position <Integer> ::= 1. (* Index of the next rune to scan. *)

	public tokenStart <Integer> ::= 0.
	public tokenKind <Symbol>
	public tokenValue (* The evaluated token, not it's substring in the source. *)
|) (
public advanceToken = (
	| byte |
	skipWhitespaceAndComments.
	tokenStart:: position.
	tokenValue:: nil.
	position <= size ifFalse:
		[tokenKind:: #end.
		 ^self].
	byte:: input at: position.
	position:: position + 1.

	(isLetterOrUnderscore: byte) ifTrue:
		[^self scanIdentifierOrKeyword].
	(isSpecialCharacter: byte) ifTrue:
		[^self scanBinarySelector].
	(isDecimalDigit: byte) ifTrue:
		[^self scanNumber].

	byte = 58 ifTrue: [
		position + 1 <= size ifTrue:
			[(input at: position) = 58 ifTrue:
				[(input at: position + 1) = 61 ifTrue:
					[position:: position + 2.
					 tokenKind:: #'::='.
					 ^self]]].
		tokenKind:: #':'.
		^self].

	byte = 34 ifTrue: [^self scanCharacter].
	byte = 35 ifTrue: [^self scanSymbol].
	byte = 39 ifTrue: [^self scanString].
	byte = 40 ifTrue: [tokenKind:: #'('. ^self].
	byte = 41 ifTrue: [tokenKind:: #')'. ^self].
	byte = 46 ifTrue: [tokenKind:: #'.'. ^self].
	byte = 59 ifTrue: [tokenKind:: #';'. ^self].
	byte = 91 ifTrue: [tokenKind:: #'['. ^self].
	byte = 93 ifTrue: [tokenKind:: #']'. ^self].
	byte = 94 ifTrue: [tokenKind:: #'^'. ^self].
	byte = 123 ifTrue: [tokenKind:: #'{'. ^self].
	byte = 125 ifTrue: [tokenKind:: #'}'. ^self].

	scanError: 'Unknown token'.
)
private extendedDigitValue: byte = (
	byte <= 57 ifTrue: [^byte - 48].
	^byte - 55
)
private isAlphanumOrUnderscore: byte = (
	byte >= 97 ifTrue: [byte <= 122 ifTrue: [^true]].
	byte >= 65 ifTrue: [byte <= 90 ifTrue: [^true]].
	byte >= 48 ifTrue: [byte <= 57 ifTrue: [^true]].
	^byte = 95
)
private isDecimalDigit: byte = (
	byte >= 48 ifTrue: [byte <= 57 ifTrue: [^true]].
	^false
)
private isExtendedDigit: byte = (
	byte >= 48 ifTrue: [byte <= 57 ifTrue: [^true]].
	byte >= 65 ifTrue: [byte <= 90 ifTrue: [^true]].
	^false
)
private isLetterOrUnderscore: byte = (
	byte >= 97 ifTrue: [byte <= 122 ifTrue: [^true]].
	byte >= 65 ifTrue: [byte <= 90 ifTrue: [^true]].
	^byte = 95
)
private isSpecialCharacter: byte = (
	byte = 33 ifTrue: [^true]. (* ! *)
	byte = 37 ifTrue: [^true]. (* % *)
	byte = 38 ifTrue: [^true]. (* & *)
	byte = 42 ifTrue: [^true]. (* * *)
	byte = 43 ifTrue: [^true]. (* + *)
	byte = 44 ifTrue: [^true]. (* , *)
	byte = 45 ifTrue: [^true]. (* - *)
	byte = 47 ifTrue: [^true]. (* / *)
	byte = 60 ifTrue: [^true]. (* < *)
	byte = 61 ifTrue: [^true]. (* = *)
	byte = 62 ifTrue: [^true]. (* > *)
	byte = 63 ifTrue: [^true]. (* ? *)
	byte = 64 ifTrue: [^true]. (* @ *)
	byte = 92 ifTrue: [^true]. (* \ *)
	byte = 124 ifTrue: [^true]. (* | *)
	byte = 126 ifTrue: [^true]. (* ~ *)
	^false
)
protected keepComment = (
	| commentStart |
	skipWhitespace.
	commentStart:: position.
	skipComment ifFalse: [^nil].
	^input copyFrom: commentStart + 2 to: position - 1 - 2
)
private peekHasRadix = (
	position + 1 <= size ifFalse: [^false].
	(input at: position) = 114 ifFalse: [^false].
	^isExtendedDigit: (input at: position + 1)
)
protected restoreContext: context = (
	position:: context.
	advanceToken.
)
protected saveContext = (
	^tokenStart
)
private scanBinarySelector = (
	[position <= size and: [isSpecialCharacter: (input at: position)]]
		whileTrue: [position:: position + 1].

	tokenValue:: input copyFrom: tokenStart to: position - 1.
	tokenKind:: #binary.

	(* Check for a longer match as the eventual send operator. *)
	tokenValue = #'<-' ifFalse: [^self].
	position <= size ifFalse: [^self].
	(input at: position) = 58 ifTrue:
		[position:: position + 1.
		 tokenValue:: nil.
		 tokenKind:: #'<-:'].
)
private scanCharacter = (
	position + 1 <= size ifFalse: [scanError: 'Unterminated character literal'].
	(input at: position + 1) = 34 ifFalse: [scanError: 'Unterminated character literal'].

	tokenKind:: #character.
	tokenValue:: input copyFrom: position to: position.
	position:: position + 2.
)
private scanError: message = (
	^(ParseError message: message position: position) signal
)
private scanIdentifierOrKeyword = (
	|
	pos ::= position.
	in = input.
	sz = size.
	|
	[pos <= sz ifFalse: [false] ifTrue: [isAlphanumOrUnderscore: (in at: pos)]]
		whileTrue: [pos:: pos + 1].

	pos <= sz ifTrue:
		[(in at: pos) = 58 ifTrue:
			[tokenValue:: in copyFrom: tokenStart to: pos.
			 pos + 1 <= sz ifTrue:
				[(input at: pos + 1) = 58 ifTrue:
					[position:: pos + 2.
					 tokenKind:: #setter.
					 ^self]].
			position:: pos + 1.
			tokenKind:: #keyword.
			^self]].

	position:: pos.
	tokenValue:: input copyFrom: tokenStart to: pos - 1.
	tokenKind:: #identifier.
)
private scanMaybeExponent ^<Integer> = (
	| neg exp byte |
	position + 1 <= size ifFalse: [^1].
	(input at: position) = 101 ifFalse: [^1].

	neg:: (input at: position + 1) = 45.
	neg
		ifTrue:
			[position + 2 <= size ifFalse: [^1].
			 (isDecimalDigit: (input at: position + 2)) ifFalse: [^1].
			 position:: position + 2 (* Consume 'e-' *)]
		ifFalse:
			[(isDecimalDigit: (input at: position + 1)) ifFalse: [^1].
			 position:: position + 1 (* Consume 'e' *)].

	exp:: 0.
	[position <= size and: [isDecimalDigit: (byte:: input at: position)]]
		whileTrue:
			[exp:: exp * 10 + (byte - 48).
			 position:: position + 1].

	neg ifTrue: [exp:: exp * -1].
	^10 ** exp
)
private scanMaybeFraction: radix <Integer> ^<Fraction> = (
	| numerator denominator byte digit |

	position + 1 <= size ifFalse: [^0].
	(input at: position) = 46 ifFalse: [^0].
	(isExtendedDigit: (input at: position + 1)) ifFalse: [^0].

	numerator:: 0.
	denominator:: 1.
	position:: position + 1. (* Consume '.' *)
	[position <= size and: [isExtendedDigit: (byte:: input at: position)]]
		whileTrue:
			[digit:: extendedDigitValue: byte.
			 digit < radix ifFalse: [scanError: 'Digit exceeds radix'].
			 numerator:: numerator * radix + digit.
			 denominator:: denominator * radix.
			 position:: position + 1].

	^numerator / denominator
)
private scanNumber = (
	(* '-'? decdigits+ [. decdigits?] ['e' '-'?' decdigit+] *)
	(* decdigit+ 'r' '-'? hexdigits+ [. hexdigits?] ['e' '-'?' decdigit+] *)

	| val byte radix digit |
	val:: (input at: position - 1) - 48.

	[position <= size and: [isDecimalDigit: (byte:: input at: position)]]
		whileTrue:
			[val:: val * 10 + (byte - 48).
			 position:: position + 1].

	radix:: 10.
	peekHasRadix ifTrue:
		[radix:: val.
		 val:: 0.
		 position:: position + 1. (* Consume "r" *)
		 [position <= size and: [isExtendedDigit: (byte:: input at: position)]]
			whileTrue:
				[digit:: extendedDigitValue: byte.
				 digit < radix ifFalse: [scanError: 'Digit exceeds radix'].
				 val:: val * radix + digit.
				 position:: position + 1]].

	val:: val + (scanMaybeFraction: radix).
	val:: val * scanMaybeExponent.

	tokenKind:: #number.
	tokenValue:: val.
)
private scanString = (
	| bytes = List new. byte |
	tokenKind:: #string.
	[position <= size] whileTrue:
		[(byte:: input at: position) = 39 ifTrue:
			[position:: position + 1.
			 position <= size ifFalse:
				[tokenValue:: String withAll: bytes. ^self].
			(input at: position) = 39 ifFalse:
				[tokenValue:: String withAll: bytes. ^self].
			(* Escaped single quote *)].
		bytes add: byte.
		position:: position + 1].

	scanError: 'Unterminated string literal'
)
private scanSymbol = (
	| byte |
	position <= size ifFalse:
		[scanError: 'Unterminated symbol literal'].
	byte:: input at: position.
	position:: position + 1.
	byte = 39 ifTrue:
		[self scanString.
		 tokenKind:: #symbol.
		 ^self].
	(isSpecialCharacter: byte) ifTrue:
		[self scanBinarySelector.
		 tokenKind:: #symbol.
		 tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
		 ^self].

	(isLetterOrUnderscore: byte) ifTrue:
		[^scanSymbolUnaryOrKeyword].

	scanError: 'Invalid symbol literal'
)
private scanSymbolUnaryOrKeyword = (
	tokenKind:: #symbol.
	[position <= size and: [isAlphanumOrUnderscore: (input at: position)]]
		whileTrue: [position:: position + 1].

	position <= size ifFalse:
		[tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
		 ^self].

	(input at: position) = 58 ifFalse:
		[tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
		 ^self].
	position:: position + 1. (* Consume : *)

	(* Keyword selector *)
	[position <= size and: [isAlphanumOrUnderscore: (input at: position)]]
		whileTrue:
			[[position <= size and: [isAlphanumOrUnderscore: (input at: position)]]
				whileTrue: [position:: position + 1].
			 position <= size ifFalse:
				[scanError: 'Unterminated symbol literal'].
			 (input at: position) = 58 ifFalse:
				[scanError: 'Unterminated symbol literal'].
			 position:: position + 1 (* Consume : *)].

	tokenValue:: input copyFrom: tokenStart + 1 to: tokenEnd.
)
private skipComment = (
	position + 1 <= size ifFalse: [^false].
	(input at: position) = 40 (* ( *) ifFalse: [^false].
	(input at: position + 1) = 42 (* * *) ifFalse: [^false].
	position:: position + 2.

	[position + 1 <= size] whileTrue:
		[(* End of comment. *)
		(input at: position) = 42 (* * *) ifTrue:
			[(input at: position + 1) = 41 (* ) *) ifTrue:
				[position: position + 2. ^true]].

		(* Nested comment. *)
		(input at: position) = 40 (* ( *) ifTrue:
			[(input at: position + 1) = 42 (* * *) ifTrue:
				[skipComment.
				 position:: position - 1]].

		position:: position + 1].

	scanError: 'Unterminated comment'
)
protected skipWhitespace = (
	[position <= input size] whileTrue:
		[(input at: position) <= 32 ifFalse: [^self].
		 position:: position + 1].
)
private skipWhitespaceAndComments = (
	| outerLoopPosition ::= 0. |
	[outerLoopPosition = position] whileFalse:
		[outerLoopPosition:: position.
		 [position <= input size
			ifFalse: [false]
			ifTrue: [(input at: position) <= 32]]
				whileTrue: [position:: position + 1].
		 skipComment].
)
public tokenEnd = (
	^position - 1
)
) : (
)
class Token value: v = (
(* Only used for class comments, where the AST expects a CombinatorialParsing-style Token. *)
|
public value = v.
public start
public end
|) (
) : (
)
) : (
)
