Newspeak3
'HopscotchIDE'
class Browsing usingPlatform: p ide: ide = (
(* Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2011 Ryan Macnak and other contributors.
Copyright 2012 Cadence Design Systems, Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)
||
	private Map = p collections Map.
	private List = p collections List.
	private Set = p collections Set.
	private Menu = p brazil menus Menu.
	private MenuItem = p brazil menus MenuItem.
	private SeparatorItem = p brazil menus SeparatorItem.
	private EditableLinePresenter = p hopscotch fragments EditableLinePresenter.
	private OutlineItem = p hopscotch outline OutlineItem.
	private Subject = p hopscotch core Subject.
	private MethodMirror = p mirrors MethodMirror.
	public (* bogus *) ClassDeclarationMirror = p mirrors ClassDeclarationMirror.
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	private Color = p graphics Color.

	private MethodReference = p squeak MethodReference.
	private PackageOrganizer = p squeak PackageOrganizer.
	private Smalltalk = p squeak Smalltalk.
	private SystemNavigation = p squeak SystemNavigation.
	private HopscotchImages = p squeak HopscotchImages.
	private SHTextStylerST80 = p squeak SHTextStylerST80.

	ide = ide.
	systemScope = ide systemScope.
	IDEWindow = ide tools IDEWindow.
	DefinitionListPresenter = ide tools DefinitionListPresenter.
	ProgrammingPresenter = ide tools ProgrammingPresenter.
	ExemplarMethodPresenter = ide tools ExemplarMethodPresenter.
	PackageSubject = ide browsingMisc PackageSubject.
	NSMethodSubject = ide browsingNS NSMethodSubject.
	InitializerMethodSubject = ide browsingNS InitializerMethodSubject.
	GlobalReferencesSubject = ide browsingST GlobalReferencesSubject.
	MethodInheritanceSubject = ide browsingST MethodInheritanceSubject.
	STMethodSubject = ide browsingST STMethodSubject.
	CodeEditorFragment = ide tools CodeEditorFragment.
	DefinitionResidue = ide tools DefinitionResidue.
	DefinitionTemplate = ide tools DefinitionTemplate.
	private Root = ide namespacing Root.
	||#ACCESSBOGUS) (
public class AssortedMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* The subject is a collection of MethodSubjects that can come from diverse sources (in the sense that they do not have to belong to the same class). The presenter displays them as a column of expandable method presenters and takes care of reasonably handling the various creation and deletion requests coming from them.  I group my methods by their containing package.

Slots
	title	<String>	The title to use for the presenter
	methodPresenters <List[ExpandableMethodPresenter]> Because the method presenters are grouped by package, if we need to expand or collapse those presenters, we only want to expand or collapse the method presenters.  The group heading is not expandable (or collapsable). *)
|
	public title ::= 'Assorted Methods'.
	methodPresenters ::= List new.
|) (
public collapseAll = (
	respondToCollapse: methodPresenters
)
public compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <[]> ifCompiledAsNew: successNewResponse <[]|[:Object]> ifFailed: failureResponse <[]|[:Object]> = (
	requestor subject
		compileNewSource: source
		ifSuccess: successResponse
		ifNewMethod:
			[:newMethod <MethodMirror> | | newSubject newPresenter |
			newSubject:: MethodSubject onMethod: newMethod.
			newPresenter:: ExpandableMethodPresenter onSubject: newSubject.
			suffixes add: newPresenter.
			successNewResponse value.
			(suffixes detectPresenter:
				[:some |
				some subject = newSubject])
				expand]
		ifFailure: failureResponse
)
contentPresenters = (
	^Array streamContents:
		[:stream | | groups |
		groups:: methodsGroupedByPackage.
		(groups keys asArray copyWithout: nil) sort do:
			[:packageName | | presenters gm |
			presenters:: List new.
			gm:: methodPresentersGroupedByEnclosingClass: (groups at: packageName).
			stream nextPut:
				(minorHeadingBlock:
					(row: {
						link: packageName asText allBold action: [browsePackage: packageName].
						filler.
						expandButtonWithAction: [respondToExpand: presenters].
						blank: 3.
						collapseButtonWithAction: [respondToCollapse: presenters].
					})).
			stream nextPut: mediumBlank.
			(gm values asSortedList: [:a :b | a size < b size]) do:
				[:v | | moduleOrClass |
				presenters addAll: v.
				moduleOrClass:: v first subject enclosingClasses last.
				(* Only show when it is above a threshold *)
				v size > 2 ifTrue:
					[stream nextPut: smallBlank.
					stream nextPut: (row: {link: moduleOrClass name asText action: [browseClass: moduleOrClass]})].
				stream nextPutAll: v].
			methodPresenters addAll: presenters.
			stream nextPut: mediumBlank]]
)
public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (
	| requestorSubject source residue |
	requestorSubject:: presenter subject.
	source:: requestorSubject source.
	requestorSubject
		deleteMethodIfSuccess:
			[residue:: DefinitionResidue new
				caption: 'Deleted method ', requestorSubject selector;
				definitionText: source;
				restoreResponse:
					[methodResidueAccepted: residue.
					suffixes remove: residue];
				forgetResponse: [suffixes remove: residue].
			suffixes add: residue.
			content remove: presenter.
			successResponse value]
		ifFailure: failureResponse value
)
public expandAll = (
	respondToExpand: methodPresenters
)
methodPresentersGroupedByEnclosingClass: methodSubjects = (
	| groupedMethods |
	groupedMethods:: Map new.
	methodSubjects do:
		[:aSubject | |methods|
		(* sadly there is no #at:ifAbsentPut: *)
		methods:: groupedMethods
			at: aSubject enclosingClasses last name
			ifPresent: [:oc | oc]
			ifAbsentPut: [List new].
		methods add: (newExpandableMethodPresenter: aSubject)].
	^groupedMethods
)
methodsGroupedByPackage = (
	| packages |
	packages:: Map new.
	subject methodSubjects do:
		[:aSubject |
		(packageOfMethod: aSubject) ifNotNil:
			[:aPackage |
			(packages
				at: aPackage packageName
				ifPresent: [:e|]
				ifAbsentPut: [List new]) add: aSubject]].
	^packages
)
newExpandableMethodPresenter: s <MethodSubject> = (
	^s createPresenter
		showClassName: true
)
packageOfMethod: method <MethodSubject> ^<PackageSubject> = (
	| registry mirror implementingClass package |
	registry:: PackageOrganizer default.
	implementingClass:: method implementingClass.
	implementingClass ifNil: [^nil].
	mirror:: ClassDeclarationMirror reflecting: implementingClass theNonMetaClass mixin.
	[mirror enclosingClass notNil]
		whileTrue: [mirror: mirror enclosingClass].

	package:: implementingClass language isNewspeakLanguage3 not
		ifTrue: [registry packageOfMethod: method methodReference ifNone: []]
		ifFalse: [registry packageOfClass: mirror reflectee definingClass ifNone: []].
	^package = nil
		ifTrue: [PackageSubject onModel: mirror header category]
		ifFalse: [PackageSubject onModel: package packageName]
)
respondToCollapse: presenters = (
	majorUpdate: [presenters do: [:each | each collapse]]
)
respondToExpand: presenters = (
	majorUpdate: [presenters do: [:each | each expand]]
)
) : (
)
public class AssortedMethodsSubject onModel: m = Subject onModel: m (|
	public title ::= 'Assorted Methods'.
|) (
public createPresenter = (
	^(AssortedMethodsPresenter onSubject: self) title: title
)
public methodSubjects = (
	^model
)
public refreshmentSubject = (
	^super refreshmentSubject
		title: title;
		yourself
)
) : (
)
public class ClassMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* The subject is a class subject. Displays methods of the class as expandable entries and supports compilation and other requests. Another similar presenter is an AssortedMethodsPresenter, but that one displays a collection of methods which do not necessarily belong to the same class, such as all senders of a selector. *)
| presenterCreationBlock groupedByCategory ::= true. subclassResponsibilitiesList seeAllLinkHolder showingPartialList ::=true. |) (
public addMethodIn: cls proposedSource: src = (
subject classObject == cls ifTrue:
	[addMethodTemplate: src]
)
addMethodTemplate = (
	addMethodTemplate: ''
)
addMethodTemplate: src = (
	prefixes add:
		(DefinitionTemplate new
			initialText: src;
			caption: 'Adding new method:';
			acceptResponse:
				[:template |
				createMethodFromTemplate: template];
			cancelResponse:
				[:template | prefixes remove: template])
)
collapseAll = (
	majorUpdate:
		[content presenters do: [:each | each collapse]]
)
public compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <Block> ifCompiledAsNew: successNewResponse <Block> ifFailed: failureResponse <Block> = (
	| newPresenter |
	requestor subject
		compileNewSource: source
		ifSuccess: successResponse
		ifNewMethod:
			[:newMethod |
			successNewResponse value.
			loadFullContentList.
			newPresenter::
					content detectPresenter:
						[:some | some subject selector = newMethod selector].
			newPresenter
				expand;
				requestVisibility]
		ifFailure: failureResponse
)
createMethodForSubclassResponsibility: template <DefinitionTemplate> = (
	| newSelector newPresenter |
	newSelector:: subject compile: template text.
	loadFullContentList.
	newSelector notNil ifTrue:
		[subclassResponsibilitiesList remove: template parent.
		newPresenter::
			content detectPresenter:
				[:some | some subject selector = newSelector].
		newPresenter
			expand;
			requestVisibility]
)
createMethodFromTemplate: template <DefinitionTemplate> = (
	| newSelector newPresenter |
	newSelector:: subject compile: template text.
	loadFullContentList.
	newSelector notNil ifTrue:
		[prefixes remove: template.
		newPresenter::
			content detectPresenter:
				[:some | some subject selector = newSelector].
		newPresenter
			expand;
			requestVisibility]
)
definition = (
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: (subject classIsMeta
					ifTrue: ['Class methods']
					ifFalse: ['Instance methods']).
				largeBlank.
				addButtonWithAction: [addMethodTemplate].
				filler.
				expandButtonWithAction: [expandAll].
				blank: 3.
				collapseButtonWithAction: [collapseAll].
				blank: 3.
				reorderButtonWithAction: [switchSortOrder].
				}).
		prefixes:: list.
		content:: list.
		suffixes:: list.
		seeAllLinkHolder:: holder: nothing.
		deferred:
			[subclassResponsibilitiesList:: list: subclassResponsibilitiesPresenters].
	}
)
public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (
	| requestorSubject source category residue |
	requestorSubject:: presenter subject.
	source:: requestorSubject source.
	category:: requestorSubject methodCategory.
	requestorSubject
		deleteMethodIfSuccess:
			[residue:: DefinitionResidue new
				caption: requestorSubject selector, ' (deleted method)';
				definitionText: source;
				extraData: category;
				restoreResponse:
					[restoreMethodResidue: residue.
					suffixes remove: residue];
				forgetResponse: [suffixes remove: residue].
			loadFullContentList.
			suffixes add: residue.
			successResponse value]
		ifFailure: failureResponse
)
expandAll = (
	majorUpdate:
		[content presenters do: [:each | each expand]]
)
initialSizeLimit ^<Integer> = (
	(* At most this many methods are displayed at first. *)

	^60
)
loadFullContentList = (
	showingPartialList:: false.
	majorUpdate: [content presenters: retrievePresenters].
	refreshSeeAllHolder
)
maybePartialSubjectListByCategory ^<Collection[MethodSubject]> = (
	(* Retrieve the subjects to show--not more than initialSizeLimit elements if there are too many--sorted by method category. Set the showingPartialList flag according to whether the result is a full list or not. *)


	| result |
	result:: List new: initialSizeLimit.
	subject sortedCategories do:
		[:each |
		(subject methodSubjectsInCategory: each) do:
			[:eachSubject |
			result add: eachSubject.
			result size >= initialSizeLimit ifTrue:
				[showingPartialList:: true.
				^result]]].
	showingPartialList:: false.
	^result
)
maybePartialSubjectListBySelector ^<Collection[MethodSubject]> = (
	(* Retrieve the subjects to show--not more than initialSizeLimit elements if there are too many--sorted by selector. Set the showingPartialList flag according to whether the result is a full list or not. *)

	| subjects |
	subjects:: (subject methodSubjects) select:
		[:some | some methodCategoryOrNil notNil].
	subjects:: subjects asSortedCollection: [:a :b | a selector < b selector].
	showingPartialList:: subjects size > initialSizeLimit.
	^showingPartialList
		ifTrue: [subjects copyFrom: 1 to: initialSizeLimit]
		ifFalse: [subjects]
)
noticeSubstanceCreation = (
	refreshContentList
)
public presenterClass: aClass = (
	presenterCreationBlock:: [:each | aClass onSubject: each]
)
presenterForSubclassResponsibility: aReference = (
	| toggle |
	toggle::
		collapsed:
			((link: aReference methodSymbol, ' (unimplemented subclass responsibility)'
			action: [toggle toggle]) color: Color lightGray)
		expanded:
			[DefinitionTemplate new
				caption: 'Subclass responsibility from ', aReference actualClass name, '>>', aReference methodSymbol;
				initialText: aReference source;
				acceptResponse: [:t | createMethodForSubclassResponsibility: t]].
	^toggle
)
public recategorizeMethodIn: presenter <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (
	| newName |
	newName:: newCategoryName withBlanksTrimmed.
	newName isEmpty ifTrue: [^failureResponse value].
	presenter subject
		changeCategoryTo: newName asSymbol
		ifSuccess:
			[loadFullContentList.
			presenter requestVisibility.
			successResponse value]
		ifFailure: failureResponse
)
refreshContentList = (
	content presenters: retrievePresenters.
	refreshSeeAllHolder
)
refreshSeeAllHolder = (
	seeAllLinkHolder content:
		(showingPartialList
			ifTrue:
				[row: {
					mediumBlank.
					(link: 'show all methods...' action: [loadFullContentList])
						tinyFont
					}]
			ifFalse:
				[nothing])
)
restoreMethodResidue: aResidue = (
	| newSelector |
	newSelector:: subject
		compile: aResidue definitionText
		classified: aResidue extraData.
	refreshContentList.
	newSelector notNil ifTrue:
		[suffixes remove: aResidue.
		(content detectPresenter: [:some | some subject selector = newSelector])
			expand]
)
retrieveAllPresenters = (
	^retrieveAllSubjects collect: presenterCreationBlock
)
retrieveAllSubjects = (
	showingPartialList:: false.
	^groupedByCategory
		ifTrue:
			[ | result |
			result:: List new: initialSizeLimit.
			subject sortedCategories do:
				[:each |
				result addAll: (subject methodSubjectsInCategory: each)].
			result]
		ifFalse:
			[ | subjects |
			subjects:: (subject methodSubjects) select:
				[:some | some methodCategoryOrNil notNil].
			subjects asSortedCollection: [:a :b | a selector < b selector]]
)
retrievePresenters = (
	^showingPartialList
		ifTrue: [retrieveSubjects collect: presenterCreationBlock]
		ifFalse: [retrieveAllSubjects collect: presenterCreationBlock]
)
retrieveSubjects = (
	^groupedByCategory
		ifTrue: [maybePartialSubjectListByCategory]
		ifFalse: [maybePartialSubjectListBySelector]
)
subclassResponsibilitiesPresenters = (
	^(subject retrieveUnimplementedAbstractMethods
		asSortedList: [:a :b | a methodSymbol < b methodSymbol])
			collect: [:each | presenterForSubclassResponsibility: each]
)
switchSortOrder = (
	groupedByCategory: groupedByCategory not.
	majorUpdate: [content presenters: retrievePresenters].
	notifyOfPossibleOutlineChange
)
) : (
)
public class ClassMethodsSubject onModel: m = Subject onModel: m (
(* The model is the class object. (Used for Smalltalk and NS1 classes). Represents the perspective of looking at the list of mehods of the class. *)
) (
addAbstractMethodsOf: aClass notIn: selectorSet to: resultCollection = (
	| implementedHere |
	implementedHere:: Set new.
	aClass selectorsAndMethodsDo:
		[:eachSelector :eachMethod |
		(selectorSet includes: eachSelector) ifFalse:
			[eachMethod isAbstract
				ifTrue: [resultCollection add:
							(MethodReference class: aClass selector: eachSelector)]
				ifFalse: [implementedHere add: eachSelector]]].
	aClass superclass ifNotNil:
		[:superclass |
		addAbstractMethodsOf: superclass
		notIn: (selectorSet union: implementedHere)
		to: resultCollection]
)
public classIsMeta = (
	^classObject isMeta
)
public classObject = (
	^model
)
public compile: source = (
	^classObject compile: source
)
public compile: source <String> classified: categoryName <Symbol> = (
	^classObject compile: source classified: categoryName
)
public createPresenter = (
	^ClassMethodsPresenter onSubject: self
)
methodSubjectForSelector: selector <Symbol> ^ <MethodSubject> = (
	^MethodSubject
		onMethod: (MethodReference class: classObject selector: selector)
)
public methodSubjects = (
	^classObject selectors collect:
		[:each | methodSubjectForSelector: each]
)
public methodSubjectsInCategory: categoryName <Symbol> ^<Collection[MethodSubject]> = (
	^(classObject organization listAtCategoryNamed: categoryName)
		asSortedCollection
			collect: [:each | methodSubjectForSelector: each]
)
public retrieveUnimplementedAbstractMethods ^<Collection[MethodReference]> = (
	(* Answer a collection of MethodReferences to abstract methods of superclasses that the class would need to implement in order to be concrete. *)

	^model superclass
		ifNil: [Array new]
		ifNotNil:
			[:superclass | | result |
			result:: List new.
			addAbstractMethodsOf: superclass notIn: model selectors to: result.
			result]
)
public sortedCategories ^<Collection[Symbol]> = (
	(* Answer a collection of category names found in the class, sorted with initialization first and private categories last. *)

	| categories init privateCategories unclassified lineup |
	categories:: classObject organization categories asSet.
	init:: categories select: [:each | 'init*' match: each].
	categories:: categories difference: init.
	privateCategories:: categories select: [:each | 'private*' match: each].
	categories:: categories difference: privateCategories.
	(categories includes: #'as yet unclassified')
		ifTrue:
			[unclassified:: {#'as yet unclassified'}.
			categories remove: #'as yet unclassified']
		ifFalse:
			[unclassified:: {}].
	lineup:: List new: categories size.
	lineup
		addAll: unclassified;
		addAll: init asSortedCollection;
		addAll: categories asSortedCollection;
		addAll: privateCategories asSortedCollection.
	^lineup
)
) : (
)
public class ClassSubject onModel: m = Subject onModel: m (
(* Represents a view of a class in the system. This is an abstract class. Concrete subclasses will implement class access in terms appropriate to the language of the class. The model they will use will again depend on the language. The one thing we assume about the model is that it behaves ''properly'' with respect to #= (and #hash), so that a ClassSubject can rely on the model for its own equality comparison. *)
) (
public = anotherSubject = (
	^(anotherSubject class = self class)
		and: [anotherSubject classOrMirror = classOrMirror]
)
public classCommentText ^<String> = (
	subclassResponsibility
)
public classCommentText: newComment <String> = (
	subclassResponsibility
)
classDefinition = (
	subclassResponsibility
)
classLanguage = (
	^model language
)
public className = (
	subclassResponsibility
)
public classOrMirror ^<Behavior | ClassDeclarationMirror> = (
	^model
)
public classUiDescription = (
	^ide languageUiDescriptionRegistry descriptionFor: classLanguage
)
public hash = (
	^model hash
)
public isAbstract = (
	(* Answer true if any methods are marked as abstract. *)
	^false
)
public isRecentlyVisited ^<Boolean> = (
	(* Answer true if the class is known to Hopscotch to be recently visited. Some presenters highlight such classes. *)
	^ide defaultPopularityRecord classVisits includes: implementationClass
)
public methodCount = (
	subclassResponsibility
)
public rememberVisit = (
	ide defaultPopularityRecord rememberClassVisit: implementationClass.
)
public totalSubclassCount = (
	subclassResponsibility
)
) : (
)
public class EditableClassNamePresenter onSubject: s = EditableLinePresenter onSubject: s (
(* The subject is an STClassSubject. The presenter displays the name of the class and allows to edit it. *)
) (
definitionText = (
	^subject className
)
respondToAccept = (
	| oldName newName referencesToFix |
	newName:: editor text asString asSymbol.
	(Smalltalk includesKey: newName) ifTrue:
		[^nil].
	oldName:: subject className.
	subject implementationClass rename: newName.
	leaveEditState.
	flag: #bogus. (* Get rid of Smalltalk and SystemNavigation dependencies below *)
	referencesToFix:: SystemNavigation default allCallsOn: (Smalltalk associationAt: newName).
	referencesToFix notEmpty ifTrue:
		[enterSubject: (GlobalReferencesSubject onModel: newName)]
)
viewerDefinition = (
	^link: [definitionText asText allBold]
		action: [sendUp browseClass: subject implementationClass].
)
) : (
)
public class EditableNSClassNamePresenter onSubject: s = EditableClassNamePresenter onSubject: s (
) (
respondToAccept = (
	| oldName newName builder klass |

	newName:: editor text asString asSymbol.
	oldName:: subject className. (* simple? *)

	newName = oldName ifTrue: [^leaveEditState].

	builder:: ClassDeclarationBuilder reflecting: subject classMirror reflectee.

	builder enclosingClass ifNil: [ (* Top level class *)
		(Root includesKey: newName) ifTrue:
			[Error signal: 'A top level class already exists with the name ', newName].
	].

	builder header name: newName.
	builder install.

	builder enclosingClass ifNil: [ (* Top level class *)
		klass:: Root removeKey: oldName.
		Root at: newName put: klass.
		ide namespacing refreshCategoryNamespaces.
	].

	leaveEditState.
)
viewerDefinition = (
	^link: [definitionText asText allBold]
		action: [sendUp browseClassMirror: subject classMirror].
)
) : (
)
public class ExpandableMethodPresenter onSubject: s = MethodPresenter onSubject: s (
(* The subject is an STMethodSubject or a similar thing. Displays as a line with the selector (optionally prepended with the class name if the showClassName slot is set to true), expandable into a full editor. *)
|
	public showClassName ::=false.
|) (
accessModifierIcon = (
	^image: (iconForAccessModifier: subject accessModifier)
)
addOutlineItemsTo: parentItem = (
parentItem addChild:
	((OutlineItem onModel: self)
		text: subject selector)
)
categoryLink ^ <Fragment> = (
	^subject isSynthetic
	    ifTrue: [(label: subject methodCategory) tinyFont color: Color gray]
	    ifFalse: [MethodCategoryPresenter onSubject: subject]
)
public collapse = (
	^substance collapse
)
definition = (
	| toggler |
	toggler::
		collapsed: methodHeading
		expanded: expandedMethod.
	toggler onUserToggled: [toggler isExpanded ifTrue: [requestVisibility]].
	^toggler
)
public expand = (
	^substance expand
)
expandedMethod ^ <Fragment> = (
	^	[column: {
			methodHeading color: methodHeadingColor.
			methodDetails.
			}
		].
)
goToMessages = (
	| messagesAndActions messageItems classItems |
	messagesAndActions:: List new.
	messagesAndActions add:
		subject selector -> [browseSelector: subject selector].
	messageItems:: referencesMenuMessageItems.
	classItems:: referencesMenuClassItems.
	messageItems isEmpty not ifTrue:
		[messagesAndActions
			add: #separator;
			addAll: messageItems].
	classItems isEmpty not ifTrue:
		[messagesAndActions
			add: #separator;
			addAll: classItems].
	openMenuWithLabelsAndActions: messagesAndActions
)
inheritanceLinkWithIcon: image = (
	^linkImage: image action:
		[enterSubject: subject asMethodInheritanceSubject]
)
public isAnOverride = (
	^subject isAnOverrideIn: parentClassSubject
)
public isExpanded = (
	^substance isExpanded
)
public isOverridden = (
	^subject isOverriddenIn: parentClassSubject
)
linkToBrowseEnclosingClass: klass <Behavior | Mixin> = (
	^(link: klass simpleName
		action: [browseClass: klass])
		color: secondaryTextColor
)
methodActionsMenu = (
	| labelsAndActions <Array[Tuple[String, []]]> |
	labelsAndActions:: {
		'Delete #', subject selector -> [respondToDelete].
		(* 'Versions' -> [respondToVersions]. *)
		(* 'Pretty Print' -> [respondToPrettyPrint]. *)
		#separator.
		'Inspect Compiled Method' -> [respondToInspectCompiledMethod].
		'Inspect Mirror' -> [inspect: subject methodMirror].
		#separator.
		'Inspect Presenter' -> [respondToInspectPresenter].
		}.
	^menuWithLabelsAndActions: labelsAndActions
)
methodDetails = (
	^super definition
)
methodHeading = (
	^row: {
		accessModifierIcon.
		smallBlank.
		(selectorAndContainment) compressibility: 1.
		mediumBlank.
		deferred: [overrideIcon].
		blank: 2.
		deferred:
			[subject isSubclassResponsibility
				ifTrue:
					[image: HopscotchImages default tinySubclassResponsibilityImage]
				ifFalse: [nothing]].
		smallBlank.
		deferred:
			[sendersOfSubjectPresenter].
		smallBlank.
		filler compressibility: 0.
		categoryLink.
		largeBlank.
		itemReferencesMenuButtonWithAction: [goToMessages].
		smallBlank.
		dropDownMenu: [methodActionsMenu].
	}
)
nestingInformationLine = (
	| enclosingClasses rowElements |
	enclosingClasses:: subject enclosingClasses.
	rowElements:: List new.
	enclosingClasses do:
		[:each |
		rowElements add: ((label: ' in ') color: tertiaryTextColor).
		rowElements add: (linkToBrowseEnclosingClass: each)].
	^row: rowElements asArray
)
overrideIcon = (
	^isAnOverride
		ifTrue:
			[isOverridden
				ifTrue: [inheritanceLinkWithIcon: HopscotchImages default itemBothOverride]
				ifFalse: [inheritanceLinkWithIcon: HopscotchImages default itemSuperOverride]]
		ifFalse:
			[isOverridden
				ifTrue: [inheritanceLinkWithIcon: HopscotchImages default itemSubOverride]
				ifFalse: [nothing]]
)
parentClassSubject = (
^sendUp deliveryOptional parentClassSubjectDo: [:s | ^s]
)
public recategorizeMethodIn: presenter <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (
	(* When the category is changed, both my expanded and collapsed state presenters need refreshing to reflect the new name. Here we effectively intercept category change requests from children to do so on success. *)

	sendUp
		recategorizeMethodIn: presenter
		under: newCategoryName
		ifSuccess: [refresh. successResponse value]
		ifFailed: failureResponse
)
referencesMenuClassItems = (
	| items |
	items:: List new.
	subject variableBindingKeys asSortedList do:
		[:eachKey |
		(eachKey notNil and: [eachKey ~= subject className]) ifTrue:
			[items add:
				eachKey -> [browseClassNamed: eachKey]]].
	^items
)
referencesMenuMessageItems = (
	| items |
	items:: List new.
	subject messages asSortedList do:
		[:selector |
		selector == subject selector ifFalse:
			[items add:
				selector -> [browseSelector: selector]]].
	^items
)
refreshSource = (
(* Only refresh if we have the editor, i.e. we are expanded. *)

editor ifNotNil: [super refreshSource]
)
respondToInspectCompiledMethod = (
	inspect: subject compiledMethod
)
respondToOutlineSelection = (
substance expand.
super respondToOutlineSelection
)
respondToRunTest = (
	self unimplemented. (* Does this make sense for Minitest? *)
)
respondToVersions = (
| cls |
cls:: subject implementingClass.
(* VersionsBrowser browseVersionsForClass: cls selector: subject selector. *)
enterSubject: (ide methodVersioning MethodHistorySubject onSelector: subject selector ofClass: cls)
)
selectorAndContainment = (
	^row: {
		(link: subject selector
			action: [substance userToggle]
			dragSubject: subject
			withImage: HopscotchImages default hsExpandImage) color: actionLinkColor.
		showClassName
			ifTrue: [nestingInformationLine]
			ifFalse: [nothing].
		}
)
sendersOfSubjectPresenter = (
	| count text |
	count:: subject usageCount.
	count = 0 ifTrue: [text:: 'no senders'].
	count = 1 ifTrue: [text:: '1 sender'].
	count > 1 ifTrue: [text:: count printString, ' senders'].
	^(link: text action: [browseSelector: subject selector])
		tinyFont color: secondaryTextColor
)
toggle = (
	^substance toggle
)
) : (
)
class MethodCategoryPresenter onSubject: s = EditableLinePresenter onSubject: s (
(* The subject is an STMethodSubject (or a similar thing). The presenter displays the category of the method and allows to edit it. *)
) (
assembleListOfUsefulNames = (
	(* Display a menu of appropriate categories. *)

	| names init pprivate result |
	names:: subject allMethodCategories copy remove: subject methodCategory ifAbsent: []; yourself.
	result:: List new: names size.
	init:: names select: [:each | 'init*' match: each].
	names:: names reject: [:ea | init includes: ea].
	pprivate:: names select: [:each | 'private*' match: each].
	names:: names reject: [:ea | pprivate includes: ea].
	result
		addAll: init asSortedList;
		addAll: names asSortedList;
		addAll: pprivate asSortedList.
	^result
)
buildCategoryChangeMenuWithNames: names = (
	| menu |
	menu:: Menu forVisual: visual.
	names do:
		[:each |
		menu add:
			(MenuItem
				label: each
				action: [changeCategoryTo: each])].
	menu add: SeparatorItem new.
	menu add:
		(MenuItem label: 'Enter Another Name' action: [enterEditState]).
	^menu
)
changeCategoryTo: aSymbol = (
	sendUp
		recategorizeMethodIn: self
		under: aSymbol asString
		ifSuccess: [refresh]
		ifFailed: []
)
definitionText = (
	^subject methodCategory
)
respondToAccept = (
	sendUp
		recategorizeMethodIn: self
		under: editor text asString
		ifSuccess: [leaveEditState]
		ifFailed: []
)
respondToClick = (
	(* Display a menu of appropriate categories. *)

	openMenu:
		(buildCategoryChangeMenuWithNames:
			assembleListOfUsefulNames)
)
viewerDefinition = (
	^(link: [subject methodCategory] action: [respondToClick])
		tinyFont color: Color gray.

(* The definition below will make this look almost like a drop-down.
	^row: {
		(link: [subject methodCategory] action: [respondToClick])
			tinyFont color: Color gray.
		blank: 3.
		linkImage: HopscotchImages default itemMenuImage
			action: [respondToClick]
		}
*)
)
) : (
)
class MethodPresenter onSubject: s = ProgrammingPresenter onSubject: s (
| editor |) (
definition = (
	editor:: CodeEditorFragment new
		text: (subject source ifNil: ['<No source>']);
		acceptResponse:
			[respondToAccept];
		cancelResponse:
			[editor text: subject source.
			editor leaveEditState].
	editor colorizerBlock: [:text | subject colorizeMethodSource: text].
	^editor
)
indicateMethodAsDeleted = (
	parent
		replaceChild: self
		with: ((label: subject selector, ' has been deleted') color: Color gray)
)
isInEditState ^<Boolean> = (
	(* True if the editor is now in the edit state and presumably has unsaved changes. *)

	^editor isInEditState
)
public refresh = (
subject isValid
	ifTrue:
		[refreshSource.
		super refresh]
	ifFalse:
		[indicateMethodAsDeleted]
)
refreshSource = (
| newSource |
newSource:: subject source.
newSource = editor text ifFalse:
	[editor isInEditState
		ifTrue:
			[editor showMessage: 'Warning: the method changed after editing started']
		ifFalse:
			[editor text: newSource]]
)
respondToAccept = (
	(* The user has just clicked the Save button in the editor. *)

	subject source asString = editor text asString ifFalse:
		[editor setText: subject source.
		^editor showMessage: 'Method changed after editing started. Click Save again to clobber those other changes.'].
	sendUp
		compileMethod: editor textBeingAccepted asString
		inPresenter: self
		ifCompiledAsSame:
			[editor defaultAcceptResponse]
		ifCompiledAsNew:
			[editor text: subject source.
			editor defaultCancelResponse]
		ifFailed:
			[:message | editor showMessage: message]
)
respondToDelete = (
	sendUp
		deleteMethodInPresenter: self
		ifSuccess: []
		ifFailure: []
)
) : (
)
public class MethodSubject onModel: m = Subject onModel: m (
) (
public accessModifier = (
	^model accessModifier
)
public allMethodCategories ^<Collection[Symbol]> = (
(* Answer a collection of all category names used in the implementor class, plus some common names. *)
| names |
names:: Set new.
names
	add: #'initialize-release';
	add: #accessing;
	add: #actions;
	add: #notifications;
	add: #parameters;
	add: #private;
	add: #restricted;
	add: #testing.
^names
)
public asMethodInheritanceSubject = (
	^MethodInheritanceSubject onModel: model
)
public changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
	subclassResponsibility
)
public className = (
	^implementingClass simpleName
)
public colorizeMethodSource: sourceText = (
	(* Subclasses may override this to perform source colorization. *)

	| styler <SHTextStyler> |
	styler:: SHTextStylerST80 new
		classOrMetaClass: implementingClass.
	styler privateStyle: sourceText.
	^sourceText
)
public compileNewSource: source <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (
	subclassResponsibility
)
public createPresenter = (
	^ExpandableMethodPresenter onSubject: self
)
public deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
	implementingClass removeSelector: selector.
	successBlock value (* always succeed *)
)
public enclosingClasses ^<List[Behavior]> = (
	^{implementingClass}
)
public exemplar = (
	subclassResponsibility
)
public implementingClass = (
	subclassResponsibility
)
public isAnOverride = (
(* True if one of the superclasses has a method with the same selector. *)

subclassResponsibility
)
public isAnOverrideIn: classSubject <ClassSubject | nil> = (
	(* True if one of the superclasses has a method with the same selector. *)
	^isAnOverride
)
public isOverridden = (
	(* True if one of the subclasses has a method with the same selector. *)
	subclassResponsibility
)
public isOverriddenIn: classSubject <ClassSubject | nil> = (
(* True if one of the subclasses has a method with the same selector. *)

^isOverridden
)
public isSubclassResponsibility = (
	(* Subclasses may override this if they are capable enough to figure out if their subject declares a subclass responsbility. *)

	^false
)
public isSynthetic = (
	^false
)
public isValid ^<Boolean> = (
	subclassResponsibility
)
public messages ^<Collection[Symbol]> = (
	(* Selectors of messages sent by the subject. *)
	subclassResponsibility
)
public methodCategory ^<String> = (
	subclassResponsibility
)
methodReference = (
	^MethodReference class: implementingClass selector: selector
)
public selector ^<Symbol> = (
	(* Answer the selector of the presented method. *)

	subclassResponsibility
)
public source ^<String> = (
	(* Answer the source of the presented method. *)

	subclassResponsibility
)
public usageCount = (
	^(systemScope allLiteralReferences at: selector ifAbsent: [^0]) size
)
public variableBindingKeys ^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *)

subclassResponsibility
)
) : (
public onMethod: mref <MethodReference | MethodMirror> ^<MethodSubject> = (
	| cls |
	#TODO yourself. (* need to ensure that squeak creates the right objects  *)
	([mref isKindOfMethodMirror] ifError: [false]) ifTrue:
		[^self onMethodMirror: mref].
	([mref isClassHeaderMirror] ifError: [false]) ifTrue:
		[^InitializerMethodSubject onModel: mref initializer].
	^self onMethodMirror: (MethodMirror reflecting: mref compiledMethod)
)
public onMethodMirror: method <MethodMirror> = (
	| cls |
	method reflectee isSynthetic ifTrue:
		[^SyntheticMethodSubject onModel: method].
	cls:: method definingMixin reflectee definingClass.
	cls language isNewspeakLanguage3 ifFalse:
		[^STMethodSubject onModel: (MethodReference class: cls selector: method simpleName)].
	method isInitializer ifTrue:
		[^InitializerMethodSubject onModel: method].
	^NSMethodSubject onModel: method
)
)
public class SelectorPresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
definition = (
^
	column: {
		implementorsPart.
		sendersPart
	}
)
implementorsPart = (
	^floatingHeader: (
		column: {
			majorHeadingBlock: (
				row: {
					label: subject selector asText allBold.
					label: ' implementors'.
				}).
			blank: 10.
		}
	)
	body: (
		column: {
			row: {
				blank: 10.
				elastic: (AssortedMethodsSubject onModel: subject implementorSubjects) presenter.
			}.
			blank: 10.
		}
	)
)
sendersPart = (
	^floatingHeader: (
		column: {
			majorHeadingBlock: (
				row: {
					label: subject selector asText allBold.
					label: ' senders'.
				}).
			blank: 10.
		})
		body: (
			column: {
				row: {
					blank: 10.
					elastic: (AssortedMethodsSubject onModel: subject senderSubjects) presenter.
				}.
				blank: 10.
			}
		)
	)
) : (
)
public class SelectorSubject onModel: m = Subject onModel: m asSymbol (
(* Holds onto a selector (a Symbol) and retrieves its senders and implementors. *)
) (
public = other = (
	^self class = other class and: [self selector = other selector]
)
public createPresenter = (
	^SelectorPresenter onSubject: self
)
public hash = (
	^model hash
)
public implementorSubjects ^ <Collection[MethodSubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^implementors collect: [:each <MethodReference> |
		MethodSubject onMethod: each]
)
implementors = (
	(* Answer a collection of implementors of our selector (as MethodReferences). *)

	| themST themNS |
	themST:: Array streamContents:
		[:s |
		systemScope smalltalkImplementorsOf: model do:
			[:cls <Class> :sel <Symbol> |
			s nextPut: (MethodReference class: cls selector: sel)]].

	themNS:: Array streamContents: [:stm |
		systemScope newspeakImplementorsOf: model do: [:mirror | stm nextPut: mirror]].

	^themST, themNS
)
isReference: a lessThan: b = (
	| aClass bClass |
	aClass:: a classSymbol.
	bClass:: b classSymbol.
	aClass < bClass ifTrue: [^true].
	aClass > bClass ifTrue: [^false].
	^a methodSymbol < b methodSymbol
)
public selector = (
	^model
)
public senderSubjects ^ <Collection[MethodSubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^senders collect: [:each <MethodReference> |
		MethodSubject onMethod: each]
)
senders = (
	(* Answer a collection of senders of our selector (as MethodReferences). *)

	| them themNS |
	them:: Array streamContents:
				[:s |
				systemScope smalltalkSendersOf: model do:
					[:cls <Class> :sel <Symbol> |
					s nextPut: (MethodReference class: cls selector: sel)]].
	them:: them asSet asArray sort: [:a :b | isReference: a lessThan: b].
	themNS:: Array streamContents: [:stm |
		systemScope newspeakSendersOf: model do: [:mirror | stm nextPut: mirror]].

	^them, themNS
)
public title = (
	^model printString
)
) : (
)
public class SyntaxErrorNotificationHandler = (|
	public text
	public failureBlock
|) (
public bindingOf: variableName = (
	failureBlock valueWithPossibleArgument: variableName, ' is undefined'
)
public notify: garbledErrorMessage <String> at: position <Integer> in: source <ReadStream> = (
| errorMessage |
errorMessage:: (garbledErrorMessage endsWith: ' ->')
	ifTrue: [garbledErrorMessage allButLast: 3]
	ifFalse: [garbledErrorMessage].
failureBlock valueWithPossibleArgument: errorMessage
)
public selectFrom: start to: end = (
halt
)
public selectionInterval = (
	^nil
)
) : (
)
class SyntheticMethodSubject onModel: m = MethodSubject onModel: m () (
public changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
   failureBlock value: 'Cannot change category of synthetic method'
)
public colorizeMethodSource: sourceText = (
(* Nothing to colorize - displayed source is just a message saying this is an accessor *)
	^sourceText
)
public compileNewSource: source <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (
  (* do nothing *)
)
compiledMethod = (
	^model compiledMethod
)
public deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
   failureBlock value
)
public implementingClass = (
	^model actualClass
)
public isAnOverride ^ <Boolean> = (
(* True if one of the superclasses has a method with the same selector. *)
	^false
)
public isOverridden ^ <Boolean> = (
	(* True if one of the subclasses has a method with the same selector. *)
	^false
)
public isSynthetic ^ <Boolean> = (
	^true
)
public isValid ^ <Boolean> = (
	^true
)
public messages ^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *)
 ^{}
)
public methodCategory ^<String> = (
	^'<synthetic method>'
)
public methodCategoryOrNil ^<String> = (
	^'<synthetic method>'
)
public selector ^ <Symbol> = (
	^model simpleName
)
public source ^ <String> = (
	^'Synthetic  method: no source available'
)
public variableBindingKeys ^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *)
 ^{}
)
) : (
)
public class UnsortedMethodsPresenter onSubject: s = AssortedMethodsPresenter onSubject: s (
(* My subject is a collection of methods and I display them unsorted, in other words not grouped by package. *)
) (
contentPresenters = (
	^Array streamContents:
		[:stream |
		methodPresenters:: subject collect: [:each | newExpandableMethodPresenter: each].
		stream nextPutAll: methodPresenters]
)
) : (
)
) : (
)
