Newspeak3
'Root'
class HopscotchForCroquet usingPlatform: p <Platform> hopscotch: H <HopscotchForHTML5 class> = (
	|
(* imports *)
    private HopscotchForHTML5 = H.
    Promise = p actors Promise.
    Resolver = p actors Resolver.
	|
) (
public class Hopscotch usingPlatform: p <Platform> images: images ducts: ds =
  HopscotchForHTML5 usingPlatform: p images: images ducts: ds

(
(*
This class overrides the normal Hopscotch UI module to allow the UI to synchronize using croquet.io.
For every interactive fragment class, we maintain:

1) A subclass, defined here, that manages the interaction with Croquet.
2) A counter that is used to generate unique ids for each fragment.
3) A corresponding Javascript Croquet model type, each instance of which has, as its associated view, an instance of the JS class NewspeakCroquetFragmentView.

Each fragment is then connected to an instance of NewspeakCroquetFragmentView. The fragment notifies this view when an interaction occurs. The croquet view notifies the croquet model, which notifies the reflector; when the reflector has signaled the croquet model, it notifies the croquet view; the view then executes a call back in which the fragment performs the normal behavior defined in its superclass.

When completed, the goal is:

A series of croquet clients running a Newspeak application can be synchronized, without any modification to the Newspeak application code; the only requirement is that application be deployed using a platform object that uses an instance of this class as its GUI.

To reach that goal, we have to implement all interactive Hopscotch fragments here, and we have to deal with the problem of saving a model of the application as a whole to the Croquet root model; presumably by adding an image mechanism to Newspeak.

Ultimately, we hope to go beyond the above, and be able to diff the saved model state and extend this to full local-first solution.
*)
  |
  buttonCount <Integer> ::= 0.
  imageButtonCount <Integer> ::= 0.  
  radioButtonCount <Integer> ::= 0. 
  checkboxCount <Integer> ::= 0.
  hyperlinkCount <Integer> ::= 0.
  hyperlinkImageCount <Integer> ::= 0.
  codeMirrorCount <Integer> ::= 0.
  toggleComposerCount <Integer> ::= 0.
  textEditorCount <Integer> ::= 0.
  pickerCount <Integer> ::= 0.
  colorPickerCount <Integer> ::= 0.
  datePickerCount <Integer> ::= 0.  
  timePickerCount <Integer> ::= 0.
  sliderCount <Integer> ::= 0.
  searchFieldCount <Integer> ::= 0.
  dropDownMenuCount <Integer> ::= 0.    
  js = p js.   
|
) (
class ButtonFragment label: l action: a = super ButtonFragment label: l action: a (
    |
    buttonId <Integer> ::= newButtonId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <ButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[croquetView <-: publish: scope event: #click]
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsbutton_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | super action value. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createButton handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_button' eventSpec: #createButton data: scope.
  ^futureView promise
)
) : (
)
class ImageButtonFragment = super ImageButtonFragment (
    |
    imageButtonId <Integer> ::= newImageButtonId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsImagebutton_', imageButtonId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ImageButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[croquetView <-: publish: scope event: #click]
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | super action value. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createImageButton handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_image_button' eventSpec: #createImageButton data: scope.
  ^futureView promise
)
) : (
)
class CheckboxFragment text: t <Holder> value: v <Boolean | Holder> action: a <[:Boolean]>  = super CheckboxFragment text: t value: v action: a (
    |
    checkboxId <Integer> ::= newCheckboxId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscheckbox_', checkboxId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <CheckboxFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[:b <Boolean> | croquetView <-: publish: scope event: (b ifTrue: [#checked] ifFalse: [#unchecked])]
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_checked handler: [:e | super action value: true. nil].
        croquetView <-: subscribe: scope eventSpec: #model_unchecked handler: [:e | super action value: false. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createCheckbox handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_checkbox' eventSpec: #createCheckbox data: scope.
  ^futureView promise
)
) : (
)
class RadioButtonFragment text: t <String> 
	value: v <Boolean | Holder> 
	group: g <String> 
	action: a <[:Boolean]> = super RadioButtonFragment text: t value: v group: g action: a (
    |
    radioButtonId <Integer> ::= newRadioButtonId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsradiobutton_', radioButtonId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <RadioButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[:b <Boolean> | croquetView <-: publish: scope event: (b ifTrue: [#pressed] ifFalse: [#released])]
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_pressed handler: [:e | super action value: true. nil].
  croquetView <-: subscribe: scope eventSpec: #model_released handler: [:e | super action value: false. nil]        
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createRadioButton handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_radio_button' eventSpec: #createRadioButton data: scope.
  ^futureView promise
)
) : (
)
class HyperlinkFragment label: l action: a = super HyperlinkFragment label: l action: a (
   |
    hyperlinkId <Integer> ::= newHyperlinkId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <HyperlinkFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[croquetView <-: publish: scope event: #click]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlink_', hyperlinkId printString].
  ^scope_slot
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | super action value. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createHyperlink handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_hyperlink' eventSpec: #createHyperlink data: scope.
  ^futureView promise
)
) : (
)
public class CodeMirrorFragment onText: t <String> = super CodeMirrorFragment onText: t (
    |
    codeMirrorId <Integer> ::= newCodeMirrorId.
    scope_slot <String>
    reflecting <Boolean> ::= true.
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscodemirror_', codeMirrorId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <CodeMirrorFragment>  ^ <Alien[Element]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
respondToKeyDown: event <Alien[Event]> = (
  ^[reflecting
        ifTrue: [preventDefault. croquetView <-: publish: scope eventSpec: #keydown data: event]
        ifFalse: [super respondToKeyDown: event.  reflecting:: true]
    ]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createCodeMirror handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_code_mirror' eventSpec: #createCodeMirror data: scope.
  ^futureView promise
)
respondToChange: event <Alien[Event]> = (
  croquetView <-: publish: scope event: #change data: (textEditor at: 'textContent')
)
respondToBeforeChange: event <Alien[Event]> = (
  croquetView <-: publish: scope event: #beforeChange data: (textEditor at: 'textContent')
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_change handler: [:e | textEditor at: 'textContent' put: e. super respondToChange: e. nil].
        croquetView <-: subscribe: scope eventSpec: #model_beforeChange handler: [:e | super respondToBeforeChange: e. nil].   
        croquetView <-: subscribe: scope eventSpec: #model_keydown handler: [:e | reflecting:: false. super respondToKeyDown: e. nil]
)
) : (
)
class HyperlinkImageFragment image: i action: a = super HyperlinkImageFragment (|
    hyperlinkImageId <Integer> ::= newHyperlinkImageId.
    scope_slot <String>
    |
    croquetView
) (
action = (
  ^[croquetView <-: publish: scope event: #click]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlinkImage_', hyperlinkImageId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <HyperlinkImageFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | super action value. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createHyperlinkImage handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_hyperlink_image' eventSpec: #createHyperlinkImage data: scope.
  ^futureView promise
)
) : (
)
class ToggleComposer collapsedDefinition: collapsed <[Fragment]>
    expandedDefinition: expanded <[Fragment]>
    initiallyExpanded: flag <Boolean> = super ToggleComposer collapsedDefinition: collapsed 
    expandedDefinition: expanded 
    initiallyExpanded: flag (
    |
    toggleComposerId <Integer> ::= newToggleComposerId.
    scope_slot <String>
    |
    croquetView
) (
public toggle = (
  ^[croquetView <-: publish: scope event: #toggle]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nstogglecomposer_', toggleComposerId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ToggleComposer>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_toggle handler: [:e | super toggle. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createToggleComposer handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_toggle_composer' eventSpec: #createToggleComposer data: scope.
  ^futureView promise
)
) : (
)
public class TextEditorFragment = super TextEditorFragment (
    |
    textEditorId <Integer> ::= newTextEditorId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <TextEditorFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createTextEditor handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_text_editor' eventSpec: #createTextEditor data: scope.
  ^futureView promise
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstexteditor_', textEditorId printString].
  ^scope_slot
)
respondToCancel: event <Alien[Event]> = (
  'responding to cancel' out.
  croquetView <-: publish: scope event: #cancel data: (textEditor at: 'textContent')
)
respondToAccept: event <Alien[Event]> = (
  'responding to accept' out.
  croquetView <-: publish: scope event: #accept data: (textEditor at: 'textContent')
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        (* how to get event data? *)
        croquetView <-: subscribe: scope eventSpec: #model_accept handler: [:e | textEditor at: 'textContent' put: e. super respondToAccept: e. nil].
        croquetView <-: subscribe: scope eventSpec: #model_change handler: [:e | textEditor at: 'textContent' put: e. super respondToChange: e. nil].
        croquetView <-: subscribe: scope eventSpec: #model_cancel handler: [:e | super respondToCancel: e. nil].        
)
respondToChange: event <Alien[Event]> = (
  croquetView <-: publish: scope event: #change data: (textEditor at: 'textContent')
)
) : (
)
class PickerFragment text: t <String> items: i <List[String]> action: a <[:String]> = super PickerFragment text: t items: i action: a (
    |
    buttonId <Integer> ::= newPickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <PickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nspicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_input handler: [:e | super inputHandler value: e. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createPicker handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_picker' eventSpec: #createPicker data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #input data: event. nil]
)
) : (
)
class ColorPickerFragment value: v <String | Holder> action: a <[:String]> = super ColorPickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newColorPickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <ColorPickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nscolorpicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_input handler: [:e | super inputHandler value: e. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createColorPicker handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_color_picker' eventSpec: #createColorPicker data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #input data: event. nil]
)
) : (
)
class DatePickerFragment value: v <String | Holder> action: a <[:String]> = super DatePickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newDatePickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <DatePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsdatepicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_input handler: [:e | super inputHandler value: e. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createDatePicker handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_date_picker' eventSpec: #createDatePicker data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #input data: event. nil]
)
) : (
)
class TimePickerFragment value: v <String | Holder> action: a <[:String]> = super TimePickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newTimePickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <TimePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstimepicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_input handler: [:e | super inputHandler value: e. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createTimePicker handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_time_picker' eventSpec: #createTimePicker data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #input data: event. nil]
)
) : (
)
class SliderFragment value: v <Holder> min: mn <Float> max: mx <Float> = super SliderFragment value: v min: mn max: mx (
    |
    buttonId <Integer> ::= newSliderId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsslider_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_input handler: [:e | super inputHandler value: e. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createSlider handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_slider' eventSpec: #createSlider data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #input data: event. nil]
)
) : (
)
class SearchFieldFragment = super SearchFieldFragment (
    |
    buttonId <Integer> ::= newSearchFieldId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
respondToKeyDown ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #keydown data: event]
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nssearchfield_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_keydown handler: [:e | super respondToKeyDown. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createSearchField handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_search_field' eventSpec: #createSearchField data: scope.
  ^futureView promise
)
) : (
)
class DropDownMenuFragment menu: ms image: img <Image> alignment: side <Symbol> = super DropDownMenuFragment menu: ms image: img alignment: side (
    |
    buttonId <Integer> ::= newDropDownMenuId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsdropdownmenu_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
  croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | super clickHandler value: e. nil].
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createDropDownMenu handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_drop_down_menu' eventSpec: #createDropDownMenu data: scope.
  ^futureView promise
)
public clickHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #click data: event. nil]
)
) : (
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: #right
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> alignment: side <Symbol> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: side
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> image: img <Image> ^ <Instance> = (
   ^menu: ms image: img alignment: #right
)
)
class Fragment = super Fragment (
|
public croquetView_slot <Promise[Alien[NewspeakCroquetFragmentView]]>
|
) (
croquetModel = (
    ^croquetView model.
)
croquetView = (
    croquetView_slot isNil ifTrue: [setupCroquetView].
    ^croquetView_slot
)
setupCroquetView = (
  (* only fragments that actively need croquet support need this *)
  subclassResponsibility
)
) : (
)
lazy rootView <Alien[NewspeakCroquetView]> = js global at: #theView.
lazy private NewspeakCroquetFragmentView <Alien[NewspeakCroquetFragmentView class]> = js global at: #NSCroquetFragmentView.
newButtonId ^ <Integer> = (
  buttonCount::buttonCount + 1.
  ^buttonCount
)
newImageButtonId ^ <Integer> = (
  imageButtonCount:: imageButtonCount + 1.
  ^imageButtonCount
)
newRadioButtonId ^ <Integer> = (
  radioButtonCount:: radioButtonCount + 1.
  ^radioButtonCount
)
newHyperlinkId ^ <Integer> = (
  hyperlinkCount:: hyperlinkCount + 1.
  ^hyperlinkCount
)
newCodeMirrorId ^ <Integer> = (
  codeMirrorCount:: codeMirrorCount + 1.
  ^codeMirrorCount
)
newHyperlinkImageId ^ <Integer> = (
  hyperlinkImageCount:: hyperlinkImageCount + 1.
  ^hyperlinkImageCount
)
newToggleComposerId ^ <Integer> = (
  toggleComposerCount:: toggleComposerCount + 1.
  ^toggleComposerCount
)
newCheckboxId ^ <Integer> = (
  checkboxCount:: checkboxCount + 1.
  ^checkboxCount
)
newTextEditorId ^ <Integer> = (
  textEditorCount:: textEditorCount + 1.
  ^textEditorCount
)
rootModel ^ <Alien[NewspeakCroquetView]> = (
  ^rootView model
)
newPickerId ^ <Integer> = (
  pickerCount:: pickerCount + 1.
  ^pickerCount
)
newSliderId ^ <Integer> = (
  sliderCount:: sliderCount + 1.
  ^sliderCount
)
newColorPickerId ^ <Integer> = (
  colorPickerCount:: colorPickerCount + 1.
  ^colorPickerCount
)
newDatePickerId ^ <Integer> = (
  datePickerCount:: datePickerCount + 1.
  ^datePickerCount
)
newTimePickerId ^ <Integer> = (
  timePickerCount:: timePickerCount + 1.
  ^timePickerCount
)
newSearchFieldId ^ <Integer> = (
  searchFieldCount:: searchFieldCount + 1.
  ^searchFieldCount
)
newDropDownMenuId ^ <Integer> = (
  dropDownMenuCount:: dropDownMenuCount + 1.
  ^dropDownMenuCount
)
public dropDownImage = (
  ^super dropDownImage
)
) : (
)
) : (
)
