Newspeak3
'Root'
class KernelForJS usingVmMirror: vmm = (
(*
Kernel classes for the Javascript-based implementation of Newspeak.
Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.
Copyright 2013 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)
|
vmmirror = vmm.
public platform
|) (
public class Array uninstantiable = () (
public , otherSequence = (
	^_js call: (_js propertyOf: self at: (_js literal: 'concat')) with: {otherSequence asArray}
)
public asArray = (
	^self
)
public asOrderedCollection = (
	^platform collections List withAll: self
)
public at: index <Integer> ^<E> = (
	| jsIndex |
	(_js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].
	jsIndex:: _js operator: '-' with: index and: (_js literal: 1).
	(_js operator: '<' with: jsIndex and: (_js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].
	(_js operator: '>=' with: jsIndex and: (_js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].
	^_js propertyOf: (_js ident: 'this') at: jsIndex
)
public at: index <Integer> put: value <E> ^<E> = (
	| jsIndex |
	(_js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].
	jsIndex:: _js operator: '-' with: index and: (_js literal: 1).
	(_js operator: '<' with: jsIndex and: (_js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].
	(_js operator: '>=' with: jsIndex and: (_js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].
	^_js assign: (_js propertyOf: (_js ident: 'this') at: (_js operator: '-' with: index and: (_js literal: 1)))
	 toBe: value
)
public binarySearchFor: el between: start and: end toCompare: compare = (
	(* This does a binary search for the index such that if el was inserted before it
	  the receiver would remain sorted.  The receiver must be sorted relative to the
	  comparison block.  The comparison block should return true if the first block argument
	  cannot appear after the second block argument *)

	| low high |
	low:: start.
	high:: end.
	[ low <= high ]
		whileTrue:
				[ | mid |
					mid:: (low + high) // 2.
	  				(compare value: (self at: mid) value: el)
						ifTrue: [ low:: mid + 1 ]
						ifFalse: [ high:: mid - 1 ].
				].
	^low
)
public collect: block = (
	^_js call: (_js propertyOf: self at: (_js literal: 'map')) with: {block}.
)
public copyFrom: start to: end = (
	^_js call: (_js propertyOf: self at: (_js literal: 'slice')) with: {start - 1. end}
)
public copyWith: extraElement = (
	| newSize ::= self size + 1. a |
	a:: (Array new: newSize) replaceFrom: 1 to: self size with: self.
	a at: newSize put: extraElement.
	^a
)
public copyWithSize: s = (
	^(Array new: s) replaceFrom: 1 to: (s min: self size) with: self
)
defaultMedianOf: a <Int> and: b <Int> and: c <Int> ^<Int> = (
	(* This is an untypesafe method that only works for MutableLists of elements that
		have Magnitude relationships with each other.  It is used by the default sorting
		method. *)

	| atA <E> atB <E> atC <E> |
	atA:: at: a.
	atB:: at: b.
	atC:: at: c.
	^atB <= atA
		ifFalse: [ atC <= atB
							ifFalse: [ b ]
							ifTrue: [ atC <= atA
												ifFalse: [ c ]
												ifTrue: [ a ] 	] ]
		ifTrue: [ atB <= atC
							ifFalse: [ b ]
							ifTrue: [ atA <= atC
												ifFalse: [ c ]
												ifTrue: [ a ] 	] ]
)
public defaultSort: l <Int> to: r <Int> = (
	(* This is an untypesafe method that only works for MutableLists of elements that
		have Magnitude relationships with each other *)

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i:: l.
	j:: r.
	n:: ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	(* Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three *)
	m:: (l + r) // 2.
	n > 7
		ifTrue: [ | pl <Int> pn <Int> s <Int> |
						pl:: l.
						pn:: r.
						n > 40
							ifTrue: [ s:: n // 8.
											pl:: defaultMedianOf: pl and: pl+s and: pl+s+s.
											m:: defaultMedianOf: m-s and: m and: m+s.
											pn:: defaultMedianOf: (pn-s)-s and: pn-s and: pn.	].
						m:: defaultMedianOf: pl and: m and: pn.		].
	x:: at: m.

	[i <= j]
		whileTrue:
			[ | ati <E> atj <E> |
			 	[ x <= (ati:: at: i)]
					whileFalse: [i:: i + 1].
				[(atj:: at: j) <= x]
					whileFalse: [j:: j - 1].
				i <= j
					ifTrue: [ at: i put: atj.
									at: j put: ati.
									i:: i + 1.
									j:: j - 1]
			].
	l < j ifTrue: [defaultSort: l to: j ].
	i < r ifTrue: [defaultSort: i to: r ].
)
public do: block = (
	_js call: (_js propertyOf: self at: (_js literal: 'forEach')) with: {block}.
)
public do: block separatedBy: betweenBlock = (
	| firstTime ::= true. |

	self do: [:element |
		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].
		block value: element].
)
public first = (
	^self at: 1
)
public flatMap: map <[:E | R def]> ^<Collection[R]> = (
	^self flatten collect: map
)
public flatten ^ <Array> = (
	| totalSize <Integer> ::= 0. c <Array> index <Integer> ::= 1. |
	self do: [:e <E> | totalSize:: totalSize + (e isKindOfCollection ifTrue: [e size] ifFalse: [1])].
	c:: Array new: totalSize.
	do: [:e <E> | e isKindOfCollection
					ifTrue: [e do: [:x | c at: index put: x. index:: index + 1]]
					ifFalse: [c at: index put: e. index:: index + 1]
		].
	^c
)
public includes: element = (
	self do: [:each | each = element ifTrue: [^true]].
	^false
)
public indexOf: element <E> ^<Integer> = (
	1 to: self size do: [:index | (self at: index) = element ifTrue: [^index]].
	^0
)
public inject: initialValue into: accumulator = (
	^_js call: (_js propertyOf: self at: (_js literal: 'reduce')) with: {accumulator. initialValue}.
)
public isEmpty = (
	^0 == size
)
public isKindOfArray ^<Boolean> = (
	^true
)
public isKindOfCollection ^<Boolean> = (
	^true
)
public keysAndValuesDo: binaryBlock <[:Integer :E]> = (
	1 to: self size do: [:index | binaryBlock value: index value: (self at: index)]
)
public last = (
	^self at: self size
)
public printString = (
	| x ::= '{'. |
	#FLAG. (* This is not safe for arrays that contain themselves. *)
	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].
	^x , '}'
)
public replaceFrom: start to: stop with: replacement = (
	(* This destructively replaces elements from start to stop in the receiver.
	Answer the receiver itself. Use copyReplaceFrom:to:with: for
	insertion/deletion which may alter the size of the result. *)

	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)
public replaceFrom: start to: stop with: replacement startingAt: repStart = (
	(* This destructively replaces elements from start to stop in the receiver
	starting at index, repStart, in the sequenceable collection,
	replacementCollection. Answer the receiver. No range checks are
	performed. *)

	| index repOff |
	repOff:: repStart - start.
	index:: start - 1.
	[(index:: index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)
public select: block = (
	^_js call: (_js propertyOf: self at: (_js literal: 'filter')) with: {block}.
)
public size ^<Integer> = (
	^_js propertyOf: self at: (_js literal: 'length')
)
public sort: binaryBlock = (
	_js
		call: (_js propertyOf: self at: (_js literal: 'sort'))
		with: {_js functionOf: {'a'. 'b'} body: (_js block: {
			_js return: ((binaryBlock value: (_js ident: 'a') value: (_js ident: 'b'))
				ifTrue: [-1] ifFalse: [1])
		})}.
)
public mergeSortFrom: startIndex to: stopIndex by: aBlock = (
(* fake for squeak compatibility *)
  sort: aBlock
)
public with:  other <List[X def]> do: action <[:E :X]> = (
  assert: [self size = other size] message: 'Cannot jointly iterate collections of different sizes'.
  1 to: size do: [:index <Integer> |
    action value: (at: index) value: (other at: index)
  ]
)
public reject: predicate <[:E | Boolean]> ^<Array[E]> = (
(* :TODO see if this is better done as a primitive, i.e., using _js *)
	| result cursor |
	result:: Array new: self size.
	cursor:: 0.
	1 to: self size do:
		[:index | | element <E> |
		 element:: self at: index.
		 (predicate value: element) ifFalse:
			[result at: (cursor:: 1 + cursor) put: element]].
	^result copyFrom: 1 to: cursor
)
public reverse ^ <Array[T]> = (
(* :TODO see if this is better done as a primitive, i.e., using _js *)
  | reversed <Array[t]> = _Array new: size. |
  size to: 1 by: -1 do: [:i | reversed at: size - i + 1put: (at: i)].
  ^reversed
)
) : (
public new: size <Integer> = (
(* should be private but does not work that way! Possible compiler bug. *)
	^self new: size withAll: nil
)
public with: element = (
	^{element}
)
new: size <Integer> withAll: initialElement <E> ^<Array[E]> = (
	| array index |
	(_js prefixOperator: 'typeof ' on: size) == 'number' ifFalse: [^Error signal: 'ArgumentError'].
	(_js operator: '<' with: size and: (_js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].

	array:: _js new: (_js ident: 'Array') with: {size}.
	_js
		for: (index:: 0)
		while: (_js operator: '<' with: index and: size)
		step: (_js postfixOperator: '++' on: index)
		do: (_js block: {
			_js assign: (_js propertyOf: array at: index) toBe: initialElement}).
	^array
)
public withAll: collection <Collection[E]> ^<Array[E]> = (
(* :TODO make this a primitive using _js. Almost the same as #new:withAll: *)
	| result index |
	result:: Array new: collection size.
	index:: 1.
	collection do: [:element <E> | result at: index put: element. index:: 1 + index].
	^result
)
)
public class Boolean uninstantiable = () (
public & other = (
	(* Evaluating conjunction. *)
	^_js operator: '&&' with: self and: other
)
public and: alternative <[Boolean]> ^ <Boolean> = (
  (* Non-evaluating conjunction *)
  ^_js ternaryIf: self then: (_js call: alternative with: {}) else: self
)
public asString = (
	^self ifTrue: ['true'] ifFalse: ['false']
)
public ifFalse: else = (
	^_js ternaryIf: self then: nil else: (_js call: else with: {})
)
public ifFalse: else ifTrue: then = (
	^_js ternaryIf: self then: (_js call: then with: {}) else: (_js call: else with: {})
)
public ifTrue: onTrue = (
	^_js ternaryIf: self then: (_js call: onTrue with: {}) else: nil
)
public ifTrue: then ifFalse: else = (
	^_js ternaryIf: self then: (_js call: then with: {}) else: (_js call: else with: {})
)
public isKindOfBoolean = (
	^true
)
public not = (
	^_js prefixOperator: '!' on: self.
)
public or: alternative <[Boolean]> ^ <Boolean> = (
  (* Non-evaluating disjunction *)
  ^_js ternaryIf: self then: self else:  (_js call: alternative with: {})
)
public printString = (
	^self ifTrue: ['true'] ifFalse: ['false']
)
public value = (
	^self
)
public | other = (
	(* Evaluating disjunction. *)
	^_js operator: '||' with: self and: other
)
) : (
)
public class ByteArray uninstantiable = (
) (
public at: index <Integer> ^<E> = (
	| jsIndex |
	(_js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].
	jsIndex:: _js operator: '-' with: index and: (_js literal: 1).
	(_js operator: '<' with: jsIndex and: (_js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].
	(_js operator: '>=' with: jsIndex and: (_js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].
	^_js propertyOf: (_js ident: 'this') at: jsIndex
)
public at: index <Integer> put: value <E> ^<E> = (
	| jsIndex |
	(_js prefixOperator: 'typeof ' on: index) == 'number' ifFalse: [^Error signal: 'ArgumentError'].
	jsIndex:: _js operator: '-' with: index and: (_js literal: 1).
	(_js operator: '<' with: jsIndex and: (_js literal: 0)) ifTrue: [^Error signal: 'ArgumentError'].
	(_js operator: '>=' with: jsIndex and: (_js verbatim: 'this.length')) ifTrue: [^Error signal: 'ArgumentError'].
	^_js assign: (_js propertyOf: (_js ident: 'this') at: (_js operator: '-' with: index and: (_js literal: 1)))
	 toBe: value
)
public isEmpty = (
	^0 == size
)
public isKindOfByteArray ^<Boolean> = (
	^true
)
public keysAndValuesDo: binaryBlock <[:Integer :Integer]> = (
	1 to: self size do: [:index | binaryBlock value: index value: (self at: index)]
)
public size ^<Integer> = (
	^_js propertyOf: self at: (_js literal: 'length')
)
) : (
public new: size <Integer> ^<ByteArray> = (
	(_js prefixOperator: 'typeof ' on: size) == 'number' ifFalse: [^Error signal: 'ArgumentError'].
	size < 0 ifTrue: [^Error signal: 'ArgumentError'].
	^_js new: (_js ident: 'Uint8Array') with: {size}
)
)
public class Class = (|
public superclass
public mixin
public enclosingObject (* Remove me *)
public enclosingObjects
public name
|) (
public isKindOfBehavior = (
	^true
)
public isKindOfClass = (
	^true
)
public isMeta = (
	^true
)
public mixinApply: newSuperclass = (
	^vmmirror
		applyMixin: (_js propertyOf: self mixin at: (_js literal: 'runtimeMixin'))
		toSuperclass: newSuperclass
		withEnclosingObjects: self enclosingObjects
)
public simpleName = (
	^mixin name
)
) : (
)
public class Closure uninstantiable = () (
public cull: a1 = (
	^_js call: (_js ident: 'this') with: {a1}
)
public cull: a1 cull: a2 = (
	^_js call: (_js ident: 'this') with: {a1. a2}
)
public cull: a1 cull: a2 cull: a3 = (
	^_js call: (_js ident: 'this') with: {a1. a2. a3}
)
public ensure: onUnwind = (
	| result |
	_js try: (_js block: {
		result:: self value.
	})
	catch: (_js ident: 'e')
	with: (_js block: {
		onUnwind value.
		_js throw: (_js ident: 'e').
	}).
	onUnwind value.
	^result
)
public isKindOfClosure ^<Boolean> = (
	^true
)
public numArgs ^<Integer> = (
	^_js propertyOf: self at: (_js literal: 'length')
)
public on: errorClass do: handler = (
	(* Perhaps we should match on mixin instead of class... *)
	| c |
	_js try: (_js block: {_js return: self value})
	catch: (_js ident: 'e')
	with: (_js block: {
		_js if: (_js operator: '===' with: (_js propertyOf: (_js ident: 'e') at: (_js literal: 'newspeakClass')) and: (_js ident: 'undefined'))
		then: (_js block: {_js throw: (_js ident: 'e')}).
		_js for: (c:: classOf: (_js ident: 'e')) while: (_js operator: '!==' with: c and: nil) step: (_js verbatim: '') do: (_js block: {
			_js if: (_js operator: '===' with: c and: errorClass)
			then: (_js block: {_js return: (handler value: (_js ident: 'e'))}).
			c:: c superclass.
		}).
		_js throw: (_js ident: 'e').
	})
)
public value = (
	^_js call: (_js ident: 'this') with: {}
)
public value: a1 = (
	^_js call: (_js ident: 'this') with: {a1}
)
public value: a1 value: a2 = (
	^_js call: (_js ident: 'this') with: {a1. a2}
)
public value: a1 value: a2 value: a3 = (
	^_js call: (_js ident: 'this') with: {a1. a2. a3}
)
public valueWithArguments: args = (
	^_js call: (_js propertyOf: (_js ident: 'this') at: (_js literal: 'apply')) with: {_js ident: 'this'. args}
)
public whileFalse: aBlock = (
	[self value] whileFalse: [aBlock value].
	^nil
)
) : (
)
public class Exception = (|
	public messageText (* squeak compatibility for Minitest *)
|) (
public printString = (
	nil = messageText ifTrue: [^super class name].
	^super class name, ': ', messageText
)
public signal = (
	_js verbatim: 'this.trace = new Error().stack'.
	_js throw: self.
)
public signal: message = (
	(* squeak compatibility for Minitest *)
	messageText:: message.
	^self signal
)
) : (
public signal: message = (
	^(self new messageText: message) signal
)
)
public class Future computing: block <[E]> = (
(* The simplest possible future. It evalutes its closure in response to nearly every message. *)
|
	private blockOrValue000 <[E] | E> ::= block.
	private state000 <Symbol> ::= #unresolved.
|) (
protected doesNotUnderstand: message = (
	^message sendTo: self resolve
)
public isKindOfFuture ^<Boolean> = (
	^true
)
resolve = (
	state000 = #resolving ifTrue: [
		Error signal: 'Divergent evaluation of ', blockOrValue000 printString].
	state000 = #unresolved ifTrue: [
		state000: #resolving.
		blockOrValue000: blockOrValue000 value.
		[blockOrValue000 isKindOfFuture] whileTrue:
			[blockOrValue000: blockOrValue000 resolve].
		state000: #resolved.
	].
	^blockOrValue000
)
public yourself = (
	(* See InstanceMixin>>apply:withName: *)
	^self resolve
)
) : (
)
public class Message mangledSelector: s arguments: a = (
(* FIXME: This factory should not be public. *)
|
	public mangledSelector = s.
	public arguments = a.
|) (
public printString = (
	^'#',selector
)
public selector = (
	^vmmirror unmangleSelector: mangledSelector
)
public sendTo: receiver = (
  _js try: 
   (_js block: {
       (_js return: 
         (_js call: (_js propertyOf: (_js propertyOf: receiver at: mangledSelector) at: (_js literal: 'apply')) with: {receiver. arguments})
       )
   }
  )
  catch: (_js ident: 'e')
  with: (_js block: {_js return:  (_js call: (_js propertyOf: receiver at: (_js literal: 'dnu')) with: {self})})
)
) : (
mangle: selector = (
	^((('$', selector)
		replaceAll: ":" with: "$") (* Keyword *)
		replaceAll: "`" with: "$") (* Qualified *)
		replaceAll: "." with: "$" (* limit temp *)
)
public selector: selector = (
	^self mangledSelector: (mangle: selector) arguments: {}
)
public selector: selector arguments: arguments = (
	^self mangledSelector: (mangle: selector) arguments: arguments
)
)
public class MessageNotUnderstood receiver: r message: m = Exception (|
	public receiver = r.
	public message = m.
|) (
public messageText = (
	(* squeak compatibility for Minitest *)
	^self printString
)
public printString ^<String> = (
	^'MessageNotUnderstood: ', (classOf: receiver) name, ' ', message selector
)
) : (
)
public class Metaclass = (
|
public superclass
public mixin
public enclosingObject
public name
public thisClass
|) (
public isKindOfBehavior = (
	^true
)
public isMeta = (
	^true
)
) : (
)
public class Mixin fromRuntimeMixin: rm = (_js assign: (_js propertyOf: self at: (_js literal: 'runtimeMixin')) toBe: rm) (
public applyTo: superclass <Class> ^<Class> = (
	(* assert: [isTopLevel] message: 'Only top-level mixins may be applied directly' *)
	assert: [isMeta not] message: 'Only instance-side mixins may be applied directly'.
	^self applyTo: superclass withName: (superclass name, ' <: ', name)
)
public applyTo: superclass <Class> withName: name <String> ^<Class> = (
	^vmmirror
		applyMixin: (_js propertyOf: self at: (_js literal: 'runtimeMixin'))
		toSuperclass: superclass
		withEnclosingObjects: {nil}
)
public isMeta ^<Boolean> = (
	^_js operator: '===' with: (_js propertyOf: (_js propertyOf: self at: (_js literal: 'runtimeMixin')) at: (_js literal: 'meta')) and: (_js ident: 'undefined')
)
public name ^<Symbol> = (
	^isMeta
		ifTrue: [(_js propertyOf: (_js propertyOf: (_js propertyOf: self at: (_js literal: 'runtimeMixin')) at: (_js literal: 'nonMeta')) at: (_js literal: 'name')), ' class']
		ifFalse: [_js propertyOf: (_js propertyOf: self at: (_js literal: 'runtimeMixin')) at: (_js literal: 'name')].
)
public printString ^<String> = (
	^name, ' mixin'
)
) : (
)
public class Number uninstantiable = () (
public * other = (
	^_js operator: '*' with: self and: other
)
public + other = (
	^_js operator: '+' with: self and: other
)
public - other = (
	^_js operator: '-' with: self and: other
)
public / other = (
	^_js operator: '/' with: self and: other
)
public // other = (
	^(self / other) floor
)
public < other = (
	^_js operator: '<' with: self and: other
)
public << other = (
	^_js operator: '<<' with: self and: other
)
public <= other = (
	^_js operator: '<=' with: self and: other
)
public = other = (
	^_js operator: '===' with: self and: other
)
public > other = (
	^_js operator: '>' with: self and: other
)
public >= other = (
	^_js operator: '>=' with: self and: other
)
public >> other = (
	^_js operator: '>>' with: self and: other
)
public \\ other = (
	^self - (self // other * other)
)
public abs = (
	self >= 0 ifTrue: [^self] ifFalse: [^-1.0 * self]
)
public asFloat = (
	^self * 1.0
)
public asInteger = (
	^self truncated
)
public asString ^<String> = (
	^_js call: (_js propertyOf: self at: (_js literal: 'toString')) with: {}
)
public asStringExponential: fractionDigits <Integer> ^<String> = (
	fractionDigits < 0 ifTrue: [^Error signal].
	fractionDigits > 20 ifTrue: [^Error signal].
	^_js call: (_js propertyOf: self at: (_js literal: 'toExponential')) with: {fractionDigits}
)
public asStringFixed: fractionDigits <Integer> ^<String> = (
	fractionDigits < 0 ifTrue: [^Error signal].
	fractionDigits > 100 ifTrue: [^Error signal].
	^_js call: (_js propertyOf: self at: (_js literal: 'toFixed')) with: {fractionDigits}
)
public asStringPrecision: precision <Integer> ^<String> = (
	precision < 1 ifTrue: [^Error signal].
	precision > 100 ifTrue: [^Error signal].
	^_js call: (_js propertyOf: self at: (_js literal: 'toPrecision')) with: {precision}
)
public asStringRadix: radix <Integer> ^<String> = (
	radix < 2 ifTrue: [^Error signal].
	radix > 36 ifTrue: [^Error signal].
	^_js call: (_js propertyOf: (_js call: (_js propertyOf: self at: (_js literal: 'toString')) with: {radix}) at: (_js literal: 'toUpperCase')) with: {}
)
public between: min and: max = (
	^self <= max and: [ self >= min ]
)
public bitAnd: other = (
	^_js operator: '&' with: self and: other
)
public bitInvert = (
	^-1 - self
)
public bitOr: other = (
	^_js operator: '|' with: self and: other
)
public bitXor: other = (
	^_js operator: '^' with: self and: other
)
public ceiling = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'ceil')) with: {self}
)
public cos = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'cos')) with: {self}
)
public exp = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'exp')) with: {self}
)
public floor = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'floor')) with: {self}
)
public hash = (
	(* Truncate to signed 32-bit integer. *)
	^_js operator: '|' with: self and: (_js literal: 0)
)
public isKindOfFloat = (
	^true
)
public isKindOfInteger = (
	^self = self asInteger
)
public isKindOfNumber = (
	^true
)
public isNaN ^<Boolean> = (
	^_js call: (_js ident: 'isNaN') with: {self}
)
public ln = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'log')) with: {self}
)
public log = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'log10')) with: {self}
)
public max: other = (
	^self > other ifTrue: [ self ] ifFalse: [ other ]
)
public min: other = (
	^self < other ifTrue: [ self ] ifFalse: [ other ]
)
public negated = (
	^0 - self
)
public printString = (
	^_js call: (_js propertyOf: self at: (_js literal: 'toString')) with: {}
)
public quo: other = (
	^(self / other) truncated
)
public rem: other = (
	^self - ((self quo: other) * other)
)
public rounded = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'round')) with: {self}
)
public sign = (
	self > 0 ifTrue: [^1].
	self < 0 ifTrue: [^-1].
	^0
)
public sin = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'sin')) with: {self}
)
public sqrt = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'sqrt')) with: {self}
)
public tan = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'tan')) with: {self}
)
public timesRepeat: block = (
	| i ::= 0. |
	_js
		for: (_js verbatim: '')
		while: (_js operator: '<' with: i and: (_js ident: 'this'))
		step: (_js postfixOperator: '++' on: i)
		do: (_js block: {_js call: block with: {}})
)
public to: stop = (
	^platform collections Interval from: self to: stop
)
public to: limit do: block = (
	| i ::= self. |
	_js
		for: (_js verbatim: '')
		while: (_js operator: '<=' with: i and: limit)
		step: (_js postfixOperator: '++' on: i)
		do: (_js block: {_js call: block with: {i}})
)
public truncated = (
	^self > 0 ifTrue: [self floor] ifFalse: [self ceiling]
)
public ** exponent = (
	^_js call: (_js propertyOf: (_js ident: 'Math') at: (_js literal: 'pow')) with: {self. exponent}
)
) : (
public parse: str <String> ^<Float> = (
	^_js call: (_js ident: 'parseFloat') with: {str}
)
public parse: str <String> radix: radix <Integer> ^<Integer> = (
	^_js call: (_js ident: 'parseInt') with: {str. radix}
)
)
public class Object = ImplementationBase () (
public = other = (
	^_js operator: '===' with: self and: other
)
public == other = (
	^_js operator: '===' with: self and: other
)
Array ^ <KernelForJS Array class> = (
	^outer KernelForJS Array
)
ByteArray ^ <KernelForJS ByteArray class> = (
	^outer KernelForJS ByteArray
)
Character ^ <KernelForJS Character class> = (
	^outer KernelForJS String
)
Error ^ <KernelForJS Error class> = (
	^outer KernelForJS Error
)
Float ^ <KernelForJS Number class> = (
	^outer KernelForJS Number
)
Future ^<KernelForJS Future class> = (
	^outer KernelForJS Future
)
Integer ^ <KernelForJS Number class> = (
	^outer KernelForJS Number
)
Object ^ <KernelForJS Object class> = (
	^outer KernelForJS Object
)
String ^ <KernelForJS String class> = (
	^outer KernelForJS String
)
assert: condition <[Boolean]> message: message = (
	(* Raises an error with the given message if and only if condition evaluates to false. *)
	condition isKindOfClosure ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signal: 'Assertion failed: ', message]
)
private cannotReturn: value = (
	(* compiler entry *)
	Exception signal: 'CannotReturn: ', value printString.
)
protected class = (
	^classOf: self
)
protected doesNotUnderstand: message = (
	(0 = message arguments size) ifTrue: [(message selector startsWith: 'isKindOf') ifTrue: [^false]].

	^(MessageNotUnderstood receiver: self message: message) signal
)
public hash ^<Integer> = (
	(* It might be worth giving every object the hashCode field at instantiation to avoid map transitions. *)
	_js verbatim: 'while(this.hashCode === 0) this.hashCode = Math.random() * 0x3FFFFFF | 0'.
	^_js verbatim: 'this.hashCode'
)
public ifNil: nilBlock = (
	^self
)
public ifNil: nilBlock ifNotNil: notNilBlock = (
	^notNilBlock value: self
)
public ifNotNil: nonNilBlock = (
	^nonNilBlock value: self
)
public isKindOfFuture = (
	^false
)
public isNil = (
	^false
)
public notNil = (
	^true
)
public out = (
	print: self printString
)
public printString = (
	^'instance of ', self class name
)
public yourself = (
	^self
)
public ~= other = (
	^(self = other) not
)
public isKindOfJSAlien = (
	^false
)
public isKindOfExpat = (
	^false
)
) : (
)
public class Stopwatch = (|
private cumulativeMillis ::= 0.
private startMillis
|) (
private currentMonotonicMillis = (
	^_js verbatim: 'performance.now()'
)
public elapsedMicroseconds ^<Integer> = (
	^elapsedMilliseconds * 1000
)
public elapsedMilliseconds ^<Integer> = (
	nil = startMillis ifTrue: [^cumulativeMillis].
	^cumulativeMillis + (currentMonotonicMillis - startMillis)
)
public start = (
	nil = startMillis ifFalse: [^self (* Already running. *)].
	startMillis:: currentMonotonicMillis
)
public stop = (
	nil = startMillis ifTrue: [^self (* Already stopped. *)].
	cumulativeMillis:: cumulativeMillis + (currentMonotonicMillis - startMillis).
	startMillis:: nil.
)
) : (
)
public class String uninstantiable = () (
public , other = (
	^_js call: (_js propertyOf: self at: (_js literal: 'concat')) with: {other}
)
public = other = (
	^_js operator: '===' with: self and: other
)
public asString = (
	^self
)
public asSymbol = (
	^self
)
public at: index = (
	^_js propertyOf: (_js ident: 'this') at: (_js operator: '-' with: index and: (_js literal: 1))
)
public copyFrom: start to: end = (
	^_js call: (_js propertyOf: self at: (_js literal: 'substring')) with: {start - 1. end}
)
public do: action = (
	|
	i ::= 0.
	len ::= _js verbatim: 'this.length'.
	|
	_js
		for: (_js verbatim: '')
		while: (_js operator: '<' with: i and: len)
		step: (_js postfixOperator: '++' on: i)
		do: (_js block: {
			_js call: action with: {_js propertyOf: self at: i}}).
)
public endsWith: substring = (
	^_js call: (_js propertyOf: self at: (_js literal: 'endsWith')) with: {substring}
)
public first = (
	^self at: 1
)
public hash ^<Integer> = (
	_js var: 'l' value: (_js propertyOf: (_js ident: 'this') at: (_js literal: 'length')).
	^_js ternaryIf: (_js operator: '==' with: (_js ident: 'l') and: (_js literal: 0))
		then: (_js literal: 1)
		else: (_js verbatim: '(l * 32 ^ this.charCodeAt(0)) * 32 ^ this.charCodeAt(l - 1)')
)
public includes: object = (
	self do: [:element | object = element ifTrue: [^true]].
	^false
)
public indexOf: substring <String> ^ <Integer> = (
	^1 + (_js call: (_js propertyOf: self at: (_js literal: 'indexOf')) with: {substring})
)
public indexOf: substring <String> startingAt: index <Integer> ^<Integer> = (
	^1 + (_js call: (_js propertyOf: self at: (_js literal: 'indexOf')) with: {substring. index - 1})
)
public isEmpty ^ <Boolean> = (
  ^0 = size
)
public isKindOfString ^ <Boolean> = (
	^true
)
public last = (
	^self at: self size
)
public lastIndexOf: substring <String> ^<Integer> = (
	^1 + (_js call: (_js propertyOf: self at: (_js literal: 'lastIndexOf')) with: {substring})
)
public lastIndexOf: substring <String> startingAt: index <Integer> ^<Integer> = (
	^1 + (_js call: (_js propertyOf: self at: (_js literal: 'lastIndexOf')) with: {substring. index - 1})
)
public out = (
	print: self.
)
public printString = (
	^_js verbatim: '"''"+this.toString()+"''"'
)
public replaceAll: substring with: newSubstring = (
	#BOGUS. (* Ought to be able to say this.replace(target, replacement, 'g'). *)
	_js var: 'target' value: substring.
	_js var: 'replacement' value: newSubstring.
	^_js verbatim: 'this.replace(new RegExp(target.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement)'
)
public runeAt: index = (
	(* This is wrong for surrogate pairs. *)
	^_js call: (_js propertyOf: self at: (_js literal: 'charCodeAt')) with: {index - 1}
)
public size = (
	^_js verbatim: 'this.length'
)
public splitBy: str = (
	^_js call: (_js propertyOf: self at: (_js literal: 'split')) with: {str}
)
public startsWith: substring = (
	^_js call: (_js propertyOf: self at: (_js literal: 'startsWith')) with: {substring}
)
public withBlanksTrimmed ^ <String> = (
  | startIndex ::=1.  endIndex ::= size. |
  isEmpty ifTrue: [^self].
  [(self at: startIndex) <= 32] whileTrue: [startIndex:: startIndex + 1. startIndex > size ifTrue: [^'']].
  [(self at: endIndex) <= 32] whileTrue: [endIndex:: endIndex - 1].
  ^copyFrom: startIndex to: endIndex
)
public withoutNbsp = (
	('a' at: 1) isKindOfInteger
		ifTrue:
			[ | bytes = copyByteArrayFrom: 1  to: size. |
			1 to: bytes size do: [:index | (bytes at: index) = 160 ifTrue: [bytes at: index put: 32]].
			^String withAll: bytes]
		ifFalse:
			[ | nonbreakingSpace = String fromRune: 160.
			space = String fromRune: 32. |
			^replaceAll: nonbreakingSpace with: space]
)
) : (
public cr = (
	^_js verbatim: '"\r"'
)
public fromRune: rune = (
	^_js call: (_js propertyOf: (_js ident: 'String') at: (_js literal: 'fromCharCode')) with: {rune}
)
public fromRunes: runes = (
	^_js call: (_js propertyOf: (_js propertyOf: (_js ident: 'String') at: (_js literal: 'fromCharCode')) at: (_js literal: 'apply')) with: {_js ident: 'null'. runes asArray}.
)
public lf = (
	^_js verbatim: '"\n"'
)
public space = (
	^" "
)
public tab = (
	^_js verbatim: '"\t"'
)
public withAll: characters = (
	^_js call: (_js propertyOf: characters asArray at: (_js literal: 'join')) with: {_js literal: ''}
)
public crlf = (
	^_js verbatim: '"\r\n"'
)
public newline ^ <Instance> = (
  ^_js verbatim: '"\n"'
)
public with: byte <Integer> ^<String> = (
(* :TODO eradicate? *)
	^fromRune: byte
)
)
public class StringBuilder = (|
protected parts = platform collections List new.
protected sizeX ::= 0.
|) (
public add: string = (
	sizeX:: sizeX + string size.
	^parts add: string
)
public asString = (
	^_js call: (_js propertyOf: parts asArray at: (_js literal: 'join')) with: {_js literal: ''}
)
public isEmpty ^<Boolean> = (
	^0 = sizeX
)
public isKindOfStringBuilder ^<Boolean> = (
	^true
)
public size = (
	^sizeX
)
public writeln: line = (
	self add: line.
	self add: String lf.
)
public asByteArray ^<ByteArray> = (
  | result = ByteArray new: size. |
  #BOGUS yourself.
  #TODO.
  ^result
)
public addByte: byte <Integer>  = (
	sizeX:: sizeX + 1.
	^parts add: (_js call: (_js propertyOf: (_js literal: '') at: (_js literal: '+')) with: {byte})
)
) : (
public new: capacity <Integer> ^<StringBuilder> = (
	^self new
)
)
public class UndefinedObject uninstantiable = () (
public ifNil: nilBlock = (
	^nilBlock value
)
public ifNil: nilBlock ifNotNil: notNilBlock = (
	^nilBlock value
)
public ifNotNil: notNilBlock = (
	^self
)
public isNil = (
	^true
)
public notNil = (
	^false
)
public printString = (
	^'nil'
)
) : (
)
public class ArgumentError value: v = Exception (|
	argument = v.
|) (
public printString = (
	^'ArgumentError: ', argument printString
)
) : (
)
class Activation = (
) (
) : (
)
public class Behavior = (
) (
) : (
)
public class ClassMixin = (
) (
) : (
)
public class Float = (
) (
) : (
)
public class Fraction = (
) (
) : (
)
public class InstanceMixin = (

) (
) : (
)
class Integer = (

) (
) : (
)
public class Proxy = (

) (
) : (
)
public class WeakArray = (
) (
) : (
)
public class WeakMap = (
) (
) : (
)
public Error = (
	(* Squeak compatibility *)
	^Exception
)
public UnhandledError = (
	(* Squeak compatibility *)
	^Exception
)
augment: prototype withPropertiesOf: runtimeClass = (
	| keys = _js call: (_js propertyOf: (_js ident: 'Object') at: (_js literal: 'keys')) with: {runtimeClass}. |
	_js call: (_js propertyOf: keys at: (_js literal: 'forEach')) with: {_js functionOf: {'key'} body: (_js block: {
		(*_js if: (_js operator: '||' with: (_js call: (_js propertyOf: (_js ident: 'key') at: (_js literal: 'startsWith')) with: {_js literal: '$'}) and:
			(_js call: (_js propertyOf: (_js ident: 'key') at: (_js literal: 'startsWith')) with: {_js literal: '_$'})) then: (_js block: {*)
			_js assign: (_js propertyOf: prototype at: (_js ident: 'key'))
				toBe: (_js propertyOf: runtimeClass at: (_js ident: 'key')).
			(*(_js call: (_js propertyOf: (_js ident: 'Object') at: (_js literal: 'defineProperty')) with: {
				prototype.
				(_js ident: 'key').
				_js objectLiteralSlotNames: {_js literal: 'enumerable'} values: {_js literal: false}.
			})
		}).*)
	})}.
)
public augmentPrototypes = (
	_js call: (_js ident: 'installDnuHandlersOn') with: {_js verbatim: 'Object.prototype'}.
	augment: (_js verbatim: 'Array.prototype') withPropertiesOf: (_js propertyOf: Object at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'Array.prototype') withPropertiesOf: (_js propertyOf: Array at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'Boolean.prototype') withPropertiesOf: (_js propertyOf: Object at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'Boolean.prototype') withPropertiesOf: (_js propertyOf: Boolean at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'Function.prototype') withPropertiesOf: (_js propertyOf: Object at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'Function.prototype') withPropertiesOf: (_js propertyOf: Closure at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'Number.prototype') withPropertiesOf: (_js propertyOf: Object at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'Number.prototype') withPropertiesOf: (_js propertyOf: Number at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'String.prototype') withPropertiesOf: (_js propertyOf: Object at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'String.prototype') withPropertiesOf: (_js propertyOf: String at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'Uint8Array.prototype') withPropertiesOf: (_js propertyOf: Object at: (_js literal: 'runtimeClass')).
	augment: (_js verbatim: 'Uint8Array.prototype') withPropertiesOf: (_js propertyOf: ByteArray at: (_js literal: 'runtimeClass')).
)
private classOf: object = (
	(_js prefixOperator: 'typeof ' on: object) == 'string' ifTrue: [^String].
	(_js prefixOperator: 'typeof ' on: object) == 'number' ifTrue: [^Number].
	(_js prefixOperator: 'typeof ' on: object) == 'boolean' ifTrue: [^Boolean].
	(_js prefixOperator: 'typeof ' on: object) == 'function' ifTrue: [^Closure].
	(_js operator: 'instanceof' with: object and: (_js ident: 'Array')) ifTrue: [^Array].
	(_js operator: 'instanceof' with: object and: (_js ident: 'Uint8Array')) ifTrue: [^ByteArray].
	^_js propertyOf: object at: (_js literal: 'newspeakClass')
)
private print: string = (
	_js
		ternaryIf: ((_js prefixOperator: 'typeof ' on: (_js ident: 'console')) == 'undefined')
		then: (_js call: (_js ident: 'print') with: {string})
		else: (_js call: (_js propertyOf: (_js ident: 'console') at: (_js literal: 'log')) with: {string})
)
) : (
)
