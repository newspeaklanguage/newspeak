Newspeak3
'Newspeak'
class NewspeakASTs usingLib: platform = ((* Abstract syntax tree node classes for Newspeak.

Issues:
The abbreviations in class and slot names should be replaced with proper identifiers.
Possibly ASTs for self/super/outer/implicitReceiver should be defined here.
The factory selector should be changed to #usingPlatform:.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2010 Felix Geller and Ryan Macnak
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)| 
        private List = platform collections List. 
|) (
public class AST = (
(* An abstract syntax tree. An AST knows where in the source code the corresponding construct is. The slots start and end are indices into the source code marking that position. *)
|
public start <Integer> ::= 0. (* Note that 0 is out-of-bounds in a Newspeak string. *)
public end <Integer> ::= 0.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^self subclassResponsibility
)
assert: block = (
	self assert: block message: 'Assert failed'
)
public copyPositionFrom: other <AST> = (
	self start: other start.
	self end: other end.
)
public isAST ^<Boolean> = (
	^true
)
) : (
)
public class ASTCopier = ASTTool ((* A visitor that copies an NS2 AST. Subclasses can override selected methods to produce altered copies. *)) (
public binaryTypeOpNode: aNode = (
	^BinaryTypeOpAST new
		leftOperand: (aNode leftOperand apply: self);
		operator: aNode operator;
		rightOperand: (aNode rightOperand apply: self);
		copyPositionFrom: aNode
)
public blockNode: aNode <BlockAST> ^ <BlockAST> = (
	^BlockAST new body: (aNode body apply: self);  
		copyPositionFrom: aNode
)
public blockTypeNode: aNode = (
	^(BlockTypeAST 
		formals: (aNode formals collect: [:f | f apply: self])
		return: (nil = aNode return ifFalse: [aNode return apply: self]))
		copyPositionFrom: aNode
)
public cascadedSendNode: aNode <CascadedSendAST> ^  <CascadedSendAST> = (
	^CascadedSendAST new
		to: (aNode previousSend apply: self) cascade: (aNode message apply: self);
		copyPositionFrom: aNode
)
public characterNode: aNode <CharacterAST> = (
	^CharacterAST new
		value: aNode value;
		copyPositionFrom: aNode
)
public classHeaderNode: node = (
	^ClassHeaderAST new
		name: node name;
		constructor: (node constructor apply: self);
		superclassName: node superclassName;
		superclassCall: node superclassCall;
		superConstructorCall: (node superConstructorCall apply: self);
		slots: (node slots collect: [ :slt | slt apply: self ]);
		isSeq: node isSeq;
		classComment: node classComment;
		category: node category;
		inheritanceChain: (node inheritanceChain collect: [:send | send apply: self]);
		initExprs: (node initExprs collect: [ :ie | ie apply: self ])
)
public classNode: aNode = (
	^ClassDeclarationAST new
		header: (aNode header apply: self);
		instanceSide: (aNode instanceSide apply: self);
		classSide: (aNode classSide apply: self);
		copyPositionFrom: aNode
)
public classPrefix: node <ClassPrefixNode> = (
	^ClassPrefixAST
		name: (node name apply: self) 
		constructor: (node constructor apply: self) 
		superclassName: (node superclassName apply: self)  
		superclassCall: (node superclassCall apply: self)      
		superConstructorCall: (node superConstructorCall apply: self) 		
)
public codeBodyNode: node = (
 	^CodeBodyAST new
		parameters: (node parameters collect: [:parameter | parameter apply: self])
		temporaries: (node temporaries collect: [:temporary | temporary apply: self])
		statements: (node statements collect: [:statement | statement apply: self]);
		isSeq: node isSeq;
		copyPositionFrom: node
)
public genericInvocationNode: aNode = (
	^ParameterizedTypeAST new
		generic: (aNode generic apply: self);
		arguments: (aNode arguments collect: [:a | a apply: self]);
		copyPositionFrom: aNode
)
public messageNode: aNode  <MessageAST> ^  <MessageAST> = (
	^MessageAST new
		send: aNode selector with: (aNode arguments collect: [:a | a apply: self]);
		copyPositionFrom: aNode
)
public messagePatternNode: aNode  <MessagePatternAST> ^ <MessagePatternAST> = (
	^MessagePatternAST new
		selector: aNode selector
		parameters: (aNode parameters collect: [:p | p apply: self])
		returnType: (nil = aNode returnType ifFalse: [aNode returnType apply: self])
		typePattern: (nil = aNode typePattern ifFalse: [aNode typePattern apply: self]);
		copyPositionFrom: aNode
)
public methodNode: aNode  <MethodAST> = (
	^MethodAST new
		pattern: (aNode pattern apply: self)
		body: (aNode body apply: self)
		accessModifier: aNode accessModifier;
		copyPositionFrom: aNode
)
public mixinApplication: node <MixinApplicationAST> = (
	^MixinApplicationAST new
		mixinExpr: (node mixinExpr apply: self);
		superclassExpr: (node superclassExpr apply: self);
		classPrefix: (nil = node classPrefix ifFalse: [node classPrefix apply: self]); 
		(*check for nil prefix during transition *)
		copyPositionFrom: node
)
public mixinApplicationClass: node <MixinApplicationClassAST> = (
	^(MixinApplicationClassAST 
		named: node name 
		factoryMsg: (node constructor apply: self) 
		inheriting: (node inheritanceChain collect: [:ic | ic apply: self]))
		copyPositionFrom: node
)
public numberNode: aNode = (
 	^NumberAST new
		value: aNode value;
		copyPositionFrom: aNode
)
public returnStatNode: aNode <ReturnStatAST> ^ <ReturnStatAST> = (
	^ReturnStatAST new
		expression: (aNode expression apply: self); 
		copyPositionFrom: aNode
)
public setterSendNode: aNode <SetterSendAST> ^ <SetterSendAST> = (
	^(SetterSendAST
		to: (aNode receiver apply: self) send: (aNode message apply: self)
		start: aNode start end: aNode end)
)
public sideNode: aNode <SideAST> ^ <SideAST> = (
 	^SideAST new 
		nestedClasses: (aNode nestedClasses collect: [:nc | nc apply: self]);
            methods: (aNode methods collect: [:m | m apply: self]);
		copyPositionFrom: aNode
)
public slotDefNode: aNode = (
	| slotDefClass |
	slotDefClass:: aNode isMutable 
						ifTrue: [ MutableSlotDefAST ] 
						ifFalse: [ ImmutableSlotDefAST ].
	^slotDefClass new
		slotDecl: (aNode slotDecl apply: self);
		initializer: (nil = aNode initializer ifFalse: [aNode initializer apply: self]);
		copyPositionFrom: aNode
)
public stringNode: aNode <StringAST> ^ <StringAST> = (
	^StringAST new
		value: aNode value;
		copyPositionFrom: aNode
)
public symbolNode: aNode = (
	^SymbolAST new
		value: aNode value;
		copyPositionFrom: aNode
)
public tupleNode: aNode <TupleAST> ^  <TupleAST> = (
	^TupleAST new
		elements: (aNode elements collect: [:e | e apply: self]); 
		copyPositionFrom: aNode
)
public typeIdNode: aNode = (
	^TypeIdAST new
		name: aNode name; 
		copyPositionFrom: aNode
)
public typePatternNode: aNode = (
	^TypePatternAST new
		formals: (aNode formals collect: [:f | f apply: self]); 
		copyPositionFrom: aNode
)
public unaryTypeOpNode: aNode = (
	^UnaryTypeOpAST new
		operand: (aNode operand apply: self);
		operator: aNode operator;
		copyPositionFrom: aNode
)
public unresolvedSendNode: aNode <UnresolvedSendAST> ^ <UnresolvedSendAST> = (
	^UnresolvedSendAST new
		to: (aNode receiver apply: self) send: (aNode message apply: self); 
		copyPositionFrom: aNode
)
public varDeclNode: aNode<VarDeclAST> ^ <VarDeclAST> = (
	^VarDeclAST
		name: aNode name
		type: (nil = aNode type ifFalse: [aNode type apply: self])
)
public variableNode: aNode <VariableAST> ^ <VariableAST> = (
	^VariableAST new
		name: aNode name;
		copyPositionFrom: aNode          
)
) : (
)
public class ASTTool = () (
public blockNode: aNode <BlockAST> = (
	self subclassResponsibility
)
public cascadedSendNode: aNode <CascadedSendAST> = (
	self subclassResponsibility
)
public characterNode: aNode <CharacterAST> = (
	self subclassResponsibility
)
public classNode: aNode <ClassAST> = (
	self subclassResponsibility
)
public codeBodyNode: aNode <CodeBodyAST> = (
	self subclassResponsibility
)
public messageNode: aNode <MessageAST> = (
	self subclassResponsibility
)
public messagePatternNode: aNode <MessagePatternAST> = (
	self subclassResponsibility
)
public methodNode: aNode <MethodAST> = (
	self subclassResponsibility
)
public mixinApplication: node <MixinApplicationAST> = (
	self subclassResponsibility
)
public mixinApplicationClass: node <MixinApplicationClassAST> = (
	self subclassResponsibility
)
public numberNode: aNode <NumberAST> = (
	self subclassResponsibility
)
public returnStatNode: aNode <ReturnStatAST> = (
	self subclassResponsibility
)
public setterSendNode: aNode <SetterSendAST> = (
	self subclassResponsibility
)
public sideNode: aNode <SideAST> = (
	self subclassResponsibility
)
public stringNode: aNode <StringAST> = (
	self subclassResponsibility
)
public symbolNode: aNode <SymbolAST> = (
	self subclassResponsibility
)
public tupleNode: aNode <TupleAST> = (
	self subclassResponsibility
)
public unresolvedSendNode: aNode <UnresolvedSendAST> = (
	self subclassResponsibility
)
public varDeclNode: aNode <VarDeclAST> = (
	self subclassResponsibility
)
public variableNode: aNode <VariableAST> = (
	(* can only be a pseudo variable : self or _here *)
	self subclassResponsibility
)
) : (
)
public class ASTTraverser = ASTTool () (
public blockNode: node <BlockAST> = (
	node body apply: self
)
public cascadedSendNode: node <CascadedSendAST> = (
	node previousSend apply: self.
	node message apply: self.
)
public characterNode: node <CharacterAST> = (
	(* Leaf *)
)
public messageNode: node <MessageAST> = (
	node arguments do: [:each | each apply: self].
)
public mixinClassNode: node <MixinClassNode> = (
	(* Leaf? *)
)
public numberNode: node <NumberAST> = (
	(* Leaf *)
)
public returnStatNode: node <ReturnStatAST> = (
	node expression apply: self.
)
public setterSendNode: node <SetterSendAST> = (
	node receiver apply: self.
	node message apply: self.
)
public stringNode: node <StringAST> = (
	(* Leaf *)
)
public symbolNode: node <SymbolAST> = (
	(* Leaf *)
)
public tupleNode: node <TupleAST> = (
	node elements do: [:each | each apply: self]
)
public unresolvedSendNode: node <UnresolvedSendAST> = (
	node receiver apply: self.
	node message apply: self.
)
public variablePatternNode: node <VariablePatternAST> = (
	#BOGUS yourself.
	(* Leaf? *)
)
) : (
)
public class BinaryTypeOpAST = AST (|
	public leftOperand <TypeAST>
	public rightOperand <TypeAST>
	public operator <Symbol>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool binaryTypeOpNode: self
)
) : (
)
public class BlockAST = AST (|
	public body <CodeBodyAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool blockNode: self
)
public isBlockNode = ( ^true)
public parameters ^ <List[ParameterAST]> = (
	^body parameters
)
) : (
)
public class BlockTypeAST formals: f return: r = AST (|
	public formals = f.
	public return = r.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool blockTypeNode: self
)
public isTypeNode ^<Boolean> = (
	^true
)
) : (
)
public class CascadedSendAST = SendAST (|
	public previousSend <SendAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool cascadedSendNode: self
)
public end = (
	(* Currently the parser doesn't set start or end positions for
	cascades, so compute from the receiver's elements.  But
	if the parser ever does set the position, take it directly. *)
	^super end = 0
		ifFalse: [super end]
		ifTrue: [message end]
)
public isCascadedSendNode = (^true)
public receiver ^ <ExpressionAST> = (
	^self previousSend receiver
)
public start = (
	(* Currently the parser doesn't set start or end positions for
	cascades, so compute from the receiver's elements.  But
	if the parser ever does set the position, take it directly. *)
	^super start = 0
		ifFalse: [super start]
		ifTrue: [previousSend start]
)
public to: aSend <SendAST> cascade: aMessage <MessageAST>  = (
  self assert:[aSend isSendNode].
  self assert:[aMessage isMessageNode].
  self previousSend: aSend; message: aMessage
)
) : (
)
public class CharacterAST = LiteralAST () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool characterNode: self
)
public isCharacterNode = (^true)
) : (
)
public class ClassBodyAST initializer: init <InitializerAST> instanceSide: iSide <SideAST> classSide: cSide <SideAST> = AST (
(* AST for a class body. *)|
	public instanceInitializer <InitializerAST> = init.
	public instanceSide <SideAST> = iSide.
	public classSide <SideAST> = cSide.
|start:: instanceInitializer start.
end:: classSide end max: instanceSide end) (
) : (
)
public class ClassDeclarationAST = AST (|
	public header <ClassHeaderAST>
	public instanceSide <SideAST>
	public classSide <SideAST>
|) (
public accessModifier ^<Symbol> = (
	^header accessModifier
)
public apply: tool <ASTTool[T]> ^<T> = (
	^tool classNode: self
)
public category ^ <CategoryAST> = (
	^header category
)
public category: cat  <CategoryAST> = (
	header category: cat
)
public classComment ^ <String> = (
	^header classComment
)
public isClassDeclarationNode ^<Boolean> = (
	^true
)
public name ^ <Symbol> = (
	^header name
)
public selector ^<Symbol> = (
	^header name
)
public superclassName ^ <Symbol> = (
	^header superclassName
)
) : (
public makeMixinNamed: klassName <Token> factoryMsg: cons <MessagePatternAST> inheriting: iList <List[SendAST]> body: body <ClassBodyAST> 
	^ <ClassDeclarationAST> = (
(* adaptor factory method for transition. Using this method, we can create an AST compatible with the unmodified compiler based on the revised parser. *)
	| 
	superCall <SendAST> = iList first. 
	instanceInitializer <InitializerAST> = body instanceInitializer.
	header = ClassHeaderAST new 
				name: klassName value asSymbol; 
				constructor: cons;
				superclassName: superCall receiver message selector;
				superclassCall: superCall receiver;
				superConstructorCall: superCall message;
				slots: instanceInitializer slots; 
				isSeq: instanceInitializer isSeq; 
				initExprs: instanceInitializer initializationExpressions; 
				inheritanceChain: iList;
				classComment: body instanceInitializer classComment;
				start: klassName start; end: instanceInitializer end.
	|
	^new 
		header: header;
		instanceSide: body instanceSide;
		classSide: body classSide
)
public named: klassName <Token> factoryMsg: cons <MessagePatternAST> inheriting: iList <List[SendAST]> body: body <ClassBodyAST> 
	^ <ClassDeclarationAST> = (
	^body isNil
		ifTrue:[MixinApplicationClassAST named: klassName value factoryMsg: cons inheriting: iList]
		ifFalse:[makeMixinNamed: klassName factoryMsg: cons inheriting: iList body: body]
)
)
public class ClassHeaderAST = AST (|
	public accessModifier
	public name <Symbol>
	public constructor <MessagePatternAST>
	public superclassName <Symbol>
	public superclassCall <NormalSendAST>
	public superConstructorCall <MessageAST>
	public slots <List[SlotDefAST]>
	public isSeq <Boolean>
	public classComment <String>
	public category <CategoryAST>
	public initExprs <List[ExpressionAST]>
	public inheritanceChain <List[SendAST]>
 |) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool classHeaderNode: self
)
public superCall ^ <SendAST> = (
	^inheritanceChain first
)
) : (
)
public class ClassPrefixAST name: n 
	constructor: k
	superclassName: sn 
	superclassCall: scc 					                         	
	superConstructorCall: sk = AST ((* A class prefix defines everything about a class except for its mixin. 
It is intended to serve as a common component between ordinary class declarations and mixin applications.

For Squeak compatibility, we maintain a category as well (ugh).
*)|
	public name <Symbol> = n.
	public constructor <MessagePatternAST> = k.
	public superclassName <Symbol> = sn.
	public superclassCall <NormalSendAST> = scc.
	public superConstructorCall <MessageAST> = sk.
	public category <CategoryAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool classPrefix: self
)
) : (
)
public class CodeBodyAST = AST (|
	public parameters <List[ParameterAST]>
	public temporaries <List[TemporaryAST]>
	public statements <List[StatementAST]>
	public isSeq <Boolean> ::=true.
	public literalMessages <List[MessageAST]>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool codeBodyNode: self
)
public isCodeBodyNode = (^true)
public parameters: pars <List[ParameterAST]> temporaries: temps <List[TemporaryAST]> statements: stats <List[StatementAST]> = ( 
	self parameters: pars; temporaries: temps; statements: stats
)
public temporaries: temps <List[TemporaryAST]> statements: stats <List[StatementAST]> = (
	self parameters: List new; temporaries: temps; statements: stats
)
) : (
)
public class ImmutableSlotDefAST = SlotDefAST () (
public isMutable ^<Boolean> = (
	^false
)
) : (
)
public class InitializerAST slots: s initializerExpressions: es comment: c slotsAreSequential: seq = AST (
(* AST for an instance initializer clause. *)|
	public slots = s.
	public initializationExpressions <List[ExpressionAST]> = es.
	public classComment = c.
	public isSeq <Boolean> = seq.
|) (
) : (
)
public class KeywordPatternAST = PatternAST (|
	public keywords <TupleAST>
	public patterns <TupleAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool keywordPatternNode: self
)
public isKeywordPatternNode = (
	^ true
)
) : (
)
public class KeywordPatternPairAST = AST (|
	keyword <Symbol>
	pattern
|) (
public isKeywordPatternPairNode = (
	^ true
)
) : (
)
public class LiteralAST = AST (|
	public value <Object>
|) (
public isLiteralNode = (^true)
public printOn: stream = (
	stream nextPutAll: class simpleName.
	stream nextPutAll: ': '.
	value printOn: stream.
)
) : (
)
public class LiteralPatternAST = PatternAST (|
	public literal <LiteralAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool literalPatternNode: self
)
public isLiteralPatternNode = (
	^ true
)
) : (
)
public class MessageAST = AST (| 
	public selector <Symbol>
	public arguments <List[ExpressionAST]>
	public isEventual <Boolean> ::= false.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool messageNode: self
)
public isMessageNode = (^true)
public send: sel <Symbol> with: args <List[ExpressionAST]> = (
    self selector: sel; arguments: args
)
) : (
)
public class MessagePatternAST = AST (
| 
      public accessModifier <Symbol>
	public selector <Symbol>
	public parameters <List[ParameterAST]>
	public returnType <TypeAST>
	public typePattern <TypePatternAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool messagePatternNode: self
)
public isMessagePatternNode = (^true)
public selector: s <Symbol> parameters: p <List[ParameterAST]> = (
  self selector: s; parameters: p
)
public selector: s <Symbol> parameters: p <List[ParameterAST]> returnType: t <TypeAST> = (
  self selector: s; parameters: p; returnType: t
)
public selector: s <Symbol> parameters: p <List[ParameterAST]> returnType: t  <TypeAST> typePattern: tp <TypePatternAST> = (
  self selector: s; parameters: p; returnType: t; typePattern: tp
)
public selector: s <Symbol> returnType: t <TypeAST> = (
  self selector: s; returnType: t
)
) : (
)
public class MethodAST = AST (| 
	public pattern <MessagePatternAST>
	public body <CodeBodyAST>
|) (
public accessModifier ^ <Symbol>  = (
	^pattern accessModifier
)
public accessModifier: am <Symbol>  = (
	pattern accessModifier: am
)
public apply: tool <ASTTool[T]> ^<T> = (
	^tool methodNode: self
)
public isMethodNode = (^true)
public pattern: p <MessagePatternAST> body: b <CodeBodyAST> accessModifier: am <Symbol> = (
	pattern: p.
	body: b.
	accessModifier: am.
)
public printOn: stream = (
	stream nextPutAll: 'MethodAST: '.
	stream nextPutAll: selector
)
public selector ^<Symbol> = (
	^pattern selector
)
) : (
)
public class MixinApplicationAST = AST ((* Represents a literal mixin application. *)| 
	public mixinExpression <NormalSendAST> 
	public superclassExpression <NormalSendAST> (* should eventually go away *)
	public classPrefix <ClassPrefixAST>
 |) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool mixinApplication: self
)
) : (
public prefix: cp mixin: me = (
(* ultimately should be a primary factory *)
	^new classPrefix: cp; mixinExpr: me; superclassExpr: cp superclassCall; yourself
)
)
public class MixinApplicationClassAST named: klassName factoryMsg: cons inheriting: iList = AST (
(* This class represents a class defined via a mixin application - that is, a class that does not provide a class body. *)|
	public accessModifier <Symbol>
	public name <Symbol> = klassName asSymbol.
	public constructor <MessagePatternAST> = cons.
	public inheritanceChain <List[SendAST]> = iList.
	public category  <CategoryAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool mixinApplicationClass: self
)
public isMixinApplicationClassAST = (
	^true
)
) : (
)
public class MutableSlotDefAST = SlotDefAST () (
public isMutable ^ <Boolean> = (^true)
) : (
)
public class NumberAST = LiteralAST () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool numberNode: self
)
public isNumberNode = (^true)
) : (
)
public class ParameterizedTypeAST = AST (|
	public generic <TypeIdAST>
	public arguments <List[TypeAST]>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool genericInvocationNode: self
)
public isTypeNode = (
	^ true
)
) : (
)
public class PatternAST = LiteralAST (|
|) (
public isPatternNode = (
	^ true
)
) : (
)
public class ReturnStatAST = AST (|
	public expression <ExpressionAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool returnStatNode: self
)
public isReturnStatNode = (^true)
) : (
)
public class SendAST send: aMsg = AST (|
	public message <MessageAST> ::= aMsg.
|) (
public isSendNode = (^true)
public receiver = (
	^self subclassResponsibility
)
) : (
)
public class SetterSendAST to: r <ExpressionAST> send: m <MessageAST> start: s <integer> end: e <Integer> = SendAST send: m (|
	public receiver <ExpressionAST> ::= r.
|
	start: s.
	end: e.
) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool setterSendNode: self
)
public isSetterSendNode = (^true)
public printOn: stream = (
	stream nextPutAll: 'SetterSendAST: '.
	stream nextPutAll: message selector.
)
) : (
)
public class SideAST = AST ((* An AST for one side of a class *)|
	public nestedClasses <Collection[ClassDeclarationAST]>
	public methods <Collection[MethodAST]>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool sideNode: self
)
public isSideNode = (
	^true
)
) : (
)
public class SlotDefAST = AST (| 
	public slotDecl <VariableAST>
	public initializer <ExpressionAST>
	public accessModifier
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool slotDefNode: self
)
public isMutable ^ <Boolean> = (self subclassResponsibility)
public isSlotDefNode = ( ^ true )
public name ^ <Symbol> = (
	^slotDecl name
)
public type ^ <TypeAST> = (
	^slotDecl type
)
) : (
)
public class StringAST = LiteralAST () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool stringNode: self
)
public isStringNode = (^true)
) : (
)
public class SymbolAST = LiteralAST () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool symbolNode: self
)
public isSymbolNode = (^true)
) : (
)
public class TupleAST = AST (| 
	public elements <List[ExpressionAST]>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool tupleNode: self
)
public isArrayNode = (^false)
public isTupleNode = ( ^ true)
) : (
)
public class TypeIdAST = AST (|
	public name <Symbol>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool typeIdNode: self
)
public isTypeNode ^ <Boolean> = (
	^ true
)
) : (
)
public class UnaryTypeOpAST = AST (| public operand <TypeAST> public operator <Symbol>  |) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool unaryTypeOpNode: self
)
) : (
)
public class UnresolvedSendAST = SendAST (|
	public receiver <ExpressionAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool unresolvedSendNode: self
)
public isUnresolvedSendNode = (
	^true
)
public printOn: stream = (
	stream nextPutAll: 'NormalSendAST: '.
	stream nextPutAll: message selector.
)
public to: anExpression <ExpressionAST> send: aMessage <MessageAST> = (
	self receiver: anExpression; message: aMessage
)
public to: anExpression <ExpressionAST> send: selector with: arguments = (
	to: anExpression send: (MessageAST new send: selector with: arguments)
)
) : (
)
public class VarDeclAST name: aName type: aType = AST (| 
	public name  <Symbol> = aName.
	public type <TypeAST> = aType.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool varDeclNode: self
)
) : (
)
public class VariableAST = AST (| 
	public name <Symbol>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool variableNode: self.
)
public isVariableNode = (^true)
public printOn: stream = (
	stream nextPutAll: class simpleName.
	stream nextPutAll: ': '.
	stream nextPutAll: name.
)
) : (
)
public class VariablePatternAST = PatternAST (|
	variableName <Symbol>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool variablePatternNode: self
)
public isVariablePatternNode = (
	^ true
)
) : (
public variableName: vn start: s end: e = (
	^self new variableName: vn; start: s; end: e; yourself
)
)
public class WildcardPatternAST = PatternAST (|
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool wildcardPatternNode: self
)
public isWildcardPatternNode = (
	^ true
)
) : (
public start: s end: e = (
	^self new start: s; end: e; yourself
)
)
) : (
)
