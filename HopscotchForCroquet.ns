Newspeak3
'Root'
class HopscotchForCroquet usingPlatform: p <Platform> hopscotch: H <HopscotchForHTML5 class> = (
	|
(* imports *)
    private HopscotchForHTML5 = H.
    private Promise = p actors Promise.
    private Resolver = p actors Resolver.
    private List  = p collections List.
    private Map = p collections Map.
	|
) (
public class Hopscotch usingPlatform: p <Platform> images: images ducts: ds =
  HopscotchForHTML5 usingPlatform: p images: images ducts: ds

(
(*
This class overrides the normal Hopscotch UI module to allow the UI to synchronize using croquet.io.
For every interactive fragment class, we maintain:

1) A subclass, defined here, that manages the interaction with Croquet.
2) A counter that is used to generate unique ids for each fragment.
3) A corresponding Javascript Croquet model type, each instance of which has, as its associated view, an instance of the JS class NewspeakCroquetFragmentView.

Each fragment is then connected to an instance of NewspeakCroquetFragmentView. The fragment notifies this view when an interaction occurs. The croquet view notifies the croquet model, which notifies the reflector; when the reflector has signaled the croquet model, it notifies the croquet view; the view then executes a call back in which the fragment performs the normal behavior defined in its superclass.

When completed, the goal is:

A series of croquet clients running a Newspeak application can be synchronized, without any modification to the Newspeak application code; the only requirement is that application be deployed using a platform object that uses an instance of this class as its GUI.

To reach that goal, we have to implement all interactive Hopscotch fragments here, and we have to deal with the problem of saving a model of the application as a whole to the Croquet root model; presumably by adding an image mechanism to Newspeak.

Ultimately, we hope to go beyond the above, and be able to diff the saved model state and extend this to full local-first solution.
*)
  |
  buttonCount <Integer> ::= 0.
  imageButtonCount <Integer> ::= 0.  
  radioButtonCount <Integer> ::= 0. 
  checkboxCount <Integer> ::= 0.
  hyperlinkCount <Integer> ::= 0.
  hyperlinkImageCount <Integer> ::= 0.
  codeMirrorCount <Integer> ::= 0.
  toggleComposerCount <Integer> ::= 0.
  textEditorCount <Integer> ::= 0.
  pickerCount <Integer> ::= 0.
  colorPickerCount <Integer> ::= 0.
  datePickerCount <Integer> ::= 0.  
  timePickerCount <Integer> ::= 0.
  sliderCount <Integer> ::= 0.
  searchFieldCount <Integer> ::= 0.
  dropDownMenuCount <Integer> ::= 0.  
  menuCount <Integer> ::= 0.  
  js = p js.   
|
) (
class ButtonFragment label: l action: a = super ButtonFragment label: l action: a (
    |
    buttonId <Integer> ::= newButtonId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <ButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[croquetView <-: publish: scope event: #click]
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsbutton_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | super action value. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createButton handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_button' eventSpec: #createButton data: scope.
  ^futureView promise
)
) : (
)
class ImageButtonFragment = super ImageButtonFragment (
    |
    imageButtonId <Integer> ::= newImageButtonId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsImagebutton_', imageButtonId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ImageButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[croquetView <-: publish: scope event: #click]
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | super action value. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createImageButton handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_image_button' eventSpec: #createImageButton data: scope.
  ^futureView promise
)
) : (
)
class CheckboxFragment text: t <Holder> value: v <Boolean | Holder> action: a <[:Boolean]>  = super CheckboxFragment text: t value: v action: a (
    |
    checkboxId <Integer> ::= newCheckboxId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscheckbox_', checkboxId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <CheckboxFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createCheckbox handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_checkbox' eventSpec: #createCheckbox data: scope.
  ^futureView promise
)
writeInput: v = (
     checkbox at: 'checked' put: v.
     super writeInput: v.
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_checked handler: [:e |  'checkbox checked event = ' out. writeInput: true. nil].
        croquetView <-: subscribe: scope eventSpec: #model_unchecked handler: [:e |  'checkbox unchecked event = ' out. writeInput: false. nil]
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:b <Boolean> | croquetView <-: publish: scope event: ((checkbox at: 'checked') ifTrue: [#checked] ifFalse: [#unchecked]). nil]
)
) : (
)
class RadioButtonFragment text: t <String> 
	value: v <Boolean | Holder> 
	group: g <String> 
	action: a <[:Boolean]> = super RadioButtonFragment text: t value: v group: g action: a (
    |
    radioButtonId <Integer> ::= newRadioButtonId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsradiobutton_', radioButtonId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <RadioButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createRadioButton handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_radio_button' eventSpec: #createRadioButton data: scope.
  ^futureView promise
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_pressed handler: [:e |  'radio button pressed event = ' out. printJSObjectTree: e. writeInput: true. nil].
  croquetView <-: subscribe: scope eventSpec: #model_released handler: [:e |  'radio button released event = ' out. printJSObjectTree: e. writeInput: false. nil]        
)
writeInput: v = (
     button at: 'checked' put: v.
     super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:b <Boolean> | croquetView <-: publish: scope event: ((button at: 'checked') ifTrue: [#pressed] ifFalse: [#released]). nil]
)
) : (
)
class HyperlinkFragment label: l action: a = super HyperlinkFragment label: l action: a (
   |
    hyperlinkId <Integer> ::= newHyperlinkId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <HyperlinkFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[croquetView <-: publish: scope event: #click]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlink_', hyperlinkId printString].
  ^scope_slot
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | super action value. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createHyperlink handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_hyperlink' eventSpec: #createHyperlink data: scope.
  ^futureView promise
)
) : (
)
public class CodeMirrorFragment onText: t <String> = super CodeMirrorFragment onText: t (
    |
    codeMirrorId <Integer> ::= newCodeMirrorId.
    scope_slot <String>
    reflecting <Boolean> ::= true.
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscodemirror_', codeMirrorId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <CodeMirrorFragment>  ^ <Alien[Element]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createCodeMirror handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_code_mirror' eventSpec: #createCodeMirror data: scope.
  ^futureView promise
)
respondToAccept: event <Alien[Event]> = (
   croquetView <-: publish: scope event: #accept data: textBeingAccepted
)
respondToCancel = (
  croquetView <-: publish: scope event: #cancel
)
respondToBeforeChange: event <Alien[Event]> = (
 'code mirror respond before change event = ' out. 
  croquetView <-: publish: scope event: #beforeChange data: textBeingAccepted
)
respondToChange: event <Alien[Event]> = (
 'code mirror respond change event = ' out.
  croquetView <-: publish: scope event: #change data: textBeingAccepted
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_change handler: [:e | 'code mirror change event = ' out.  text: e. super respondToChange: e. nil].
        croquetView <-: subscribe: scope eventSpec: #model_beforeChange handler: [:e | 'code mirror before change event = ' out.  super respondToBeforeChange: e. nil].   
        croquetView <-: subscribe: scope eventSpec: #model_keydown handler: [:e | 'code mirror keydown event = ' out.  reflecting:: false. super respondToKeyDown: e. nil].
        croquetView <-: subscribe: scope eventSpec: #model_accept handler: [:e | 'code mirror accept event = ' out.  reflecting:: false. super respondToAccept: e. nil].
        croquetView <-: subscribe: scope eventSpec: #model_cancel handler: [:e | 'code mirror cancle event = ' out.  reflecting:: false. super respondToCancel. nil].        
)
respondToKeyDown: event <Alien[Event]> = (
	| 
    e = replaceUndefined: event.
	key <Character> = e at: 'key'. 
    (* customary on mac, does not work on windows *)
	metaPressed <Boolean> = e at: 'metaKey'.
    (* works on windows *)
    ctrlPressed <Boolean> = e at: 'ctrlKey'.   
    shiftPressed <Boolean> = e at: 'shiftKey'.
	|
    ('key = ', key printString) out. 
    ('metaPressed = ', metaPressed printString) out.
    ('ctrlPressed = ', ctrlPressed printString) out.
    ('shiftPressed = ', shiftPressed printString) out.
   'code mirror respond keydown event = ' out.
   croquetView <-: publish: scope eventSpec: #keydown data: (replaceUndefined: event)
)
) : (
)
class HyperlinkImageFragment image: i action: a = super HyperlinkImageFragment (|
    hyperlinkImageId <Integer> ::= newHyperlinkImageId.
    scope_slot <String>
    |
    croquetView
) (
action = (
  ^[croquetView <-: publish: scope event: #click]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlinkImage_', hyperlinkImageId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <HyperlinkImageFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | super action value. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createHyperlinkImage handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_hyperlink_image' eventSpec: #createHyperlinkImage data: scope.
  ^futureView promise
)
) : (
)
class ToggleComposer collapsedDefinition: collapsed <[Fragment]>
    expandedDefinition: expanded <[Fragment]>
    initiallyExpanded: flag <Boolean> = super ToggleComposer collapsedDefinition: collapsed 
    expandedDefinition: expanded 
    initiallyExpanded: flag (
    |
    toggleComposerId <Integer> ::= newToggleComposerId.
    scope_slot <String>
    |
    croquetView
) (
public toggle = (
  ^[croquetView <-: publish: scope event: #toggle]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nstogglecomposer_', toggleComposerId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ToggleComposer>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
        croquetView_slot:: getCroquetView.
        croquetView <-: subscribe: scope eventSpec: #model_toggle handler: [:e | super toggle. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createToggleComposer handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_toggle_composer' eventSpec: #createToggleComposer data: scope.
  ^futureView promise
)
) : (
)
public class TextEditorFragment = super TextEditorFragment (
    |
    textEditorId <Integer> ::= newTextEditorId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <TextEditorFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createTextEditor handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_text_editor' eventSpec: #createTextEditor data: scope.
  ^futureView promise
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstexteditor_', textEditorId printString].
  ^scope_slot
)
respondToCancel: event <Alien[Event]> = (
  'responding to cancel' out.
  croquetView <-: publish: scope event: #cancel data: (textEditor at: 'textContent')
)
respondToAccept: event <Alien[Event]> = (
  'responding to accept' out.
  croquetView <-: publish: scope event: #accept data: (textEditor at: 'textContent')
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        (* how to get event data? *)
        croquetView <-: subscribe: scope eventSpec: #model_accept handler: [:e | textEditor at: 'textContent' put: e. super respondToAccept: e. nil].
        croquetView <-: subscribe: scope eventSpec: #model_change handler: [:e | textEditor at: 'textContent' put: e. super respondToChange: e. nil].
        croquetView <-: subscribe: scope eventSpec: #model_cancel handler: [:e | super respondToCancel: e. nil].        
)
respondToChange: event <Alien[Event]> = (
  croquetView <-: publish: scope event: #change data: (textEditor at: 'textContent')
)
) : (
)
class PickerFragment text: t <String> items: i <List[String]> action: a <[:String]> = super PickerFragment text: t items: i action: a (
    |
    buttonId <Integer> ::= newPickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <PickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nspicker_', buttonId printString].
  ^scope_slot
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createPicker handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_picker' eventSpec: #createPicker data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #input data: extractInput. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)   
   super writeInput: v.
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will write the input *)
        croquetView <-: subscribe: scope eventSpec: #model_input handler: [:e | writeInput: e. nil]
)
) : (
)
class ColorPickerFragment value: v <String | Holder> action: a <[:String]> = super ColorPickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newColorPickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <ColorPickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nscolorpicker_', buttonId printString].
  ^scope_slot
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createColorPicker handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_color_picker' eventSpec: #createColorPicker data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #pick data: extractInput. nil]
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will write the input *)
        croquetView <-: subscribe: scope eventSpec: #model_pick handler: [:e | writeInput: e. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
) : (
)
class DatePickerFragment value: v <String | Holder> action: a <[:String]> = super DatePickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newDatePickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <DatePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsdatepicker_', buttonId printString].
  ^scope_slot
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createDatePicker handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_date_picker' eventSpec: #createDatePicker data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #input data: extractInput. nil]
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will write the input *)
        croquetView <-: subscribe: scope eventSpec: #model_input handler: [:e | writeInput: e. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
) : (
)
class TimePickerFragment value: v <String | Holder> action: a <[:String]> = super TimePickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newTimePickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <TimePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstimepicker_', buttonId printString].
  ^scope_slot
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createTimePicker handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_time_picker' eventSpec: #createTimePicker data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #input data: extractInput. nil]
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will write the input *)
        croquetView <-: subscribe: scope eventSpec: #model_input handler: [:e | writeInput: e. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
) : (
)
class SliderFragment value: v <Holder> min: mn <Float> max: mx <Float> = super SliderFragment value: v min: mn max: mx (
    |
    buttonId <Integer> ::= newSliderId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsslider_', buttonId printString].
  ^scope_slot
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createSlider handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_slider' eventSpec: #createSlider data: scope.
  ^futureView promise
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | 'Publishing pick event' out. event printString out. croquetView <-: publish: scope event: #pick data: extractInput. nil]
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_pick handler: [:e |  'slider event = ' out. printJSObjectTree: e. writeInput: e. nil]
)
writeInput: v = (
  visual at: 'value' put: v.
   super writeInput: v.
)
) : (
)
class SearchFieldFragment = super SearchFieldFragment (
    |
    buttonId <Integer> ::= newSearchFieldId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
respondToKeyDown ^ <[:Alien | Boolean]> = (
  ^[:event | croquetView <-: publish: scope event: #keydown data: event]
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nssearchfield_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        croquetView <-: subscribe: scope eventSpec: #model_keydown handler: [:e | super respondToKeyDown. nil]
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createSearchField handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_search_field' eventSpec: #createSearchField data: scope.
  ^futureView promise
)
) : (
)
class DropDownMenuFragment menu: ms image: img <Image> alignment: side <Symbol> = super DropDownMenuFragment menu: ms image: img alignment: side (
    |
    buttonId <Integer> ::= newDropDownMenuId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  croquetView_slot::  oldFragment croquetView_slot.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsdropdownmenu_', buttonId printString].
  ^scope_slot
)
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createDropDownMenu handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_drop_down_menu' eventSpec: #createDropDownMenu data: scope.
  ^futureView promise
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        croquetView_slot:: getCroquetView.
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
  croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e | ('dispatching ', e printString) out. super clickHandler value: e. nil].
)
public clickHandler ^ <[:Alien | Boolean]> = (
  ^[:event | ('click handler ', event printString) out. (event at: 1) printString out. croquetView <-: publish: scope event: #click data: 0. nil]
)
updateContent ^ <Alien[Element]> = (
    | menu <Alien[Div]> = computeContentForMenu: [(Menu supplier: menuSupplier) menuContents] . |
    isActive: true.
	showMenu: menu forShell: shell inVisual: visual.
    ^menu.
)
) : (
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: #right
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> alignment: side <Symbol> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: side
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> image: img <Image> ^ <Instance> = (
   ^menu: ms image: img alignment: #right
)
)
class Fragment = super Fragment (
|
public croquetView_slot <Promise[Alien[NewspeakCroquetFragmentView]]>
|
) (
croquetModel = (
    ^croquetView model.
)
croquetView = (
    croquetView_slot isNil ifTrue: [setupCroquetView].
    ^croquetView_slot
)
setupCroquetView = (
  (* only fragments that actively need croquet support need this *)
  subclassResponsibility
)
) : (
)
class Menu supplier: ms <[{Symbol | {String. []}}]>  = (
	| 
    menuId <Integer> ::= newMenuId.
    public menuContents <List[Symbol | {String. []}]> = List new.
    menuItemMap <Map[String, []]> = Map new.
	|
    buildMenuItemMap: ms.
    croquetView.
) (
lazy scope <String> = 'nsMenu_', menuId printString.
lazy croquetView <Promise[Alien[NewspeakCroquetFragmentView]]> = getCroquetView.
getCroquetView ^ <Promise[Alien[NewspeakCroquetFragmentView]]> = (
  |  (* create a future *) futureView <Resolver> = Resolver new.  resolved ::= false. |
  
  rootView subscribe: scope event: #model_createMenu handler: [:m | 
    resolved ifFalse: [
      resolved:: true.
      futureView fulfill: (NewspeakCroquetFragmentView new: m)
      ]. 
      nil
  ].
  rootView publish: 'newspeak_croquet_menu' eventSpec: #createMenu data: scope.
  ^futureView promise
)
setupCroquetView = (
        croquetView <-: subscribe: scope eventSpec: #model_click handler: [:e <String> | (menuItemMap at: e) value. nil]
)
buildMenuItemMap: ms <[{Symbol | {String. []}}]> ^  <Map[String, []]> = (
   ms value do: [:item <Symbol | {String. []}> |
     item = #separator ifFalse: [
       menuItemMap at: item first put: item last.
       menuContents add: {item first. [croquetView <-: publish: #click scope: scope data: item first]}.
     ]
     ifTrue: [menuContents add: #separator].
   ]
)
) : (
)
lazy rootView <Alien[NewspeakCroquetView]> = js global at: #theView.
lazy private NewspeakCroquetFragmentView <Alien[NewspeakCroquetFragmentView class]> = js global at: #NSCroquetFragmentView.
newButtonId ^ <Integer> = (
  buttonCount::buttonCount + 1.
  ^buttonCount
)
newImageButtonId ^ <Integer> = (
  imageButtonCount:: imageButtonCount + 1.
  ^imageButtonCount
)
newRadioButtonId ^ <Integer> = (
  radioButtonCount:: radioButtonCount + 1.
  ^radioButtonCount
)
newHyperlinkId ^ <Integer> = (
  hyperlinkCount:: hyperlinkCount + 1.
  ^hyperlinkCount
)
newCodeMirrorId ^ <Integer> = (
  codeMirrorCount:: codeMirrorCount + 1.
  ^codeMirrorCount
)
newHyperlinkImageId ^ <Integer> = (
  hyperlinkImageCount:: hyperlinkImageCount + 1.
  ^hyperlinkImageCount
)
newToggleComposerId ^ <Integer> = (
  toggleComposerCount:: toggleComposerCount + 1.
  ^toggleComposerCount
)
newCheckboxId ^ <Integer> = (
  checkboxCount:: checkboxCount + 1.
  ^checkboxCount
)
newTextEditorId ^ <Integer> = (
  textEditorCount:: textEditorCount + 1.
  ^textEditorCount
)
rootModel ^ <Alien[NewspeakCroquetView]> = (
  ^rootView model
)
newPickerId ^ <Integer> = (
  pickerCount:: pickerCount + 1.
  ^pickerCount
)
newSliderId ^ <Integer> = (
  sliderCount:: sliderCount + 1.
  ^sliderCount
)
newColorPickerId ^ <Integer> = (
  colorPickerCount:: colorPickerCount + 1.
  ^colorPickerCount
)
newDatePickerId ^ <Integer> = (
  datePickerCount:: datePickerCount + 1.
  ^datePickerCount
)
newTimePickerId ^ <Integer> = (
  timePickerCount:: timePickerCount + 1.
  ^timePickerCount
)
newSearchFieldId ^ <Integer> = (
  searchFieldCount:: searchFieldCount + 1.
  ^searchFieldCount
)
newDropDownMenuId ^ <Integer> = (
  dropDownMenuCount:: dropDownMenuCount + 1.
  ^dropDownMenuCount
)
public dropDownImage = (
  ^super dropDownImage
)
replaceUndefined: event = (
  ^js global replaceUndefined: event
)
printJSObjectTree: event  = (
  ^js global printJSObjectTree: event
)
newMenuId ^ <Integer> = (
  menuCount::menuCount + 1.
  ^menuCount
)
openMenu: aMenu <Menu> = (	
	showMenu: (computeContentForMenu: [(Menu supplier: [aMenu]) menuContents]) forShell: shell inVisual: visual.
)
computeContentForMenu: menuSupplier <[Menu]> ^ <Alien[Div]> = (
  ^super computeContentForMenu: menuSupplier
)
showMenu: menu <Alien[Div]> 
		forShell: s <HopscotchShell> 
		inVisual: v <Visual> = (
   showMenu: menu forShell: s inVisual: v 
)
) : (
)
) : (
)
