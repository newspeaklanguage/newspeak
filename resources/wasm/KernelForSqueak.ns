Newspeak3
'NS2Squeak'
class KernelForSqueak usingPlatform: p vmMirror: vmm = (
(* N.B.: Although Newspeak classes and mixins are represented by the Behavior and Mixin classes of this module, not all code here is live in the system.  In particular, true, false and nil are not instances of the True, False and UndefinedObject defined here but still instances of the corresponding Squeak classes.

This code was derived in part by converting the Strongtalk Magnitude, Boolean and  UndefinedObject classes to Newspeak. For those classes, the Sun Microsystems copyright and BSD license below applies.

Copyright 2008 Cadence Design Systems, Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0

Copyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
Copyright 2008-2009 David Pennell, Stephen Pair, Gilad Bracha and other contributors.
Copyright 2011 Ryan Macnak

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
 this  list of conditions and the following disclaimer.

* Redistribution in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.

Neither the name of Sun Microsystems or the names of contributors may
be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE. *)
|
	private Map = p squeak Dictionary.
	private WeakSet = p squeak WeakSet.
	private MethodDictionary = p squeak MethodDictionary.
	(* Note we use Squeak's collection classes for serializing/bootstrapping purposes. *)
	private Smalltalk = p squeak Smalltalk.
	private Time = p squeak Time.

	private vmmirror = vmm.

	private ImplementationBase = p squeak ImplementationBase.
	private ArraySlot = Array.
	private ByteArraySlot = ByteArray.
	private CharacterSlot = Character.
	private ErrorSlot = Error.
	private FloatSlot = Float.
	private IntegerSlot = Integer.
	private ObjectSlot = Object.
	private StringSlot = String.
	private SymbolSlot = Symbol.

	public newspeakLanguage3 = NewspeakLanguage3 new.
|) (
class AbstractMixin = (
(* A mixin is the difference between a class and its superclass: a set of additional methods, slots and nested class declarations.  Newspeak class declarations implicitly define instance-side and class-side pairs of mixins, and Newspeak classes (other than Top) are all mixin applications.

Most of the methods of this class are to allow mixins to behave like Smalltalk classes when we must deal with Squeak, since Newspeak classes do reside in Squeak's system dictionary, mostly source control (the changes file) and IDE utilities like senders/implementors. These methods are not part of a mature Newspeak system.

In principle, slots common to both instance- and class-side mixins should be defined here. However, for historic reasons the offsets at which the VM expects these slots are not at the beginning of the object, so they are duplicated in InstanceMixin and ClassMixin. *)
) (
public allSubclassesDo: blk = (
	self warnObsolete.
	(* IDE crap *)
)
public allSuperclasses = (
	self warnObsolete.
	^{}
)
public canUnderstand: sel = (
	^self methodDictionary includesKey: sel
)
public classSide = (
	self warnObsolete.
	^self theMetaClass
)
public compiledMethodAt: selector <Symbol> ^<CompiledMethod> = (
	^self methodDictionary at: selector
)
public compiledMethodAt: selector ifAbsent: aBlock = (
	(* Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock *)

	^self methodDict at: selector ifAbsent: aBlock
)
public definingClass = (
	^self
)
public enclosingClass = (
	#BOGUS. (* Used by syntax highlighter, at least *)
	^self enclosingMixin
)
public fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex = (
	(* File a description of the messages of this class that have been
	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If
	moveSource, is true, then set the method source pointer to the new file position.
	Note when this method is called with moveSource=true, it is condensing the
	.changes file, and should only write a preamble for every method. *)
	| org |
	(org:: self organization) categories do:
		[:cat |
		| sels |
		sels:: (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].
		((cat beginsWith: '*') and: [cat endsWith: '-override'])
			ifTrue: [
				sels do:
					[:sel | self printMethodChunkHistorically: sel on: aFileStream
						moveSource: moveSource toFile: fileIndex]]
			ifFalse: [
				sels do:
					[:sel | self printMethodChunk: sel withPreamble: true on: aFileStream
						moveSource: moveSource toFile: fileIndex]]]
)
public includesBehavior: aClass = (
	^self == aClass or: [(* self inheritsFrom: aClass *) aClass == Object]
)
public includesSelector: sel <Symbol> ^<Boolean> = (
	(* Answer whether the message whose selector is the argument is in the
	method dictionary of the receiver's class. *)

	^self methodDict includesKey: sel
)
public isMixin ^<Boolean> = (
	^true
)
public language = (
	^newspeakLanguage3
)
public methodDict = (
	^self methodDictionary
)
public mixin = (
	^self
)
public moveChangesTo: newFile = (
	(* Used in the process of condensing changes, this message requests that
	the source code of all methods of the receiver that have been changed
	should be moved to newFile. *)

	| changes |
	changes:: self methodDict keys select: [:sel |
		(self compiledMethodAt: sel) fileIndex > 1].
	self
		fileOutChangedMessages: changes
		on: newFile
		moveSource: true
		toFile: 2
)
public printCategoryChunk: cat on: aFileStream priorMethod: priorMethod = (
)
public printMethodChunk: selector withPreamble: doPreamble on: outStream
		moveSource: moveSource toFile: fileIndex = (
	(* Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method. *)
	| preamble method oldPos newPos sourceFile endPos |
	doPreamble
		ifTrue: [preamble:: self name , ' methodsFor: ' ,
					(self organization categoryOfElement: selector) asString printString]
		ifFalse: [preamble:: ''].
	method:: self methodDict at: selector ifAbsent:
		[outStream nextPutAll: selector; cr.
		outStream tab; nextPutAll: '** ERROR!  THIS SCRIPT IS MISSING ** ' translated; cr; cr.
		outStream nextPutAll: '  '.
		^outStream].

	((method fileIndex = 0
		or: [(SourceFiles at: method fileIndex) == nil])
		or: [(oldPos:: method filePosition) = 0])
		ifTrue:
		[(* The source code is not accessible.  We must decompile... *)
		preamble size > 0 ifTrue: [outStream cr; nextPut: "!"; nextChunkPut: preamble; cr].
		outStream nextChunkPut: method decompileString]
		ifFalse:
		[sourceFile:: SourceFiles at: method fileIndex.
		preamble size > 0
			ifTrue: (* Copy the preamble *)
				[outStream copyPreamble: preamble from: sourceFile at: oldPos]
			ifFalse:
				[sourceFile position: oldPos].
		(* Copy the method chunk *)
		newPos:: outStream position.
		outStream copyMethodChunkFrom: sourceFile.
		sourceFile skipSeparators.      (* The following chunk may have ]style[ *)
		sourceFile peek == "]" ifTrue: [
			outStream cr; copyMethodChunkFrom: sourceFile].
		moveSource ifTrue: (* Set the new method source pointer *)
			[endPos:: outStream position.
			method checkOKToAdd: endPos - newPos at: newPos.
			method setSourcePosition: newPos inFile: fileIndex]].
	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].
	^outStream cr
)
public putClassCommentToCondensedChangesFile: aFileStream = (
)
public selectorsAndMethodsDo: selectorAndMethodBlock = (
	(* Evaluate the two argument selectorAndMethodBlock for all the selector/method pairs in my method dictionary. *)
	self warnObsolete.
	^self methodDict keysAndValuesDo: selectorAndMethodBlock
)
public soleInstance = (
	(* Required for Squeak bytecode printing. *)
	^self
)
public superclass = (
	self warnObsolete.
	^nil (* IDE crap: allLiteralsOf *)
)
) : (
)
class Behavior = (
(* My instances describe the behavior of other objects. I provide the minimum state necessary for creating and running instances. Most objects are created as instances of the more fully supported subclass, Class, but I am a good starting point for providing instance-specific behavior (as in Metaclass).

At this time, and for the foreseeable future, this class is polluted by a large number of methods necessary to support interaction with the surrounding Squeak Smalltalk implementation. In a pure Newspeak setting, these methods would be handled by mirrors exclusively.  The data in the slots would be private.

Any functionality beyond instantiation, mixin application and answering the class name is a security hole.

*)
|
public superclass <Behavior | nil> (* Must be slot 1; known to VM *)
public methodDict <MethodDictionary> (* Must be slot 2; known to VM *)
public format <SmallInteger> (* Must be slot 3; known to VM *)
public mixinSlot <Mixin | nil> (* Must be slot 4; known to VM *)
public enclosingObjectSlot <Behavior | nil> (* Must be slot 5; known to VM *)
|) (
public allInstVarNames = (
	(* Answer an Array of the names of the receiver's instance variables. The
	Array ordering is the order in which the variables are stored and
	accessed by the interpreter. *)

	| vars |
	superclass == nil
		ifTrue: [vars:: self instVarNames copy]	(* Guarantee a copy is answered. *)
		ifFalse: [vars:: superclass allInstVarNames , self instVarNames].
	^vars
)
public allInstancesDo: aBlock = (
	(* Evaluate the argument, aBlock, for each of the current instances of the
	receiver.

	Because aBlock might change the class of inst (for example, using become:),
	it is essential to compute next before aBlock value: inst. *)
	| instancesOrNil inst next |
	instancesOrNil:: vmmirror allInstancesOf: self.
	nil == instancesOrNil ifFalse: [instancesOrNil do: aBlock. ^self].
	(* Bulk instances primitive failed, fall back to old iterative primitive. *)
	inst: self someInstance.
	[nil == inst]
		whileFalse:
		[
		next: inst nextInstance.
		aBlock value: inst.
		inst: next]
)
public allSubclassesDo: aBlock = (
	(* Evaluate the argument, aBlock, for each of the receiver's subclasses. *)

	self subclassesDo:
		[:cl |
		aBlock value: cl.
		cl allSubclassesDo: aBlock]
)
public allSubclassesDoGently: block = (
	self allSubclassesDo: block
)
public allSuperclasses = (
	(* Answer an List of the receiver's and the receiver's
	ancestor's superclasses. The first element is the receiver's immediate
	superclass, followed by its superclass; the last element is Object. *)
	| temp |
	^superclass == nil
		ifTrue: [ List new]
		ifFalse: [temp:: superclass allSuperclasses asOrderedCollection.
			temp addFirst: superclass.
			temp]
)
public asString = (
	^self printString
)
public basicNew = (
	(* <primitive: 70> *)
	^vmmirror instantiateFixedClass: self
)
public basicNew: sizeRequested = (
	(* <primitive: 71> *)
	^vmmirror instantiateVariableClass: self withSize: sizeRequested
)
public binding = (
	^nil -> self
)
public canUnderstand: selector = (
	(* Answer whether the receiver can respond to the message whose selector
	is the argument. The selector can be in the method dictionary of the
	receiver's class or any of its superclasses. *)

	(self includesSelector: selector) ifTrue: [^true].
	superclass == nil ifTrue: [^false].
	^superclass canUnderstand: selector
)
public classSide = (
	^self theMetaClass
)
public compiledMethodAt: selector <Symbol> ^<CompiledMethod> = (
	^self methodDictionary at: selector
)
public compiledMethodAt: selector ifAbsent: aBlock = (
	(* Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock *)

	^self methodDict at: selector ifAbsent: aBlock
)
public decompilerClass = (
	(* IDE crap for when synthetic methods are confused as Smalltalk methods *)
	self warnObsolete.
	^(Smalltalk at: #Compiler) decompilerClass
)
public enclosingClass = (
	#BOGUS. (* Used by syntax highlighter. *)
	^self enclosingObjectSlot == nil ifFalse: [self enclosingObjectSlot class]
)
public identityHash ^<Integer> = (
	(*
	 Answer a SmallInteger whose value is related to the receiver's identity.
	 Behavior implements identityHash to allow the VM to use an object representation which
	 does not use a direct reference to an object's class.  If the VM is using this implementation
	 then classes are held in a class table and instances refer to their index in the table.  This is
	 more compact because the index field in the object header is less than a full word in size,
	 and this simplifies a just-in-time compiler's in-line cache management because class indices
	 are not updated by the garbage collector.  A class's class table index is its identityHash so
	 that an instance can be created without searching the table for a class's index.  The VM uses
	 this primitive to enter the class into the class table, assigning its identityHash with an as-yet
	 unused class table index. *)

	^vmmirror behaviorHashOf: self
)
public includesBehavior: aClass = (
	^self == aClass or: [self inheritsFrom: aClass]
)
public includesSelector: sel <Symbol> ^<Boolean> = (
	(* Answer whether the message whose selector is the argument is in the
	method dictionary of the receiver's class. *)

	^self methodDict includesKey: sel
)
public inheritsFrom: aClass = (
	(* Answer whether the argument, aClass, is on the receiver's superclass
	chain. *)

	| aSuperclass |
	aSuperclass:: superclass.
	[aSuperclass == nil]
		whileFalse:
			[aSuperclass == aClass ifTrue: [^true].
			aSuperclass:: aSuperclass superclass].
	^false
)
public instSize = (
	(* Answer the number of named instance variables
	(as opposed to indexed variables) of the receiver.
	 Above Cog Spur the class format is
		<5 bits inst spec><16 bits inst size> *)
	^format bitAnd: 16rFFFF
)
public instSpec = (
	(* Answer the instance specification part of the format that defines what kind of object
	 an instance of the receiver is.  The formats are
		0 = 0 sized objects (UndefinedObject True False et al)
		1 = non-indexable objects with inst vars (Point et al)
		2 = indexable objects with no inst vars (Array et al)
		3 = indexable objects with inst vars (MethodContext AdditionalMethodState et al)
		4 = weak indexable objects with inst vars (WeakArray et al)
		5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
		6 unused, reserved for exotic pointer objects?
		7 reserved by the VM
		8 unused, reserved for exotic non-pointer objects?
		9 (?) 64-bit indexable
		10 - 11 32-bit indexable
		12 - 15 16-bit indexable
		16 - 23 byte indexable
		24 - 31 compiled method *)
	^(format bitShift: -16) bitAnd: 16r1F
)
public instVarIndexFor: instVarName ifAbsent: aBlock = (
	(* Answer the index of the named instance variable. *)

	^self allInstVarNames indexOf: instVarName ifAbsent: aBlock
)
public instVarNames = (
	^mixin == nil
		ifTrue: [{} (* Top *)]
		ifFalse: [mixin instVarNames]
)
public instVarNamesAndOffsetsDo: aBinaryBlock = (
	(* This is part of the interface between the compiler and a class's instance or field names.
	 The class should enumerate aBinaryBlock with the instance variable name strings and
	 their integer offsets.  The order is important. Names evaluated later will override the
	 same names occurring earlier. *)

	| superInstSize |
	(superInstSize:: superclass notNil ifTrue: [superclass instSize] ifFalse: [0]) > 0 ifTrue:
		[superclass instVarNamesAndOffsetsDo: aBinaryBlock].
	1 to: self instSize - superInstSize do:
		[:i| aBinaryBlock value: (self instVarNames at: i) value: i + superInstSize]
)
public isBehavior = (
	(* Return true if the receiver is a behavior *)
	^true
)
public isBits = (
	(* Answer whether the receiver contains just bits (not pointers).
	 Above Cog Spur the class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
		 0 = 0 sized objects (UndefinedObject True False et al)
		 1 = non-indexable objects with inst vars (Point et al)
		 2 = indexable objects with no inst vars (Array et al)
		 3 = indexable objects with inst vars (MethodContext AdditionalMethodState et al)
		 4 = weak indexable objects with inst vars (WeakArray et al)
		 5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
		 6,7,8 unused
		 9 (?) 64-bit indexable
		 10 - 11 32-bit indexable
		 12 - 15 16-bit indexable
		 16 - 23 byte indexable
		 24 - 31 compiled method *)
	^self instSpec >= 9
)
public isBytes = (
	(* Answer whether the receiver has 8-bit instance variables.
	 Above Cog Spur the class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
		 0 = 0 sized objects (UndefinedObject True False et al)
		 1 = non-indexable objects with inst vars (Point et al)
		 2 = indexable objects with no inst vars (Array et al)
		 3 = indexable objects with inst vars (MethodContext AdditionalMethodState et al)
		 4 = weak indexable objects with inst vars (WeakArray et al)
		 5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
		 6,7,8 unused
		 9 (?) 64-bit indexable
		 10 - 11 32-bit indexable
		 12 - 15 16-bit indexable
		 16 - 23 byte indexable
		 24 - 31 compiled method *)
	^self instSpec >= 16
)
public isFixed = (
	(* Answer whether the receiver does not have a variable (indexable) part. *)

	^self isVariable not
)
public isKindOfBehavior = (
	(* Return true if the receiver is a behavior *)
	^true
)
public isMeta = (
	^false
)
public isMixinApplication = (
	^true (* All instances of this Behavior class are.  Squeak Behaviors are not. *)
)
public isPointers = (
	(* Answer whether the receiver contains just pointers (not bits). *)

	^self isBits not
)
public isVariable = (
	(* Answer whether the receiver has indexable variables.
	 Above Cog Spur the class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
		 0 = 0 sized objects (UndefinedObject True False et al)
		 1 = non-indexable objects with inst vars (Point et al)
		 2 = indexable objects with no inst vars (Array et al)
		 3 = indexable objects with inst vars (MethodContext AdditionalMethodState et al)
		 4 = weak indexable objects with inst vars (WeakArray et al)
		 5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
		 6,7,8 unused
		 9 (?) 64-bit indexable
		 10 - 11 32-bit indexable
		 12 - 15 16-bit indexable
		 16 - 23 byte indexable
		 24 - 31 compiled method *)
	| instSpec |
	instSpec:: self instSpec.
	^instSpec >= 2 and: [instSpec ~= 5]
)
public isWeak = (
	(* Answer whether the receiver has contains weak references. *)
	^self instSpec = 4
)
public isWords = (
	(* Answer whether the receiver has 16-bit instance variables. *)
	^self isBytes not
)
public language = (
	^newspeakLanguage3
)
public lookupSelector: selector = (
	(* Look up the given selector in my methodDictionary.
	Return the corresponding method if found.
	Otherwise chase the superclass chain and try again.
	Return nil if no method is found. *)
	| lookupClass |
	lookupClass:: self.
	[lookupClass == nil]
		whileFalse:
			[(lookupClass includesSelector: selector)
				ifTrue: [^ lookupClass compiledMethodAt: selector].
			lookupClass:: lookupClass superclass].
	^nil
)
public methodDictionary = (
	^methodDict
)
public name = (
	^'someBehavior'
)
public organization = (
	^mixin organization
)
public printOn: stm = (
	stm nextPutAll: self name.
)
public selectorsAndMethodsDo: selectorAndMethodBlock = (
	(* Evaluate the two argument selectorAndMethodBlock for all the selector/method pairs in my method dictionary. *)
	self warnObsolete.
	^self methodDict keysAndValuesDo: selectorAndMethodBlock
)
public simpleName = (
	^mixin simpleName
)
public someInstance = (
	^vmmirror firstInstanceOf: self ifNone: [nil]
)
public sourceCodeAt: selector = (
	(* IDE crap for when synthetic methods are confused as Smalltalk methods *)
	self warnObsolete.
	^(self methodDict at: selector) getSourceFor: selector in: self
)
public superclass: sc methodDictionary: md format: fmt = (
	vmmirror namedSlotOf: self at: 1 put: sc ifFail: [halt].
	methodDict: md.
	format: fmt.
)
public withAllSuperclasses = (
	(* Answer an OrderedCollection of the receiver and the receiver's
	superclasses. The first element is the receiver,
	followed by its superclass; the last element is Object. *)

	| temp |
	temp:: self allSuperclasses.
	temp addFirst: self.
	^temp
)
) : (
)
class Boolean = Value (
(* Boolean is an abstract class defining the protocol for logic testing operations and conditional control structures for the logical values represented by the instances of its subclasses True and False. *)self error: 'You may not create any more Booleans - this is two-valued logic') (
public & other <Boolean> ^<Boolean> = (
	(* Evaluating conjunction *)
	self subclassResponsibility
)
public and: f <[Boolean]> ^<Boolean> = (
	(* Non-evaluating conjunction *)
	self subclassResponsibility
)
public asAlien ^ <Integer> = (
	(* Convert to C boolean representation *)
	self subclassResponsibility
)
public ifFalse: then <[]> ^<Object> = (
	self subclassResponsibility
)
public ifFalse: then <[X def]> ifTrue: else <[Y def]> ^<X | Y> = (
	self subclassResponsibility
)
public ifTrue: then <[]> ^<Object> = (
	self subclassResponsibility
)
public ifTrue: then <[X def]> ifFalse: else <[Y def]> ^ <X | Y> = (
	self subclassResponsibility
)
public isKindOfBoolean ^<Boolean> = (
	^true
)
public not ^ <Boolean> = (
	(* Negation *)
	self subclassResponsibility
)
public or: f <[Boolean]> ^<Boolean> = (
	(* Non-evaluating disjunction *)
	self subclassResponsibility
)
public xor: other <Boolean> ^ <Boolean> = (
	(* Exclusive disjunction *)
	^self ~~ other
)
public | other <Boolean> ^<Boolean> = (
	(* Evaluating disjunction *)
	self subclassResponsibility
)
) : (
)
public class Class = Behavior (
(* My instances describe the representation and behavior of objects.  Except for Top, my instances are the result of mixin applications.

The slot 'subclasses' is a redundant structure.  It is never used during execution, but is used by the development system to simplify or speed certain operations.

See comments in Behavior regarding problems wrt IDE support and security.
*)
|
protected subclassesSlot <WeakSet>
protected nameSlot <Symbol> (* N.B.: This must not be called name.  Otherwise its setter will conflict classes such as CLibrary that have #name: as their primary factory. *)
|) (
public addSubclass: subclass = (
	self assert: [subclass superclass == self] message: 'Not my subclass!'.
	subclassesSlot == nil ifTrue: [subclassesSlot: WeakSet new].
	subclassesSlot add: subclass.
)
public addWeakSubclass: subclass = (
	addSubclass: subclass.
)
public category = (
	^mixin category
)
public category: newCategory = (
)
public isMeta = (
	^false
)
public mixin = (
	^self mixinSlot
)
public mixinApply: superklass = (
	| application |
	application:: self mixin apply: superklass withName: (self simpleName, 'mixinApply: ', superclass name).
	application setEnclosingObjectSlot: self enclosingObjectSlot.
	^application
)
public name = (
	^self nameSlot
)
public removeSubclass: aSubclass = (
	(* If the argument, aSubclass, is one of the receiver's subclasses, remove it. *)
	subclassesSlot == nil
		ifFalse: [subclassesSlot remove: aSubclass ifAbsent: []].
)
public setEnclosingObjectSlot: e = (
	(* Sent by the compiler from nested class accessors. *)
	enclosingObjectSlot: e.
	self class setEnclosingObjectSlot: e.
)
public setName: n = (
	self nameSlot: n
)
public subclasses= (
	^subclassesSlot ifNil: [{}]
)
public subclassesDo: aBlock = (
	(* Evaluate the argument, aBlock, for each of the receiver's immediate subclasses. *)
	subclasses == nil ifFalse: [subclasses do: aBlock].
)
public theMetaClass = (
	^self class
)
public theNonMetaClass = (
	^self
)
) : (
)
public class ClassMixin = AbstractMixin (
(* A class-side mixin is the difference between a metaclass and Class. (In Newspeak metaclasses are direct subclasses of Class, unlike Smalltalk where they are subclasses of the class's superclass's metaclass.) Note that class-side mixins can only introduce additional methods, unlike instance-side mixins which can introduce slots, methods and nested classes. Because of this, module definitions (top-level classes) are always stateless.
*)
|
public organization <ClassOrganizer>
public methodDictionary <MethodDictionary> (* must be slot 2; known to VM *)
public instanceMixin <InstanceMixin>
public enclosingMixin <InstanceMixin> (* must be slot 4; known to VM *)
public binding <Association> = nil -> self.
|) (
public applications = (
	^{}
)
public category = (
	^instanceMixin category
)
public instVarNames = (
	^Array new
)
public isMeta ^<Boolean> = (
	^true
)
public name = (
	^instanceMixin name, ' class'
)
public printOn: stream = (
	stream nextPutAll: name , ' mixin'
)
public qualifiedName = (
	^instanceMixin qualifiedName, ' class'
)
public simpleName = (
	^instanceMixin simpleName, ' class'
)
public slots = (
	^{}
)
public theMetaClass = (
	^self
)
public theNonMetaClass = (
	^instanceMixin
)
) : (
)
class False = Boolean (
(* False defines the behavior of its single instance, false -- logical negation. Notice how the truth-value checks become direct message sends, without the need for explicit testing.

Be aware however that most of these methods are not sent as real messages in normal use. Most are inline coded by the compiler as test and jump bytecodes - avoiding the overhead of the full message sends. So simply redefining these methods here will have no effect. *)
) (
public & other <Boolean> ^ <Boolean> = (
	^false
)
public and: f <[Boolean]> ^ <Boolean> = (
	^false
)
public asAlien ^ <Integer> = (
	^0
)
public ifFalse: then <[]> ^<Object> = (
	^then value
)
public ifFalse: then <[X def]> ifTrue: else <[Y def]> ^<X | Y> = (
	^then value
)
public ifTrue: then <[]> ^<Object> = (
	^nil
)
public ifTrue: then <[X def]> ifFalse: else <[Y def]> ^ <X | Y> = (
	^else value
)
public not ^ <Boolean> = (
	^true
)
public or: q <[Boolean]> ^<Boolean> = (
	^q value
)
public printOn: stream <CharOutputStream> = (
	stream nextPutAll: 'false'
)
public | other <Boolean> ^ <Boolean> = (
	^other
)
) : (
)
public class Future computing: block <[E]> = (
(* A deferred computation. Used for simultaneous slots. It evalutes its closure in response to nearly every message.

The future used for actors/asynchrony is a 'push future'. The future used for simultaneous slots/laziness is a 'pull future'.

TODO: Forward every message except isFuture/isResolved/resolve. Make the IDE not send messages to unresolved futures in inspectors and debuggers.

TODO: Deal for more compilated simultaneous slot cases by introducing some notion of a resolution group and doing increment resolution in breadth-first order.

TODO: Rename to something like Deferred? Even if actor futures and lazy futures are duals, that doesn't mean they have equal claims to the name 'future'. Push collections are called 'observables', not 'collections'. *)
|
	private blockOrValue000 <[E] | E> ::= block. (* Can we get rid of the 000 terminated names please *)
	private state000 <Symbol> ::= #unresolved.
|) (
Future = (
	(* When access control is enforced the inherited method won't be activated by other objects sending #Future and this stub can be removed. *)
	^resolve Future
)
protected doesNotUnderstand: message = (
	^message sendTo: self resolve
)
public isFuture ^<Boolean> = (
	^true
)
public isKindOfFuture ^<Boolean> = (
	^true
)
public (* bogus? recursive resolution *) resolve = (
	state000 = #resolving ifTrue: [
		Error signal: 'Divergent evaluation of ', blockOrValue000 printString].
	state000 = #unresolved ifTrue: [
		state000: #resolving.
		blockOrValue000: blockOrValue000 value.
		[blockOrValue000 isFuture] whileTrue:
			[blockOrValue000: blockOrValue000 resolve].
		state000: #resolved.
	].
	^blockOrValue000
)
public yourself = (
	(* See InstanceMixin>>apply:withName: *)
	^self resolve
)
) : (
)
public class InstanceMixin = AbstractMixin (
(* An instance-side mixin is the difference between a (non-meta) class and its superclass: a set of additional methods, slots and nested class declarations.

All of my members except methods to invoke mixin application should be hidden, and be only accessible by mirrors. *)
|
public name <Symbol>
public methodDictionary <MethodDictionary> (* must be slot 2; known to VM *)
public slots <List[{Symbol.Boolean.Symbol}]> (* name, mutable?, accessModifier *)
public enclosingMixin <InstanceMixin | nil> (* must be slot 4; known to VM *)
public nestedMixins <Map[Symbol, InstanceMixin]> = Map new. (* must be called nestedMixins; known to compiler *)
public applications <WeakSet> = WeakSet new.
public classMixin <ClassMixin>
public cachedHeaderSource <String>
public cachedConstructorName <Symbol>
public category <Symbol> ::= #Uncategorized.
public organization <ClassOrganizer> (* Yuck *)
public binding <Association> = nil -> self.
|) (
public accessModifier ^ <Symbol> = (
	#BOGUS. (* Should remember the value from proper parsing in a slot. *)
	isTopLevel ifTrue: [^#public].
	(cachedHeaderSource startsWith: #public) ifTrue: [^#public].
	(cachedHeaderSource startsWith: #private) ifTrue: [^#private].
	^#protected
)
public apply: superklass <Class> ^ <Class> = (
	^self |> superklass
)
public apply: superklass <Class> index: index <Integer> ^ <Class> = (
	| application = apply: superklass withName: self simpleName, ' mixin |>', superclass name. |
	^renameMixinInitializerOf: application index: index
)
public apply: superklass <Class> index: index <Integer> enclosingObject: eo ^ <Class> = (
	| application = apply: superklass withName: self simpleName, ' mixin |>', superclass name enclosingObject: eo. |
	^renameMixinInitializerOf: application index: index
)
public apply: superclassArg <Class> withName: n <String> ^ <Class> = (
	(* Sent by the compiler in nested class accessors. *)

	| superClass <Class> invocation <Class> offset <Integer> |
	superClass:: superclassArg yourself. (* Extract real object from potential Delay *)
	superClass isNil ifTrue: [superClass:: Object].
	invocation:: self invokeWithSuperclass: superClass withName: n.
	offset:: superClass instSize.
	(*offset ~= 0*)true ifTrue: [self generateAccessorsFor: invocation offset: offset].
	applications add: invocation.
	^invocation
)
public apply: superclassArg <Class> withName: n <String> enclosingObject: eo ^ <Class> = (
	(* Sent by the compiler in nested class accessors. *)

	| superClass <Class> invocation <Class> offset <Integer> |
	superClass:: superclassArg yourself. (* Extract real object from potential Delay *)
	superClass isNil ifTrue: [superClass:: Object].
	invocation:: self invokeWithSuperclass: superClass withName: n.
	offset:: superClass instSize.
	self generateAccessorsFor: invocation offset: offset.
	applications add: invocation.
	invocation setEnclosingObjectSlot: eo.
	^invocation
)
public apply: superklass <Class> withName: n <String> index: index <Integer> ^ <Class> = (
	^renameMixinInitializerOf: (apply: superklass withName: n) index: index
)
public apply: superklass <Class> withName: n <String> index: index <Integer> enclosingObject: eo^ <Class> = (
	^renameMixinInitializerOf: (apply: superklass withName: n enclosingObject: eo) index: index
)
public applyTo: superklass <Class> withEnclosingObject: eo ^ <Class> = (
	(* Sent by the compiler in nested class accessors. *)
	^apply: superklass withName: (name , '`', eo hash printString) asSymbol enclosingObject: eo
)
public definingModule = (
	^enclosingMixin isNil ifTrue: [self] ifFalse: [enclosingMixin definingModule]
)
generateAccessorsFor: invocation <Class> offset: offset <Integer> = (
	| ivs <Collection[String]> mtds <MethodDictionary> |
	ivs:: invocation instVarNames.
	mtds:: invocation methodDict.
	(offset + 1 to: offset + ivs size) with: slots do:
		[:index <Integer> :slotDescriptor <{Name.Mutable.AccessModifier}> |
		|
		slotName = slotDescriptor at: 1.
		isMutable = slotDescriptor at: 2.
		slotAccessModifier = slotDescriptor at: 3.
		slotSetterName = (slotName, ':') asSymbol.
		initializerName = ('init`', slotName, ':') asSymbol.
		getter = CompiledMethod newGetterForSlot: index accessModifier: slotAccessModifier.
		setter = CompiledMethod newSetterForSlot: index accessModifier: slotAccessModifier.
		initializer = CompiledMethod newSetterForSlot: index accessModifier: #private.
		|
		initializer selector: initializerName; methodClass: self.
		mtds at: initializerName put: initializer.
		getter selector: slotName; methodClass: self.
		mtds at: slotName put: getter.
		isMutable ifTrue:
			[setter selector: slotSetterName; methodClass: self.
			mtds at: slotSetterName put: setter]].
)
public hasBody ^ <Boolean> = (
	#BOGUS yourself.
	^cachedHeaderSource last ~= "."
)
public instVarNames = (
	^(slots collect: [:pair | pair at: 1]) asArray
)
public invokeWithSuperclass: superClass <Class> withName: n <String> ^<Class> = (
	| fmt <Integer> newMeta <Metaclass> newClass <Class> env |

	(isValidSuperclass: superClass) ifFalse: [^Error signal: 'Invalid superclass'].
	(isMixedInto: superClass) ifTrue: [^Error signal: 'The current implementation cannot handle repeated applications of a mixin to the same inheritance chain (', name, ').'].

	newMeta:: Metaclass new.
	newMeta
		superclass: Class
		methodDictionary: classMixin methodDictionary copy
		format: Class format.

	(* newMeta setInstVarNames: {}. *)
	newClass:: newMeta new.
	fmt:: self pointerFormatNumberOfInstVars: superClass instSize + slots size.
	newClass
		superclass: superClass
		methodDictionary: methodDictionary copy
		format: fmt.
	newClass setName: n.

	newClass mixinSlot: self.
	newMeta mixinSlot: self classMixin.

	applications add: newClass.
	superClass addWeakSubclass: newClass.

	^newClass
)
public isMeta ^<Boolean> = (
	^false
)
private isMixedInto: klass = (
	| k ::= klass. |
	[nil == k] whileFalse:
		[self == k mixin ifTrue: [^true].
		k:: k superclass].
	^false
)
isTopLevel = (
	^enclosingMixin isNil
)
private isValidSuperclass: object = (
	| cls |
	cls:: vmmirror classOf: object. (* Any class or metaclass *)
	cls:: vmmirror classOf: cls. (* Any metaclass or Metaclass *)
	cls isMeta ifTrue: [^false].
	object isPointers ifFalse: [^false].
	object isFixed ifFalse: [^false].
	^true
)
public lookupSelector: selector = (
	(* Look up the given selector in my methodDictionary.
	Return the corresponding method if found.
	Otherwise chase the superclass chain and try again.
	Return nil if no method is found. *)
	| lookupClass |
	lookupClass:: self.
	[lookupClass == nil]
		whileFalse:
			[(lookupClass includesSelector: selector)
				ifTrue: [^ lookupClass compiledMethodAt: selector].
			lookupClass:: lookupClass superclass].
	^nil
)
pointerFormatNumberOfInstVars: n <Integer> ^ <Integer> = (
	^16r10000 + n
)
public printOn: stm = (
	stm nextPutAll: name , ' mixin'
)
public qualifiedName = (
	enclosingMixin = nil ifTrue: [^self name].
	^(enclosingMixin qualifiedName, '`', self name) asSymbol
)
private renameMixinInitializerOf: superklass <Class> index: index <Integer> ^ <Class> = (
(*
Many mixin applications need to have the instance initializer of the mixin renamed so that it never conflicts with other mixin applications in the same superclass chain. This routine takes an index that is unique in the superclass chain. The index N is then used to rename the initializer from the form mixinInitializer`foo to mixinInitializer`foo`N.
*)
	|
	mtds <MethodDictionary> = superklass methodDictionary.
	initName <Symbol> = ('mixinInitializer`', cachedConstructorName) asSymbol.
	newInitName = ('mixinInitializer`',  index printString, '`', cachedConstructorName) asSymbol.
	factory <CompiledMethod> = mtds at: initName.
	|
	mtds removeKey: initName.
	mtds removeKey: ('initializer`', cachedConstructorName) asSymbol.
	(* add renamed instance initializer *)
	mtds at: newInitName put: factory. (* copy factory so name matches? *)
	^superklass.
)
public simpleName = (
	^self name
)
public superclass = (
	^Object
)
public theMetaClass = (
	^classMixin
)
public theNonMetaClass = (
	^self
)
public |> superclass <Class> ^<Class> = (
	assert: [enclosingMixin isNil] message: 'Nested mixins must be applied with an enclosing object'.
	^self apply: superclass withName: (self simpleName, ' mixin |>', superclass name)
)
) : (
)
public class Magnitude = (
(* A Magnitude[M] is an object that has a linear relationship with objects of type M, such
that they can be compared using the relational operations <,>,<=,>=.

%note: The derived operations are carefully defined to use <
	and not = for the following reasons:
	- speed
	- use of = may be bad for subclasses with a problematic definition of =,
	such as floating point numbers.
*)
) (
public < other <M> ^<Boolean> = (
	self subclassResponsibility
)
public <= other <M> ^<Boolean> = (
	^self < other or: [self = other]
)
public > other <M> ^<Boolean> = (
	^(self <= other) not
)
public >= other <M> ^<Boolean> = (
	^(self < other) not
)
public between: min <M> and: max <M> ^<Boolean> = (
	(* test whether the receiver is in the range min -> max, inclusive *)
	(* test the max case first since end of range overflow is generally more common *)
	^self <= max and: [ self >= min ]
)
public max: other <ARG> ^<Self | ARG> = (
		(* {where X is arg 1 of #< message of receiverType;
			where ARG <X> is arg 1} *)

	(* The guaranteed is safe because of the inference clause *)
	^self > (
(* guaranteed <M>:\ *) other)
		ifTrue: [ self ]
		ifFalse: [ other ]
)
public min: other <ARG> ^<Self | ARG> = (
		(* {where X is arg 1 of #< message of receiverType;
			where ARG <X> is arg 1} *)

	(* The guaranteed is safe because of the inference clause *)
	^self < (
(* guaranteed <M> *) other)
		ifTrue: [ self ]
		ifFalse: [ other ]
)
) : (
)
public class Metaclass = Behavior (
(* Each class is an instance of a unique metaclass. All metaclasses are instances
of Metaclass, and are direct subclasses of Class. This differs from Smalltalk, where the metaclass would be a subclass of the metaclass of the class's superclass.
See comments in Behavior regarding problems wrt IDE suppport and security.
*)
|
	protected thisClass <Instance>
|) (
public category = (
	^theNonMetaClass category
)
public isMeta = (
	^true
)
public mixin ^<ClassMixin> = (
	^self mixinSlot
)
public name = (
	thisClass == nil
		ifTrue: [^'a Metaclass']
		ifFalse: [^thisClass name , ' class']
)
public new = (
	(* The receiver can only have one instance. Create it or complain that
	one already exists. *)

	thisClass class == self
		ifTrue: [self error: 'A Metaclass should only have one instance!']
		ifFalse: [thisClass: self basicNew. ^thisClass]
)
public removeSubclass: aClass = (
	(* Do nothing. *)
)
public setEnclosingObjectSlot: e = (
	(* Sent by the compiler from nested class accessors. *)
	enclosingObjectSlot: e
)
public subclassesDo: aBlock = (
	(* Evaluate aBlock for each of the receiver's immediate subclasses. *)
	thisClass subclassesDo: [:aSubclass|
		(* The following test is for Class class which has to exclude
		the Metaclasses being subclasses of Class. *)
		aSubclass isMeta ifFalse: [aBlock value: aSubclass class]].
)
public theMetaClass = (
	^self
)
public theNonMetaClass = (
	^thisClass
)
) : (
)
public class NewspeakLanguage3 = () (
public = other = (
	^self name = other name
)
public activationMirrorFor: context using: activationMirrors = (
	^activationMirrors ActivationMirrorCompiledByNewspeak onContext: context
)
public classSubjectFor: aClass using: ide = (
	(* Note we use the ClassDeclarationMirror from the IDE instance, rather the one from the mirror system imported by this module. When there are multiple IDEs and mirror systems in an image, this ensures the mirrors listening for changes and the mirrors that will make changes in a given IDE belong to the same mirror system. *)
	^ide browsingNS classSubjectOn:
		(ide browsing ClassDeclarationMirror reflecting: aClass mixin)
)
public fileExtension = (
	^'ns'
)
public isNewspeakLanguage3 = (
	^true
)
public name = (
	^#Newspeak3
)
) : (
)
public class Object = ImplementationBase (
(* Object is the root of the object hierarchy in the Newspeak programming language, and provides behavior common to all objects.  The superclass of Object is the empty class Top.  The purpose of Top is to allow all code to live in mixins.

For each protocol P in the system, this class provides a method 'isP' which answers true if and only if the receiver is an instance of a class which implements the protocol P.

Unlike other systems inspired by Smalltalk, the number of methods in this class is deliberately kept to a minimum. Behavior should only be provided by this class if it should be considered part of the core set of features available to *all* Newspeak programmers.

The security model of the Newspeak programming language is based on capabilities and it is essential that capabilities cannot leak through behavior provided by this class. For example, this class provides no mechanism for accessing instance variables of its instances. Instead such capabilities are provided to the debugger and other tools through mirror based reflection modules.

Object has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes. *)
) (
public = other <Object> ^<Boolean> = (
	(* Answers whether the receiver is considered equal to 'other'.
	May be overridden by subclasses, and should be overridden if the method 'hash' is overridden.
	This method must implement an equivalence relation, that is, the following must hold:
	* x = x evaluates to true
	* if x = y evaluates to true then y = x must evaluate to true
	* if x = y evaluates to true and y = z evaluates to true then x = z must evaluate to true.
	Furthermore, this method must be consistent with the implementation of hash, that is:
	* if x = y evaluates to true then x hash = y hash must evaluate to true. *)
	^self == other
)
public == other <Object> ^<Boolean> = (
	(* Answers whether the receiver is indistinguishable from 'other'. The default implementation answers whether the receiver is the same object as 'other'. Value objects should override to answer =.  *)
	(* :openquestion: Should we remove this? Identity seems only useful to tools that must cooperate with VM internals, such as atomic install and serializers, and these tools should already use the VM mirror since this method may be overridden. *)
	^vmmirror is: self identicalTo: other
)
protected Array = (
	^ArraySlot
)
protected ByteArray = (
	^ByteArraySlot
)
protected Character = (
	(* To be removed when Strings and Characters are unified. *)
	^CharacterSlot
)
protected Error = (
	^ErrorSlot
)
protected Float = (
	^FloatSlot
)
protected Future = (
	^outer KernelForSqueak Future
)
protected Integer = (
	^IntegerSlot
)
protected Object ^ <Kernel Object> = (
	^ObjectSlot
)
protected String = (
	^StringSlot
)
protected Symbol = (
	(* To be removed when symbol literals are removed. *)
	^SymbolSlot
)
protected assert: condition <[Boolean]> message: message = (
	(* Raises an error with the given message if and only if condition evaluates to false. *)
	condition isClosure ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signal: message]
)
protected class = (
	(* Answers the class of the receiver. *)
	(* :openquestion: Should this method be protected or public? If this method is public, code wishing to separate the authority granted by an object from the authority granted by its class must explicitly override it with a private or protected version. If this method is protected, code wishing to use patterns like Collection>>species must explicit override it with a public version. *)
	^vmmirror classOf: self
)
protected doesNotUnderstand: message = (
	| selector exception resumptionValue |
	selector: message selector.
	0 == message arguments size ifTrue: [(selector startsWith: 'is') ifTrue:
		[
		(* The following IF deals with the problem of a protected isFoo method present in a class X.  Previously, If a public send 'o isFoo' was performed, the method lookup would have reached here and returned false, instead of throwing a DNU exception as in the spec. So this is the fix: if the method is not already registered in Object, we add it and perform (again)  an ordinary send to self. If a protected method does not exist down in the hierarchy, the newly installed  method will be executed and it will not come back here. Otherwise, we are back here and the method is in fact present in Object class. In this case a DNU exception is thrown.     *) 
		(Object methodDict includesKey: selector) ifFalse: [ 
			(* 2 = LdFalse - LdSelf, i.e. this is a ^false method *)
			| method = CompiledMethod toReturnConstant: 2 trailerBytes: CompiledMethodTrailer empty. |
			method selector: selector.
			method methodClass: Object.
			(* :bug: This should be added to the receiver class to avoid making the behavior of proxies dependent whether an isFoo message has already been sent to another class. *)
			Object
				methodDict at: selector put: method.
			selector flushCache.
			^message sendTo: self]]].

	exception:: MessageNotUnderstood new
		message: message;
		receiver: self.
	resumptionValue: exception signal.

	^exception reachedDefaultHandler
		ifTrue: [ message sentTo: self ]
		ifFalse: [ resumptionValue ].
)
public hash ^<Integer> = (
	(* Answers the hash code for the receiver.
	May be overridden by subclasses, and should be overridden if the method '=' is overridden.
	The hash code must obey the requirements set forth in the method '=', that is, the following must hold:
	* if x = y evaluates to true then x hash = y hash must evaluate to true. *)
	^self identityHash
)
public identityHash ^<Integer> = (
	(* Answers the identity hash code of the reciever. *)
	^vmmirror identityHashOf: self
)
public isNil ^<Boolean> = (
	(* Note this method is used as a template for the generated isFoo ^false methods, so do not remove it. *)
	^false
)
public printOn: s <WriteStream> = (
	(* Prints a representation of the receiver on the given stream.
	The printed representation is for debugging purposes only and should not be relied on for any other purpose whatsoever.
	May be overridden in subclasses. *)
	s
		nextPutAll: self class name;
		nextPut: "#";
		nextPutAll: self identityHash printString
)
public printString ^<String> = (
	(* Returns a printed representation of the receiver.
	The printed representation is for debugging purposes only and should not be relied on for any other purpose whatsoever.
	May be overridden in subclasses. *)
	^self String streamContents: [:s | self printOn: s]
)
protected subclassResponsibility = (
	self Error signal: 'My subclass should have overridden ', vmmirror currentActivation sender name
)
public yourself = (
	(* Answers the receiver. *)
	^self
)
public ~= anObject = (
	^(self = anObject) not
)
public ~~ anObject = (
	^(self == anObject) not
)
) : (
)
public class Stopwatch = (|
private cumulativeMicros ::= 0.
private startMicros
|) (
public elapsedMicroseconds ^<Integer> = (
	nil = startMicros ifTrue: [^cumulativeMicros].
	^cumulativeMicros + (Time primUTCMicrosecondClock - startMicros)
)
public elapsedMilliseconds ^<Integer> = (
	^elapsedMicroseconds quo: 1000
)
public start = (
	nil = startMicros ifFalse: [^self (* Already running. *)].
	startMicros:: Time primUTCMicrosecondClock.
)
public stop = (
	nil = startMicros ifTrue: [^self (* Already stopped. *)].
	cumulativeMicros:: cumulativeMicros + (Time primUTCMicrosecondClock - startMicros).
	startMicros:: nil.
)
) : (
)
public class StringBuilder = (|
protected parts = List new.
protected sizeX ::= 0.
|) (
public add: string = (
	sizeX:: sizeX + string size.
	^parts add: string
)
public asString = (
	| stm |
	stm:: (String new: sizeX) writeStream.
	parts do: [:part | stm nextPutAll: part].
	^stm contents
)
public isEmpty ^<Boolean> = (
	^0 = sizeX
)
public isKindOfStringBuilder ^<Boolean> = (
	^true
)
public size = (
	^sizeX
)
public writeln: line = (
	self add: line.
	self add: String lf.
)
) : (
public new: capacity <Integer> ^<StringBuilder> = (
	^self new
)
)
class True = Boolean (
(* True defines the behavior of its single instance, true -- logical assertion. Notice how the truth-value checks become direct message sends, without the need for explicit testing.

Be aware however that most of these methods are not sent as real messages in normal use. Most are inline coded by the compiler as test and jump bytecodes - avoiding the overhead of the full message sends. So simply redefining these methods here will have no effect. *)
) (
public & other <Boolean> ^<Boolean> = (
	^other
)
public and: f <[Boolean]> ^<Boolean> = (
	^f value
)
public asAlien ^<Integer> = (
	^1
)
public ifFalse: then <[]> ^<Object> = (
	^nil
)
public ifFalse: then <[X def]> ifTrue: else <[Y def]> ^<X | Y> = (
	^else value
)
public ifTrue: then <[]> ^<Object> = (
	^then value
)
public ifTrue: then <[X def]> ifFalse: else <[Y def]> ^<X | Y> = (
	^then value
)
public not ^<Boolean> = (
	^false
)
public or: f <[Boolean]> ^<Boolean> = (
	^true
)
public printOn: stream <CharOutputStream> = (
	stream nextPutAll: 'true'
)
public | other <Boolean> ^<Boolean> = (
	^true
)
) : (
)
class UndefinedObject = Value (
(* UndefinedObject's sole instance is nil. nil represents a prior value for variables that have not been initialized, or for results which are meaningless. *)
) (
public = other <Object> ^<Boolean> = (
	^other isNil
)
public isNil ^<Boolean> = (
	^true
)
public notNil ^<Boolean> = (
	^false
)
public printOn: stream <CharOutputStream> = (
	stream putAll: 'nil'
)
) : (
)
class Value = (
(* Some objects cannot change after they are created. They are deeply immutable and known as value objects. A value object is globally unique, in the sense that no other object is equal to it.

An object o is a value object iff, under the assumption that o is a value object, it can be shown that:
-All its slots are immutable and contain value objects.
-Its enclosing objects are all value objects.
-Its class inherits from class Value and does not override its identity method (==).

Examples of such objects are numbers, booleans, characters, literal strings, symbols and module definitions. *)
) (
public copy ^<Instance> = (
	^self
)
) : (
)
private CompiledMethod = (
	(* Must be referred to indirectly so it is not serialized. *)
	^Smalltalk at: #CompiledMethod
)
private CompiledMethodTrailer = (
	(* Must be referred to indirectly so it is not serialized. *)
	^Smalltalk at: #CompiledMethodTrailer
)
public Exception = (
	(* Must be referred to indirectly so it is not serialized. *)
	^Smalltalk at: #Exception
)
private List = (
	(* Must be referred to indirectly so it is not serialized. *)
	^Smalltalk at: #OrderedCollection
)
public Message = (
	(* Must be referred to indirectly so it is not serialized. *)
	^Smalltalk at: #Message
)
public MessageNotUnderstood = (
	(* Must be referred to indirectly so it is not serialized. *)
	^Smalltalk at: #MessageNotUnderstood
)
private SourceFiles = (
	(* Must be referred to indirectly so it is not serialized. *)
	^Smalltalk at: #SourceFiles
)
public UnhandledError = (
	(* Must be referred to indirectly so it is not serialized. *)
	^Smalltalk at: #UnhandledError
)
public takeOver = (
	(* Sent near the end of bootstrapping. *)
	| oldKernel |

	oldKernel:: (vmmirror classOf: (vmmirror classOf: Class)) enclosingObjectSlot.
	(takeOver: oldKernel) ifTrue: [^true].

	oldKernel:: ((Smalltalk at: #NewspeakGlobalState)
					namespace at: #NSCompilerTesting) superclass enclosingObjectSlot.

	(takeOver: oldKernel) ifTrue: [^true].
	^false
)
takeOver: oldKernel <Kernel> = (
	| oldClasses newClasses |
	oldKernel == self ifTrue: [^false (* Already in charge *)].

	(* Become all instantiated classes of the old kernel into the new kernel. *)

	oldClasses:: {
		oldKernel Class.
		vmmirror classOf: oldKernel Class.
		oldKernel Metaclass.
		vmmirror classOf: oldKernel Metaclass.
		oldKernel InstanceMixin.
		vmmirror classOf: oldKernel InstanceMixin.
		oldKernel ClassMixin.
		vmmirror classOf: oldKernel ClassMixin.
		oldKernel Object.
		vmmirror classOf: oldKernel Object.
		oldKernel Future.
		vmmirror classOf: oldKernel Future}.

	newClasses:: {
		self Class.
		vmmirror classOf: self Class.
		self Metaclass.
		vmmirror classOf: self Metaclass.
		self InstanceMixin.
		vmmirror classOf: self InstanceMixin.
		self ClassMixin.
		vmmirror classOf: self ClassMixin.
		self Object.
		vmmirror classOf: self Object.
		self Future.
		vmmirror classOf: self Future}.

	1 to: oldClasses size do:
		[:i | (oldClasses at: i) == (newClasses at: i) ifTrue:
			[Error signal: 'Unexpected overlap between old and new kernel']].

	oldClasses elementsForwardIdentityTo: newClasses.
	vmmirror flushCache.
	^true
)
) : (
)
