Newspeak3
'Win32API'
class Win32API platform: platform = Object platform: platform (
(* This module provides access to select functions of Windows API from the following libraries: Kernel, GDI, User, Msimg32 and GDI+.

All of those functions are defined by nested subclasses of WinLibrary. For example, the functions from the User DLL are defined by the UserLibrary class. The module holds an instance of UserLibrary in its UserDLL slot. The same pattern is used for all the other libraries.

Most functions defined by the nested libraries are re-exported at the module level, so that it is possible to retrieve them by sending messages to the module. For example, instead of sending #GetLastError to KernelDLL it is possible to send the same message directly to Win32API instance. An exception to this rule is GDIplusFlatDLL. Its functions are not re-exported. Intead, the GDIplus inner module provides a class-based Newspeak wrapper interface, similar to that of the official C++ based GDI+ API.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2012 Cadence Design Systems, Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)
|
	public KernelDLL = KernelLibrary new.
	public GDIDLL = GDILibrary new.
	public UserDLL = UserLibrary new.
	public MsimgDLL = MsimgLibrary new.
	public GDIplusFlatDLL = GDIplusLibrary new.
	public Comdlg32DLL = Comdlg32Library new.

	public CHARFORMAT = platform squeak Win32apiCHARFORMAT.
	public CHARFORMAT2 = platform squeak Win32apiCHARFORMAT2.
	public CHARRANGE = platform squeak Win32apiCHARRANGE.
	public FIND_DATA = platform squeak Win32apiFINDDATA.
	public GRADIENT_RECT = platform squeak Win32apiGRADIENTRECT.
	public MSG = platform squeak Win32apiMSG.
	public MSGFILTER = platform squeak Win32apiMSGFILTER.
	public NMHDR = platform squeak Win32apiNMHDR. (* MSFT hs a wy wth wrds *)
	public OPENFILENAME = platform squeak Win32apiOPENFILENAME.
	public PAINTSTRUCT = platform squeak Win32apiPAINTSTRUCT.
	public PARAFORMAT = platform squeak Win32apiPARAFORMAT.
	public POINT = platform squeak Win32apiPOINT.
	public PROCESS_INFORMATION = platform squeak Win32apiPROCESSINFORMATION.
	public RECT = platform squeak Win32apiRECT.
	public REQRESIZE = platform squeak Win32apiREQRESIZE.
	public SCROLLINFO = platform squeak Win32apiSCROLLINFO.
	public SECURITY_ATTRIBUTES = platform squeak Win32apiSECURITYATTRIBUTES.
	public STARTUPINFO = platform squeak Win32apiSTARTUPINFO.
	public TRACKMOUSEEVENT = platform squeak Win32apiTRACKMOUSEEVENT.
	public TRIVERTEX = platform squeak Win32apiTRIVERTEX.
	public WNDCLASS = platform squeak Win32apiWNDCLASS.
	public WINDOWPOS = platform squeak Win32apiWINDOWPOS.
	public WindowProc = platform squeak Win32apiWindowProc.
	public WCharAlien = platform squeak WCharAlien.

	public GiveUp = platform squeak GiveUp.

	CrLfFileStream = platform squeak CrLfFileStream.
	Delay = platform squeak Delay.
	FileDirectory = platform squeak FileDirectory.
|addLibrary: KernelDLL.
	addLibrary: GDIDLL.
	addLibrary: UserDLL.
	addLibrary: MsimgDLL.
	addLibraryNoImport: GDIplusFlatDLL.
	addLibrary: Comdlg32DLL) (
class Comdlg32Library = WinLibrary name: 'comdlg32' (
(* Common Dialog Boxes aka. comdlg32.dll.
http://msdn.microsoft.com/en-us/library/ms645524(VS.85).aspx *)
) (
GetOpenFileNameA = (
(* BOOL GetOpenFileName(
	LPOPENFILENAME lpofn
); *)
	^functionNamed: #GetOpenFileNameA argc: 1
)
GetSaveFileNameA = (
(*
BOOL GetSaveFileName(
	LPOPENFILENAME lpofn
);
*)	^functionNamed: #GetSaveFileNameA argc: 1
)
public exportFunctionsTo: capi = (
	(* Please keep the list sorted alphabetically. *)
	capi
		exportFunction: GetOpenFileNameA as: #GetOpenFileName;
		exportFunction: GetSaveFileNameA as: #GetSaveFileName
)
) : (
)
class CommonDataTypes = (
) (
) : (
specification = (
	(* See http://msdn.microsoft.com/en-us/library/aa505945.aspx *)
	^'
typedef int BOOL, *PBOOL, *LPBOOL;

typedef BYTE  BOOLEAN, *PBOOLEAN;

typedef WCHAR  * BSTR;

typedef unsigned char BYTE, *PBYTE, *LPBYTE;

typedef char CHAR, *PCHAR;

typedef unsigned long DWORD, *PDWORD, *LPDWORD;

typedef ULONGLONG  DWORDLONG, *PDWORDLONG;

typedef ULONG_PTR  DWORD_PTR;

typedef unsigned int DWORD32;

typedef unsigned __int64  DWORD64;

typedef int INT, *LPINT;

typedef signed char INT8;

typedef signed short INT16;

typedef signed int INT32;

typedef signed __int64 INT64;

typedef long LONG, *LPLONG;

typedef signed int LONG32;

typedef __int64  LONG64;

typedef LPCSTR  LPCTSTR;

typedef unsigned __int64  QWORD;

typedef short SHORT;

typedef unsigned char UCHAR, *PUCHAR;

typedef unsigned int UINT;

typedef unsigned char UINT8;

typedef unsigned short UINT16;

typedef unsigned int UINT32;

typedef unsigned __int64  UINT64;

typedef unsigned long ULONG, *PULONG;

typedef unsigned int ULONG32;

typedef unsigned __int64  ULONG64;

typedef unsigned short UNSIGNED16;

typedef unsigned long UNSIGNED32;

typedef unsigned short USHORT;

typedef void VOID, *PVOID;

typedef wchar_t  WCHAR, *PWCHAR;

typedef unsigned short WORD, *PWORD, *LPWORD;
'
)
)
class File = (|
	public name
	public handle
|) (
public close = (
	closeHandle: handle
)
public deleteAfter: action <[:ReadStream]> = (
	| result |
	[result:: do: action] ensure: [FileDirectory deleteFilePath: name].
	^result
)
public do: action <[:ReadStream]> = (
	^CrLfFileStream readOnlyFileNamed: name do: action
)
public openReadOnly = (
	^CrLfFileStream readOnlyFileNamed: name
)
) : (
)
class GDILibrary = WinLibrary name: 'GDI' (
(* Defines the functions of the GDI (the classic one, not GDI+) dll we are using. *)
) (
BitBlt = (
	^functionNamed: #BitBlt argc: 9
)
CreateCompatibleBitmap = (
	^functionNamed: #CreateCompatibleBitmap argc: 3
)
CreateCompatibleDC = (
	^functionNamed: #CreateCompatibleDC argc: 1
)
CreateFontA = (
	^functionNamed: #CreateFontA argc: 14
)
CreatePen = (
	^functionNamed: #CreatePen argc: 3
)
CreateSolidBrush = (
	^functionNamed: #CreateSolidBrush argc: 1
)
DeleteDC = (
	^functionNamed: #DeleteDC argc: 1
)
DeleteObject = (
	^functionNamed: #DeleteObject argc: 1
)
Ellipse = (
	^functionNamed: #Ellipse argc: 5
)
ExtTextOutA = (
	(* BOOL ExtTextOut(
  		HDC hdc,          // handle to DC
		int X,            // x-coordinate of reference point
		int Y,            // y-coordinate of reference point
		UINT fuOptions,   // text-output options
		CONST RECT* lprc, // optional dimensions
		LPCTSTR lpString, // string
		UINT cbCount,     // number of characters in string
		CONST INT* lpDx   // array of spacing values
); *)
	^functionNamed: #ExtTextOutA argc: 8
)
GetStockObject = (
	^functionNamed: #GetStockObject argc: 1
)
GetTextExtentPoint32A = (
	(* BOOL GetTextExtentPoint32(
		HDC hdc,           // handle to DC
		LPCTSTR lpString,  // text string
		int c,      // characters in string
		LPSIZE lpSize      // string size
	); *)
	^functionNamed: #GetTextExtentPoint32A argc: 4
)
LineTo = (
	^functionNamed: #LineTo argc: 3
)
MoveToEx = (
	^functionNamed: #MoveToEx argc: 4
)
Polygon = (
(* BOOL Polygon(
  HDC hdc,                // handle to DC
  CONST POINT *lpPoints,  // polygon vertices
  int nCount              // count of polygon vertices
); *)
	^functionNamed: #Polygon argc: 3
)
Rectangle = (
	^functionNamed: #Rectangle argc: 5
)
SelectObject = (
	^functionNamed: #SelectObject argc: 2
)
SetBkMode = (
	^functionNamed: #SetBkMode argc: 2
)
SetDCBrushColor = (
	^functionNamed: #SetDCBrushColor argc: 2
)
SetDCPenColor = (
	^functionNamed: #SetDCPenColor argc: 2
)
SetTextColor = (
	^functionNamed: #SetTextColor argc: 2
)
TextOutA = (
	(* BOOL TextOut(
		HDC hdc,           // handle to DC
		int nXStart,       // x-coordinate of starting position
		int nYStart,       // y-coordinate of starting position
		LPCTSTR lpString,  // character string
		int cbString       // number of characters
); *)
	^functionNamed: #TextOutA argc: 5
)
public exportFunctionsTo: capi = (
	(* Please keep the list sorted alphabetically. *)
	capi
		exportFunction: BitBlt;
		exportFunction: CreateCompatibleBitmap;
		exportFunction: CreateCompatibleDC;
		exportFunction: CreateFontA as: #CreateFont;
		exportFunction: CreatePen;
		exportFunction: CreateSolidBrush;
		exportFunction: DeleteDC;
		exportFunction: DeleteObject;
		exportFunction: Ellipse;
		exportFunction: ExtTextOutA as: #ExtTextOut;
		exportFunction: GetStockObject;
		exportFunction: GetTextExtentPoint32A as: #GetTextExtentPoint32;
		exportFunction: LineTo;
		exportFunction: MoveToEx;
		exportFunction: Polygon;
		exportFunction: Rectangle;
		exportFunction: SelectObject;
		exportFunction: SetBkMode;
		exportFunction: SetDCBrushColor;
		exportFunction: SetDCPenColor;
		exportFunction: SetTextColor;
		exportFunction: TextOutA as: #TextOut
)
) : (
)
public class GDIplus = (
(* This is a nested module providing a Newspeak wrapper around GDI+ flat api, similar to the C++ wrapper provided by Microsoft as the official GDI+ API. *)
|
	private token <Alien | nil>
	protected flatAPI = GDIplusFlatDLL.
|) (
public class Bitmap = GDIplusObject (
(* Provides a subset of the functionality of the Bitmap class of the official GDI+ API. *)
|
	public nativeImagePtr <Integer> ::= 0. (* a raw pointer to the native bitmap object *)
	bits <Alien | nil> (* Holds onto the memory with the bitmap data of those bitmaps created from bits *)
|) (
public initWidth: width
height: height
format: format
= (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateBitmapFromScan0
		unsignedValue: width
		value: height
		value: 0
		value: format
		value: 0
		value: pointerBox address.
	lastResult = 0 ifFalse:
		[pointerBox free.
		^GiveUp signal: 'Bitmap creation failed with status: ', lastResult asString,  ' (', getLastErrorMessage, ')'].
	nativeImagePtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
public initWidth: width
height: height
stride: stride
format: format
bits: data <Alien> = (
	(* The last argument must be an alient pointing to a static buffer with the bitmap data. That buffer should stay around and be valid for the lifetime of the GDI+ bitmap object. The Bitmap will free it on receipt of #release. *)
	| pointerBox |
	bits:: data.
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateBitmapFromScan0
		unsignedValue: width
		value: height
		value: stride
		value: format
		value: bits address
		value: pointerBox address.
	lastResult = 0 ifFalse:
		[pointerBox free.
		^reportError: 'Bitmap creation failed with status: ', lastResult printString].
	nativeImagePtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
public initWidth: width <Integer>
height: height <Integer>
target: target <Graphics> = (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateBitmapFromGraphics
		unsignedValue: width
		value: height
		value: target nativeGraphicsPtr
		value: pointerBox address.
	lastResult = 0 ifFalse:
		[pointerBox free.
		^reportError: 'Bitmap creation failed with status: ', lastResult printString].
	nativeImagePtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
public release = (
	nativeImagePtr ~= 0 ifTrue:
		[flatAPI GdipDisposeImage value: nativeImagePtr.
		nativeImagePtr:: 0].
	bits notNil ifTrue:
		[bits free.
		bits:: nil]
)
) : (
public width: width height: height format: f = (
	^self new
		initWidth: width
		height: height
		format: f
)
public width: width height: height stride: stride format: f bits: bits <Alien> = (
	^self new
		initWidth: width
		height: height
		stride: stride
		format: f
		bits: bits
)
public width: width <Integer> height: height <Integer> target: target <Graphics> = (
	^self new
		initWidth: width
		height: height
		target: target
)
)
class Brush = GDIplusObject (
(* Corresponds to (a subset of) the C++ class Brush of the official GDI+ API. This class is abstract. *)
|
	nativeBrushPtr <Integer> ::= 0.
|) (
release = (
	nativeBrushPtr ~= 0 ifTrue:
		[flatAPI GdipDeleteBrush value: nativeBrushPtr.
		nativeBrushPtr:: 0]
)
) : (
)
class CachedBitmap = GDIplusObject (
(* Same as the CachedBitmap class of the official GDI+ API. *)
|
	nativeCachedBitmap ::= 0.
|) (
initBitmap: bitmap <Bitmap> graphics: graphics <Graphics> = (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateCachedBitmap
		unsignedValue: bitmap nativeImagePtr
		value: graphics nativeGraphicsPtr
		value: pointerBox address.
	nativeCachedBitmap:: pointerBox asUnsignedLong.
	lastResult = 0 ifFalse: [reportError: 'CachedBitmap creation failed with status: ', lastResult printString].
	pointerBox free.
)
release = (
	nativeCachedBitmap ~= 0 ifTrue:
		[flatAPI GdipDeleteCachedBitmap value: nativeCachedBitmap.
		nativeCachedBitmap:: 0]
)
) : (
bitmap: bitmap <Bitmap> graphics: graphics <Graphics> = (
	^self new initBitmap: bitmap graphics: graphics
)
)
class Color fromArgb: argb_ = (
(* Corresponds to the GDI+ Color class encoding 32-bit ARGB color values. The maximum value of each color component is 255. The alpha value of 255 means fully opaque. In this default constructor we trust the sender to provide us with values within their acceptable ranges. All objects of this module expect this as the color values they operate with rather than the Squeak color things. *)
|
	public argb <Integer> = argb_.
|) (
alpha ^<Integer> = (
	^argb >> 24
)
asColorref ^<Integer> = (
	^argb bitAnd: 16rFFFFFF
)
blue ^<Integer> = (
	^argb bitAnd: 16rFF
)
green ^<Integer> = (
	^argb >> 8 bitAnd: 16rFF
)
red ^<Integer> = (
	^argb >> 16 bitAnd: 16rFF
)
) : (
a: alpha r: red g: green b: blue = (
	(* The quick and not fully safe constructor from components that doesn't clip them to correct bit sizes. *)
	^fromArgb: (alpha << 24) | (red << 16) | (green << 8) | blue
)
alpha: alpha <Integer> red: red <Integer> green: green <Integer> blue: blue <Integer> = (
	(* This range-clipping variant of the constructor is safer in that out-of-range values of a color will not affect other color components. *)
	^a: (alpha bitAnd: 16rFF)
	  r: (red bitAnd: 16rFF)
	  g: (green bitAnd: 16rFF)
	  b: (blue bitAnd: 16rFF)
)
black = (
	^a: 255 r: 0 g: 0 b: 0
)
blue = (
	^a: 255 r: 0 g: 0 b: 255
)
fromColorref: colorref <Integer> = (
	^fromArgb: 16rFF000000 | colorref
)
fromSqueakColor: color <Color> = (
	^a: color privateAlpha
	  r: (color red * 255) rounded
	  g: (color green * 255) rounded
	  b: (color blue * 255) rounded
)
gray = (
	^a: 255 r: 128 g: 128 b: 128
)
gray: value = (
	^a: 255 r: value g: value b: value
)
green = (
	^a: 255 r: 0 g: 255 b: 0
)
orange = (
	^a: 255 r: 255 g: 16rA5 b: 0
)
red = (
	^a: 255 r: 255 g: 0 b: 0
)
transparent = (
	^a: 0 r: 255 g: 255 b: 255
)
white = (
	^a: 255 r: 255 g: 255 b: 255
)
yellow = (
	^a: 255 r: 255 g: 255 b: 0
)
)
class GDIplusObject = (
(* The common superclass of other GDI+ objects. Not much stuff here so far, but I'm sure we'll find what to put here. *)
|
	lastResult <Integer> ::= 0.
|) (
ensureOkStatusAfter: functionName = (
	lastResult = 0 ifFalse:
		[^reportError: functionName, ' failed with status: ', (statusStringFor: lastResult)]
)
) : (
)
public class Graphics = GDIplusObject (
(* A minimal subset of the Graphics class from GDI+. *)
|
	nativeGraphicsPtr <Integer> ::= 0.
	private gdiPlus_
|) (
public clear: color <Color> = (
	lastResult:: flatAPI GdipGraphicsClear
		unsignedValue: nativeGraphicsPtr
		value: color argb.
	^lastResult
)
public drawCachedBitmap: bitmap <CachedBitmap> at: point <Point> = (
	lastResult:: flatAPI GdipDrawCachedBitmap
		unsignedValue: nativeGraphicsPtr
		value: bitmap nativeCachedBitmap
		value: point x
		value: point y.
	^lastResult
)
public drawEllipse: bounds <Rectangle> using: pen <Pen> = (
	lastResult:: flatAPI GdipDrawEllipseI
		unsignedValue: nativeGraphicsPtr
		value: pen nativePenPtr
		value: bounds left
		value: bounds top
		value: bounds width
		value: bounds height.
	^lastResult
)
public drawImage: image <Bitmap> at: point <Point> = (
	lastResult:: flatAPI GdipDrawImageI
		unsignedValue: nativeGraphicsPtr
		value: image nativeImagePtr
		value: point x
		value: point y.
	^lastResult
)
public drawLineFrom: from <Point> to: to <Point> using: pen <Pen> = (
	lastResult:: flatAPI GdipDrawLineI
		unsignedValue: nativeGraphicsPtr
		value: pen nativePenPtr
		value: from x rounded
		value: from y rounded
		value: to x rounded
		value: to y rounded.
	^lastResult
)
public drawPolygon: vertices <Sequence[Points]> using: pen <Pen> = (
	withPointArrayFrom: vertices do:
		[:pointBuffer |
		lastResult:: flatAPI GdipDrawPolygonI
			unsignedValue: nativeGraphicsPtr
			value: pen nativePenPtr
			value: pointBuffer address
			value: vertices size].
	^lastResult
)
public drawRectangle: bounds <Rectangle> using: pen <Pen> = (
	lastResult:: flatAPI GdipDrawRectangleI
		unsignedValue: nativeGraphicsPtr
		value: pen nativePenPtr
		value: bounds left rounded
		value: bounds top rounded
		value: bounds width rounded
		value: bounds height rounded.
	^lastResult
)
public fillEllipse: bounds <Rectangle> using: brush <Brush> = (
	lastResult:: flatAPI GdipFillEllipseI
		unsignedValue: nativeGraphicsPtr
		value: brush nativeBrushPtr
		value: bounds left
		value: bounds top
		value: bounds width
		value: bounds height.
	^lastResult
)
public fillPolygon: vertices <Sequence[Points]> using: brush <Brush> = (
	withPointArrayFrom: vertices do:
		[:pointBuffer |
		lastResult:: flatAPI GdipFillPolygonI
			unsignedValue: nativeGraphicsPtr
			value: brush nativeBrushPtr
			value: pointBuffer address
			value: vertices size
			value: 0 (* FillModeAlternate, the default in the C++ mapping *)].
	^lastResult
)
public fillRectangle: rect <Rectangle> using: brush <Brush> = (
	lastResult:: flatAPI GdipFillRectangleI
		unsignedValue: nativeGraphicsPtr
		value: brush nativeBrushPtr
		value: rect left rounded
		value: rect top rounded
		value: rect width rounded
		value: rect height rounded.
	^lastResult
)
public flush = (
	lastResult:: flatAPI GdipFlush
		unsignedValue: nativeGraphicsPtr
		value: 1 (* FlushIntentionSync *)
)
gdiPlus ^<GDIplus> = (
	(* The module this graphics instance belongs to. *)
	^gdiPlus_ ifNil:
		[gdiPlus_:: outer GDIplus yourself.
		gdiPlus_]
)
getHDC ^<Integer> = (
	| hdcBox hdc |
	hdcBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipGetDC
		unsignedValue: nativeGraphicsPtr
		value: hdcBox address.
	lastResult = 0 ifFalse:
		[hdcBox free.
		^reportError: 'GdipGetDC() failed with status ', lastResult printString].
	hdc:: hdcBox asUnsignedLong.
	hdcBox free.
	^hdc
)
getHDCWhile: action <[:Integer]> = (
	(* Get hdc, feed it to the block and make sure to clean up. Do this, C++! *)
	| hdc |
	hdc:: getHDC.
	^[action value: hdc] ensure: [releaseHDC: hdc]
)
public initFromBitmap: bitmap <Bitmap> = (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipGetImageGraphicsContext
		unsignedValue: bitmap nativeImagePtr
		value: pointerBox address.
	lastResult = 0 ifFalse:
		[pointerBox free.
		^reportError: 'Graphics creation failed with status: ', lastResult printString].
	nativeGraphicsPtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
public initFromHDC: hdc = (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateFromHDC
		unsignedValue: hdc
		value: pointerBox address.
	lastResult = 0 ifFalse:
		[pointerBox free.
		^reportError: 'Graphics creation failed with status: ', lastResult printString].
	nativeGraphicsPtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
polygon: vertices <Sequence[Points]> drawUsing: pen <Pen> fillUsing: brush <Brush> = (
	(* A combination of draw and fill, to translate the vertices only once. *)
	withPointArrayFrom: vertices do:
		[:pointBuffer |
		lastResult:: flatAPI GdipFillPolygonI
			unsignedValue: nativeGraphicsPtr
			value: brush nativeBrushPtr
			value: pointBuffer address
			value: vertices size
			value: 0. (* FillModeAlternate, the default in the C++ mapping *)
		lastResult:: flatAPI GdipDrawPolygonI
			unsignedValue: nativeGraphicsPtr
			value: pen nativePenPtr
			value: pointBuffer address
			value: vertices size].
	^lastResult
)
public release = (
	nativeGraphicsPtr ~= 0 ifTrue:
		[flatAPI GdipDeleteGraphics value: nativeGraphicsPtr.
		nativeGraphicsPtr:: 0].
)
releaseHDC: hdc <Integer> = (
	lastResult:: flatAPI GdipReleaseDC
		unsignedValue: nativeGraphicsPtr
		value: hdc.
)
resetClip = (
	lastResult:: flatAPI GdipResetClip
		unsignedValue: nativeGraphicsPtr.
	^lastResult
)
setCompositingMode: mode <Integer> = (
	lastResult:: flatAPI GdipSetCompositingMode
		unsignedValue: nativeGraphicsPtr
		value: mode.
	^lastResult
)
setCompositingQuality: mode <Integer> = (
	lastResult:: flatAPI GdipSetCompositingQuality
		unsignedValue: nativeGraphicsPtr
		value: mode.
	^lastResult
)
setSmoothingMode: mode <Integer> = (
	lastResult:: flatAPI GdipSetSmoothingMode
		unsignedValue: nativeGraphicsPtr
		value: mode.
	^lastResult
)
protected withPointArrayFrom: vertices <Sequence[Points]> do: action<[:Alien]> = (
	| buffer offset |
	buffer:: Alien rawNewC: vertices size * 8.
	offset:: 1.
	vertices keysAndValuesDo:
		[:index :each |
		buffer signedLongAt: offset put: each x.
		offset:: offset + 4.
		buffer signedLongAt: offset put: each y.
		offset:: offset + 4].
	^[action value: buffer] ensure: [buffer free]
)
) : (
public forBitmap: bitmap <Bitmap> ^ <Graphics> = (
	(* Create a new Graphics instance on the specified bitmap instance. The creator must make arrangements to send #release to the instance when done using it. *)
	^self new initFromBitmap: bitmap
)
public fromHDC: hdc <Integer> ^ <Graphics> = (
	(* Create a new Graphics instance on the specified device handle. The creator must make arrangements to send #release to the instance when done using it. *)
	^self new initFromHDC: hdc
)
)
class LinearGradientBrush = Brush (
(* Corresponds to (a subset of) the LinearGradientBrush class of the official API. *)
) (
initFrom: from <Point> to: to <Point> fromColor: fromColor <Color> toColor: toColor <Color> = (
	| p1 p2 pointerBox |
	p1:: POINT newC initializeFromPoint: from.
	p2:: POINT newC initializeFromPoint: to.
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateLineBrushI
		unsignedValue: p1 address
		value: p2 address
		value: fromColor argb
		value: toColor argb
		value: 0 (* WrapModeTile *)
		value: pointerBox address.
	nativeBrushPtr:: pointerBox asUnsignedLong.
	lastResult = 0 ifFalse:
		[reportError: 'LinearGradientBrush creation failed with status: ',
			lastResult printString].
	pointerBox free.
	p2 free.
	p1 free.
)
) : (
from: p1 <Point> color: c1 <Color> to: p2 <Point> color: c2 <Color> = (
	^self new initFrom: p1 to: p2 fromColor: c1 toColor: c2
)
)
class PaintDCGraphics = Graphics (
|
	hdc
|) (
getHDC = (
	^hdc
)
getHDCWhile: action = (
	^action value: hdc
)
initFromHDC: hdc_ = (
	super initFromHDC: hdc_.
	hdc:: hdc_
)
releaseHDC = (
)
) : (
fromHDC: hdc_ = (
	^self new initFromHDC: hdc_
)
)
class Pen = GDIplusObject (
(* Corresponds to the Pen class of the official GDI+ API. *)
|
	nativePenPtr <Integer> ::= 0.
|) (
initColor: color <Color> width: width <Float> = (
	| pointerBox widthFloat |
	pointerBox:: alienClass newC: 4.
	widthFloat:: alienClass new: 4.
	widthFloat floatAt: 1 put: width.
	lastResult:: flatAPI GdipCreatePen1
		unsignedValue: color argb
		value: widthFloat
		value: 0 (* UnitWorld *)
		value: pointerBox address.
	nativePenPtr:: pointerBox asUnsignedLong.
	lastResult = 0 ifFalse: [reportError: 'Pen creation failed with status: ', lastResult printString].
	pointerBox free.
)
release = (
	nativePenPtr ~= 0 ifTrue:
		[flatAPI GdipDeletePen value: nativePenPtr.
		nativePenPtr:: 0]
)
) : (
color: color <Color> width: width <Float> = (
	^self new initColor: color width: width
)
)
class SolidBrush = Brush (
(* Corresponds to (a subset of) the SolidBrush class of the official C++ GDI+ API. *)
) (
initColor: color <Color> = (
	(* The last argument must be an alient pointing to a static buffer with the bitmap data. That buffer should stay around and be valid for the lifetime of the GDI+ bitmap object. The Bitmap will free it on receipt of #release. *)
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateSolidFill
		unsignedValue: color argb
		value: pointerBox address.
	nativeBrushPtr:: pointerBox asUnsignedLong.
	lastResult = 0 ifFalse: [reportError: 'Solid brush creation failed with status: ', lastResult printString].
	pointerBox free.
)
) : (
color: color <Color> = (
	^self new initColor: color
)
)
alienClass = (
	^outer Win32API Alien
)
public resetForNewImageSession = (
	token: nil
)
public shutdown = (
	(* Shutdown GDI+ if started. *)
	token notNil ifTrue:
		[flatAPI GdiplusShutdown value: token asUnsignedLong.
		token: nil]
)
public startup ^<Boolean> = (
	(* Attempt to start GDI+ and return a Boolean indicating success. *)
	| status |
	token:: alienClass newC: 4.
	withGdiplusStartupInputAndOutputDo:
		[:input :output |
		status:: flatAPI GdiplusStartup
			unsignedValue: token address
			value: input address
			value: output address].
	status = 0 (* ok *)
		ifFalse: [token free. token: nil].
	^token notNil
)
statusStringFor: statusCode = (
	^{'Ok'.
	'GenericError'.
	'InvalidParameter'.
	'OutOfMemory'.
	'ObjectBusy'.
	'InsufficientBuffer'.
	'NotImplemented'.
	'Win32Error'.
	'WrongState'.
	'Aborted'.
	'FileNotFound'.
	'ValueOverflow'.
	'AccessDenied'.
	'UnknownImageFormat'.
	'FontFamilyNotFound'.
	'FontStyleNotFound'.
	'NotTrueTypeFont'.
	'UnsupportedGdiplusVersion'.
	'GdiplusNotInitialized'.
	'PropertyNotFound'.
	'PropertyNotSupported'.
	'ProfileNotFound'.
	} at: statusCode + 1
)
withGdiplusStartupInputAndOutputDo: action = (
	(* For now we are skimping on having real definitions for GDI+ input and output structures and simply fake them here. *)
	| input output result |
	input:: alienClass newC: 16.
	input
		unsignedLongAt: 1 put: 1; (* version *)
		unsignedLongAt: 5 put: 0; (* debug callback *)
		unsignedLongAt: 9 put: 0; (* suppress background thread *)
		unsignedLongAt: 13 put: 0. (* suppress external codecs *)
	output:: alienClass newC: 8.
	result:: action value: input value: output.
	input free.
	output free.
	^result
)
) : (
)
class GDIplusLibrary = WinLibrary name: 'gdiplus' (
(* Provides access to functions of GDI+ flat API. See GDIplus class for a higher-level wrapper similar to Microsoft's C++ API. Note that the functions of this library are NOT imported into the containing Win32API instance. *)
) (
public GdipCreateBitmapFromGraphics = (
	(* GpStatus WINGDIPAPI GdipCreateBitmapFromGraphics(INT width, INT height, GpGraphics* target, GpBitmap** bitmap) *)
	^functionNamed: #GdipCreateBitmapFromGraphics argc: 4
)
public GdipCreateBitmapFromScan0 = (
	(* GpStatus WINGDIPAPI GdipCreateBitmapFromScan0(INT width, INT height, INT stride, PixelFormat format, BYTE* scan0, GpBitmap** bitmap) *)
	^functionNamed: #GdipCreateBitmapFromScan0 argc: 6
)
public GdipCreateCachedBitmap = (
	(* GpStatus WINGDIPAPI GdipCreateCachedBitmap( GpBitmap *bitmap, GpGraphics *graphics, GpCachedBitmap **cachedBitmap ) *)
	^functionNamed: #GdipCreateCachedBitmap argc: 3
)
public GdipCreateFromHDC = (
	(* GpStatus WINGDIPAPI GdipCreateFromHDC(HDC hdc, GpGraphics **graphics) *)
	^functionNamed: #GdipCreateFromHDC argc: 2
)
public GdipCreateFromHWND = (
	(* GpStatus WINGDIPAPI GdipCreateFromHWND(HWND hwnd, GpGraphics **graphics) *)
	^functionNamed: #GdipCreateFromHWND argc: 2
)
public GdipCreateLineBrushI = (
	(* GpStatus WINGDIPAPI GdipCreateLineBrushI(GDIPCONST GpPoint* point1, GDIPCONST GpPoint* point2, ARGB color1, ARGB color2, GpWrapMode wrapMode, GpLineGradient **lineGradient) *)
	^functionNamed: #GdipCreateLineBrushI argc: 6
)
public GdipCreatePen1 = (
	(* GpStatus WINGDIPAPI GdipCreatePen1(ARGB color, REAL width, GpUnit unit, GpPen **pen) *)
	^functionNamed: #GdipCreatePen1 argc: 4
)
public GdipCreatePen2 = (
	(* GpStatus WINGDIPAPI GdipCreatePen2(GpBrush *brush, REAL width, GpUnit unit, GpPen **pen) *)
	^functionNamed: #GdipCreatePen2 argc: 4
)
public GdipCreateSolidFill = (
	(* GpStatus WINGDIPAPI GdipCreateSolidFill(ARGB color, GpSolidFill **brush) *)
	^functionNamed: #GdipCreateSolidFill argc: 2
)
public GdipDeleteBrush = (
	(* GpStatus WINGDIPAPI GdipDeleteBrush(GpBrush *brush) *)
	^functionNamed: #GdipDeleteBrush argc: 1
)
public GdipDeleteCachedBitmap = (
	(* GpStatus WINGDIPAPI GdipDeleteCachedBitmap(GpCachedBitmap *cachedBitmap) *)
	^functionNamed: #GdipDeleteCachedBitmap argc: 1
)
public GdipDeleteGraphics = (
	(* GpStatus WINGDIPAPI GdipDeleteGraphics(GpGraphics *graphics) *)
	^functionNamed: #GdipDeleteGraphics argc: 1
)
public GdipDeletePen = (
	(* GpStatus WINGDIPAPI GdipDeletePen(GpPen *pen) *)
	^functionNamed: #GdipDeletePen argc: 1
)
public GdipDisposeImage = (
	(* GpStatus WINGDIPAPI GdipDisposeImage(GpImage *image) *)
	^functionNamed: #GdipDisposeImage argc: 1
)
public GdipDrawCachedBitmap = (
	(* GpStatus WINGDIPAPI GdipDrawCachedBitmap( GpGraphics *graphics, GpCachedBitmap *cachedBitmap, INT x, INT y ) *)
	^functionNamed: #GdipDrawCachedBitmap argc: 4
)
public GdipDrawEllipseI = (
	(* GpStatus WINGDIPAPI GdipDrawEllipseI(GpGraphics *graphics, GpPen *pen, INT x, INT y, INT width, INT height) *)
	^functionNamed: #GdipDrawEllipseI argc: 6
)
public GdipDrawImageI = (
	(* GpStatus WINGDIPAPI GdipDrawImageI(GpGraphics *graphics, GpImage *image, INT x, INT y); *)
	^functionNamed: #GdipDrawImageI argc: 4
)
public GdipDrawLineI = (
	(* GpStatus WINGDIPAPI GdipDrawLineI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1, INT x2, INT y2) *)
	^functionNamed: #GdipDrawLineI argc: 6
)
public GdipDrawPolygonI = (
	(* GpStatus WINGDIPAPI GdipDrawPolygonI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count) *)
	^functionNamed: #GdipDrawPolygonI argc: 4
)
public GdipDrawRectangleI = (
	(* GpStatus WINGDIPAPI GdipDrawRectangleI(GpGraphics *graphics, GpPen *pen, INT x, INT y, INT width, INT height) *)
	^functionNamed: #GdipDrawRectangleI argc: 6
)
public GdipFillEllipseI = (
	(* GpStatus WINGDIPAPI GdipFillEllipseI(GpGraphics *graphics, GpBrush *brush, INT x, INT y, INT width, INT height) *)
	^functionNamed: #GdipFillEllipseI argc: 6
)
public GdipFillPolygonI = (
	(* GpStatus WINGDIPAPI GdipFillPolygonI(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPoint *points, INT count, GpFillMode fillMode) *)
	^functionNamed: #GdipFillPolygonI argc: 5
)
public GdipFillRectangleI = (
	(* GpStatus WINGDIPAPI GdipFillRectangleI(GpGraphics *graphics, GpBrush *brush, INT x, INT y, INT width, INT height) *)
	^functionNamed: #GdipFillRectangleI argc: 6
)
public GdipFlush = (
	(* GpStatus WINGDIPAPI GdipFlush(GpGraphics *graphics, GpFlushIntention intention) *)
	^functionNamed: #GdipFlush argc: 2
)
public GdipGetDC = (
	(* GpStatus WINGDIPAPI GdipGetDC(GpGraphics* graphics, HDC * hdc) *)
	^functionNamed: #GdipGetDC argc: 2
)
public GdipGetImageGraphicsContext = (
	(* GpStatus WINGDIPAPI GdipGetImageGraphicsContext(GpImage *image, GpGraphics **graphics) *)
	^functionNamed: #GdipGetImageGraphicsContext argc: 2
)
public GdipGraphicsClear = (
	(* GpStatus WINGDIPAPI GdipGraphicsClear(GpGraphics *graphics, ARGB color) *)
	^functionNamed: #GdipGraphicsClear argc: 2
)
public GdipReleaseDC = (
	(* GpStatus WINGDIPAPI GdipReleaseDC(GpGraphics* graphics, HDC hdc) *)
	^functionNamed: #GdipReleaseDC argc: 2
)
public GdipResetClip = (
	(* GpStatus WINGDIPAPI GdipResetClip(GpGraphics *graphics) *)
	^functionNamed: #GdipResetClip argc: 1
)
public GdipSetCompositingMode = (
	(* GpStatus WINGDIPAPI GdipSetCompositingMode(GpGraphics *graphics, CompositingMode compositingMode) *)
	^functionNamed: #GdipSetCompositingMode argc: 2
)
public GdipSetCompositingQuality = (
	(* GpStatus WINGDIPAPI GdipSetCompositingQuality(GpGraphics *graphics, CompositingQuality compositingQuality) *)
	^functionNamed: #GdipSetCompositingQuality argc: 2
)
public GdipSetSmoothingMode = (
	(* GpStatus WINGDIPAPI
	GdipSetSmoothingMode(GpGraphics *graphics, SmoothingMode smoothingMode); *)
	^functionNamed: #GdipSetSmoothingMode argc: 2
)
public GdiplusShutdown = (
(* void GdiplusShutdown(
	ULONG_PTR token
); *)
	^functionNamed: #GdiplusShutdown argc: 1
)
public GdiplusStartup = (
(* Status GdiplusStartup(
	ULONG_PTR token *token,
	const GdiplusStartupInput *input,
	GdiplusStartupOutput *output
); *)
	^functionNamed: #GdiplusStartup argc: 3
)
public exportFunctionsTo: capi = (
	(* Please keep the list sorted alphabetically. *)
	capi
		exportFunction: GdipCreateBitmapFromGraphics;
		exportFunction: GdipCreateBitmapFromScan0;
		exportFunction: GdipCreateCachedBitmap;
		exportFunction: GdipCreateFromHDC;
		exportFunction: GdipCreateFromHWND;
		exportFunction: GdipCreateLineBrushI;
		exportFunction: GdipCreatePen1;
		exportFunction: GdipCreatePen2;
		exportFunction: GdipCreateSolidFill;
		exportFunction: GdipDeleteBrush;
		exportFunction: GdipDeleteCachedBitmap;
		exportFunction: GdipDeleteGraphics;
		exportFunction: GdipDeletePen;
		exportFunction: GdipDisposeImage;
		exportFunction: GdipDrawCachedBitmap;
		exportFunction: GdipDrawEllipseI;
		exportFunction: GdipDrawImageI;
		exportFunction: GdipDrawLineI;
		exportFunction: GdipDrawRectangleI;
		exportFunction: GdipFillEllipseI;
		exportFunction: GdipFillRectangleI;
		exportFunction: GdipFlush;
		exportFunction: GdipGetDC;
		exportFunction: GdipGetImageGraphicsContext;
		exportFunction: GdipReleaseDC;
		exportFunction: GdipSetCompositingMode;
		exportFunction: GdipSetCompositingQuality;
		exportFunction: GdipSetSmoothingMode;
		exportFunction: GdiplusShutdown;
		exportFunction: GdiplusStartup
)
) : (
)
class KernelLibrary = WinLibrary name: 'Kernel' (
(* Contains functions from the Kernel Windows library. *)
) (
CloseHandle ^ <Win32Function> = (
(*
BOOL WINAPI CloseHandle(
  __in  HANDLE hObject
);
*)
	^functionNamed: #CloseHandle argc: 1
)
CopyFileA ^ <Win32Function> = (
(* BOOL WINAPI CopyFile(
  __in  LPCTSTR lpExistingFileName,
  __in  LPCTSTR lpNewFileName,
  __in  BOOL bFailIfExists
);
*)
	^functionNamed: #CopyFileA argc: 3
)
CreateDirectoryA ^ <Win32Function> = (
(* BOOL WINAPI CreateDirectory(
  __in_opt  LPCTSTR lpPathName,
  __in      LPSECURITY_ATTRIBUTES lpSecurityAttributes
); *)
	^functionNamed: #CreateDirectoryA argc: 2
)
CreateFileA ^ <Win32Function> = (
(*
HANDLE WINAPI CreateFile(
  __in      LPCTSTR lpFileName,
  __in      DWORD dwDesiredAccess,
  __in      DWORD dwShareMode,
  __in_opt  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  __in      DWORD dwCreationDisposition,
  __in      DWORD dwFlagsAndAttributes,
  __in_opt  HANDLE hTemplateFile
);
*)
	^functionNamed: #CreateFileA argc: 7
)
CreatePipe ^ <Win32Function> = (
(*
BOOL WINAPI CreatePipe(
  __out     PHANDLE hReadPipe,
  __out     PHANDLE hWritePipe,
  __in_opt  LPSECURITY_ATTRIBUTES lpPipeAttributes,
  __in      DWORD nSize
);
*)
	^functionNamed: #CreatePipe argc: 4
)
CreateProcessA ^ <Win32Function> = (
(*
BOOL WINAPI CreateProcessA(
  __in_opt     LPCTSTR lpApplicationName,
  __inout_opt  LPTSTR lpCommandLine,
  __in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,
  __in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes,
  __in         BOOL bInheritHandles,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCTSTR lpCurrentDirectory,
  __in         LPSTARTUPINFO lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInformation
); *)
	^functionNamed: #CreateProcessA argc: 10
)
DeleteFileA ^ <Win32Function> = (
(*
BOOL WINAPI DeleteFile(
	_in LPCTSTR lpFileName
);
*)
	^functionNamed: #DeleteFileA argc: 1
)
FindClose ^ <Win32Function> = (
(*
BOOL WINAPI FindClose(
  __inout  HANDLE hFindFile
);
*)
	^functionNamed: #FindClose argc: 1
)
FindFirstFileA ^ <Win32Function> = (
(*
HANDLE WINAPI FindFirstFile(
  __in  LPCTSTR lpFileName,
  __out  LP_WIN32_FIND_DATA lpFindFileData
);
*)
	^functionNamed: #FindFirstFileA argc: 2
)
FindNextFileA ^ <Win32Function> = (
(*
BOOL WINAPI FindNextFile(
  __in  HANDLE  hFindFile,
  __out  LP_WIN32_FIND_DATA lpFindFileData
);
*)
	^functionNamed: #FindNextFileA argc: 2
)
FormatMessageA ^ <Win32Function> = (
(*
DWORD WINAPI FormatMessage(
  __in      DWORD dwFlags,
  __in_opt  LPCVOID lpSource,
  __in      DWORD dwMessageId,
  __in      DWORD dwLanguageId,
  __out     LPTSTR lpBuffer,
  __in      DWORD nSize,
  __in_opt  va_list *Arguments
);
*)
	^functionNamed: #FormatMessageA argc: 7
)
FreeEnvironmentStringsW ^ <Win32Function> = (
(*
BOOL WINAPI FreeEnvironmentStrings(
  __in  LPTCH lpszEnvironmentBlock
);
*)
	^functionNamed: #FreeEnvironmentStringsW argc: 1
)
public GetACP ^ <Win32Function> = (
	(*
	Get ANSI Code Page
	UINT GetACP(VOID);
	*)
	^functionNamed: #GetACP argc: 0
)
GetCurrentDirectoryA = (
(* DWORD WINAPI GetCurrentDirectory(
  __in  LPCTSTR nBufferLength,
  __out  LPCTSTR lpBuffer,
);
*)
	^functionNamed: #GetCurrentDirectoryA argc: 2
)
GetCurrentThread ^ <Win32Function> = (
(*
HANDLE WINAPI GetCurrentThread(void);
*)
	^functionNamed: #GetCurrentThread argc: 0
)
GetDiskFreeSpaceA ^ <Win32Function> = (
(*
BOOL WINAPI GetDiskFreeSpaceA(
  __in     LPCTSTR lpRootPathName,
  __out   LPDWORD lpSectorsPerCluster,
  __out  LPDWORD lpBytesPerSector,
  __out  LPDWORD lpNumberOfFreeClusters,
  __out  LPDWORD lpTotalNumberOfClusters
);
*)
	^functionNamed: #GetDiskFreeSpaceA argc: 5
)
GetEnvironmentStringsW ^ <Win32Function> = (
(*
LPTCH WINAPI GetEnvironmentStrings(void);
*)
	^functionNamed: #GetEnvironmentStringsW argc: 0
)
GetExitCodeProcess ^ <Win32Function> = (
(*
BOOL WINAPI GetExitCodeProcess(
  __in   HANDLE hProcess,
  __out  LPDWORD lpExitCode
);
*)
	^functionNamed: #GetExitCodeProcess argc: 2
)
GetFileAttributesA ^ <Win32Function> = (
(*
DWORD WINAPI GetFileAttributes(
  __in  LPCTSTR lpFileName
);
*)
	^functionNamed: #GetFileAttributesA argc: 1
)
GetFileSize ^ <Win32Function> = (
(*
DWORD WINAPI GetFileSize(
  __in HANDLE hFile,
 __out_opt LPDWORD lpFileSizeHigh,
);
*)
	^functionNamed: #GetFileSize argc: 2
)
GetLastError ^ <Win32Function> = (
	(* DWORD WINAPI GetLastError(void); *)
	^functionNamed: #GetLastError argc: 0
)
GetModuleHandleA ^ <Win32Function> = (
	^functionNamed: #GetModuleHandleA argc: 1
)
GetStdHandle ^ <Win32Function> = (
(*
HANDLE WINAPI GetStdHandle(
  __in  DWORD nStdHandle
);
*)
	^functionNamed: #GetStdHandle argc: 1
)
GetTempFileNameA ^ <Win32Function> = (
(*
UINT WINAPI GetTempFileName(
  __in   LPCTSTR lpPathName,
  __in   LPCTSTR lpPrefixString,
  __in   UINT uUnique,
  __out  LPTSTR lpTempFileName
);
*)
	^functionNamed: #GetTempFileNameA argc: 4
)
GetTempPathA ^ <Win32Function> = (
(*
DWORD WINAPI GetTempPath(
  __in   DWORD nBufferLength,
  __out  LPTSTR lpBuffer
);
*)
	^functionNamed: #GetTempPathA argc: 2
)
GetUserDefaultLangID ^ <Win32Function> = (
(*
LANGID GetUserDefaultLangID(void);
*)
	^functionNamed: #GetUserDefaultLangID argc: 0
)
LoadLibraryA ^ <Win32Function> = (
	^functionNamed: #LoadLibraryA argc: 1
)
MoveFileA ^ <Win32Function> = (
(*
BOOL WINAPI MoveFile(
  __in  LPCTSTR lpExistingFileName,
  __in  LPCTSTR lpNewFileName
);
*)
	^functionNamed: #MoveFileA argc: 2
)
MultiByteToWideChar ^ <Win32Function> = (
	(* int MultiByteToWideChar(
  UINT CodePage,
  DWORD dwFlags,
  LPCSTR lpMultiByteStr,
  int cbMultiByte,
  LPWSTR lpWideCharStr,
  int cchWideChar
); *)
	^functionNamed: #MultiByteToWideChar argc: 6
)
ReadFile ^ <Win32Function> = (
(*
BOOL WINAPI ReadFile(
  __in         HANDLE hFile,
  __out        LPVOID lpBuffer,
  __in         DWORD nNumberOfBytesToRead,
  __out_opt    LPDWORD lpNumberOfBytesRead,
  __inout_opt  LPOVERLAPPED lpOverlapped
);
*)
	^functionNamed: #ReadFile argc: 5
)
RemoveDirectoryA ^ <Win32Function> = (
(*
BOOL WINAPI RemoveDirectory(
	__in LPCTSTR lpPathName
);
*)
	^functionNamed: #RemoveDirectoryA argc: 1
)
SetFileApisToOEM ^ <Win32Function> = (
(*
	void WINAPI SetFileApisToOEM(void);
*)
	^functionNamed: #SetFileApisToOEM argc: 0
)
SetFilePointer ^ <Win32Function> = (
(*
BOOL WINAPI SetFilePointer(
  __in         		HANDLE hFile,
  __in         		LONG lDistanceToMove,
  __in out_opt    PLONG lpDistanceToMoveHigh,
  __in              	DWORD dwMoveMethod,
);
*)
	^functionNamed: #SetFilePointer argc: 4
)
SetHandleInformation ^ <Win32Function> = (
(*
BOOL WINAPI SetHandleInformation(
  __in  HANDLE hObject,
  __in  DWORD dwMask,
  __in  DWORD dwFlags
);
*)
	^functionNamed: #SetHandleInformation argc: 3
)
WaitForSingleObject ^ <Win32Function> = (
(*
DWORD WINAPI WaitForSingleObject(
  __in  HANDLE hHandle,
  __in  DWORD dwMilliseconds
);
*)
	^functionNamed: #WaitForSingleObject argc: 2
)
WideCharToMultiByte ^ <Win32Function> = (
	(* int WideCharToMultiByte(
  UINT CodePage,
  DWORD dwFlags,
  LPCWSTR lpWideCharStr,
  int cchWideChar,
  LPSTR lpMultiByteStr,
  int cbMultiByte,
  LPCSTR lpDefaultChar,
  LPBOOL lpUsedDefaultChar
); *)
	^functionNamed: #WideCharToMultiByte argc: 8
)
WriteFile ^ <Win32Function> = (
(*
BOOL WINAPI WriteFile(
  __in HANDLE hFile,
 __in LPCVOID lpBuffer,
 __in DWORD nNumberOfBytesToWrite,
  __out_opt  LPDWORD lpNumberOfBytesWritten,
  __inout_opt  LPOVERLAPPED lpOverlapped
);
*)
	^functionNamed: #WriteFile argc: 5
)
public exportFunctionsTo: capi = (
	capi
		exportFunction: CloseHandle;
		exportFunction: CopyFileA as: #CopyFile;
		exportFunction: CreateDirectoryA as: #CreateDirectory;
		exportFunction: CreateFileA as: #CreateFile;
		exportFunction: CreatePipe;
		exportFunction: CreateProcessA as: #CreateProcess;
		exportFunction: DeleteFileA as: #DeleteFile;
		exportFunction: FindClose;
		exportFunction: FindFirstFileA as: #FindFirstFile;
		exportFunction: FindNextFileA as: #FindNextFile;
		exportFunction: FormatMessageA as: #FormatMessage;
		exportFunction: FreeEnvironmentStringsW;
		exportFunction: GetCurrentDirectoryA as: #GetCurrentDirectory;
		exportFunction: GetCurrentThread;
		exportFunction: GetDiskFreeSpaceA as: #GetDiskFreeSpace;
		exportFunction: GetEnvironmentStringsW;
		exportFunction: GetExitCodeProcess;
		exportFunction: GetFileAttributesA as: #GetFileAttributes;
		exportFunction: GetFileSize;
		exportFunction: GetLastError;
		exportFunction: GetModuleHandleA as: #GetModuleHandle;
		exportFunction: GetStdHandle;
		exportFunction: GetTempFileNameA as: #GetTempFileName;
		exportFunction: GetTempPathA as: #GetTempPath;
		exportFunction: GetUserDefaultLangID;
		exportFunction: LoadLibraryA as: #LoadLibrary;
		exportFunction: MoveFileA as: #MoveFile;
		exportFunction: MultiByteToWideChar;
		exportFunction: ReadFile;
		exportFunction: RemoveDirectoryA as: #RemoveDirectory;
		exportFunction: SetFileApisToOEM;
		exportFunction: SetFilePointer;
		exportFunction: SetHandleInformation;
		exportFunction: WaitForSingleObject;
		exportFunction: WideCharToMultiByte;
		exportFunction: WriteFile
)
) : (
)
class MsimgLibrary = WinLibrary name: 'Msimg32' (
) (
GradientFill = (
(* BOOL GradientFill(
  HDC hdc,                   // handle to DC
  PTRIVERTEX pVertex,        // array of vertices
  ULONG dwNumVertex,         // number of vertices
  PVOID pMesh,               // array of gradients
  ULONG dwNumMesh,           // size of gradient array
  ULONG dwMode               // gradient fill mode
); *)
	^functionNamed: #GradientFill argc: 6
)
public exportFunctionsTo: capi = (
	(* Please keep the list sorted alphabetically. *)
	capi
		exportFunction: GradientFill
)
) : (
)
class Pipe = (|
	public myEnd
	public otherEnd
|) (
public closeBothEnds = (
	closeMyEnd.
	closeOtherEnd.
)
public closeMyEnd = (
	closeHandle: myEnd
)
public closeOtherEnd = (
	closeHandle: otherEnd
)
) : (
)
class Process = (|
	public lpProcessInformation
|) (
public waitForExitCode ^<Integer> = (
	^[ | lpExitCode delay |
		lpExitCode:: outer Win32API Alien newGC: 4.
		delay:: Delay forMilliseconds: 10.
		[ | rcode |
			rcode:: outer Win32API WaitForSingleObject
				unsignedValue: lpProcessInformation hProcess
				value: 0. (* dwMilliseconds *)
			16r00000102 = rcode (* WAIT_TIMEOUT *)] whileTrue: [delay wait].
		outer Win32API GetExitCodeProcess
			boolValue: lpProcessInformation hProcess
			value: lpExitCode pointer.
		lpExitCode signedLongAt: 1.
	] ensure: [lpProcessInformation closeHandles].
)
) : (
)
class UserLibrary = WinLibrary name: 'User' (
|
|) (
AdjustWindowRect = (
(* BOOL AdjustWindowRect(
	LPRECT lpRect,
	DWORD dwStyle,
	BOOL bMenu
); *)
	^functionNamed: #AdjustWindowRect argc: 3
)
AnimateWindow = (
(*
BOOL AnimateWindow(
	HWND hwnd,
	DWORD dwTime,
	DWORD dwFlags
);
*)
	^functionNamed: #AnimateWindow argc: 3
)
AppendMenuA = (
	^functionNamed: #AppendMenuA argc: 4
)
BeginDeferWindowPos = (
	(* HDWP BeginDeferWindowPos(
  		  int nNumWindows
	); *)
	^functionNamed: #BeginDeferWindowPos argc: 1
)
BeginPaint = (
	^functionNamed: #BeginPaint argc: 2
)
CreateMenu = (
	(* HMENU CreateMenu(VOID); *)
	^functionNamed: #CreateMenu argc: 0
)
CreatePopupMenu = (
	(* HMENU CreatePopupMenu(VOID); *)
	^functionNamed: #CreatePopupMenu argc: 0
)
CreateWindowExA = (
	^functionNamed: #CreateWindowExA argc: 12
)
DefWindowProcA = (
	^functionNamed: #DefWindowProcA argc: 4
)
DeferWindowPos = (
	(* HDWP DeferWindowPos(
			HDWP hWinPosInfo,
   		HWND hWnd,
			HWND hWndInsertAfter,
			int x,
			int y,
			int cx,
   		 int cy,
			UINT uFlags
	); *)
	^functionNamed: #DeferWindowPos argc: 8
)
DestroyWindow = (
	^functionNamed: #DestroyWindow argc: 1
)
DispatchMessageA = (
	^functionNamed: #DispatchMessageA argc: 1
)
DrawMenuBar = (
	(* BOOL DrawMenuBar(HWND hWnd); *)
	^functionNamed: #DrawMenuBar argc: 1.
)
DrawTextA = (
	^functionNamed: #DrawTextA argc: 5
)
EnableWindow = (
	^functionNamed: #EnableWindow argc: 2
)
EndDeferWindowPos = (
	(* BOOL EndDeferWindowPos(
			HDWP hWinPosInfo
	); *)
	^functionNamed: #EndDeferWindowPos argc: 1
)
EndPaint = (
	^functionNamed: #EndPaint argc: 2
)
EnumThreadWindows = (
(*
BOOL EnumThreadWindows(
	DWORD dwThreadId,
	WNDENUMPROC lpfn,
	LPARAM lParam
);
*)
	^functionNamed: #EnumThreadWindows argc: 3
)
FillRect = (
	^functionNamed: #FillRect argc: 3
)
FindWindowA = (
	(* HWND FindWindow(
	LPCTSTR lpClassName,
	LPCTSTR lpWindowName
); *)
	^functionNamed: #FindWindowA argc: 2
)
FlashWindow = (
	(* BOOL WINAPI FlashWindow(HWND hWnd, BOOL bInvert); *)
	^functionNamed: #FlashWindow argc: 2
)
FlashWindowEx = (
	(* BOOL WINAPI FlashWindowEx(PFLASHWINFO pfwi); *)
	^functionNamed: #FlashWindowEx argc: 1
)
GetAncestor = (
	(* HWND GetAncestor(HWND hwnd, UINT gaFlags); *)
	^functionNamed: #GetAncestor argc: 2
)
GetClientRect = (
	(* BOOL GetClientRect(HWND hWnd, LPRECT lpRect); *)
	^functionNamed: #GetClientRect argc: 2
)
GetCursorPos = (
	(* BOOL GetCursorPos(LPPOINT lpPoint); *)
	^functionNamed: #GetCursorPos argc: 1
)
GetDC = (
	^functionNamed: #GetDC argc: 1
)
GetForegroundWindow = (
(* HWND GetForegroundWindow(VOID); *)
	^functionNamed: #GetForegroundWindow argc: 0
)
GetKeyState = (
	(* SHORT GetKeyState(int nVirtKey); *)
	^functionNamed: #GetKeyState argc: 1
)
GetMessageA = (
	^functionNamed: #GetMessageA argc: 4
)
GetScrollInfo = (
	(* BOOL GetScrollInfo(
		HWND hwnd,
		int fnBar,
		LPSCROLLINFO lpsi
); *)
	^functionNamed: #GetScrollInfo argc: 3
)
GetSystemMetrics = (
	(* int WINAPI GetSystemMetrics(__in  int nIndex); *)
	^functionNamed: #GetSystemMetrics argc: 1
)
GetWindowLongA = (
	(* LONG GetWindowLongA(HWND hWnd, int nIndex); *)
	^functionNamed: #GetWindowLongA argc: 2
)
InvalidateRect = (
	^functionNamed: #InvalidateRect argc: 3
)
IsWindow = (
(*
BOOL IsWindow(
	HWND hWnd
);
*)
	^functionNamed: #IsWindow argc: 1
)
IsWindowVisible = (
(*
BOOL IsWindowVisible(
	HWND hWnd
);
*)
	^functionNamed: #IsWindowVisible argc: 1
)
LoadCursorA = (
	^functionNamed: #LoadCursorA argc: 2
)
LoadIconA = (
	^functionNamed: #LoadIconA argc: 2
)
MessageBeep = (
(*
BOOL WINAPI MessageBeep(
  __in  UINT uType
);
*)
	^functionNamed: #MessageBeep argc: 1
)
MoveWindow = (
	^functionNamed: #MoveWindow argc: 6
)
PeekMessageA = (
(*
BOOL PeekMessage(
	LPMSG lpMsg,
	HWND hWnd,
	UINT wMsgFilterMin,
	UINT wMsgFilterMax,
	UINT wRemoveMsg
);
*)
	^functionNamed: #PeekMessageA argc: 5
)
PostQuitMessage = (
	^functionNamed: #PostQuitMessage argc: 1
)
RegisterClassA = (
	^functionNamed: #RegisterClassA argc: 1
)
ReleaseCapture = (
	(* BOOL ReleaseCapture(VOID); *)
	^functionNamed: #ReleaseCapture argc: 0
)
ReleaseDC = (
	^functionNamed: #ReleaseDC argc: 2
)
SendMessageA = (
	^functionNamed: #SendMessageA argc: 4
)
SetActiveWindow = (
(*
HWND SetActiveWindow(
	HWND hWnd
);
*)
	^functionNamed: #SetActiveWindow argc: 1
)
SetCapture = (
	(* HWND SetCapture(HWND); *)
	^functionNamed: #SetCapture argc: 1
)
SetCursorPos = (
	(* BOOL SetCursorPos(int X, int Y); *)
	^functionNamed: #SetCursorPos argc: 2
)
SetFocus = (
	(* HWND SetFocus(HWND hWnd); *)
	^functionNamed: #SetFocus argc: 1
)
SetForegroundWindow = (
(*
BOOL SetForegroundWindow(
	HWND hWnd
);
*)
	^functionNamed: #SetForegroundWindow argc: 1
)
SetLayeredWindowAttributes = (
(* BOOL SetLayeredWindowAttributes(
	HWND hwnd,
	COLORREF crKey,
	BYTE bAlpha,
	DWORD dwFlags
); *)
	^functionNamed: #SetLayeredWindowAttributes argc: 4
)
SetMenu = (
	(* BOOL SetMenu(HWND hWnd, HMENU hMenu); *)
	^functionNamed: #SetMenu argc: 2
)
SetScrollInfo = (
	(* int SetScrollInfo(
	    HWND hwnd,
	    int fnBar,
	    LPCSCROLLINFO lpsi,
	    BOOL fRedraw
	); *)
	^functionNamed: #SetScrollInfo argc: 4
)
SetWindowLongA = (
	(* LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong); *)
	^functionNamed: #SetWindowLongA argc: 3
)
SetWindowTextA = (
	^functionNamed: #SetWindowTextA argc: 2
)
ShowWindow = (
	^functionNamed: #ShowWindow argc: 2
)
SystemParametersInfoA = (
	(* BOOL WINAPI SystemParametersInfo(
		__in     UINT uiAction,
		__in     UINT uiParam,
		__inout  PVOID pvParam,
		__in     UINT fWinIni
	); *)
	^functionNamed: #SystemParametersInfoA argc: 4
)
TabbedTextOutA = (
	^functionNamed: #TabbedTextOutA argc: 8
)
TrackMouseEvent = (
	(* BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack); *)
	^functionNamed: #TrackMouseEvent argc: 1
)
TrackPopupMenu = (
	(* BOOL TrackPopupMenu(
	    HMENU hMenu,
	    UINT uFlags,
 	   int x,
	    int y,
	    int nReserved,
	    HWND hWnd,
	    CONST RECT *prcRect); *)
	^functionNamed: #TrackPopupMenu argc: 7
)
TranslateMessage = (
	^functionNamed: #TranslateMessage argc: 1
)
UnregisterClassA = (
	^functionNamed: #UnregisterClassA argc: 2
)
UpdateLayeredWindow = (
(* BOOL UpdateLayeredWindow(
	HWND hwnd,
	HDC hdcDst,
	POINT *pptDst,
	SIZE *psize,
	HDC hdcSrc,
	POINT *pptSrc,
	COLORREF crKey,
	BLENDFUNCTION *pblend,
	DWORD dwFlags
); *)
	^functionNamed: #UpdateLayeredWindow argc: 9
)
UpdateWindow = (
	^functionNamed: #UpdateWindow argc: 1
)
WindowFromPoint = (
	(* HWND WindowFromPoint(POINT Point); *)
	^functionNamed: #WindowFromPoint argc: 1
)
public exportFunctionsTo: capi = (
	(* Please keep the exports ordered alphabetically. *)
	capi
		exportFunction: AdjustWindowRect;
		exportFunction: AnimateWindow;
		exportFunction: AppendMenuA as: #AppendMenu;
		exportFunction: BeginDeferWindowPos;
		exportFunction: BeginPaint;
		exportFunction: CreateMenu;
		exportFunction: CreatePopupMenu;
		exportFunction: CreateWindowExA as: #CreateWindowEx;
		exportFunction: DefWindowProcA as: #DefWindowProc;
		exportFunction: DeferWindowPos;
		exportFunction: DestroyWindow;
		exportFunction: DispatchMessageA as: #DispatchMessage;
		exportFunction: DrawMenuBar;
		exportFunction: DrawTextA as: #DrawText;
		exportFunction: EnableWindow;
		exportFunction: EndDeferWindowPos;
		exportFunction: EndPaint;
		exportFunction: EnumThreadWindows;
		exportFunction: FillRect;
		exportFunction: FindWindowA as: #FindWindow;
		exportFunction: FlashWindow;
		exportFunction: FlashWindowEx;
		exportFunction: GetAncestor;
		exportFunction: GetClientRect;
		exportFunction: GetCursorPos;
		exportFunction: GetDC;
		exportFunction: GetForegroundWindow;
		exportFunction: GetKeyState;
		exportFunction: GetMessageA as: #GetMessage;
		exportFunction: GetScrollInfo;
		exportFunction: GetSystemMetrics;
		exportFunction: GetWindowLongA as: #GetWindowLong;
		exportFunction: InvalidateRect;
		exportFunction: IsWindow;
		exportFunction: IsWindowVisible;
		exportFunction: LoadCursorA as: #LoadCursor;
		exportFunction: LoadIconA as: #LoadIcon;
		exportFunction: MessageBeep;
		exportFunction: MoveWindow;
		exportFunction: PeekMessageA as: #PeekMessage;
		exportFunction: PostQuitMessage;
		exportFunction: RegisterClassA as: #RegisterClass;
		exportFunction: ReleaseCapture;
		exportFunction: ReleaseDC;
		exportFunction: SendMessageA as: #SendMessage;
		exportFunction: SetActiveWindow;
		exportFunction: SetCapture;
		exportFunction: SetCursorPos;
		exportFunction: SetFocus;
		exportFunction: SetForegroundWindow;
		exportFunction: SetLayeredWindowAttributes;
		exportFunction: SetMenu;
		exportFunction: SetScrollInfo;
		exportFunction: SetWindowLongA as: #SetWindowLong;
		exportFunction: SetWindowTextA as: #SetWindowText;
		exportFunction: ShowWindow;
		exportFunction: SystemParametersInfoA as: #SystemParametersInfo;
		exportFunction: TabbedTextOutA as: #TabbedTextOut;
		exportFunction: TrackMouseEvent;
		exportFunction: TrackPopupMenu;
		exportFunction: TranslateMessage;
		exportFunction: UpdateWindow;
		exportFunction: UpdateLayeredWindow;
		exportFunction: UnregisterClassA as: #UnregisterClass;
		exportFunction: WindowFromPoint
)
) : (
)
class Win32Function library: theLibrary <CLibrary> name: theName <Symbol> argc: numArgs <Integer> = CFunction library: theLibrary name: theName argc: numArgs (
(* A Windows function: same as CFunction but with some extra handy utilities. *)
) (
public boolValue ^<Boolean> = (
	(* Invoke the function with zero arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^unsignedValue ~= 0
)
public boolValue: arg <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 1 argument and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 2 argument and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 3 argument and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 4 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 5 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 6 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 7 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 8 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> value: arg9 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 9 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> value: arg9 <Alien | Integer> value: arg10 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 10 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9 value: arg10) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> value: arg9 <Alien | Integer> value: arg10 <Alien | Integer> value: arg11 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 11 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9 value: arg10 value: arg11) ~= 0
)
public boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> value: arg9 <Alien | Integer> value: arg10 <Alien | Integer> value: arg11 <Alien | Integer> value: arg12 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 12 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9 value: arg10 value: arg11 value: arg12) ~= 0
)
) : (
)
class WinLibrary name: theName <String> = CLibrary name: theName (
(* A Windows DLL. Mostly the same as CLibrary but uses different function instances. *)
) (
functionClass ^<Class> = (
	(* The class of instances of functions managed by this library. *)
	^Win32Function
)
) : (
)
public ANSI_FIXED_FONT = (
	^11
)
public ANSI_VAR_FONT = (
	^12
)
public ANTIALIASED_QUALITY = (
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^4
)
public AW_ACTIVATE = (
	(* #define AW_ACTIVATE                 0x00020000 *)
	^16r00020000
)
public AW_BLEND = (
	(* #define AW_BLEND                    0x00080000 *)
	^16r00080000
)
public AW_CENTER = (
	(* #define AW_CENTER                   0x00000010 *)
	^16r00000010
)
public AW_HIDE = (
	(* #define AW_HIDE                     0x00010000 *)
	^16r00010000
)
public AW_HOR_NEGATIVE = (
	(* #define AW_HOR_NEGATIVE             0x00000002 *)
	^16r00000002
)
public AW_HOR_POSITIVE = (
	(* #define AW_VER_POSITIVE             0x00000004 *)
	^16r00000004
)
public AW_SLIDE = (
	(* #define AW_SLIDE                    0x00040000 *)
	^16r00040000
)
public AW_VER_NEGATIVE = (
	(* #define AW_VER_NEGATIVE             0x00000008 *)
	^16r00000008
)
public Alien = (
	(* Make the name lexically visible to everything nested here. *)
	^super Alien
)
public BCM_GETIDEALSIZE = (
	^16r1601
)
public BN_CLICKED = (
	^0
)
public CFE_AUTOCOLOR = (
	^16r40000000
)
public CFE_BOLD = (
	^16r1
)
public CFE_ITALIC = (
	^16r2
)
public CFE_UNDERLINE = (
	^16r4
)
public CFM_BACKCOLOR = (
	^16r04000000
)
public CFM_BOLD = (
	^16r1
)
public CFM_COLOR = (
	^16r40000000
)
public CFM_ITALIC = (
	^16r2
)
public CFM_UNDERLINE = (
	^16r4
)
public CLEARTYPE_QUALITY = (
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^5
)
public COLOR_BACKGROUND = (
	^1
)
public COLOR_MENU = (
	^4
)
public COLOR_WINDOW = (
	^5
)
public CREATE_ALWAYS = (
(* http://msdn.microsoft.com/en-us/library/aa363858(VS.85).aspx
CREATE_ALWAYS
2
*)
	^2
)
public CS_HREDRAW = (
	^2
)
public CS_VREDRAW = (
	^1
)
public CW_USEDEFAULT = (
	^2147483648
)
public DC_BRUSH = (
	^18
)
public DC_PEN = (
	^19
)
public DEFAULT_QUALITY = (
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^0
)
public DRAFT_QUALITY = (
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^1
)
public EM_EXGETSEL = (
	^WM_USER + 52
)
public EM_EXSETSEL = (
	^WM_USER + 55
)
public EM_GETCHARFORMAT = (
	^WM_USER + 58
)
public EM_GETEVENTMASK = (
	^WM_USER + 59
)
public EM_GETPARAFORMAT = (
	^WM_USER + 61
)
public EM_HIDESELECTION = (
	^WM_USER + 63
)
public EM_LINEFROMCHAR = (
	^16r00C9
)
public EM_LINEINDEX = (
	^16r00BB
)
public EM_LINELENGTH = (
	^16r00C1
)
public EM_REQUESTRESIZE = (
	^WM_USER + 65
)
public EM_SETCHARFORMAT = (
	^WM_USER + 68
)
public EM_SETEVENTMASK = (
	^WM_USER + 69
)
public EM_SETPARAFORMAT = (
	^WM_USER + 71
)
public EM_SETSCROLLPOS = (
	^WM_USER + 222
)
public EM_SHOWSCROLLBAR = (
	^WM_USER + 96
)
public ENM_CHANGE = (
	^16r1
)
public ENM_KEYEVENTS = (
	^16r10000
)
public ENM_REQUESTRESIZE = (
	(* Richedit.h *)
	^16r40000
)
public EN_CHANGE = (
	^16r300
)
public EN_MSGFILTER = (
	^16r700
)
public EN_REQUESTRESIZE = (
	(* Richedit.h *)
	^16r701
)
public ERROR_ALREADY_EXISTS = (
	^16rB7
)
public ERROR_NO_MORE_FILES = (
	^16r12
)
public ERROR_SHARING_VIOLATION = (
	^16r20
)
public ES_MULTILINE = (
	^4
)
public ES_PASSWORD = (
	^16r20
)
public ES_READONLY = (
	^16r800
)
public ES_WANTRETURN = (
	^16r1000
)
public FILE_ATTRIBUTE_DIRECTORY = (
	^16
)
public FILE_ATTRIBUTE_NORMAL = (
(* http://msdn.microsoft.com/en-us/library/aa363858(VS.85).aspx
FILE_ATTRIBUTE_NORMAL
128
0x80
*)
	^128
)
public FILE_ATTRIBUTE_READONLY = (
	^1
)
public FILE_FLAG_SEQUENTIAL_SCAN = (
	^16r0800
)
public FORMAT_MESSAGE_ALLOCATE_BUFFER = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_ALLOCATE_BUFFER
0x00000100
*)
	^16r00000100
)
public FORMAT_MESSAGE_ARGUMENT_ARRAY = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_ARGUMENT_ARRAY
0x00002000
*)
	^16r00002000
)
public FORMAT_MESSAGE_FROM_HMODULE = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_FROM_HMODULE
0x00000800
*)
	^16r00000800
)
public FORMAT_MESSAGE_FROM_STRING = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_FROM_STRING
0x00000400
*)
	^16r00000400
)
public FORMAT_MESSAGE_FROM_SYSTEM = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_FROM_SYSTEM
0x00001000
*)
	^16r00001000
)
public FORMAT_MESSAGE_IGNORE_INSERTS = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_IGNORE_INSERTS
0x00000200
*)
	^16r00000200
)
public FORMAT_MESSAGE_MAX_WIDTH_MASK = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_MAX_WIDTH_MASK
0x000000FF
*)
	^16r000000FF
)
public GA_PARENT = (
	^1
)
public GA_ROOT = (
	^2
)
public GA_ROOTOWNER = (
	^3
)
public GENERIC_WRITE = (
	^16r40000000
)
public GRADIENT_FILL_RECT_H = (
(* #define GRADIENT_FILL_RECT_H    0x00000000 *)
	^0
)
public GRADIENT_FILL_RECT_V = (
(* #define GRADIENT_FILL_RECT_V    0x00000001 *)
	^1
)
public GWL_EXSTYLE = (
	^-20
)
public GWL_STYLE = (
	^-16
)
public IDC_ARROW = (
	^32512
)
public IDI_APPLICATION = (
	^32512
)
public INVALID_FILE_SIZE ^ <Integer> = (
	^16rFFFFFFFF
)
public INVALID_HANDLE_VALUE = (
	^16rFFFFFFFF
)
public LBN_DBLCLK = (
	^2
)
public LBN_ERRSPACE = (
	^-2
)
public LBN_KILLFOCUS = (
	^5
)
public LBN_SELCANCEL = (
	^3
)
public LBN_SELCHANGE = (
	^1
)
public LBN_SETFOCUS = (
	^4
)
public LBS_DISABLENOSCROLL = (
	^16r1000
)
public LBS_EXTENDEDSEL = (
	^16r800
)
public LBS_HASSTRINGS = (
	^16r40
)
public LBS_MULTIPLESEL = (
	^8
)
public LBS_NOINTEGRALHEIGHT = (
	^16r100
)
public LBS_NOTIFY = (
	^1
)
public LB_ADDSTRING = (
	^16r180
)
public LB_DELETESTRING = (
	^16r182
)
public LB_GETCOUNT = (
	^16r18B
)
public LB_GETCURSEL = (
	^16r188
)
public LB_GETSEL = (
	^16r187
)
public LB_INITSTORAGE = (
	^16r1A8
)
public LB_INSERTSTRING = (
	^16r181
)
public LB_RESETCONTENT = (
	^16r184
)
public LB_SETCURSEL = (
	^16r186
)
public LB_SETHORIZONTALEXTENT = (
	^16r194
)
public LB_SETSEL = (
	^16r185
)
public MF_CHECKED = (
	^16r8
)
public MF_DISABLED = (
	^16r2
)
public MF_ENABLED = (
	^16r0
)
public MF_GRAYED = (
	^16r1
)
public MF_POPUP = (
	^16r10
)
public MF_SEPARATOR = (
	^16r800
)
public MF_UNCHECKED = (
	^16r0
)
public MK_CONTROL = (
	^8
)
public MK_LBUTTON = (
	^1
)
public MK_MBUTTON = (
	^16r10
)
public MK_RBUTTON = (
	^2
)
public MK_SHIFT = (
	^4
)
public NONANTIALIASED_QUALITY = (
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^3
)
public NULL = (
	^0
)
public OUT_TT_PRECIS = (
	(* WinGDI.h:#define OUT_TT_PRECIS               4 *)
	^4
)
public PFM_TABSTOPS = (
	^16r10
)
public PM_REMOVE = (
	^1
)
public PROOF_QUALITY = (
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^2
)
public PS_SOLID = (
	^0
)
public SB_BOTH = (
	^2
)
public SB_CTL = (
	^2
)
public SB_HORZ = (
	^0
)
public SB_VERT = (
	^1
)
public SIF_ALL = (
	^16r1F
)
public SM_CMONITORS = (
	^80
)
public SM_CXSCREEN = (
	^0
)
public SM_CXVIRTUALSCREEN = (
	^78
)
public SM_CXVSCROLL = (
	^2
)
public SM_CYHSCROLL = (
	^3
)
public SM_CYSCREEN = (
	^1
)
public SM_CYVIRTUALSCREEN = (
	^79
)
public SM_XVIRTUALSCREEN = (
	^76
)
public SM_YVIRTUALSCREEN = (
	^77
)
public SPI_GETWORKAREA = (
	^16r30
)
public SRCCOPY = (
	^16rCC0020
)
public STARTF_USESHOWWINDOW = (
	(* #define STARTF_USESHOWWINDOW    0x00000001 *)
	^16r00000001
)
public STARTF_USESTDHANDLES = (
	^256
)
public SWP_HIDEWINDOW = (
	^16r80
)
public SWP_NOMOVE = (
	^16r2
)
public SWP_NOREDRAW = (
	^16r8
)
public SWP_NOSIZE = (
	^16r1
)
public SWP_NOZORDER = (
	^16r4
)
public SWP_SHOWWINDOW = (
	^16r40
)
public SW_HIDE = (
	^0
)
public SW_MINIMIZE = (
	(* #define SW_MINIMIZE         6 *)
	^6
)
public SW_SHOW = (
	^5
)
public SYSTEM_FONT = (
	^13
)
public TPM_NONOTIFY = (
	^16r80
)
public TPM_RETURNCMD = (
	^16r100
)
public VK_CAPITAL = (
	^16r14
)
public VK_CONTROL = (
	^16r11
)
public VK_ESCAPE = (
	^16r1B
)
public VK_LBUTTON = (
	^1
)
public VK_MBUTTON = (
	^4
)
public VK_MENU = (
	(* This means the Alt key. *)
	^16r12
)
public VK_PAUSE = (
	^16r13
)
public VK_RBUTTON = (
	^2
)
public VK_SHIFT = (
	^16r10
)
public WHITE_BRUSH = (
	^0
)
public WM_CHAR = (
	^16r102
)
public WM_CLOSE = (
	(* #define WM_CLOSE                        0x0010 *)
	^16r10
)
public WM_COMMAND = (
	^273
)
public WM_CREATE = (
	^1
)
public WM_DESTROY = (
	^2
)
public WM_ERASEBKGND = (
	^16r14
)
public WM_GETFONT = (
	^16r31
)
public WM_GETTEXT = (
	^16rD
)
public WM_GETTEXTLENGTH = (
	^16rE
)
public WM_HSCROLL = (
	^16r114
)
public WM_KEYDOWN = (
	^16r100
)
public WM_KEYUP = (
	^16r101
)
public WM_LBUTTONDBLCLK = (
	^16r203
)
public WM_LBUTTONDOWN = (
	^16r201
)
public WM_LBUTTONUP = (
	^16r202
)
public WM_MOUSELEAVE = (
	^16r2A3
)
public WM_MOUSEMOVE = (
	^16r200
)
public WM_MOUSEWHEEL = (
	^16r20A
)
public WM_NCDESTROY = (
	^130
)
public WM_NOTIFY = (
	^16r4E
)
public WM_PAINT = (
	^15
)
public WM_RBUTTONDBLCLK = (
	^16r206
)
public WM_RBUTTONDOWN = (
	^16r204
)
public WM_RBUTTONUP = (
	^16r205
)
public WM_SETFONT = (
	^16r30
)
public WM_SETREDRAW = (
	^16r0B
)
public WM_SETTEXT = (
	^12
)
public WM_SYSCHAR = (
	^16r106
)
public WM_SYSCOMMAND = (
(* #define WM_SYSCOMMAND                   0x0112 *)
	^16r0112
)
public WM_SYSKEYDOWN = (
	^16r104
)
public WM_USER = (
	^16r400
)
public WM_VSCROLL = (
	^16r115
)
public WM_WINDOWPOSCHANGED = (
	^71
)
public WS_BORDER = (
	^16r00800000
)
public WS_CAPTION = (
	^16r00C00000
)
public WS_CHILD = (
	^16r40000000
)
public WS_CHILDWINDOW = (
	^WS_CHILD
)
public WS_CLIPCHILDREN = (
	^16r02000000
)
public WS_CLIPSIBLINGS = (
	^16r04000000
)
public WS_DISABLED = (
	^16r08000000
)
public WS_DLGFRAME = (
	^16r00400000
)
public WS_EX_CLIENTEDGE = (
	^16r200
)
public WS_EX_COMPOSITED = (
	^16r02000000
)
public WS_EX_LAYERED = (
	^16r80000
)
public WS_EX_NOACTIVATE = (
	^16r8000000
)
public WS_EX_STATICEDGE = (
	^16r20000
)
public WS_EX_TOPMOST = (
	^16r8
)
public WS_EX_TRANSPARENT = (
	^16r20
)
public WS_GROUP = (
	^16r00020000
)
public WS_HSCROLL = (
	^16r00100000
)
public WS_MAXIMIZE = (
	^16r01000000
)
public WS_MAXIMIZEBOX = (
	^16r00010000
)
public WS_MINIMIZE = (
	^16r20000000
)
public WS_MINIMIZEBOX = (
	^16r00020000
)
public WS_OVERLAPPED = (
	^0
)
public WS_OVERLAPPEDWINDOW = (
	^bits: {#WS_OVERLAPPED. #WS_CAPTION. #WS_SYSMENU. #WS_THICKFRAME. #WS_MINIMIZEBOX. #WS_MAXIMIZEBOX}
)
public WS_POPUP = (
	^16r80000000
)
public WS_POPUPWINDOW = (
	^bits: {#WS_POPUP. #WS_BORDER. #WS_SYSMENU}
)
public WS_SYSMENU = (
	^16r00080000
)
public WS_TABSTOP = (
	^16r00010000
)
public WS_THICKFRAME = (
	^16r00040000
)
public WS_VISIBLE = (
	^16r10000000
)
public WS_VSCROLL = (
	^16r00200000
)
public closeHandle: handle <Integer | Alien> ^ <Boolean> = (
	(self CloseHandle boolValue: handle) ifFalse: [reportError]
)
public createPipeForReading ^<Pipe> = (
	^Alien autoFreeAfter: [:autofree | | readPipe writePipe |
		readPipe:: autofree value: (Alien newC: 4).
		writePipe:: autofree value: (Alien newC: 4).
		createPipeForReading: readPipe withChildPipe: writePipe.
		Pipe new myEnd: readPipe asUnsignedLong; otherEnd: writePipe asUnsignedLong
	]
)
createPipeForReading: readPipe <Alien> withChildPipe: writePipe <Alien> = (
	| lpSecurityAttributes result |
	lpSecurityAttributes:: SECURITY_ATTRIBUTES newGC bInheritHandle: true.
	result:: self CreatePipe
		boolValue: readPipe address
		value: writePipe address
		value: lpSecurityAttributes address value: 0.
	result ifFalse: [^reportError].
	result:: self SetHandleInformation
		boolValue: readPipe
		value: 1
		value: 0.
	result ifFalse: [^reportError].
)
public createPipeForWriting ^<{Integer. Integer}> = (
	^Alien autoFreeAfter: [:autofree | | readPipe writePipe |
		readPipe:: autofree value: (Alien newC: 4s).
		writePipe:: autofree value: (Alien newC: 4).
		createPipeForWriting: writePipe withChildPipe: readPipe.
		Pipe new myEnd: writePipe asUnsignedLong; otherEnd: readPipe asUnsignedLong
	]
)
createPipeForWriting: writePipe <Alien> withChildPipe: readPipe <Alien> = (
	| lpSecurityAttributes result |
	lpSecurityAttributes:: SECURITY_ATTRIBUTES newGC bInheritHandle: true.
	result:: self CreatePipe
		boolValue: readPipe address
		value: writePipe address
		value: lpSecurityAttributes address value: 0.
	result ifFalse: [^reportError].
	result:: self SetHandleInformation
		boolValue: writePipe
		value: 1
		value: 0.
	result ifFalse: [^reportError].
)
public createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	| lpProcessInformation lpStartupInfo result |
	lpProcessInformation:: PROCESS_INFORMATION newGC.
	lpStartupInfo:: STARTUPINFO newGC.

	Alien autoFreeAfter: [:autoFree |
		lpStartupInfo dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW.
		lpStartupInfo wShowWindow: SW_HIDE.
		lpStartupInfo lpTitle: (autoFree value: (Alien newCString: title)) address.
		lpStartupInfo hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]).
		lpStartupInfo hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]).
		lpStartupInfo hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
		result:: self CreateProcess
			boolValue: 0 (* lpApplicationName *)
			value: (autoFree value: (Alien newCString: commandLine)) address
			value: 0 (* lpProcessAttributes *)
			value: 0 (* lpThreadAttributes *)
			value: 1 (* bInheritHandles *)
			value: 0 (* dwCreationFlags *)
			value: 0 (* lpEnvironment *)
			value: (autoFree value: (Alien newCString: dir fullName)) address
			value: lpStartupInfo address
			value: lpProcessInformation address.
		result ifFalse: [^reportError]].
	^Process new lpProcessInformation: lpProcessInformation
)
public createTemporaryFile: inherit ^<{String. Alien}> = (
	|
	pathBuffer <Alien>
	tempName <Alien>
	result <Integer>
	hTempFile <Integer>
	lpSecurityAttributes <Alien>
	|
	lpSecurityAttributes:: SECURITY_ATTRIBUTES newGC bInheritHandle: inherit.
	Alien autoFreeAfter: [:autoFree |
		pathBuffer:: Alien newGC: 512.
		result:: self GetTempPath unsignedValue: 512 value: pathBuffer address.
		(result > 512 or: [result = 0]) ifTrue: [^reportError].

		tempName:: Alien newGC: 512.
		result:: self GetTempFileName
			unsignedValue: pathBuffer address
			value: (autoFree value: (Alien newCString: 'NSP')) address
			value: 0
			value: tempName address.
		result = 0 ifTrue: [reportError]].

	hTempFile:: self CreateFile
		unsignedValue: tempName address
		value: GENERIC_WRITE
		value: 0
		value: lpSecurityAttributes address
		value: CREATE_ALWAYS
		value: FILE_ATTRIBUTE_NORMAL
		value: NULL.
	hTempFile = INVALID_HANDLE_VALUE ifTrue: [reportError].
	^File new name: tempName strcpy; handle: hTempFile
)
public environmentVariables ^<Dictionary> = (
	| envp env string strings count a dict |
	envp:: self GetEnvironmentStringsW unsignedValue.
	env:: WCharAlien forPointer: envp.
	count:: 1.
	strings:: List new.
	[a:: Array streamContents: [:s | | c |
		[c:: env unsignedShortAt: count.
		count:: count + 2.
		c = 0] whileFalse: [s nextPut: (Character value: c)]].
	string:: String newFrom: a.
	string isEmpty] whileFalse: [strings add: string].
	self FreeEnvironmentStringsW boolValue: envp.
	dict:: Map new.
	strings do: [:ea | | i k v |
		i:: ea indexOf: "=".
		k:: ea copyFrom: 1 to: i - 1.
		v:: ea allButFirst: i.
		dict at: k asUppercase asSymbol put: v].
	^dict
)
error: message = (
	^GiveUp signal: message
)
getErrorMessage: errorCode <Integer> ^<String> = (
(*
http://msdn.microsoft.com/en-us/library/ms680582(VS.85).aspx
	FormatMessage(
	FORMAT_MESSAGE_ALLOCATE_BUFFER |
	FORMAT_MESSAGE_FROM_SYSTEM |
	FORMAT_MESSAGE_IGNORE_INSERTS,
	NULL,
	dw,
	MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
	(LPTSTR) &lpMsgBuf,
	0, NULL );
*)
	(Alien newC: 4)	freeAfter: [:lpMsgBuf | | result |
		result:: self FormatMessage
			unsignedValue:	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_IGNORE_INSERTS
			value: NULL
			value: errorCode
			value: self GetUserDefaultLangID unsignedValue
			value: lpMsgBuf address
			value: 0
			value: NULL.
		result = 0 ifTrue: [
			error:	'Could not retrieve error code: ', errorCode asString,
					' reason: ', getLastErrorCode asString].
		^((Alien forPointer: lpMsgBuf asUnsignedLong) strcpy copyWithout: Character lf) withBlanksTrimmed]
)
public getLastErrorCode ^<Integer> = (
	^self GetLastError unsignedValue
)
public getLastErrorMessage ^<String> = (
	^getErrorMessage: getLastErrorCode
)
public nullTerminatedCString: strings <SequenceableCollection[String]> = (
	| null |
	null:: Character value: 0.
	strings isEmpty ifTrue: [^Alien newCString: {null.null} asString].
	^Alien newCString: (String streamContents: [:s |
		strings do: [:string |
			s nextPutAll: string.
			s nextPut: null].
		s nextPut: null]).
)
public reportError = (
	^error: getLastErrorMessage
)
public reportError: message = (
	^error: message, ' (', getLastErrorMessage, ')'
)
reportError: message code: code = (
	^error: message, ' (', (getErrorMessage: code) , ')'
)
) : (
public usingPlatform: platform = (
	^self platform: platform
)
)
