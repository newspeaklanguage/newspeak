Newspeak3
'Root'
class HopscotchForCroquet usingPlatform: p <Platform> hopscotch: H <HopscotchForHTML5 class> = (
	|
(* imports *)
    private HopscotchForHTML5 = H.
    private Promise = p actors Promise.
    private Resolver = p actors Resolver.
    private List  = p collections List.
    private Map = p collections Map.
	|
) (
public class Hopscotch usingPlatform: p <Platform> images: images ducts: ds =
  HopscotchForHTML5 usingPlatform: p images: images ducts: ds

(
(*
This class overrides the normal Hopscotch UI module to allow the UI to synchronize using croquet.io.
For every interactive fragment class, we maintain:

1) A subclass, defined here, that manages the interaction with Croquet.
2) A counter that is used to generate unique ids for each fragment.

The fragment notifies the Croquet root view when an interaction occurs. The croquet view notifies the croquet model, which notifies the reflector; when the reflector has signaled the croquet model, it notifies the croquet view; the view then executes a call back in which the fragment performs the normal behavior defined in its superclass.

When completed, the goal is:

A series of croquet clients running a Newspeak application can be synchronized, without any modification to the Newspeak application code; the only requirement is that application be deployed using a platform object that uses an instance of this class as its GUI.

To reach that goal, we have to implement all interactive Hopscotch fragments here, and we have to deal with the problem of saving a model of the application as a whole to the Croquet root model; presumably by adding an image mechanism to Newspeak.

Ultimately, we hope to go beyond the above, and be able to diff the saved model state and extend this to full local-first solution.
*)
  |
  buttonCount <Integer> ::= 0.
  imageButtonCount <Integer> ::= 0.  
  radioButtonCount <Integer> ::= 0. 
  checkboxCount <Integer> ::= 0.
  hyperlinkCount <Integer> ::= 0.
  hyperlinkImageCount <Integer> ::= 0.
  codeMirrorCount <Integer> ::= 0.
  toggleComposerCount <Integer> ::= 0.
  textEditorCount <Integer> ::= 0.
  pickerCount <Integer> ::= 0.
  colorPickerCount <Integer> ::= 0.
  datePickerCount <Integer> ::= 0.  
  timePickerCount <Integer> ::= 0.
  sliderCount <Integer> ::= 0.
  searchFieldCount <Integer> ::= 0.
  dropDownMenuCount <Integer> ::= 0.  
  menuCount <Integer> ::= 0.  
  js = p js.   
|
) (
class ButtonFragment label: l action: a = super ButtonFragment label: l action: a (
    |
    buttonId <Integer> ::= newButtonId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <ButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[rootView <-: publish: 'nsbutton_' event: #button_click data: buttonId printString]
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsbutton_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        rootView <-: subscribe: scope eventSpec: #model_button_click handler: [:e | super action value. nil]
)
) : (
)
class ImageButtonFragment = super ImageButtonFragment (
    |
    imageButtonId <Integer> ::= newImageButtonId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsImagebutton_', imageButtonId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ImageButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[rootView <-: publish: 'nsImagebutton_' event: #image_button_click data: imageButtonId printString]
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_image_button_click handler: [:e | super action value. nil]
)
) : (
)
class CheckboxFragment text: t <Holder> value: v <Boolean | Holder> action: a <[:Boolean]>  = super CheckboxFragment text: t value: v action: a (
    |
    checkboxId <Integer> ::= newCheckboxId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscheckbox_', checkboxId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <CheckboxFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
writeInput: v = (
     checkbox at: 'checked' put: v.
     super writeInput: v.
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_checkBox_checked handler: [:e |  'checkbox checked event = ' out. writeInput: true. nil].
        rootView <-: subscribe: scope eventSpec: #model_checkBox_unchecked handler: [:e |  'checkbox unchecked event = ' out. writeInput: false. nil]
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:b <Boolean> | rootView <-: publish: 'nscheckbox_' event: ((checkbox at: 'checked') ifTrue: [#checkBox_checked] ifFalse: [#checkBox_unchecked]) data: checkboxId printString. nil]
)
) : (
)
class RadioButtonFragment text: t <String> 
	value: v <Boolean | Holder> 
	group: g <String> 
	action: a <[:Boolean]> = super RadioButtonFragment text: t value: v group: g action: a (
    |
    radioButtonId <Integer> ::= newRadioButtonId.
    scope_slot <String>
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsradiobutton_', radioButtonId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <RadioButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
  rootView <-: subscribe: scope eventSpec: #model_radioButton_pressed handler: [:e | writeInput: true. nil].
  rootView <-: subscribe: scope eventSpec: #model_radioButton_released handler: [:e | writeInput: false. nil]        
)
writeInput: v = (
     button at: 'checked' put: v.
     super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:b <Boolean> | rootView <-: publish: 'nsradiobutton_' event: ((button at: 'checked') ifTrue: [#radioButton_pressed] ifFalse: [#radioButton_released]) data: radioButtonId printString. nil]
)
) : (
)
class HyperlinkFragment label: l action: a = super HyperlinkFragment label: l action: a (
   |
    hyperlinkId <Integer> ::= newHyperlinkId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <HyperlinkFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[rootView <-: publish: 'nshyperlink_' event: #hyperlink_click data: hyperlinkId printString]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlink_', hyperlinkId printString].
  ^scope_slot
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_hyperlink_click handler: [:e | super action value. nil]
)
) : (
)
public class CodeMirrorFragment onText: t <String> = super CodeMirrorFragment onText: t (
    |
    codeMirrorId <Integer> ::= newCodeMirrorId.
    scope_slot <String>
    reflecting <Boolean> ::= true.
    |
    croquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscodemirror_', codeMirrorId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <CodeMirrorFragment>  ^ <Alien[Element]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
respondToCancel = (
  rootView <-: publish: 'nscodemirror_' event: #codeMirror_cancel data: codeMirrorId
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_codeMirror_change handler: [:e | 'code mirror change event = ' out.  text: e. super respondToChange: e. nil].
        rootView <-: subscribe: scope eventSpec: #model_codeMirror_beforeChange handler: [:e | 'code mirror before change event = ' out.  super respondToBeforeChange: e. nil].   
        rootView <-: subscribe: scope eventSpec: #model_codeMirror_keydown handler: [:e | 'code mirror keydown event = ' out.  reflecting:: false. super respondToKeyDown: e. nil].
        rootView <-: subscribe: scope eventSpec: #model_codeMirror_accept handler: [:e | 'code mirror accept event = ' out.  reflecting:: false. super respondToAccept: e. nil].
        rootView <-: subscribe: scope eventSpec: #model_codeMirror_cancel handler: [:e | 'code mirror cancle event = ' out.  reflecting:: false. super respondToCancel. nil].        
)
respondToKeyDown: event <Alien[Event]> = (
	| 
    e = replaceUndefined: event.
	key <Character> = e at: 'key'. 
    (* customary on mac, does not work on windows *)
	metaPressed <Boolean> = e at: 'metaKey'.
    (* works on windows *)
    ctrlPressed <Boolean> = e at: 'ctrlKey'.   
    shiftPressed <Boolean> = e at: 'shiftKey'.
	|
    ('key = ', key printString) out. 
    ('metaPressed = ', metaPressed printString) out.
    ('ctrlPressed = ', ctrlPressed printString) out.
    ('shiftPressed = ', shiftPressed printString) out.
   'code mirror respond keydown event = ' out.
   rootView <-: publish: scope eventSpec: #codeMirror_keydown data: (js global newspeakFragmentData: codeMirrorId data: key)
)
respondToAccept: event <Alien[Event]> = (
   rootView <-: publish: 'nscodemirror_' event: #codeMirror_accept data: codeMirrorData
)
respondToBeforeChange: event <Alien[Event]> = (
 'code mirror respond before change event = ' out.
  (*rootView <-: publish: 'nscodemirror_' event: #codeMirror_beforeChange data: codeMirrorData*)
)
respondToChange: event <Alien[Event]> = (
 'code mirror respond change event = ' out.
  rootView <-: publish: 'nscodemirror_' event: #codeMirror_change data: codeMirrorData
)
codeMirrorData = (
  ^js global newspeakFragmentData: codeMirrorId data: textBeingAccepted 
)
) : (
)
class HyperlinkImageFragment image: i action: a = super HyperlinkImageFragment (|
    hyperlinkImageId <Integer> ::= newHyperlinkImageId.
    scope_slot <String>
    |
    croquetView
) (
action = (
  ^[rootView <-: publish: 'nshyperlinkImage_' event: #hyperlink_image_click data: hyperlinkImageId printString]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlinkImage_', hyperlinkImageId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <HyperlinkImageFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_hyperlink_image_click handler: [:e | super action value. nil]
)
) : (
)
class ToggleComposer collapsedDefinition: collapsed <[Fragment]>
    expandedDefinition: expanded <[Fragment]>
    initiallyExpanded: flag <Boolean> = super ToggleComposer collapsedDefinition: collapsed 
    expandedDefinition: expanded 
    initiallyExpanded: flag (
    |
    toggleComposerId <Integer> ::= newToggleComposerId.
    scope_slot <String>
    |
    croquetView
) (
public toggle = (
  ^[rootView <-: publish: 'nstogglecomposer_' event: #toggleComposer_toggle data: toggleComposerId]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nstogglecomposer_', toggleComposerId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ToggleComposer>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
        rootView <-: subscribe: scope eventSpec: #model_toggleComposer_toggle handler: [:e | super toggle. nil]
)
) : (
)
public class TextEditorFragment = super TextEditorFragment (
    |
    textEditorId <Integer> ::= newTextEditorId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <TextEditorFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstexteditor_', textEditorId printString].
  ^scope_slot
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        (* how to get event data? *)
        rootView <-: subscribe: scope eventSpec: #model_textEditor_accept handler: [:e | 'accept' out. textEditor at: 'textContent' put: e. super respondToAccept: e. nil].
        rootView <-: subscribe: scope eventSpec: #model_textEditor_change handler: [:e | 'change' out. textEditor at: 'textContent' put: e. super respondToChange: e. nil].
        rootView <-: subscribe: scope eventSpec: #model_textEditor_cancel handler: [:e | 'cancel' out. super respondToCancel: e. nil].        
)
respondToAccept: event <Alien[Event]> = (
  'responding to accept' out.
  rootView <-: publish: 'nstexteditor_' event: #textEditor_accept data: textEditorData
)
respondToChange: event <Alien[Event]> = (
  rootView <-: publish: 'nstexteditor_' event: #textEditor_change data: textEditorData
)
respondToCancel: event <Alien[Event]> = (
  'responding to cancel' out.
  rootView <-: publish: 'nstexteditor_' event: #textEditor_cancel data: textEditorData 
)
textEditorData = (
  ^js global newspeakFragmentData: textEditorId data: (textEditor at: 'textContent')
)
) : (
)
class PickerFragment text: t <String> items: i <List[String]> action: a <[:String]> = super PickerFragment text: t items: i action: a (
    |
    buttonId <Integer> ::= newPickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <PickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nspicker_', buttonId printString].
  ^scope_slot
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)   
   super writeInput: v.
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        (* When the Croquet view is notified of a click, it will write the input *)
        rootView <-: subscribe: scope eventSpec: #model_picker_pick handler: [:e | writeInput: e. nil]
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | 'picker pick' out. rootView <-: publish: 'nspicker_' event: #picker_pick data: pickerData. nil]
)
pickerData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
class ColorPickerFragment value: v <String | Holder> action: a <[:String]> = super ColorPickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newColorPickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <ColorPickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nscolorpicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will write the input *)
        rootView <-: subscribe: scope eventSpec: #model_colorPicker_pick handler: [:e | writeInput: e. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | 'colorpicker pick' out. rootView <-: publish: 'nscolorpicker_' event: #colorPicker_pick data: colorPickerData. nil]
)
colorPickerData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
class DatePickerFragment value: v <String | Holder> action: a <[:String]> = super DatePickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newDatePickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <DatePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsdatepicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will write the input *)
        rootView <-: subscribe: scope eventSpec: #model_datePicker_pick handler: [:e | writeInput: e. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event |  'date picker pick' out.  rootView <-: publish: 'nsdatepicker_' event: #datePicker_pick data: datePickerData. nil]
)
datePickerData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
class TimePickerFragment value: v <String | Holder> action: a <[:String]> = super TimePickerFragment value: v action: a (
    |
    buttonId <Integer> ::= newTimePickerId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <TimePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstimepicker_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will write the input *)
        rootView <-: subscribe: scope eventSpec: #model_timePicker_pick handler: [:e | 'time picker pick' out.  writeInput: e. nil]
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | rootView <-: publish: 'nstimepicker_' event: #timePicker_pick data: timePickerData. nil]
)
timePickerData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
class SliderFragment value: v <Holder> min: mn <Float> max: mx <Float> = super SliderFragment value: v min: mn max: mx (
    |
    buttonId <Integer> ::= newSliderId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsslider_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        rootView <-: subscribe: scope eventSpec: #model_slider_pick handler: [:e | writeInput: e. nil]
)
writeInput: v = (
  visual at: 'value' put: v.
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | rootView <-: publish: 'nsslider_' event: #slider_pick data: sliderData. nil]
)
sliderData = (
  ^js global newspeakFragmentData: buttonId data: extractInput
)
) : (
)
class SearchFieldFragment = super SearchFieldFragment (
    |
    buttonId <Integer> ::= newSearchFieldId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nssearchfield_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (

        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        rootView <-: subscribe: scope eventSpec: #model_searchField_keydown handler: [:e | super respondToKeyDown. nil]
)
respondToKeyDown ^ <[:Alien | Boolean]> = (
  ^[:event | rootView <-: publish: 'nssearchfield_' event: #searchField_keydown data: (js global newspeakFragmentData: buttonId data: event)]
)
) : (
)
class DropDownMenuFragment menu: ms image: img <Image> alignment: side <Symbol> = super DropDownMenuFragment menu: ms image: img alignment: side (
    |
    buttonId <Integer> ::= newDropDownMenuId.
    scope_slot <String>
    |
    croquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsdropdownmenu_', buttonId printString].
  ^scope_slot
)
setupCroquetView = (
  (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
  ('Drop down menu ', buttonId printString, ' subscribed to event model_dropDownMenu_click in scope ', scope) out.
  rootView <-: subscribe: scope eventSpec: #model_dropDownMenu_click handler: [:e |'drop down' out.  super clickHandler value: e. nil].
)
public clickHandler ^ <[:Alien | Boolean]> = (
  ^[:event | ('click handler ', event printString) out. (event at: 1) printString out. rootView <-: publish: 'nsdropdownmenu_' event: #dropDownMenu_click data: buttonId. nil]
)
updateContent ^ <Alien[Element]> = (
    | menu <Alien[Div]> = computeContentForMenu: [(Menu supplier: menuSupplier) menuContents] . |
    isActive: true.
	showMenu: menu forShell: shell inVisual: visual.
    ^menu.
)
) : (
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: #right
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> alignment: side <Symbol> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: side
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> image: img <Image> ^ <Instance> = (
   ^menu: ms image: img alignment: #right
)
)
class Fragment = super Fragment (
|
public croquetView_slot <Promise[Alien[NewspeakCroquetFragmentView]]>
|
) (
croquetModel = (
    ^croquetView model.
)
croquetView = (
    croquetView_slot isNil ifTrue: [setupCroquetView].
    ^croquetView_slot
)
setupCroquetView = (
  (* only fragments that actively need croquet support need this *)
  subclassResponsibility
)
) : (
)
class Menu supplier: ms <[{Symbol | {String. []}}]>  = (
	| 
    menuId <Integer> ::= newMenuId.
    public menuContents <List[Symbol | {String. []}]> = List new.
    menuItemMap <Map[String, []]> = Map new.
	|
    buildMenuItemMap: ms.
    croquetView.
) (
lazy scope <String> = 'nsMenu_', menuId printString.
lazy croquetView <Promise[Alien[NewspeakCroquetFragmentView]]> = getCroquetView.
setupCroquetView = (
        croquetView <-: subscribe: scope eventSpec: #model_menu_click handler: [:e <String> | (menuItemMap at: e) value. nil]
)
buildMenuItemMap: ms <[{Symbol | {String. []}}]> ^  <Map[String, []]> = (
   ms value do: [:item <Symbol | {String. []}> |
     item = #separator ifFalse: [
       menuItemMap at: item first put: item last.
       menuContents add: {item first. [croquetView <-: publish: #menu_click scope: 'nsMenu_' data: (js global newspeakFragmentData: menuId data: item first)]}.
     ]
     ifTrue: [menuContents add: #separator].
   ]
)
) : (
)
lazy rootView <Alien[NewspeakCroquetView]> = js global at: #theView.
newButtonId ^ <Integer> = (
  buttonCount::buttonCount + 1.
  ^buttonCount
)
newImageButtonId ^ <Integer> = (
  imageButtonCount:: imageButtonCount + 1.
  ^imageButtonCount
)
newRadioButtonId ^ <Integer> = (
  radioButtonCount:: radioButtonCount + 1.
  ^radioButtonCount
)
newHyperlinkId ^ <Integer> = (
  hyperlinkCount:: hyperlinkCount + 1.
  ^hyperlinkCount
)
newCodeMirrorId ^ <Integer> = (
  codeMirrorCount:: codeMirrorCount + 1.
  ^codeMirrorCount
)
newHyperlinkImageId ^ <Integer> = (
  hyperlinkImageCount:: hyperlinkImageCount + 1.
  ^hyperlinkImageCount
)
newToggleComposerId ^ <Integer> = (
  toggleComposerCount:: toggleComposerCount + 1.
  ^toggleComposerCount
)
newCheckboxId ^ <Integer> = (
  checkboxCount:: checkboxCount + 1.
  ^checkboxCount
)
newTextEditorId ^ <Integer> = (
  textEditorCount:: textEditorCount + 1.
  ^textEditorCount
)
rootModel ^ <Alien[NewspeakCroquetView]> = (
  ^rootView model
)
newPickerId ^ <Integer> = (
  pickerCount:: pickerCount + 1.
  ^pickerCount
)
newSliderId ^ <Integer> = (
  sliderCount:: sliderCount + 1.
  ^sliderCount
)
newColorPickerId ^ <Integer> = (
  colorPickerCount:: colorPickerCount + 1.
  ^colorPickerCount
)
newDatePickerId ^ <Integer> = (
  datePickerCount:: datePickerCount + 1.
  ^datePickerCount
)
newTimePickerId ^ <Integer> = (
  timePickerCount:: timePickerCount + 1.
  ^timePickerCount
)
newSearchFieldId ^ <Integer> = (
  searchFieldCount:: searchFieldCount + 1.
  ^searchFieldCount
)
newDropDownMenuId ^ <Integer> = (
  dropDownMenuCount:: dropDownMenuCount + 1.
  ^dropDownMenuCount
)
public dropDownImage = (
  ^super dropDownImage
)
replaceUndefined: event = (
  ^js global replaceUndefined: event
)
printJSObjectTree: event  = (
  ^js global printJSObjectTree: event
)
newMenuId ^ <Integer> = (
  menuCount::menuCount + 1.
  ^menuCount
)
openMenu: aMenu <Menu> = (	
	showMenu: (computeContentForMenu: [(Menu supplier: [aMenu]) menuContents]) forShell: shell inVisual: visual.
)
computeContentForMenu: menuSupplier <[Menu]> ^ <Alien[Div]> = (
  ^super computeContentForMenu: menuSupplier
)
showMenu: menu <Alien[Div]> 
		forShell: s <HopscotchShell> 
		inVisual: v <Visual> = (
   showMenu: menu forShell: s inVisual: v 
)
) : (
)
) : (
)
