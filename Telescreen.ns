Newspeak3
'Root'
class Telescreen usingPlatform: p <HopscotchPlatform> ide: webIDE <HopscotchWebIDE> = (
(*
This class is a Work-In-Progress.
Telescreen aspires to be a presentation manager that allows embedding of live Newspeak code, and live editing of content.
This is a basic prototype, built as a conventional Newspeak Presenter-Subject-Model UI. It might be better to build it as a compund
document instead.

class Presentation models a single presentation, which is a list of documents.
The code includes TelescreenSubject/TelescreenPresenter pair, which handle the UI for a single presentation. In addition, the PresentationNamespaceSubject/PresentationNamespacePresenter pair provides a namespace for all running presentations.

Presentations are saved as zip files of a directory holding all the documents in the presentation (which are, in turn, saved as HTML files).


*)
    |
    private List = p collections List.
    private Map = p collections Map.
    private Presenter = p hopscotch Presenter.
    private Subject = p hopscotch Subject.
    private ProgrammingPresenter = webIDE browsing ProgrammingPresenter.
    private DefinitionListPresenter = webIDE browsing DefinitionListPresenter.
    private DefinitionTemplate = webIDE browsing DefinitionTemplate.
    private DefinitionListSubject = webIDE browsing DefinitionListSubject.
    private EntryPresenter = webIDE browsing EntryPresenter.
    private Root = webIDE namespacing Root.
    private NamespaceSubject = webIDE browsing NamespaceSubject.
    private Utilities = webIDE browsing Utilities.
    private webFiles = webIDE webFiles.
    private Documents = webIDE documents.
    private Document = Documents Document.
    private DocumentSubject = webIDE documents DocumentSubject.
    private JSObject = p js global at: 'Object'.
    private JSPromise = p js global at: 'Promise'.
    private JSArray = p js global at: 'Array'.
    presentationListSubject = PresentationNamespaceSubject onModel: List new.
    |
) (
public class Presentation named: n <String> (* :exemplar: Presentation named: 'ExemplarPresentation' *) = (
  (* The model for a presentation. A presentation has a #name, and consists of a list of Documents, #slides, each representing a slide.*)
  | public name <String> ::= n.  public slides <List[Document]> ::= List new. |
) (
) : (
)
class TelescreenPresenter onSubject: s <TelescreenSubject> (*:exemplar: TelescreenPresenter onSubject: (TelescreenSubject onModel: (Presentation named: 'ExemplarPresentation'))*) = ProgrammingPresenter onSubject: s (
	|
    public activeSlideIndex <Integer> ::= subject slideNumber.
	|
) (
public isKindOfTelescreenPresenter ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment>  ^ <Boolean> = (
  ^other isKindOfTelescreenPresenter
)
respondToDelete = (
	updateGUI: [
    	  Root removeKey: subject name.
	  enterSubject: NamespaceSubject new.
        ]
)
slideNumbers ^ <List[Integer]> = (
  | sns = List new. |
  1 to: subject numberOfSlides do: [:i <Integer> | sns add: i].
  ^sns
)
respondToListPresentations = (
  enterSubject: presentationListSubject
)
helpText ^ <Fragment> = (
  | 
  mapping = Map new. 
  menuImage = Utilities uriForIconNamed: #hsDropdownImage. 
  referenceImage = Utilities uriForIconNamed: #itemReferencesImage.
  |
  mapping
    at: #newSlideButton put: newSlideButton;
    at: #previousSlideButton put: previousSlideButton;
    at: #nextSlideButton put: nextSlideButton;
    at: #hopscotchTelescreenActionsMenuButton put: (dropDownMenu: [tsMenu]);
    at: #hopscotchTelescreenReferencesButton put: (itemReferencesButtonWithAction: [browseSelector: subject name]);
    at: #hopscotchSaveButton put: (saveButtonWithAction: [subject save]);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchRefreshButton put: refreshButton;
    at: #hopscotchSaveButton put: (saveButtonWithAction: [subject save]).

  ^ampleforth: 'A TelescreenPresenter presenter provides a view of a slide presentation. The first line tells you the presentation name and slide number, and provides the following buttons:
  <ul>
  <li> <div class="newSlideButton"> </div>Creates a new blank slide immediately after the current slide, and makes it the current slide. </li>
  <li> <div class="previousSlideButton"> </div>Moves to the preceding slide, if it exists. </li>
  <li> <div class="nextSlideButton"> </div>Moves to the next slide, if it exists. </li>
  <li> <div class="hopscotchTelescreenReferencesButton"> </div>Allows you to find references to this presentation. </li>
  <li><div class="hopscotchSaveButton"> </div> Downloads the presentation. The presentation is saved as a zipped directory with the same name as the presentation, inside of which each slide is saved as an HTML file representing it as a Newspeak Document.
   .</li>
 <li><div class="hopscotchRefreshButton"> </div> Refreshes the display</li>
    <li><div class="hopscotchHelpButton"> </div> Shows this help message.</li>
   <li> <div class="hopscotchTelescreenActionsMenuButton"> </div> Opens a menu of additional operations, such as listing all loaded presentations, deleting the presentation or inspecting this presenter.
 </ul> 
The current slide is shown below all of these controls. Each slide is  Document, with the usual Document affordances. See it''s help section for details.
'  mapping: mapping
)
currentSlide ^ <DocumentPresenter> = (
  ^subject currentSlide presenter
)
updateVisualsFromSameKind: oldPresenter <TelescreenPresenter> ^ <Alien[Element]> = (
  (* If the we have switched to a different slide, we must not the update the slide based the one that was displayed before -
      they are unrelated. *)
  activeSlideIndex ~= oldPresenter activeSlideIndex ifTrue: [ 
    (* Use the new visual, disregarding the old presenter entirely. This may need to be refined. *)
     ^replaceVisual: oldPresenter visual with: substance visual
  ].
  ^super updateVisualsFromSameKind: oldPresenter
)
sideBar = (
  ^column: (slideNumbers collect: [:si <Integer> |  
      link: (subject nameOfSlide: si) action: [updateGUI: [subject slideNumber: si]]])
)
newSlideButton ^ <ButtonFragment> = (
  ^addButtonWithAction: [updateGUI: [subject new]]
)
nextSlideButton ^ <ButtonFragment> = (
  ^button: 'Next' action: [updateGUI: [subject next]]
)
previousSlideButton ^ <ButtonFragment> = (
  ^button: 'Previous' action: [updateGUI: [subject previous]]
)
tsMenu ^ <Menu> = (
  ^menuWithLabelsAndActions: {
        {'List Presentations'.  [respondToListPresentations]}.
        {'Remove Current Slide'. [respondToRemoveCurrentSlide]}
        {'Delete'. [respondToDelete]}.
        {'Inspect Presenter'. [respondToInspectPresenter]}.
	}
)
respondToRemoveCurrentSlide = (
  updateGUI: [subject removeCurrentSlide]
)
definition ^ <Fragment> = (
  ^column: {
    helpSection.
    row: {
       label: subject name.
       smallBlank.
       label: 'Slide ', subject slideNumber printString.
       smallBlank.       
       newSlideButton.
       smallBlank.
       previousSlideButton.
       smallBlank.  
       nextSlideButton.
       smallBlank.
       itemReferencesButtonWithAction: [browseSelector: subject name].
       smallBlank.
       saveButtonWithAction: [subject save].
       smallBlank.
       refreshButton.			
       smallBlank.
       helpButton.
       smallBlank.
       dropDownMenu: [tsMenu].
      }.
      row: {sideBar. mediumBlank. currentSlide}
    }
)
) : (
)
public class TelescreenSubject onModel: m <Presentation> (* :exemplar: TelescreenSubject onModel: (Presentation named: 'ExemplarPresentation') *)= Subject onModel: m (
  (* Represents an actively viewed presentation.  At any time, the presentation is at a particular slide, represented by its index, #currentSlideIndex, in the slides list. The actual document representing the slide is accessible by invoking #currentSlide.
*)
  |
  public name <String> = presentation name.
  currentSlideIndex <Integer> ::= 1 min: presentation slides size.
  slides <List[DocumentSubject]> ::= presentation slides collect: [:s <Document> | DocumentSubject onModel: s].
  |
) (
public createPresenter ^ <TelescreenPresenter> = (
  ^TelescreenPresenter onSubject: self
)
public isKindOfTelescreenSubject ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment>  ^ <Boolean> = (
  ^other isKindOfTelescreenSubject
)
public previous = (
  currentSlideIndex > 1 ifTrue: [currentSlideIndex:: currentSlideIndex - 1]
)
public next = (
  currentSlideIndex < slides size ifTrue: [currentSlideIndex:: currentSlideIndex + 1]
)
public presentation ^ <Presentation> = (
  ^model
)
public slideNumber ^ <Integer> = (
  ^currentSlideIndex
)
public currentSlide ^ <DocumentSubject> = (
  slides isEmpty ifTrue: [new].
  ^slides at: currentSlideIndex
)
public numberOfSlides ^ <Integer> = (
  ^slides size
)
public nameOfSlide: i <Integer> ^ <String> (* :exemplar: nameOfSlide: 1 *) = (
  ^name, '_slide_', i printString
)
public slideNumber: i <Integer> ^ <Integer> (* :exemplar1: slideNumber: 1 *) 
(* :exemplar2: slideNumber: 0 *) (* :exemplar3: slideNumber: numberOfSlides + 1 *) 
(* :exemplar4: slideNumber: -1 *)= (
  ^currentSlideIndex:: i
)
public save = (
  | folder = (* Create a zip folder *) webFiles Folder named: name. |
  (* add docs to folder *)
  slides do: [:s <DocumentSubject> | folder addTextFile: s name, '.html' contents: s completeHTML].
  folder save.
)
public removeCurrentSlide = (
  |
  l1 <List[DocumentSubject]> = (slides copyFrom: 1 to: currentSlideIndex -1).
  l2 <List[DocumentSubject]> = slides copyFrom: currentSlideIndex +1 to: slides size.
  |  
  slides:: l1, l2.
  model slides: (slides collect: [:s <DocumentSubject> | s document]).
  previous.
)
maxClassNumber = (
  | classNums = presentation slides collect: [:s <Document> | Integer parse: (s name copyFrom: (s name indexOf: '_slide_') +7 to: s name size)]. |
  ^classNums reduce: [:cn1 :cn2 | cn1 max: cn2] ifEmpty: [0].
)
public new = (
  |
  ed <DocumentSubject> = DocumentSubject onModel: (Documents freshDocumentNamed: name, '_slide_', (maxClassNumber + 1) printString).
  l1 <List[DocumentSubject]> = (slides copyFrom: 1 to: currentSlideIndex) addLast: ed; yourself.
  l2 <List[DocumentSubject]> = slides copyFrom: currentSlideIndex +1 to: slides size.
  |
  slides:: l1, l2.
  model slides: (slides collect: [:s <DocumentSubject> | s document]).
  next.
)
) : (
)
class PresentationNamespacePresenter onSubject: s <PresentationNamespaceSubject> (* :exemplar: presentationListSubject presenter *) = DefinitionListPresenter onSubject: s (
	|
	
	|
) (
public isKindOfPresentationNamespacePresenter ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfPresentationNamespacePresenter
)
listDescription ^ <String> = (
  ^'Telescreen presentation list'
)
public title = (
  ^'Loaded Telescreen Presentations'
)
elementDescription ^ <String> = (
  ^' presentations loaded into Telescreen'
)
contentPresenters ^ <List[PresentationEntryPresenter]> = (
	| lexicalOrder <[:Presentation :Presentation | Boolean]> |
	lexicalOrder:: [:a <Presentation> :b <Presentation> |
		Utilities lexicallyLessOrEqual: a name than: b name
	].
	^(subject presentations asArray sort: lexicalOrder) collect: [:p | PresentationEntryPresenter onSubject: (TelescreenSubject onModel: p)]
)
public addNewItemTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new presentation:'
			initialText: 'NewPresentation'
			colorizerBlock:
				[:text <String> :cm <CodeMirrorFragment> | ]
			acceptResponse:
				[:template | 
                  newPresentationNamed: template text.
                  prefixState removePrefix: template.
                  updateGUI: []
              ]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]])].
)
definitionListMenu = (
  	^menuWithLabelsAndActions: {
        {'Load Presentation'. [loadPresentations]}.
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
loadPresentations = (
   multipleFileChooser chooseFileList: [:fl <List[Alien[File]]> | 
      updateGUI: [subject loadPresentations: fl]
	]
)
public completeAsyncUpdate = (
  updateGUI: []
)
) : (
)
class PresentationNamespaceSubject onModel: m <List[Presentation]> (* :exemplar: presentationListSubject *) = DefinitionListSubject onModel: m  (
	|
	public presentations <List[Presentation]> = m.
	topFolder ::= webFiles Folder named: 'TelescreenFolder'.
	|
) (
isMyKind: other ^ <Boolean> = (
  ^other isKindOfPresentationNamespaceSubject
)
public isKindOfPresentationNamespaceSubject ^ <Boolean> = (
  ^true
)
createPresenter ^ <PresentationNamespacePresenter> = (
  ^PresentationNamespacePresenter onSubject: self
)
public addPresentation: n <String> ^ <TelescreenSubject> = (
  ^TelescreenSubject onModel: (presentations add: (Presentation named: n))
)
public loadPresentations: fl <List[Alien[File]]> = (
  fl do: [:f <Alien[File]> | loadPresentation: f].
)
loadPresentation: preso <Presentation> fromZip: jsz <Alien[JSZip]> = (
  |
  ps <List[Alien[Promise[[String]]]]>  = List new.  
  a <Alien[JSArray[Promise[String]]]>
  |
  jsz forEach: [:path :zo <Alien[ZipObject]> |  
    ps add: (zo async: #string). 
    nil] onError: [:e | e printString out].
  a:: JSArray new: ps size.
  1 to: ps size do: [:i <Integer> | a at: i put: (ps at: i)].
  (JSPromise all: a) then: [:sa <JSArray[String]>  | 
       1 to: ps size do: [:i <Integer> | | s <String> = sa at: i. |
        s isEmpty ifFalse: [preso slides add: (Documents freshDocumentWithContents: s)].
        ].
        presentations add: preso.
        presenter completeAsyncUpdate.
        nil
       ] onError: [:ex | ex printString out. nil]
)
public loadPresentation:  f <Alien[File]> = (
  | 
  preso = Presentation named: ((f at: #name) copyFrom: 1 to: (f at: #name) size - 4).
  options <Alien> = JSObject new.
  folder = webFiles Folder named: preso name.
  p <Alien[Promise[JSZip]]> = folder loadAsync: f options: options. 
  |
  p then: [:jsz <Alien[JSZip]> | loadPresentation: preso fromZip: jsz. nil ]
     onError: [:ex | ex printString out. nil].
)
) : (
)
class PresentationEntryPresenter onSubject: s <TelescreenSubject> =  EntryPresenter onSubject: s(
) (
public tag ^ <String> = (
  ^subject name
)
expandedDefinition ^ <TelescreenPresenter>= (
	^subject presenter
)
presentationEntryMenu = (
  	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
collapsedDefinition = (
	^row1: {
        defaultBlank.
		row: {link: subject name action: [enterSubject: subject]}.
	} row2: {
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [presentationEntryMenu]
	}.
)
) : (
)
public newPresentationNamed: n <String> ^ <TelescreenSubject> = (
  ^presentationListSubject addPresentation: n
)
) : (
)
