Newspeak3
'Root'
class VoiceController usingPlatform: aPlatform editor: anEditor = (
(* WIP, largely written by ChatGPT.
A speech recognizer for coding Newspeak and controlling the IDE.
*)
|
    webSpeech = aPlatform js global at: #webkitSpeechRecognition.

    editor   = DummyEditor new (*anEditor*).         (* Abstraction over the Newspeak editor*)
  (* Internal state*)

    public mode ::= #command.   (* Either #command or #code *)
    listening ::= false.
    interimTranscript ::= ''.
    lastFinalTranscript ::= ''.
  (* Optional UI callbacks *)
    public onInterimTranscript ::=  [ :text | ('[interim] ', text) out].
    public onFinalTranscript ::= [ :text | ('[final] ', text) out].
    public onStatusChanged ::= [ :msg | ('[status] ', msg) out].
|
) (
class DummyEditor = () (
public goToNextMethod = (
    '[DummyEditor] goToNextMethod' out.
  )
public goToPreviousMethod = (
    '[DummyEditor] goToPreviousMethod' out.
  )
public goToMethodNamed: aName = (
    ('[DummyEditor] goToMethodNamed: ', aName) out.
  )
public selectCurrentLine = (
    '[DummyEditor] selectCurrentLine' out.
  )
public selectCurrentMethod = (
    '[DummyEditor] selectCurrentMethod' out.
  )
public selectCurrentBlock = (
    '[DummyEditor] selectCurrentBlock' out.
  )
public deleteCurrentLine = (
    '[DummyEditor] deleteCurrentLine' out.
  )
public commentSelection = (
    '[DummyEditor] commentSelection' out.
  )
public formatSelection = (
    '[DummyEditor] formatSelection' out.
  )
public runCurrentProgram = (
    '[DummyEditor] runCurrentProgram' out.
  )
public runTests = (
    '[DummyEditor] runTests' out.
  )
public toggleConsole = (
    '[DummyEditor] toggleConsole' out.
  )
public insertTextAtCaret: text = (
    ('[DummyEditor] insertTextAtCaret: ', text) out.
  )
) : (
)
lazy speechRecognizer ::= webSpeech new
  at: #continuous     put: true;
  at: #interimResults put: true;
  at: #lang           put: 'en-US';
  at: #onresult       put: [ :event | self handleResultEvent: event. nil];
  at: #onerror        put: [ :event | self handleErrorEvent: event. nil ];
  yourself.
public start = (
    listening ifTrue: [ ^self ].
    speechRecognizer start.
    listening:: true.
    self statusChanged: 'listening'.
  )
public stop = (
    listening ifFalse: [ ^self ].
    speechRecognizer stop.
    listening:: false.
    self statusChanged: 'stopped'.
  )
public toggleMode = (
    mode:: (mode == #command ifTrue: [ #code ] ifFalse: [ #command ]).
    self statusChanged: ('mode: ', mode asString).
  )
public setModeToCommand = (
    mode:: #command.
    self statusChanged: 'mode: command'.
  )
public setModeToCode = (
    mode:: #code.
    self statusChanged: 'mode: code'.
  )
isCommandMode = ( ^mode == #command )
isCodeMode    = ( ^mode == #code )
handleCommandTranscript: text = (
    (*For now, implement a tiny pattern-based parser.
     Later, you can plug in an LLM or a more structured command grammar.*)

    (self tryHandleNavigationCommand: text) ifTrue: [ ^self ].
    (self tryHandleSelectionCommand: text) ifTrue: [ ^self ].
    (self tryHandleEditingCommand:   text) ifTrue: [ ^self ].
    (self tryHandleUICommand:        text) ifTrue: [ ^self ].

    (* Fallback: unknown command *)
    self statusChanged: ('unrecognized command: ', text).
  )
handleCodeTranscript: text = (
    (*First naive version: convert some obvious spoken punctuation to characters,
     then insert at the caret. Later you swap this for something smarter
     (AST-based or LLM-backed).*)

    | normalized = normalizeCodeSpeech: text. |

    editor insertTextAtCaret: normalized.
  )
normalizeCodeSpeech: text = (
    | lower  = text asLowercase.
      tokens = lower splitOnWhitespace.
      builder ::= ''.
    |
    tokens do: [ :t |
      builder addAll:
        (t = 'colon'       ifTrue: [ ':' ]
         ifFalse: (t = 'comma'   ifTrue: [ ',' ]
         ifFalse: (t = 'dot'     ifTrue: [ '.' ]
         ifFalse: (t = 'equals'  ifTrue: [ ' = ' ]
         ifFalse: (t = 'newline' ifTrue: [ '\n' ]
           ifFalse: t))))).
	   
      builder add: '$' .  
    ].
    ^builder
  )
handleResultEvent: event = (
  | results = event at: #results.
    index   = event at: #resultIndex.
    final   ::= ''.
    interim ::= ''.
    length  = results at: #length.
  |

  (index to: length - 1) do: [ :i |
    | result = results at: i. 
      alt    = result at: 0.
      text   = alt at: #transcript.
      isFinal = result at: #isFinal.
    |
    isFinal
      ifTrue:  [ final:: final, text ]
      ifFalse: [ interim:: interim, text ].
  ].

  interim isEmpty ifFalse: [ self handleInterimTranscript: interim ].
  final   isEmpty ifFalse: [ self handleFinalTranscript: final ].
)
statusChanged: message = (
    onStatusChanged value: message.
    ('[Voice] ', message) out.
  )
handleInterimTranscript: text = (
    interimTranscript:: text.
    onInterimTranscript value: text.
  )
handleFinalTranscript: text = (
    interimTranscript:: ''.
    lastFinalTranscript:: text.
    onFinalTranscript value: text.
    self handleTranscript: text
  )
handleErrorEvent: event = (
  | error = event at: #error. |
  self statusChanged: ('speech error: ', error printString).
)
handleTranscript: text = (
    (* Simple router based on current mode and maybe magic phrases.*)
    | trimmed = text withBlanksTrimmed. |

    (self isCommandMode and: [ self isExplicitModeSwitchCommand: trimmed ])
      ifTrue: [ ^self handleModeSwitchCommand: trimmed ].

    self isCommandMode
      ifTrue:  [ self handleCommandTranscript: trimmed ]
      ifFalse: [ self handleCodeTranscript: trimmed ].
  )
isExplicitModeSwitchCommand: text = (
    (* You can expand this over time; for now just a few phrases. Worry about lower/upper case later *)
    ^{ 'switch to code mode'.
       'code mode'.
       'switch to command mode'.
       'command mode' } anySatisfy: [ :phrase |
      text asLowercase = phrase
    ]
  )
tryHandleEditingCommand: text = (
    | lower = text asLowercase. |
    (lower = 'delete line')
      ifTrue: [ editor deleteCurrentLine. ^true ].

    (lower = 'comment selection')
      ifTrue: [ editor commentSelection. ^true ].

    (lower = 'format selection')
      ifTrue: [ editor formatSelection. ^true ].

    ^false
  )
tryHandleNavigationCommand: text = (
    | lower = text asLowercase. |
    (lower = 'go to next method')
      ifTrue: [ editor goToNextMethod. ^true ].

    (lower = 'go to previous method')
      ifTrue: [ editor goToPreviousMethod. ^true ].

    (lower startsWith: 'go to method ')
      ifTrue: [
        | name = (text copyFrom: 'go to method ' size + 1 to: text size) withBlanksTrimmed. |
        editor goToMethodNamed: name.
        ^true
      ].

    ^false
  )
tryHandleSelectionCommand: text = (
    | lower = text asLowercase. |
    (lower = 'select line')
      ifTrue: [ editor selectCurrentLine. ^true ].

    (lower = 'select method')
      ifTrue: [ editor selectCurrentMethod. ^true ].

    (lower = 'select block')
      ifTrue: [ editor selectCurrentBlock. ^true ].

    ^false
  )
tryHandleUICommand: text = (
    | lower = text asLowercase. |
    (lower = 'run program') ifTrue: [ editor runCurrentProgram. ^true ].
    (lower = 'run tests')   ifTrue: [ editor runTests. ^true ].
    (lower = 'toggle console') ifTrue: [ editor toggleConsole. ^true ].
    ^false
  )
handleModeSwitchCommand: text = (
    | lower = text asLowercase. |
    (lower includesSubstring: 'code')
      ifTrue: [setModeToCode ]
      ifFalse: [setModeToCommand ].
  )
) : (
)
