Newspeak3
'Mirrors'
class MirrorsForSqueak usingPlatform: platform <Platform> vmMirror: vmm <VMMirror> = (
 (* The new Newspeak mirrors API. It is a work in progress that attempts to address weaknesses of the current API and of past mirror APIs. The mirrors here are high level mirrors: they represent language constructs in NS2 and above.

The API follows several general guidelines:

1) Operations return mirrors (an exception is getting the reflectee).
2) Operations take non-mirrors as arguments.
3) Operations take a failure block.

The motivation for (3) is that mirrors should be useful in both local and distributed settings. Forcing the user to confront the possibility of failure helps make code more robust in the distributed case.  This also contributes to (1); returned results may refer to remote values, and going through the mirror API to deal with them will help ensure failure scenarios are dealt with.

On the other hand, arguments can always be converted to mirrors by the API.  Much of the awkwardness in mirror APIs stems from the need to package arguments as mirrors - with the API often immediately extracting the reflectee afterwards.  The API should endeavor to deal with either mirrors or non-mirrors when this makes sense (e.g., when applying a mixin to a superclass, the superclass argument could be either a class or a class mirror) or to provide a separate call for mirrors (say, when adding a method - one call might accept source as a string, another a MethodMirror).

The implementation will likely change. As we reform the reflective interface, we are likely to reduce our reliance on existing code like SqueakVMMirror and NS2Reflection; either their code will migrate here or vice versa.

The API is divided into immutable and mutable parts. Mirrors are basically immutable.  As such they support introspection directly. In order to mutate code, one uses MirrorBuilders. These are created based on a mirror, and allow modifications to be accumulated without having any effect on the system.  The builder can be asked to provide a mirror reflecting its current state at any time. This allows the results of multiple builders to be batched and submitted to the atomic installer as well.

All this brings up the question of how mirrors differ from ASTs. Mirrors and ASTs should ideally be viewed as different implementations of the same interface.  Mirrors differ in how they are constructed and how they compute their subtrees. Mirrors may be connected to a live representation, or to a source base or whatever. 

MirrorBuilders also differ in supporting mutability and in what inputs can drive them (e.g, addFromSource:) so they extend the base API of mirrors and ASTs. 

It may be a while before this module realizes the ideal description given above. Also, the implementation still relies heavily on earlier reflective APIs - be they the built-in Squeak reflection classes or other efforts. Ultimately, the actual logic for this should reside here.

   Copyright 2008 Cadence Design Systems, Inc.
   Copyright (c) 2009-2010 Gilad Bracha
   Copyright 2011 Gilad Bracha, Ryan Macnak and Cadence Design Systems

   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|  
private MutableHashedMap = platform collections Dictionary.
private MutableList = platform collections OrderedCollection.
private IdentitySet = platform squeak IdentitySet.
private IdentityDictionary = platform squeak IdentityDictionary.

private Duct = platform ducts Duct.
private WeakStorage = platform ducts WeakStorage.

private Metaclass = platform kernel Metaclass.

private atomicInstaller = platform namespace AtomicInstaller usingPlatform: platform vmMirror: vmm.

private groups = platform namespace MirrorGroups usingLib: platform.
private intermediates = platform namespace Intermediates usingPlatform: platform.
private ImmutableMirrorGroup = groups ImmutableMirrorGroup.

private vmmirror = vmm.

public (* bogus *) parserLib = Future computing: [platform namespace CombinatorialParsing usingPlatform: platform].
(* Often imported by other module because it is annoying to get and assemble the parts to instaniate it. *)
public (* bogus *) grammar = Future computing: [platform namespace NewspeakGrammar usingPlatform: platform parsers: parserLib].
(* Used by the language adaptor for the colorizer. *)
asts = Future computing: [platform namespace NewspeakASTs usingLib: platform].
parsing = Future computing: [platform namespace NewspeakParsing
	usingPlatform: platform
	grammar: grammar
	asts: asts].
public (* bogus *) compilation = Future computing: [platform namespace Newspeak2SqueakCompilation
	usingPlatform: platform 
	newspeakParser: parsing
	intermediates: intermediates].

protected storedCompiler (* cached compiler and module *)

private mixinBasedMirrors <WeakIdentitySet[MixinMirror]> = WeakStorage new.

public channelForMemoryHole = (Duct owner: self) beWeak. (* bogus *)
|) (
public class ClassDeclarationBuilder fromIntermediate: ir <IntermediateClassDeclaration> forExistingMixin: mixin <InstanceMixin> = (
(*Builders do not give an ordinary mirror representing their current state: ask the builder itself. (Although this could be done: submit to atomic install without a namespace, don't install into Smalltalk, don't update the existingMixin, and reflect on the result.)

Builders internally keep a CompiledMixinMirror that reflects the current state, including edits made but not yet installed. Queries reflect the state of this CMM.

Builders are connected up and down.  If you get a builder on a declaration, if you ask *the builder* for an enclosing or nested declaration and edit, installing any of them means installing all of them.  Builders created de novo (via reflecting: or fromSource:) remain independent.*)|
	public prvtIntermediate <CompiledMixinMirror> = ir.
	
	public header <ClassHeaderBuilder> = ClassHeaderBuilder forIntermediate: ir.
|prvtIntermediate existingMixin: mixin) (
'API'
public accessModifier = (
	(*TODO: we might want to change an access modifier. Currently this is only a getter reading from the old existing mixin. *)
	^ prvtExistingMixin accessModifier
)
public enclosingClass ^<ClassDeclarationBuilder> = (
	| enclosingMixin <Mixin> enclosingDecl |

	nil = prvtIntermediate enclosingClass ifFalse: 
		[^prvtIntermediate enclosingClass declaration builder].

	nil = prvtIntermediate existingMixin ifTrue: 
		[^nil].

	enclosingMixin:: prvtIntermediate existingMixin enclosingMixin.
	nil = enclosingMixin ifTrue:
		[^nil].
	
	enclosingDecl:: ClassDeclarationBuilder reflecting: enclosingMixin.
	enclosingDecl prvtIntermediate instanceSide nestedClasses do: 
		[:e | e simpleName = prvtIntermediate simpleName ifTrue:
			[prvtIntermediate accessor: e accessor]].
	enclosingDecl prvtIntermediate instanceSide nestedClasses removeAllSuchThat:
		[:e | e simpleName = prvtIntermediate simpleName].
	enclosingDecl prvtIntermediate instanceSide nestedClasses
		add: prvtIntermediate.
	enclosingDecl instanceSide nestedClasses addMirror: self.
	prvtIntermediate enclosingClass: enclosingDecl prvtIntermediate instanceSide.
	^enclosingDecl
)
public headerFromSource: newHeader <String> = (
	| prefix newIR |

	(* only top-level classes can specify categories *)
	prefix:: prvtIntermediate isTopLevel
		ifTrue: [ 'Newspeak3 ''', header category, ''' ' ]
		ifFalse: [ ' ' ].

	self enclosingClass. (* For side effect. *)
	newIR:: compiler
		compileClassHeader: (prefix, newHeader)
		within: prvtIntermediate enclosingClass.

	checkForSlotConflicts: newIR.
	assert: [prvtIntermediate name = newIR name] message: ''.

	prvtIntermediate headerSource: newIR headerSource.
	prvtIntermediate factoryName: newIR factoryName.
	prvtIntermediate comment: newIR comment.
	prvtIntermediate accessor: newIR accessor.
	prvtIntermediate factory: newIR factory.
	prvtIntermediate initializers: newIR initializers.
	prvtIntermediate instanceSide slots: newIR instanceSide slots.
)
public install ^<ClassDeclarationMirror> = (
	
	^(installAtomically: {self}) first
)
public name ^<Symbol> = (
	^prvtIntermediate simpleName
)
public reflectee ^<InstanceMixin | nil> = (
	#BOGUS yourself.
	(* If this builder corresponds to a class declaration that was already installed, we're okay. But this builder might represent a new class declaration that doesn't have a corresponding Mixin yet (#install will ensure it is filled, though). So, do we return a potentially nil reflectee or not support accessing a reflectee at all? *)
	
	^prvtExistingMixin
)
public simpleName ^<Symbol> = (
	self warnObsolete.
	^self name
)
'as yet unclassifed'
public printOn: stm = (
	stm nextPutAll: 'ClassDeclarationBuilder:'; nextPutAll: name
)
'as yet unclassified'
public classSide ^<MixinBuilder> = (
	| ir builder |
	prvtIntermediate builder = nil ifTrue: [halt].
	ir:: prvtIntermediate classSide.
	builder:: ir builder.
	nil = builder ifTrue:
		[builder:: MixinBuilder forClassDeclaration: self intermediate: ir.
		 ir builder: builder].
	^builder
)
public instanceSide ^<MixinBuilder> = (
	| ir builder |
		prvtIntermediate builder = nil ifTrue: [halt].

	ir:: prvtIntermediate instanceSide.
	builder:: ir builder.
	nil = builder ifTrue:
		[builder:: MixinBuilder forClassDeclaration: self intermediate: ir.
		 ir builder: builder].
	^builder
)
public prvtExistingMixin = (
	^prvtIntermediate existingMixin
)
public prvtExistingMixin: m = (
	^prvtIntermediate existingMixin: m
)
public qualifiedName ^<Symbol> = (
	^prvtIntermediate qualifiedName
)
public source ^<String> = (
	^String streamContents:
		[:stream |
		stream nextPutAll: prvtIntermediate headerSource.
		stream nextPutAll: ' ('; cr.
		(instanceSide nestedClasses
			asSortedList: [:a :b | a simpleName <= b simpleName])
			do: [:nc | stream nextPutAll: nc source].
		writeOrganizationOf: instanceSide on: stream.
		stream nextPutAll: ') : ('; cr.
		writeOrganizationOf: classSide on: stream.
		stream nextPut: ")"; cr]
)
private writeOrganizationOf: mixin on: stream = (
	mixin methods do:
		[:method | 
		stream nextPut: "'"; nextPutAll: method category; nextPut: "'"; cr.
		stream nextPutAll: method source; cr].
)
'private'
checkForNameChange: newCompiledMixinMirror = (
	
	(fullyQualifiedNameToSimple: newCompiledMixinMirror name) = self simpleName
		ifFalse: [Error signal: 'Cannot change name this way'].
)
checkForSlotConflicts: newIntermediate <IntermediateClassDeclaration> = (
	
	newIntermediate instanceSide slots do:
		[:slot <IntermediateSlotDeclaration> | 
		instanceSide
			checkNameConflictsForSlot: slot name
			mutable: slot isMutable].
)
public notifyExistingMirrors = (
	instanceSide notifyExistingMirrors.
	classSide notifyExistingMirrors.
)
'restricted'
public collectExistingMixinsInto: map <Map[IntermediateClassDeclaration, InstanceMixin]> ^<IntermediateClassDeclaration> = (
	prvtExistingMixin ifNotNil: [map at: prvtIntermediate put: prvtExistingMixin].
	instanceSide nestedClasses do: [:ea | ea collectExistingMixinsInto: map].
	^prvtIntermediate
)
public extractReflecteeFrom: mixin <Mixin> = (

	(* For builders that already had a non-nil reflectee, this is not necessary since the old reflectee has been become:d to the new one (at least if atomic install is working right...).  But this is required for builders that have been created from source and didn't have a reflectee yet.  This will connect them to their reflectees. *)

	prvtExistingMixin:: mixin.
	
	mixin nestedMixins keysAndValuesDo: [:n :nestedMixin |
		| m |
		m:: instanceSide nestedClasses findMirrorNamed: n.
		m extractReflecteeFrom: nestedMixin
	].
)
public ultimateInstallee ^<ClassDeclarationBuilder> = (
	| topMostDirtyIntermediate <IntermediateClassDeclaration> |
	topMostDirtyIntermediate:: prvtIntermediate.
	[nil = topMostDirtyIntermediate enclosingClass] whileFalse: 
		[topMostDirtyIntermediate:: topMostDirtyIntermediate enclosingClass declaration].	
	^topMostDirtyIntermediate builder
)
'testing'
public isClassDeclarationMirror ^<Boolean> = (
	^true
)
) : (
'accessing'
public fromSource: src <String> ^<ClassDeclarationBuilder> = (
	^self fromUnitSource: 'Newspeak3 ''Uncategorized'' ', src
)
'as yet unclassified'
public fromUnitSource: source <String> ^<ClassDeclarationBuilder> = (
	| ir <IntermediateClassDeclaration> builder |
	ir:: compiler compileClassSource: source within: nil.
	builder:: fromIntermediate: ir forExistingMixin: nil.
	ir builder: builder.
	^builder
)
public reflecting: mixin <InstanceMixin> ^<ClassDeclarationBuilder> = (
	| ir builder |
	assert: [mixin isMixin & mixin isMeta not] message: 'Provide an instance-side mixin'.
	ir:: buildIntermediateFor: mixin.
	builder:: self fromIntermediate: ir forExistingMixin: mixin.
	ir builder: builder.
	^builder
)
)
public class ClassDeclarationMirror reflecting: mixin <Mixin> = Mirror reflecting: mixin (
(* A class declaration defines the instance and class sides, and a header. Each side comprises methods and nested classes. The header provides a superclass clauses, a primary factory a class comment and an instance initializer.  

This mirror provides a view of a class declaration based on its runtime representation in the Newspeak image running on Squeak. To create an instance, provide the instance-side mixin. The mirror can obtain all necessary information from that. *)|
	instanceSideLazy
	classSideLazy
|assert: [mixin isMixin & mixin isMeta not] message: 'Provide an instance-side mixin') (
'API'
public classSide ^ <MixinMirror> = (
	classSideLazy ifNil: [
		classSideLazy:: MixinMirror reflecting: reflectee classMixin].
	^classSideLazy
)
public enclosingClass ^ <ClassDeclarationMirror> = (
	| enclosing <InstanceMixin> |
	enclosing:: reflectee enclosingMixin. 
	nil == enclosing ifTrue: [^nil].
	^ClassDeclarationMirror reflecting: enclosing mixin
)
public header ^ <ClassHeaderMirror> = (
	^ClassHeaderMirror reflecting: reflectee
)
public instanceSide ^ <MixinMirror> = (
	instanceSideLazy ifNil: [
		instanceSideLazy:: MixinMirror reflecting: reflectee].
	^instanceSideLazy
)
public name ^ <Symbol> = (
	^self simpleName
)
public simpleName ^ <Symbol> = (
	^reflectee simpleName
)
public source ^<String> = (
	^String streamContents: [:stm | reflectee printClassOn: stm]
)
'as yet unclassified'
public = other = (
	^other isClassDeclarationMirror and: [self reflectee == other reflectee]
)
public accessModifier ^ <Symbol>= (
	(*	Finding the accessModifier of a class Declaration is hell. ClassDeclarationBuilders are
		constructed from a mixin. Mixins, by definition, do not know with which accessModifier they
		are applied with. So, we ask the enclosing mixin instead and assume that top-level mixins can
		only be applied as public. *)
	^ reflectee accessModifier
)
public applyToObject ^<ClassMirror> = (
	nil = reflectee enclosingMixin ifFalse: [^notTopLevel].
	^ClassMirror reflecting: (reflectee apply: Object withName: reflectee simpleName)
)
public asBuilder = (
	^ClassDeclarationBuilder reflecting: reflectee
)
public compilationUnitSource ^<String> = (
	^String streamContents: [:stm | reflectee printTopClassOn: stm]
)
public definingMixin ^ <MixinMirror> = (
	| enclosing <InstanceMixin> |
	enclosing:: reflectee enclosingMixin. 
	nil == enclosing ifTrue: [^nil].
	^MixinMirror reflecting: enclosing mixin
)
public hasBody ^ <Boolean> = (
 (* Does my reflectee have a class body *)
	(* A bit of a hack, until we have clean per-mixin metadata *)
	^instanceSide initializer metadata at: #hasBody ifAbsent:[true].
)
public hash = (
	^reflectee identityHash
)
public qualifiedName ^ <Symbol> = (
	^reflectee qualifiedName
)
'testing'
public isClassDeclarationMirror ^<Boolean> = (
	^true
)
) : (
)
class ClassHeaderBuilder forIntermediate: ir = (|
protected intermediate <ClassDeclarationBuilder> = ir.  
|) (
'as yet unclassified'
public category ^<Symbol> = (
	^intermediate category ifNil: ['Uncategorized']
)
public classComment ^<String> = (
	^(compilation parser classHeader parseString: source) classComment
)
public classComment: newClassComment <String> = (
	| ast token newHeaderSource |
	ast:: grammar TypedNS3Grammar new classHeader parseString: source.
	token:: (ast at: 8) at: 2.
	
	newHeaderSource:: 
		(source copyFrom: 1 to: token start + 2), 
		newClassComment,
		(source copyFrom: token end - 1 to: source size).

	intermediate
		headerSource: newHeaderSource;
		comment: newClassComment.
)
public name ^<Symbol> = (
	^intermediate name
)
public name: newSimpleName <Symbol> = (
	| declaration <ClassDeclarationBuilder> token newClassSource newIR |
	
	declaration:: intermediate builder.

	(* check for name conflict with sibling members *)
	intermediate isTopLevel ifFalse:
		[ | existing |
		existing:: intermediate builder enclosingClass instanceSide nestedClasses findMirrorNamed: newSimpleName.
		(nil = existing or: [existing = intermediate builder])
			ifFalse: [^Error signal: 'A sibling already exists with the name ', newSimpleName]].

	(* patch header source with the new name *)
	token:: (grammar TypedNS3Grammar new classHeader parseString: source) at: 3.
	newClassSource::
		(intermediate isTopLevel
			(* only top-level classes can specify categories *)
			ifTrue: [ 'Newspeak3 ''', category, ''' ' ]
			ifFalse: [ ' ' ]),
		(source copyFrom: 1 to: token start - 1) ,
		newSimpleName ,
		(source copyFrom: token end + 1 to: source size).

	(* compile etc *)
	declaration enclosingClass. (* For side effect. *)
	newIR:: compiler
		compileClassHeader: newClassSource
		within: intermediate enclosingClass.
		
	intermediate simpleName: newIR simpleName.
	intermediate headerSource: newIR headerSource.
	intermediate factoryName: newIR factoryName.
	intermediate comment: newIR comment.
	intermediate accessor: newIR accessor.
	intermediate factory: newIR factory.
	intermediate initializers: newIR initializers.
	intermediate instanceSide slots: newIR instanceSide slots.
)
public primaryFactory ^ <MethodBuiler> = (

	| factoryName intermediateMethod |
	factoryName:: intermediate factoryName.
	intermediateMethod:: intermediate classSide methods
		detect: [:im | im simpleName = factoryName].

	^MethodBuilder reflecting: intermediateMethod in: intermediate builder classSide
)
public source ^<String> = (
	^intermediate headerSource
)
public source: newHeaderSource <String> = (
	intermediate builder headerFromSource: newHeaderSource
)
) : (
)
class ClassHeaderMirror reflecting: mixin <Mixin> = Mirror reflecting: mixin ((* A class header defines the class' name, primary factory, superclass clause, class comment and instance initializer (slots and init expressions).

This mirror provides access to a class header based on the runtime representation. *)) (
'API'
public category ^ <Symbol> = (
	^reflectee category
)
public classComment ^ <String> = (
	^(compilation parser classHeader parseString: source) classComment
)
public declaration ^<ClassDeclarationMirror> = (
	^ClassDeclarationMirror reflecting: self reflectee
)
public primaryFactory ^ <MethodMirror> = (

	^MethodMirror reflecting: (reflectee classMixin
		methodDict at: primaryFactoryName)
)
public source ^ <String> = (
	^ reflectee cachedHeaderSource
)
'as yet unclassified'
public initializer = (
	#BOGUS.
	reflectee methodDictionary keysAndValuesDo:
		[:selector :method |
		(isSubinitializerSelector: selector) ifTrue:
			[^MethodMirror reflecting: method]].
	halt.
)
public isClassHeaderMirror ^<Boolean> = (
	^true
)
public name ^ <Symbol> = (
	^reflectee name
)
public preamble ^<Symbol> = (
	(* Foo factory = SuperFoo superFactory *)
	| headerAst |
	headerAst:: compilation parser classHeader parseString: source.
	^source copyFrom: headerAst start to: headerAst superConstructorCall end
)
public primaryFactoryName ^ <Symbol> = (
	^reflectee cachedConstructorName
)
public qualifiedName ^ <Symbol> = (
	^reflectee qualifiedName
)
public sendsSelector: sel <Symbol> ^<Boolean> = (
	(* This is incomplete for the quick send selectors. *)
	(* Look through instance initializers. *)
	reflectee methodDictionary keysAndValuesDo:
		[:selector :method |
		(isSubinitializerSelector: selector) ifTrue:
			[(method hasLiteral: sel) ifTrue: [^true]]].
	(* Look at the nested class accessor, if nested. *)
	reflectee enclosingMixin ifNotNil: [:parent | 
		((parent compiledMethodAt: simpleName) hasLiteral: sel) ifTrue: [^true]].
	^false
)
public simpleName ^ <Symbol> = (
	^fullyQualifiedNameToSimple: name
)
public slots ^ <MirrorGroup[SlotDeclarationMirror]> = (
	^ImmutableMirrorGroup group: 
		((reflectee slots
			reject: [:ea | ea first includes: "`"])
				collect: [:ea | 
					(SlotDeclarationMirror named: ea first mutable: ea second accessModifier: ea last)
					  mixin: reflectee; yourself
					])
)
public superclassClause ^ <SendAST> = (
	| ast <ClassHeaderAST> |
      ast:: compilation parser classHeader parseString: source.
      ^ast superCall. 
)
) : (
)
public class ClassMirror reflecting: c <Behavior> = Mirror reflecting: c () (
'as yet unclassified'
public = other = (
	^other isClassMirror and: [vmmirror is: reflectee identicalTo: other reflectee]
)
public allSuperclasses ^ <List[ClassMirror]> = (
	| klass <ClassMirror> superclasses <List[ClassMirror]> |
	superclasses:: MutableList new.
	klass:: superclass.
	[klass isNil] whileFalse: [
		superclasses add: klass.
		klass:: klass superclass.
	].
	^superclasses
)
public canUnderstand: selector <Symbol> ^<Boolean> = (
	
	(mixin canUnderstand: selector) ifTrue: [^true].
	superclass
		ifNil: [^false]
		ifNotNil: [^superclass canUnderstand: selector].
)
computeMirrorGroup: mgAccessor <[:Mirror | MirrorGroup]> ^ <MirrorGroup> = (
	(* Return a mirror group based on the mixins group and those of all superclasses. The argument mgAccessor extracts a mirror group from any mirror provided to it. *)
	| mg <MirrorGroup>  |
	mg:: MutableMirrorGroup group: {} within: self.
	(allSuperclasses reverse add: self; yourself) do:
		[:klass <ClassMirror> |
		mg addAllMirrors: (mgAccessor value: klass mixin)].
	^ImmutableMirrorGroup group: mg	
)
public enclosingObject ^<ObjectMirror> = (
	^ObjectMirror reflecting:
		(reflectee language isNewspeakLanguage3
			ifTrue: [reflectee enclosingObjectSlot]
			ifFalse: [nil])
)
public hash = (
	^vmmirror identityHashOf: reflectee
)
public isClassMirror = (
	^true
)
public methods ^<MirrorGroup[MethodMirror]> = (
	^computeMirrorGroup: [:r | r methods]
)
public mixin ^<MixinMirror> = (
	^MixinMirror reflecting: reflectee mixin
)
public name ^ <Symbol> = (
	^reflectee name
)
public nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	^computeMirrorGroup: [:r | r nestedClasses]
)
public simpleName ^<Symbol> = (
	^ mixin simpleName
)
public slots ^<MirrorGroup[SlotMirror]> = (
	^computeMirrorGroup: [:r <MixinMirror>  | r slots].
)
public superclass ^<ClassMirror> = (
	reflectee superclass isNil ifTrue: [^nil].
	^ClassMirror reflecting: reflectee superclass
)
) : (
)
class ImmutableMirrorGroupInMixin group: mirrorz in: mixinMirror = ImmutableMirrorGroup group: mirrorz (|
	public enclosingMixin <MixinMirror> = mixinMirror.
	public definingMixin <MixinMirror> = mixinMirror.
	public channelForChanges <Duct> = Duct new.
|channelForChanges beWeak owner: self) (
'private'
private notifyAddedMirror: newMirror = (
	channelForChanges send: (MirrorAddedEvent forNewMirror: newMirror)
)
private notifyRemovedMirror: oldMirror = (
	channelForChanges send: (MirrorRemovedEvent forOldMirror: oldMirror)
)
private notifyReplacedMirror: oldMirror with: newMirror = (
	channelForChanges send: (MirrorReplacedEvent from: oldMirror to: newMirror)
)
'restricted'
public updateToContain: actualMirrors <Collection[Mirror]> = (	
	| mirrorNames |
	#ACCESSBOGUS.
	mirrorNames:: actualMirrors collect: [:newMirror |
		| oldMirror |
		oldMirror:: findMirrorNamed: newMirror simpleName.
		oldMirror == nil ifTrue: [
			mirrors addLast: newMirror.
			notifyAddedMirror: newMirror.
		] ifFalse: [
			oldMirror = newMirror ifTrue: [
				(* Unchanged *)
			] ifFalse: [
				mirrors at: (mirrors indexOf: oldMirror) put: newMirror.
				notifyReplacedMirror: oldMirror with: newMirror.
			]
		].
		newMirror simpleName.
	].

	mirrors copy do: [:oldMirror |
		(mirrorNames includes: oldMirror simpleName) ifFalse: [
			mirrors remove: oldMirror.
			notifyRemovedMirror: oldMirror.
		].
	].
)
) : (
)
class InitializerMethodMirror reflecting: m <MethodReference> = MethodMirror reflecting: m (
(* Initializers are distinnct in Newspeak and therefore require distinct mirrors. 
A mirror on an initilaizer is based upon a method, but in practice the implementation of 
the initializer is often spread across multiple methods.  The exact scheme will vary based
on details of the implementation. The knowledge of these details should be limited to the
compiler and the mirror system.  Indeed, the purpose of this class is to abstract those 
details so that tools like the IDE need not be aware of them.

 *)) (
'as yet unclassified'
public isInitializerMethodMirror ^ <Boolean> = (
	^true
)
public source ^ <String> = (
	^definingMixin declaration header source
)
) : (
)
public class MethodBuilder reflecting: ir in: mb = (|
	public prvtIntermediate <IntermediateMethod> = ir.
	prvtMixinBuilder <MixinBuilder> = mb.
|) (
'as yet unclassified'
public accessModifier ^<Symbol> = (
	^prvtIntermediate accessModifier
)
public category ^<Symbol> = (
	^prvtIntermediate category
)
public category: cat <String | Symbol> = (
	^prvtIntermediate category: cat asSymbol
)
public definingMixin ^<MixinBuilder> = (
	^prvtMixinBuilder
)
public name ^<Symbol> = (
	^prvtIntermediate selector
)
public reflectee ^<CompiledMethod> = (
	#BOGUS yourself.
	(* Poorly defined: If this a new method, the compiled method retrieved from the low level method would not be able to answer with its source.  This is because in Squeak, the compiled method has to ask for it from its class, which will fail if the method is not yet installed. Perhaps it would be better to not give access to this. *)
	(* ^lowLevelMethodMirror compiledMethod *)
	FAIL.
)
public selector ^<Symbol> = (
	^name
)
public simpleName ^<Symbol> = (
	^name
)
public source ^<String> = (
	^prvtIntermediate method 
		ifNil: [prvtIntermediate source]
		ifNotNil: [:it | it getSource]
)
) : (
)
public class MethodMirror mirroring: m <CompiledMethod> = Mirror reflecting: m (
(* A basic mirror for a language level method. *)) (
'as yet unclassified'
public = other = (
	^other isKindOfMethodMirror
		and: [reflectee == other reflectee]
)
public accessModifier ^<Symbol> = (
	reflectee isProtected ifTrue: [^#protected].
	reflectee isPrivate ifTrue: [^#private].
	^#public
)
public category ^<Symbol> = (
	^reflectee methodClass ifNotNil: [:mc| mc organization categoryOfElement: name]
)
public definingMixin ^<MixinMirror> = (
	^MixinMirror reflecting: reflectee methodClass mixin
)
public hash = (
	^reflectee identityHash
)
public isExpression ^<Boolean> = (
	^reflectee properties at: #isExpression ifAbsent: [false].
)
public isInitializer ^ <Boolean> = (
	^(isSubinitializerSelector: reflectee selector)
)
public isKindOfMethodMirror ^<Boolean> = (
	^true
)
public isMethodMirror ^<Boolean> = (
	^true
)
public metadata = (
	^reflectee properties
)
public name ^<Symbol> = (
	^reflectee selector
)
public sendsSelector: sel <Symbol> ^<Boolean> = (
	(* This is incomplete for the quick send selectors. *)
	^reflectee hasLiteral: sel
)
public simpleName = (
	^ name
)
public source ^<String> = (
	| sourceAvailable |
	sourceAvailable:: (reflectee properties includesKey: #source) or: [(reflectee trailer hasSourcePointer)].
	^sourceAvailable ifTrue: [reflectee getSource asString] ifFalse: [nil]
)
) : (
'as yet unclassified'
public reflecting: method <CompiledMethod> = (
	^(isSubinitializerSelector: method selector) 
		ifTrue: [InitializerMethodMirror reflecting: method]
		ifFalse: [self mirroring: method]
)
)
class Mirror reflecting: r <Object> = (
(* Top of the Mirror hierarchy. An abstract class. *)|
	public reflectee <Object> = r.
|) (
'as yet unclassified'
public = other = (
	^self class = other class and: [self reflectee == other reflectee]
)
public hash = (
	^ reflectee identityHash
)
public isMirror ^<Boolean> = (
	^true
)
public printOn: stm = (
	stm nextPutAll: class simpleName.
	stm nextPutAll: ' reflecting: '.
	reflectee printOn: stm.
)
) : (
)
class MirrorAddedEvent forNewMirror: m = MirrorEvent (
(* Sent by a mirror group on its channelForUpdates when a new mirror has been added. *)|
	public newMirror = m.
|) (
'as yet unclassified'
isMirrorAddedEvent ^<Boolean> = (
	^true
)
) : (
)
class MirrorEvent = (
(*  *)|
|) (
'testing'
isMirrorEvent ^<Boolean> = (
	^true
)
) : (
)
class MirrorRemovedEvent forOldMirror: m = MirrorEvent (
(* Sent by a mirror group on its channelForUpdates when an existing mirror has been removed. *)|
	public oldMirror = m.
|) (
'as yet unclassified'
isMirrorRemovedEvent ^<Boolean> = (
	^true
)
) : (
)
class MirrorReplacedEvent from: oldM to: newM = MirrorEvent (
(* Sent by a mirror group on its channelForUpdates when an existing mirror has been replaced by a new mirror. *)|
	public oldMirror = oldM.
	public newMirror = newM.
|) (
'as yet unclassified'
isMirrorReplacedEvent ^<Boolean> = (
	^true
)
) : (
)
public class MixinBuilder forClassDeclaration: cbd intermediate: mixinIR = (
(* The mirror builder for mixins.  See MixinMirror. *)|
	private intermediate <IntermediateMixin> = mixinIR.
	public methods <MutableMethodGroup> = MutableMethodGroup group: (methodsFrom: mixinIR) within: mixinIR.
	public nestedClasses <MutableNestedClassGroup> = MutableNestedClassGroup group: (nestedClassesFrom: mixinIR) within: mixinIR.
|) (
'accessing'
public canUnderstand: selector <Symbol> ^<Boolean> = (
	
	(* Slot, method, nested class, or factory method *)
	
	(methods includesMirrorNamed: selector) ifTrue: [^true].
	(nestedClasses includesMirrorNamed: selector) ifTrue: [^true].
	(slots includesMirrorNamed: selector) ifTrue: [^true].
	(selector last = ":") ifTrue: [
		#BOGUS. (* Someday immutable slots will be enforced and this won't be quite right *)
		(slots includesMirrorNamed: (selector allButLast: 1)) ifTrue: [^true].
	].
	isMeta ifTrue: [
		declaration header primaryFactory simpleName = selector ifTrue: [^true].
	].
	^false
)
public slots ^ <ImmutableMirrorGroup[SlotMirror]> = (
	| slotMirrors <Collection[SlotMirror]> | 
	slotMirrors:: (intermediate slots collect:
		[:each <IntermediateSlotDeclaration> |
		SlotDeclarationMirror
			named: each name
			mutable: each isMutable
			accessModifier: each accessModifier])
		reject:
		[:each <SlotDeclarationMirror> | each name includes: "`"].
	^ImmutableMirrorGroup group: slotMirrors
)
'as yet unclassified'
public checkNameConflictsForSlot: slotName <Symbol> mutable: isMutable <Boolean> = (
	(nestedClasses includesMirrorNamed: slotName) 
		ifTrue: [^Error signal: 'Class already has nested class named ', slotName].		
	(methods includesMirrorNamed: slotName)
		ifTrue: [^Error signal: 'Class already has method named ', slotName].
	(isMutable and: [methods includesMirrorNamed: slotName, ':'])
		ifTrue: [^Error signal: 'Class already has method named ', slotName].
)
public declaration ^<ClassDeclarationBuilder> = (
	^intermediate declaration builder
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
public isMeta ^<Boolean> = (
	^intermediate isMeta
)
'private'
methodsFrom: mixinIR <IntermediateMixin> ^<List[MethodBuilder]> = (
	^(mixinIR methods 
		reject: [:m <LowLevelMethodMirror> | m isSynthetic])
			collect: [:m <LowLevelMethodMirror> | MethodBuilder reflecting: m in: self]
)
nestedClassesFrom: mixinIR <IntermediateMixin> ^<List[ClassDeclarationBuilder]> = (
	^mixinIR nestedClasses collect: [:nestedClassIR <IntermediateNestedClass> | | nc nestedMixin |
		
		(* The existingMixin will be nil if this is a new (uninstalled) class declaration. *)
		(* MUST COMPUTE THIS BEFORE CONSTRUCTING! Cannot be filled in after constructing the nested CDB or CDs with more than one level of nested will not be attached to their existing mixin! *)
		declaration reflectee ifNotNil: [:mixin |
			nestedMixin:: mixin nestedMixins at: nestedClassIR simpleName ifAbsent: [].
		].
		
		nc:: (ClassDeclarationBuilder fromIntermediate: nestedClassIR forExistingMixin: nestedMixin).
		nestedClassIR builder: nc.
		nc
	]
)
public notifyExistingMirrors = (
	isMeta
		ifTrue: [mixinChanged: declaration reflectee classMixin]
		ifFalse: [mixinChanged: declaration reflectee].

	nestedClasses do: [:ea | ea notifyExistingMirrors].
)
) : (
'as yet unclassified'
public reflecting: mxn <Mixin | ClassMixin> ^<MixinBuilder> = (
	^mxn isMeta
		ifTrue: [(ClassDeclarationBuilder reflecting: mxn instanceMixin) classSide]
		ifFalse: [(ClassDeclarationBuilder reflecting: mxn) instanceSide]
)
)
public class MixinMirror reflecting: m <Mixin> = Mirror reflecting: m (
(* A mixin is the difference between a class and its superclass: a set of additional methods, slots and nested class declarations.  Newspeak class declarations define an instance-side mixin and a class-side mixin, and Newspeak classes (other than Top) are all the result of mixin application.

What about mirroring the initializer?

Need to decide who does these things - the class declaration mirror or the mixin mirror. One should delegate to the other. *)|
	slotsLazy
	methodsLazy
	nestedClassesLazy
	accessModifierLazy
|mixinBasedMirrors add: self) (
'accessing'
public applications ^<Set[ClassMirror]> = (

	^reflectee applications collect: [:ea | ClassMirror reflecting: ea]
)
public canUnderstand: selector <Symbol> ^<Boolean> = (
	
	(* Slot, method, nested class, or factory method *)
	
	(methods includesMirrorNamed: selector) ifTrue: [^true].
	(nestedClasses includesMirrorNamed: selector) ifTrue: [^true].
	(slots includesMirrorNamed: selector) ifTrue: [^true].
	(selector last = ":") ifTrue: [
		#BOGUS. (* Someday immutable slots will be enforced and this won't be quite right *)
		(slots includesMirrorNamed: (selector allButLast: 1)) ifTrue: [^true].
	].
	isMeta ifTrue: [
		declaration header primaryFactory simpleName = selector ifTrue: [^true].
	].
	^false
)
public declaration ^ <ClassDeclarationMirror> = (
	^ClassDeclarationMirror 
		reflecting: (isMeta ifFalse:[reflectee] ifTrue:[reflectee instanceMixin]) 
)
public isMeta ^ <Boolean> = (
	^self reflectee isMeta
)
public methods ^ <MirrorGroup[MethodMirror]> = (
	methodsLazy ifNil: [
		methodsLazy:: ImmutableMirrorGroupInMixin group: computeMethods in: self].
	^methodsLazy
)
public name ^ <Symbol> = (
	^reflectee simpleName
)
public nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	nestedClassesLazy ifNil: [
		nestedClassesLazy:: ImmutableMirrorGroupInMixin group: computeNestedClasses in: self].
	^nestedClassesLazy
)
public simpleName ^ <Symbol> = (

	^reflectee simpleName
)
public slots ^ <MirrorGroup[SlotMirror]> = (
	slotsLazy ifNil: [
		slotsLazy:: ImmutableMirrorGroupInMixin group: computeSlots in: self].
	^slotsLazy
)
'as yet unclassified'
public = other <Object> ^<Boolean> = (
	^other isKindOfMixinMirror and: [reflectee = other reflectee]
)
public accessModifier ^ <Symbol> = (
	warnObsolete.
	accessModifierLazy ifNil: [
		accessModifierLazy:: computeAccessModifiers].
	^ accessModifierLazy
)
public classMixin ^ <MixinMirror> = (
	isMeta 
		ifFalse:[^MixinMirror reflecting: reflectee classMixin]
		ifTrue:[^MixinMirror reflecting: Metaclass mixin].
)
computeAccessModifiers = (
	^ ((ClassDeclarationMirror reflecting: reflectee) accessModifier)
)
computeMethods ^ <Collection[MethodMirror]> = (

	^(reflectee methodDictionary values
		collect: [:each <CompiledMethod> | MethodMirror reflecting: each])
			reject: [:each <MethodMirror> | each reflectee isSynthetic].
)
public enclosingMixin ^ <MixinMirror> = (
	| enclosing |
	enclosing:: reflectee enclosingMixin.
	nil = enclosing ifTrue:[^nil].
	^MixinMirror reflecting: enclosing
)
public initializer ^ <MethodMirror> = (
	reflectee methodDictionary keysAndValuesDo:
		[:selector :method |
		(isSubinitializerSelector: selector) ifTrue:
			[^MethodMirror reflecting: method]].
	^nil
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
public qualifiedName ^ <Symbol> = (
	^reflectee qualifiedName
)
'private'
computeNestedClasses ^<Collection[ClassDeclarationMirror]> = (
	| metadata |
	isMeta ifTrue: [^{}].

	^reflectee nestedMixins values 
		collect: [:each | ClassDeclarationMirror reflecting: each]
)
computeSlots ^ <Collection[SlotDeclarationMirror]> = (

	^(reflectee slots 
		reject: [:iv <{String. Boolean. Symbol}> | iv first includes: "`"])
			collect: [:iv <{String. Boolean. Symbol}> | 
				(SlotDeclarationMirror named: iv first mutable: iv second accessModifier: iv last)
				  mixin: reflectee;
				  yourself
				 ].
)
'restricted'
public mixinChanged = (
	#ACCESSBOGUS.
	slotsLazy ifNotNil: [:it | it updateToContain: computeSlots].
	methodsLazy ifNotNil: [:it | it updateToContain: computeMethods].
	nestedClassesLazy ifNotNil: [:it | it updateToContain: computeNestedClasses].
	accessModifierLazy ifNotNil: [:it | accessModifierLazy:: computeAccessModifiers].
)
) : (
)
class MutableMethodGroup group: mirrors within: ir = MutableMirrorGroup group: mirrors within: ir () (
'accessing'
public addFromSource: s <String> ^<MethodBuilder> = (
	| 
	ir <IntermediateMethod>
	oldMirror <MethodBuilder>
	newMirror <MethodBuilder>
	|
	ir:: compiler
		compileMethodSource: s 
		within: enclosingMixin.
	
	oldMirror:: findMirrorNamed: ir simpleName.
	(* Category must be set or it will think it's synthetic and lose the source *)
	nil = oldMirror 
		ifTrue:
			[ir category: #'as yet unclassified']
		ifFalse: 
			[ir category: oldMirror category.
			 removeMirror: oldMirror].
	
	newMirror:: MethodBuilder reflecting: ir in: enclosingMixin.
	addMirror: newMirror.
	^newMirror
)
public addMirror: m <MethodBuilder>= (
	
	(* What would it mean if a user of builders called this?  A MethodMirror would need to be converted to a MethodBuilder.  A MethodBuilder that already is a member of another method group may need to be copied. *)
	
	intermediate checkNameConflictsForMethod: m name.
	
	super addMirror: m.
	intermediate methods add: m prvtIntermediate.
	^m
)
removeMirror: mirror <MethodBuilder> = (
	intermediate methods remove: mirror prvtIntermediate.
	super removeMirror: mirror.
)
) : (
)
class MutableMirrorGroup group: ms within: ir = ImmutableMirrorGroup group: ms (
(* A mirror group for high level mirrors. Takes base level elements as arguments to be added, and supports a notion of ordering, so that source declaration ordering can be preserved.

A MutableMirrorGroup knows about its enclosing mirror, because it supports adding members in source form via the #addFromSource: abstract method, which is specialized by subclasses. The source must be compiled, and that requires the enclosing mirror to provide the necessary surrounding scope.
*)| 
	protected intermediate <IntermediateMixin> = ir.
|) (
'as yet unclassified'
public addAllMirrors: mirrorGroup <MirrorGroup | Collection[Mirror]> = (
	mirrorGroup do: [:each | addMirror: each]
)
public addFromSource: s <String> = (
	self subclassResponsibility
)
public addMirror: m <Mirror>  = (
	mirrors keysAndValuesDo: [:index :mirror | 
		mirror name = m name ifTrue: [^mirrors at: index put: m]].
	^mirrors addLast: m
)
public enclosingMixin ^<MixinBuilder> = (
	(* definingMixin? *)
	^intermediate builder
)
mirrors ^ <MutableHashedMap[Mirror]> = (
(* mirrors is also an outer scope slot; we define this method to ensure we get the inherited one. *)
	^super mirrors
)
public removeAll = (
	mirrors: MutableList new.
)
public removeAllSuchThat: blk = (
	mirrors select: blk thenDo: [ :m <Mirror> | removeMirrorNamed: m name].
)
public removeMirror: m <Mirror> = (
	^mirrors remove: m
)
public removeMirrorNamed: n <Symbol | String> = (
	| m |
	m:: findMirrorNamed: n.
	^m ifNotNil: [removeMirror: m].
)
) : (
)
class MutableNestedClassGroup group: mirrors within: mb = MutableMirrorGroup group: mirrors within: mb (
(*  *)|
|) (
'accessing'
public addFromSource: source <String> ^<ClassDeclarationBuilder> = (
	| 
	ir <IntermediateClassDeclaration>
	oldMirror <ClassDeclarationBuilder>
	newMirror <ClassDeclarationBuilder>
	|
	ir:: compiler 
		compileClassSource: source
		within: intermediate.
		
	oldMirror:: findMirrorNamed: ir simpleName.
	nil = oldMirror ifFalse:
		[removeMirror: oldMirror].
	
	newMirror:: ClassDeclarationBuilder fromIntermediate: ir forExistingMixin: nil.
	ir builder: newMirror.
	addMirror: newMirror.
	^newMirror
)
public addMirror: m <ClassDeclarationBuilder> = (

	#BOGUS yourself.
	(* What would it mean if a user of builders called this?  A ClassDeclarationMirror would need to be converted to a ClassDeclarationBuilder.  A ClassDeclarationBuilder that already has an enclosing class different than this group's would need to be deep copied. *)

	intermediate checkNameConflictsForNestedClass: m name.
	super addMirror: m.
	intermediate nestedClasses include: m prvtIntermediate.
	^m
)
'as yet unclassified'
removeMirror: mirror <ClassDeclarationBuilder> = (
	intermediate nestedClasses remove: mirror prvtIntermediate.
	super removeMirror: mirror.
)
) : (
)
public class ObjectMirror reflecting: r <Object> = Mirror reflecting: r (
(* A high level mirror on local objects. The API for a Newspeak object mirror is exceedingly simple. One can view or change its reflectee's class; one can send the reflectee a message; one can set the reflectee's slots; and one can request access to the reflectee.  We may later extend this with printing/safe printing, the ability to execute an arbitrary method on the reflectee, or generalized super-object access.

All of this is realized in methods of this class, except reflectee access which is inherited.

Note that there is no need to get slots - we can send a message to do that.  However, for the time being we support that as well, as there is no way to access overridden features.

The differences between #perform: on an object and a mirror are:

1. The mirror can perform private messages.
2. The mirror forces the user to deal with possible failure.
3. The result is also a mirror.

We may choose to refactor the implementation so that all the work is done by a NewspeakObjectMirorUtility. The idea is that in cases where many objects are involved, it is wasteful to allocate a dedicated mirror per object. Instead,  the utility can be shared across all the objects. This works as long as we are prepared to give out a global authority to mirror all objects; if we want fine grain security, we need a capability per object.

Copyright (c) 2009-2010 Gilad Bracha

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ''Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*)) (
'as yet unclassified'
public = other <Object> ^<Boolean> = (
	^other isObjectMirror
		and: [vmmirror is: reflectee identicalTo: other reflectee]
)
public evaluate: expression <String>
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (
	
	(* Evaluate [expression] with the reflectee as the receiver. If [expression] cannot be compiled, activate [compilationErrorHandler] with the exception. If the evaluation of [expression] raises an error, activate [evalErrorHandler] with the error. Otherwise return an ObjectMirror on the result of [expression]. *)
	
	| cls mxn mtdMirror result |
	[cls:: vmmirror classOf: reflectee.
	mxn:: MixinMirror reflecting: cls mixin.
	mtdMirror:: compiler
		compileExpressionSource: expression
		inContext: nil
		inMixin: mxn. 
		
	mtdMirror category: #DoIts.
	mtdMirror methodMixin: cls mixin definingClass.
	mtdMirror compiledMethod properties
		at: #source put: expression;
		at: #debugInfo put: mtdMirror debugInfo]
			on: Error
			do: [:e | ^compilationErrorHandler cull: e ].
	
	[result:: vmmirror 
		object: reflectee 
		executeMethod: mtdMirror compiledMethod
		with: {}
		ifFail: [ ^compilationErrorHandler cull: (Error description: 'primitiveExecuteMethod failed') ]]
			on: Error
			do: [:e | ^evalErrorHandler cull: e].

	^ObjectMirror reflecting: result
)
public evaluate: expression <String> 
withBlackMarket: blackMarket <Object> 
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (

	(* Evaluate [expression] with the reflectee as the receiver. Allow [`] as an identifier, bound to [blackMarket]. If [expression] cannot be compiled, activate [compilationErrorHandler] with the exception. If the evaluation of [expression] raises an error, activate [evalErrorHandler] with the error. Otherwise return an ObjectMirror on the result of [expression]. *)
	
	| cls mxn mtdMirror result |
	[cls:: vmmirror classOf: reflectee.
	mxn:: MixinMirror reflecting: cls mixin.
	mtdMirror:: compiler
		compileExpressionSource: expression asString
		inContext: nil
		inMixin: mxn
		allowBlackMarket: true.
		
	mtdMirror category: #DoIts.
	mtdMirror methodMixin: cls mixin definingClass.
	mtdMirror compiledMethod properties
		at: #source put: expression;
		at: #debugInfo put: mtdMirror debugInfo]
			on: Error
			do: [:e | ^compilationErrorHandler cull: e ].
	
	[result:: vmmirror 
		object: reflectee 
		executeMethod: mtdMirror compiledMethod
		with: {blackMarket}
		ifFail: [ ^compilationErrorHandler cull: (Error description: 'primitiveExecuteMethod failed') ]]
			on: Error
			do: [:e | ^evalErrorHandler cull: e].

	^ObjectMirror reflecting: result
)
public getClass ^<ClassMirror>  = (
	^ClassMirror reflecting: (vmmirror classOf: reflectee)
)
public getSlot: slotName <Symbol> ^<ObjectMirror> = (
	^self class reflecting: 
		(vmmirror
			namedSlotOf: reflectee
			at: ((vmmirror classOf: reflectee) allInstVarNames indexOf: slotName)
			ifFail: [halt])
)
public hash ^<Integer> = (
	^self class hash bitXor: (vmmirror identityHashOf: reflectee)
)
public indexedSlotAt: index <Integer> = (
	(* Provisional *)
	^self class reflecting:
		(vmmirror indexedSlotOf: reflectee at: index ifFail: [halt])
)
public indexedSlotAt: index <Integer> put: value <Object> = (
	(* Provisional *)
	vmmirror indexedSlotOf: reflectee at: index put: value ifFail: [halt]
)
public indexedSlotSize ^<Integer> = (
	(* Provisional *)
	^vmmirror indexedSlotsOf: reflectee
)
public isObjectMirror = (
	^true
)
public perform: selector <Symbol> with: args <Array[Object]> ifFail:  fblk <[:Exception]>  ^ <ObjectMirror> = (
	| result <Object> |
	result:: [reflectee perform: selector withArguments: args] on: Error do: [:ex <Error> | ^fblk value: ex].
	^self class reflecting: result
)
public safePrintOn: stream <WriteStream> = (
	#BOGUS. (* Sending #name is not guarenteed safe. *)
	stream nextPutAll:
		([String streamContents: [:s | reflectee printOn: s]]
			on: Error
			do: ['an instance of ', (vmmirror classOf: reflectee) name])
)
public safePrintString ^<String> = (
	^String streamContents: [:s | safePrintOn: s]
)
public safePrintStringLimitedTo: limit <Integer> ^<String> = (
	#BOGUS. (* Sending #name is not guarenteed safe. *)
	^[reflectee printStringLimitedTo: limit]
		on: Error
		do: ['an instance of ', (vmmirror classOf: reflectee) name]
)
public setClass: newClass <ClassMirror> = (
	vmmirror changeClassOf: reflectee to: newClass reflectee ifFail: [halt].
)
public setSlot: slotName <Symbol> to: obj <Object> = (
	vmmirror
		namedSlotOf: reflectee
		at: ((vmmirror classOf: reflectee) allInstVarNames indexOf: slotName)
		put: obj
		ifFail: [halt]
)
) : (
)
class SlotDeclarationMirror named: n <String> mutable: m <Boolean> accessModifier: am <Symbol> = Mirror reflecting: n (|
	public (* bogus *) mutable = m.
	public accessModifier = am.
	public mixin <Mixin>
|) (
'as yet unclassified'
public = other = (
	(* BOGUS. Should check declared in the same mixin. *)
	^other isKindOfSlotDeclarationMirror
		and: [self name == other name]
		and: [self mutable == other mutable]
		and: [self accessModifier == other accessModifier]
)
public hash = (
	^name hash
)
public isKindOfSlotDeclarationMirror ^<Boolean> = (
	^true
)
public isMutable = (
	(* Used by compiler in scope building *)
	^mutable
)
public name ^ <String> = (
	#BOGUS yourself.
	^reflectee
)
public simpleName = (

	^ name
)
public source = (
	| myTree <SlotDefAST> ast <ClassHeaderAST> |
	ast:: compilation parser classHeader parseString: mixin cachedHeaderSource.
	myTree:: (ast slots select: [:t | t name = name]) first.
	^ mixin cachedHeaderSource copyFrom: myTree start to: myTree end
)
) : (
)
'API'
public installAtomically: builders <List[ClassDeclarationBuilder]> 
^<List[ClassMirrorBuilder]> = (
(*	
mirrors:: platform mirrors.

a:: mirrors ClassDeclarationBuilder reflecting: A mixin.
b:: mirrors ClassDeclarationBuilder reflecting: B mixin.

a headerFromSource: 'A = (|  aa bb |)'.
b headerFromSource: 'B = (| cc dd |)'.

mirrors installAtomically: {a. b}
*)

	| 
	topmostBuilders <List[CDB]> = builders collect: [:ea | ea ultimateInstallee].
	reps <List[IntermediateClassDeclaration]>
	existingMixinMap <IdentityMap[MixinRep,InstanceMixin]> = IdentityDictionary new.
	mixinResults <List[InstanceMixin]>
	|
	
	#BOGUS. (* We should check that the set of builders is disjoint *)
	
	(* Have builders construct their new IntermediateClassDeclaration and fill in existing mixins *)
	reps:: topmostBuilders collect: [:b | b collectExistingMixinsInto: existingMixinMap].

	(* Submit to atomic install *)
	mixinResults:: atomicInstaller install: reps withExistingMixins: existingMixinMap.
	
	(* Fill-in reflectees, important for builders that were created from source *)
	topmostBuilders with: mixinResults do: 
		[:builder :newMixin |	builder extractReflecteeFrom: newMixin].

	(* Notify those listening on the mirrors' Ducts (the IDE) *)
	topmostBuilders do: [:b | b notifyExistingMirrors]. 
	
	#BOGUS yourself.
	(* Should these events come from the IDE instead? Deletion events only make sense from the IDE. *)
	mixinResults do: [:mixin | channelForMemoryHole send: mixin definingClass].
	
	^builders collect: [:b | ClassDeclarationMirror reflecting: b reflectee]
)
'as yet unclassified'
public compiler ^ <Newspeak3Compilation Compiler> = (
	#ACCESSBOGUS.
	storedCompiler ifNil: [storedCompiler:: compilation Compiler new].
	^storedCompiler
)
fullyQualifiedNameToSimple: name = (
	^(name subStrings: {"`"}) last asSymbol
)
isSubinitializerSelector: selector = (
	nil == selector ifTrue: [^false].
	(selector startsWith: 'mixinInitializer`') ifTrue: [^true].
	(selector startsWith: 'initializer`') ifTrue: [^true].
	^false
)
isSyntheticSlotSelector: selector = (
	^selector endsWith: '`slot'
)
mixinChanged: mixin = (
	mixinBasedMirrors do: [:mirror | 
		mirror reflectee = mixin ifTrue: [mirror mixinChanged]].
)
'construct-intermediate'
buildIntermediate: i <IntermediateMixin> from: mixin <AbstractMixin> = (
	| initializers = MutableList new. |
	
	mixin methodDictionary keysAndValuesDo: 
		[:selector :method |
		|
		imethod = intermediates IntermediateMethod new.
		category = mixin organization categoryOfElement: selector.
		|
		imethod method: method.
		imethod methodMixin: mixin.
		imethod selector: selector.
		imethod accessModifier: method accessModifier.
		imethod isSynthetic: nil = category.
		imethod category: category.
		(isSubinitializerSelector: selector) ifTrue:
			[initializers add: imethod].
		imethod isSynthetic ifFalse:
			[i methods add: imethod]].
	
	mixin isMeta ifTrue:
		[ | factoryName factoryCM factoryIR |
		factoryName:: mixin instanceMixin cachedConstructorName.
		factoryCM:: mixin methodDictionary at: factoryName.
		factoryIR:: intermediates IntermediateMethod new.
		factoryIR method: factoryCM.
		factoryIR methodMixin: mixin.
		factoryIR selector: factoryName.
		factoryIR accessModifier: factoryCM accessModifier.
		factoryIR isSynthetic: true.
		factoryIR category: nil.
		i declaration factory: factoryIR.
		^self].
	
	i declaration initializers: initializers. 
	
	mixin slots do:
		[:tuple |
		| slot = intermediates IntermediateSlotDeclaration new. |
		slot name: (tuple at: 1).
		slot isMutable: (tuple at: 2).
		slot accessModifier: (tuple at: 3).
		(isSyntheticSlotSelector: slot name) ifFalse: 
			[i slots add: slot]].
	
	mixin nestedMixins valuesDo:
		[:nestedMixin <InstanceMixin> | 
		| 
		nestedIR <IntermediateClassDeclaration> 
		accessorCM <CompiledMethod> 
		accessorIR <IntermediateMethod>
		|
		nestedIR:: buildIntermediateFor: nestedMixin.
		i nestedClasses add: nestedIR.
		
		accessorCM:: mixin methodDictionary at: nestedIR simpleName.
		accessorIR:: intermediates IntermediateMethod new.
		accessorIR method: accessorCM.
		accessorIR methodMixin: mixin.
		accessorIR selector: nestedIR simpleName.
		accessorIR accessModifier: accessorCM accessModifier.
		accessorIR isSynthetic: true.
		accessorIR category: nil.
		nestedIR accessor: accessorIR].
)
buildIntermediateFor: mixin <InstanceMixin> ^<IntermediateClassDeclaration> = (
	| i = intermediates IntermediateClassDeclaration new. |
	i simpleName: mixin simpleName.
	i headerSource: mixin cachedHeaderSource.
	i factoryName: mixin cachedConstructorName.
	i comment: nil.
	i category: mixin category.
	buildIntermediate: i instanceSide from: mixin.
	buildIntermediate: i classSide from: mixin classMixin.
	^i
)
) : (
)
