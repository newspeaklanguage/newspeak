Newspeak3
'Newspeak'
class NewspeakTypechecker usingPlatform: p ide: ide ast: astModule namespace: ns = (
(* A visitor that computes the type of a Newspeak program.

Newspeak has no global namespace, but a nominal typechecker needs one. The typechecker takes a namespace as a parameter to its factory.  All types are identified by a fully qualified name that is rooted in a top level class that is stored in this namespace. Well, almost.  Details below.

Fully qualified names are used to define object types (see below). The checker has utilities to convert between classes and object types.

Types are represented via a class hierarchy that consists of:

a. Type, the abstract class at the top of the hierarchy.
b. ObjectType, which is defined by an underlying mixin.
c. FunctionType, which is defined by a pair of a list of argument types and a return type.
d. ErrorType, the magical type that is a subtype and supertype of everything and supports all methods. There is a special subclass
	of ErrorType, AccessErrorType, for errors involving accessibility violations. We cache singleton instances for both.
e. UnionType, defined by a list of types that are acceptable at a given point.
f. TypeVariable, defined by its name, and a bound, which is a type.
g. Pseudo types (subclasses of PseudoType) used to represent the receiver types of self, super, here and outer sends (respectively SelfType, SuperType, HereType, OuterType).  Each such type captures the special lookup rules of the corresponding send, especially wrt access control. This ensures that for each kind of send, the type exposes methods that are valid.
h. GenericType, defined by an object type representing the generic, and a list of type arguments. For the time being, we largely ignore generics.

The typechecker is designed to be incremental. The basic ideas go back as far as the Cecil typechecker, but are properly explained in the context of Scala optimization in the OOPSLA 2016 paper: Parallel Incremental Whole-Program Optimizations for Scala.js.

These principles are:

a. Access to program structure beyond the method currently being typechecked must go through a query API. This API will track any dependencies of the method on types of other program components.

b. These queries are pure functions of immutable data and the program.

c. We maintain dependencies between (previously) typechecked methods and queries.  We also maintain dependencies between queries and the program parts they describe.

d. Query results are cached, and invalidated if the source code they depend on has changed. This means that we will need to either:
 1. Note when a given change is made and invalidate its dependent queries, or
 2. Compute a diff when a typecheck starts, and use it to decide which changes have been made, and thus invalidate any dependent
	queries.
  There are two kinds of queries: SignatureQuery, representing signatures of members, and SubtypeQuery, representing the results of
  subtype tests (more on these below). Each kind of query has its results cached separately. Signature query results are stored in
  cachedTypes. Subtype query results are cached in trail (The term trail originates in algorithms dealing with recursive types, as far
  back as Algol 68).

e. Memory required grows linearly with program size, as both the number of methods and the queries about them are proportional to code size.

f. Time is proportional to the size of the code being typechecked (especially if we note changes as they occur).  Initial typechecks may be slower, as they often require global program information like subtype relations, but this should not be an issue. We can also trade memory for time  by constructing cached subtype queries at type definition time if need be.

The query hierarchy consists of:

a. Query,  the abstract class at the top of the hierarchy.
b. Subtype(T, S) where T and S are types, which answers whether T <: S.
c. Signature(T, m) where T is a type and m is a selector, which yields the FunctionType of method m in type T, or Error if m is undefined.

We maintain three maps of dependencies:

a. dependentDeclarations. A Map[Query, Set[Declaration]] which lists, for each query q, all declarations whose typecheck required q.
b. dependentQueries. A Map[Declaration, Set[Query]] which lists, for each declaration d, all queries that refer to d.
c. queriesOfDeclaration. A Map[Declaration, Set[Query]] which lists, for each declaration d, all queries that d used in its last typecheck.

Declarations can be methods but also class headers.

All this is encapsulated in this module, which eventually needs to be fed into the IDE.  Even in an offline scenario where the typechecker is used as a service, the dependencies need to exist.  Other tools need to maintain the dependencies as code changes.

Errors are reported by calling the error:at: method, which produces a TypeError object and adds it to a set that is returned by the typecheck. If the set is empty, typechecking succeeded. The client can then determine how to report the errors, which carry a message and source location information.

More on namespacing:

While modules in Newspeak are completely self contained (modulo inheritance from Object) types inherently cross module boundaries, as they describe inter-module communication.  A module typically traffics in some datatypes that it does not define. The obvious example
is the types of the parameters to the factory method, which must originate elsewhere, unless they are all instances of the basic classes inherited from Object and their allied types. However, such types can also originate as inputs to arbitrary methods.

It follows that these types cannot be found by Newspeak's dynamic lookup rules, which are restricted to the module and its superclass
chain. The need for an external namespace stems from the above considerations.

The scoping rules for types largely follow the Newspeak lookup rules, but they deviate for the following reasons:

a. The need to lookup in the external namespace as noted above. We use a global, top level namespace that is consulted after conventional lookup has failed. In addition, the concept of conflict namespaces is used. See below.

b. The namespace of types includes type variables that have no runtime presence. These include the special type Self and any
type parameters (though these we may forego).

c.  We cannot follow the dynamic lookup rules precisely, because the typechecker is doing a static lookup. In particular, it does not have  access to actual classes and their associated class hierarchy. Instead, it must work based on class declarations. These specify superclasses via expressions in their superclass clauses. These expressions cannot be evaluated by the typechecker, as it is intended to typecheck declarations in isolation with no access to a module's actual factory parameters.  Instead, these superclass expressions must typechecked, and a superclass type inferred in the process.  Care must be taken to avoid infinite regress in this situation.  First, we must detect circular references among superclass clauses. These are neither impossible nor illegal in Newspeak. Consider

class Inane () (
  class X = Y ()()
  class Y = X()()
)

This is perfectly valid, and nothing bad will happen until one of the classes Inane>>X or Inane>>Y, or a subclass thereof, is instantiated, at which point we have an infinite loop. The typechecker however, should not loop in such situations.  Furthermore, we need to be able to detect the class Object at the end of the superclass chain without provoking such a cycle. This also requires care.


 If a class named C uses a type that conflicts with the top level namespace, then a special conflict namespace #'C conflicts' is added to the top level and is consulted before looking up things at the top level. The typechecker does not look into other nested namespaces.


 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 (c) Google Inc. 2016 - 2017.

Use and distribution of this software is subject to the terms of the attached source license.


*)
|
(* imports *)
private List = p collections List.
private Map = p collections Map.
private Set = p collections Set.

private TypeIdAST = astModule TypeIdAST.
private TupleAST = astModule TupleAST.
private ParameterizedTypeAST = astModule ParameterizedTypeAST.
private UnaryTypeOpAST = astModule UnaryTypeOpAST.
private BinaryTypeOpAST = astModule BinaryTypeOpAST.
private MessagePatternAST = astModule MessagePatternAST.
private SlotDefAST = astModule SlotDefAST.
private ImmutableSlotDefAST = astModule ImmutableSlotDefAST.
private VarDeclAST = astModule VarDeclAST.

private ClassDeclarationMirror = p mirrors ClassDeclarationMirror.
private MixinMirror = p mirrors MixinMirror.

private Scope = p mirrors compiler Scope.

(* module variables *)

parser <NewspeakParsing Parser> = p mirrors compilation parser.
namespace <Map[Symbol, Object]> = ns.
trail <Map[SubtypeQuery, Boolean]> = Map new.
scopeStack <List[Scope]> = List new.
typeBuilder <TypeBuilder>
currentClass <MixinMirror>
currentTopLevelClass <ClassDeclarationMirror>
currentDeclaration <Symbol>
currentReturnType <ObjectType>
errorSet <Set>

objectMixin <MixinMirror> = (localMember: #Object in:  (MixinMirror reflecting: (namespace at: #Kernel) mixin)) instanceSide.
klassMixin <MixinMirror> = (localMember: #Class in:  (MixinMirror reflecting: (namespace at: #Kernel) mixin)) instanceSide.
nilMixin <MixinMirror> = (localMember: #UndefinedObject in:  (MixinMirror reflecting: (namespace at: #Kernel) mixin)) instanceSide.
boolMixin <MixinMirror> = (localMember: #Boolean in:  (MixinMirror reflecting: (namespace at: #Kernel) mixin)) instanceSide.
errorType <ErrorType> = ErrorType new.
accessErrorType <AccessErrorType> = AccessErrorType new.
bottom <BottomType> = BottomType new.
dependentDeclarations <Map[Query, Set[Declaration]]> = Map new.
queriesOfDeclaration <Map[Declaration, Set[Query]]> = Map new.
dependentQueries <Map[Declaration, Set[Query]]> = Map new.
cachedTypes <Map[Query, Type]> = Map new.
superclassTable <Map[Mixin, Mixin]> = Map new.
cycle = Object new.
|
superclassTable at: klassMixin put: objectMixin.
) (
class AccessErrorType = ErrorType (
(* A special type for access errors. These need to be reported whenever they come up, so they need to be preserved in caches.
   This, they are distinct from normal type errors.
*)
) (
public isKindOfAccessErrorType ^ <Boolean> = (
	^true
)
) : (
)
class BottomType = Type (
(* The bottom of the type lattice. *)
) (
public apply: v  = (
  ^v bottomType: self
)
public asFunctionType ^ <FunctionType> = (
  ^FunctionType domain: List new range: self
)
public subtypeOf: t <Type> ^ <Boolean> = (
	^true
)
) : (
)
class ErrorDummy = (
(*
The purpose of this class is to provide a dummy mixin that we can associate with the error type.
*)
) (
) : (
)
class ErrorType = Type (
(* The error type. *)
) (
public apply: v  = (
  ^v errorType: self
)
public asFunctionType  = (
  ^self
)
public at: o = (
(* One can ask an error type for the type of any selector, or for the type of the nth argument for any n *)
	^self
)
public domain = (
	^self
)
public isKindOfErrorType ^ <Boolean> = (
	^true
)
public mixin = (
  ^(ClassDeclarationMirror reflecting: ErrorDummy mixin) instanceSide
)
public name ^ <String> = (
  ^'Unspecified type'
)
public range = (
	^self
)
public subtypeOf: t <Type> ^ <Boolean> = (
	^true
)
) : (
)
class FunctionType domain: d <List[Type]> range: r <Type> = Type (
(* The type of a method. *)
|
	public domain <List[Type]> = d.
	public range <Type> = r.
|) (
public = o = (
	o isKindOfFunctionType ifFalse: [^false].
	^domain = o domain and: [range = o range]
)
public apply: v  = (
  ^v functionType: self
)
public asFunctionType  = (
  ^self
)
public hash ^ <Integer> = (
	^(domain hash xor: range hash) bitXor: class hash
)
public isKindOfFunctionType ^ <Boolean> = (
	^true
)
public subtypeOf: t <Type> ^ <Boolean> = (
 | ft <FunctionType> ftd <List[Type]> |
	t = errorType ifTrue: [^true].
	t isKindOfFunctionType ifFalse: [^false] ifTrue: [ft:: t].

	(range subtypeOf: ft range) ifFalse: [^false].
	ftd:: ft domain.
	domain size = ftd size ifFalse: [^false].
	1 to: domain size do: [:i <Integer> |
		((ftd at: i) subtypeOf: (domain at: i)) ifFalse: [^false]
		].
	^true.
)
) : (
)
class GenericType generic: g <ObjectType> typeArguments: tas <List[ObjectType]> = ObjectType forMixin: g mixin (
(* A generic (aka parameterized) type such as List[String]. *)
|
	public generic <ObjectType> = g.
	public typeArguments <List[ObjectType]> = tas.
|) (
public = o = (
	o isKindOfGenericType ifFalse: [^false].
	^mixin = o mixin and: [typeArguments = o typeArguments]
)
public apply: v = (
  ^v genericType: self
)
public at: selector <Symbol> ^ <FunctionType> = (
	halt.
)
public hash ^ <Integer> = (
	^(mixin hash bitXor: class hash) bitXor: typeArguments hash
)
public isKindOfGenericType ^ <Boolean> = (
	^true
)
public isKindOfObjectType ^ <Boolean> = (
	^false
)
public printOn: s = (
	s nextPutAll: class name.
	s nextPutAll: ' generic: '.
	s nextPutAll: mixin printString.
	s nextPutAll: ' typeArguments: ['.
	typeArguments do: [:ta <ObjectType> |
		s nextPutAll: ta printString.
		s nextPut: ' '.
		].
	s nextPut: ']'.
)
public subtypeOf: t <Type> ^ <Boolean> = (
	halt.
)
) : (
)
class HereType forMixin: m <MixinMirror> = PseudoType forMixin: m (
(* The type of the lexical scope. *)
) (
public = o = (
	o isKindOfHereType ifFalse: [^false].
	^mixin = o mixin
)
public at: selector <Symbol> ^ <FunctionType> = (
(* Override so that we don't insist on public members only *)
 |
m <Mirror> = hereMember: selector in: mixin.
signature <MessagePatternAST | SlotDefAST | ClassHeaderAST | Nil>
|

  nil = m ifTrue: [^errorTypeForSelector: selector].
  signature:: signatureFor: m withSelector: selector.
  nil = signature ifTrue: [^errorType].
  ^((signature apply: selfSubstitution) apply: typeBuilder) asFunctionType
  (* deal with substitution of Self and build a function type *)
)
public isKindOfHereType ^ <Boolean> = (
	^true
)
public isKindOfObjectType ^ <Boolean> = (
(* Bogus. If we give it the right path and fix sub/supertype methods as suggested in comments,
	we can get rid of this as well as = and hash*)
	^false
)
selfIdAST ^ <AST> = (
	(* should be a type variable; definitely not the here type *)
)
selfSubstitution ^ <Substitutor> = ( (* we should cache these *)
	 ^Substitutor forSubstitution: (Map new at: #Self put: typeOfSelf; yourself)
)
public subtypeOf: t <Type> ^ <Boolean> = (
(* could use equality *)
	assert: [false] message: 'No one should ask a here type if it is a subtype of anything!'
)
supertype ^ <ObjectType> = ( (* Could return Object *)
	assert: [false] message: 'Here types have no supertype, and no one should ask!'
)
) : (
)
class ObjectType forMixin: m <MixinMirror> = Type (
(* The type of an Object. *)
|
	public mixin = m.
|) (
public = o ^ <Boolean> = (
	o isKindOfObjectType ifFalse: [^false].
	^mixin = o mixin
)
public apply: v  = (
  ^v objectType: self
)
public asFunctionType ^ <FunctionType> = (
  ^FunctionType domain: List new range: self
)
public at: selector <Symbol> ^ <FunctionType> = (
 | m <Mirror | Nil> = publicMember: selector at: mixin. signature <MessagePatternAST> |

  nil = m ifTrue: [^errorTypeForSelector: selector].
  signature:: signatureFor: m withSelector: selector.
  ^((signature apply: selfSubstitution) apply: myTypeBuilder) asFunctionType
  (* deal with substitution of Self and build a function type *)
)
errorTypeForSelector: selector  = (
   | result |
   result::  anyMember: selector at: mixin.
   result = nil ifTrue: [^errorType].
   ^accessErrorType
)
public hash ^ <Integer> = (
	^mixin hash bitXor: class hash
)
public isKindOfObjectType ^ <Boolean> = (
	^true
)
myTypeBuilder ^ <TypeBuilder> = (
(* really need to cache this somewhere *)
	^typeBuilderFor: mixin declaration
)
public name ^ <String> = (
	^mixin name.
)
public printOn: s = (
	s nextPutAll: class name.
	s nextPutAll: ' forMixin: '.
	s nextPutAll: mixin name
)
selfIdAST ^ <AST> = (
| tree <AST> |
	assert: [path isEmpty not] message: 'Object type must have non-empty path'.
	tree:: TypeIdAST new name: path first.
	(2 to: path size) do: [:i |
		tree:: UnaryTypeOpAST new
				operand: tree;
				operator: (path at: i);
				yourself.
		].
	^tree
)
selfSubstitution ^ <Substitutor> = ( (* we should cache these out the object type *)
	 ^Substitutor forSubstitution: (Map new at: #Self put: selfIdAST; yourself)
)
signatureFor: m <Mirror> withSelector: selector <Symbol> ^ <MessagePatternAST> = (
	^m isKindOfMethodMirror ifTrue: [
		parser parseMessagePattern: m source. (* parse the message pattern *)
		] ifFalse: [
		m isKindOfSlotDeclarationMirror
			ifTrue: [signatureForSlot: m withSelector: selector]
			ifFalse: [signatureForNestedClass: m]
		].
)
signatureForNestedClass: m <ClassDeclarationMirror> ^ <MessagePatternAST> = (
	| classType <UnaryTypeOpAST> |
	classType:: UnaryTypeOpAST new
		operand: (TypeIdAST new name: m name; yourself);
		operator: #class;
		yourself.
	^MessagePatternAST new
		selector: m name;
		parameters: {};
		returnType: classType;
		accessModifier: m accessModifier;
		yourself
)
signatureForSlot: m <SlotDeclarationMirror> withSelector: selector <Symbol> ^ <MessagePatternAST> = (
	| ast <SlotDefAST> = parser parseSlotDefinition: m source. slotType <AST> params |
	slotType:: ast type.
	nil = slotType ifTrue: [slotType:: errorType].
	params:: (selector last asSymbol = ':'
		ifTrue: [{VarDeclAST name: m name type: slotType}]
		ifFalse: [{}]).
	^MessagePatternAST new
		selector: selector;
		parameters: params;
		returnType: slotType;
		accessModifier: m accessModifier;
		yourself
)
public subtypeOf: t <Type> ^ <Boolean> = (
	| ot <ObjectType> |
	t = errorType ifTrue: [^true].
	t isKindOfObjectType ifFalse: [^false] ifTrue: [ot:: t].

	mixin = ot mixin ifTrue: [^true].
	(supertype subtypeOf: t) ifTrue: [^true].
	^false
)
supertype ^ <ObjectType> = (
  ^ObjectType forMixin: (superclassOf: mixin).
)
) : (
)
class OuterType forMixin: m <MixinMirror> = PseudoType forMixin: m (
(* The type of outer inside mixin m. *)
) (
public = o = (
	o isKindOfOuterType ifFalse: [^false].
	^mixin = o mixin
)
public at: selector <Symbol> ^ <FunctionType> = (
(* override superclass to avoid access check. Maybe we just want to create an overridable access check to be called
from ObjectType>>at: instead?  *)
 | m <Mirror> = localMember: selector in: mixin. signature <MessagePatternAST> |

  nil = m ifTrue: [^errorType].
  signature:: signatureFor: m withSelector: selector.
  (* deal with substitution of Self *)
  ^((signature apply: selfSubstitution) apply: myTypeBuilder) asFunctionType (* and build a function type *)
)
public isKindOfOuterType ^ <Boolean> = (
	^true
)
signatureForNestedClass: m <ClassDeclarationMirror> ^ <MessagePatternAST> = (
(* override superclass so that we get the instance side, not the class side.
This is because outer N signifies a receiver that is an instance of N
whereas normally, a nested class N, gives us a receiver of type N class.
*)
	^MessagePatternAST new
		selector: m name;
		parameters: {};
		returnType: (TypeIdAST new name: m name; yourself);
		accessModifier: m accessModifier;
		yourself
)
public subtypeOf: t <Type> ^ <Boolean> = (
	^self = t
)
supertype ^ <ObjectType> = (
(* No one should be asking an outer type for its supertype *)
	^ObjectType forMixin: objectMixin
)
) : (
)
class PseudoType forMixin: m <MixinMirror> = ObjectType forMixin: m (
(* An abstract type for pseudo variables like here and outer. *)
) (
public = o = (
(* If we add any new subclass, must test for it here too
so that we never answer true if one of these somehow
gets instantiated. *)
   o isKindOfPseudoType ifFalse: [^false].
   o isKindOfHereType ifTrue: [^false].
   o is isKindOfOuterType ifTrue: [^false].
   mixin = o mixin
)
public isKindOfPseudoType ^ <Boolean> = (
	^true
)
) : (
)
class Query = (
(* Abstract class. The root of the query hierrachy. *)
) (
public invalidate = (
	subclassResponsibility
)
) : (
)
class SelfType forMixin: m <MixinMirror> = PseudoType forMixin: m (
(* The type of the pseudovariable 'self'. As usual, the motivation is access control.
Because self sends behave differently wrt access control, type enforcement must be
specialized as it is here.
*)
) (
public = o ^ <Boolean> = (
	o isKindOfSelfType ifFalse: [^false].
	^mixin = o mixin
)
public at: selector <Symbol> ^ <FunctionType> = (
 | result <Mirror> signature <MessagePatternAST> |
      result:: selfMember: selector at: mixin.
      result = nil ifTrue: [^errorTypeForSelector: selector].
	signature:: signatureFor: m withSelector: selector.
	 (* deal with substitution of Self, Instance? *)
	^((signature apply: selfSubstitution) apply: myTypeBuilder) asFunctionType (* and build a function type *)
)
public isKindOfSelfType ^ <Boolean> = (
	^true
)
myTypeBuilder ^ <TypeBuilder> = (
	^typeBuilderFor: mixin
)
) : (
)
class SignatureQuery type: t <Type> selector: m <Symbol> = Query (
(* What is the type of method m of class t? *)
|
	public type <Type> = t.
	public selector <Symbol> = m.
|) (
public = o = (
	o isKindOfSignatureQuery ifFalse: [^false].
	^type = o type and: [selector = o selector]
)
public declarations ^ <List[ObjectType]> = (
	^declarationsForSignatureQuery: self
)
public hash ^ <Integer> = (
	^(type hash bitXor: selector hash) bitXor: class hash
)
public invalidate = (
	cachedTypes removeKey: self
)
public isKindOfSignatureQuery ^ <Boolean> = (
	^true
)
) : (
)
class Substitutor forSubstitution: s <Map[Symbol, AST]> = (
(* A visitor that applies a substitution to an AST. *)
|
	substitution <Map[Symbol, AST]> = s.
|) (
public binaryTypeOpNode: node <BinaryTypeOpAST> ^ <BinaryTypeOpAST> = (
	^BinaryTypeOpAST new
		operator: node operator;
		leftOperand: (node leftOperand apply: self);
		rightOperand: (node rightOperand apply: self);
		yourself
)
public genericInvocationNode: node <ParameterizedTypeAST> ^ <ParameterizedTypeAST> = (
	^ParameterizedTypeAST new
		generic: node generic;
		arguments: (node arguments collect: [:ta <AST> | ta apply: self]);
		yourself
)
public messagePatternNode: node <MessagePatternAST> = (
	^MessagePatternAST new
		selector: node selector;
		accessModifier: node accessModifier;
		parameters: (node parameters collect: [:p <AST> | p apply: self]);
		returnType: ((returnTypeFor: node) apply: self);
		yourself
)
public slotDefNode: node <SlotDefAST> = (
  |
  slotKlass = node isMutable ifTrue: [SlotDefAST] ifFalse: [ImmutableSlotDefAST].
  result = slotKlass new.
  |
  result accessModifier: node accessModifier.
  result isTransient: node isTransient.
  result slotDecl: (node slotDecl apply: self).
  result initializer: node initializer. (* BOGUS *)
  ^result.
)
public typeIdNode: node <TypeIdAST> ^ <AST> = (
	^(substitution at: node name ifAbsent: [^node]) apply: Type2AST new
)
public unaryTypeOpNode: node <UnaryTypeOpAST> ^ <UnaryTypeOpAST> = (
	^UnaryTypeOpAST new
		operator: node operator;
		operand: (node operand apply: self);
		yourself
)
public varDeclNode: node <VarDeclAST> = (
  ^VarDeclAST name: node name type: (node type isNil ifTrue: [nil] ifFalse: [node type apply: self])
)
) : (
)
class SubtypeQuery subtype: s <Type> supertype: t <Type> = Query (
(* Is s <: t ?. *)
|
	public subtype <Type> = s.
	public supertype <Type> = t.
|) (
public = o = (
	o isKindOfSubtypeQuery ifFalse: [^false].
	^subtype = o subtype and: [supertype = o supertype]
)
public declarations ^ <List[ObjectType]> = (
	^declarationsForSubtypeQuery: self
)
public hash ^ <Integer> = (
	^(subtype hash bitXor: supertype hash) bitXor: class hash
)
public invalidate = (
	trail removeKey: self
)
public isKindOfSubtypeQuery ^ <Boolean> = (
	^true
)
) : (
)
class SuperType forMixin: m <MixinMirror>  = PseudoType forMixin: m (
(* The type of the pseudovariable super. Here, c represents the mirror on the superclass
of the class being typechecked.

The main reason for having a special type is to ensure correct access control,
since super sends behave differenty than either self sends or normal sends.
 *)
) (
public = o = (
	o isKindOfSuperType ifFalse: [^false].
	^mixin = o mixin
)
public at: selector <Symbol> ^ <FunctionType> = (
 | m <Mirror> = superMember: selector at: mixin. signature <MessagePatternAST> |

  nil = m ifTrue: [^errorTypeForSelector: selector].
  signature:: signatureFor: m withSelector: selector.
  (* deal with substitution of Self. Self must be substituted with the appropriate values
for the current class, not the the superclass *)
	^((signature apply: selfSubstitution) apply: myTypeBuilder) asFunctionType (* and build a function type *)
)
public isKindOfSuperType ^ <Boolean> = (
	^true
)
) : (
)
class Type = (
(* Abstract class, root of the type hierarchy. *)
) (
public asFunctionType  = (
  ^subclassResponsibility
)
public subtypeOf: t <Type> ^ <Boolean> = (
	subclassResponsibility
)
) : (
)
class Type2AST = (
) (
public bottomType: b <BottomType> = (
  ^TypeIdAST new name: #'bottom``'; yourself
)
public errorType: e <ErrorType> = (
  ^TypeIdAST new name: #'error``'; yourself
)
public functionType: f <FunctionType> ^ <MessagePatternAST> = (
  | ps = f domain collect: [:t | t apply: self].  r = f range apply: self.|

  ^MessagePatternAST selector: #'unknown`' parameters: ps  returnType: r
)
public genericType: g <GenericType> ^ <ParameterizedTypeAST> = (
  ^ParameterizedTypeAST new
      generic: (g generic apply: self);
      arguments: (g typeArguments collect: [:ta <ObjectType> | ta apply: self]);
      yourself
)
public objectType: ot <ObjectType> ^ <TypeIdAST> = (
  ^TypeIdAST new name: ot name; yourself
)
public typeVariable: tv <TypeVariable> ^ <TypeIdAST> = (
  ^TypeIdAST new name: tv name; yourself
)
public unionType: u <UnionType> ^ <BinaryTypeOpAST> = (
  ^u elements fold: [:e <Type> :f <BinaryTypeOpAST> |
	BinaryTypeOpAST new
        leftOperand: (e apply: self);
        rightOperand: f;
        operator: #|;
        yourself
  ]
)
) : (
)
class TypeBuilder forTypesIn: klass <MixinMirror> = (
(* A visitor that creates a Type from an AST representing a type. *)
|
surroundingClass <ClassDeclarationMirror> = klass.
|

assert: [klass isKindOfMirror] message: '') (
public binaryTypeOpNode: node <BinaryTypeOpAST> ^ <Type> = (
	| l = node leftOperand apply: self. r = node rightOperand apply: self. |
	node operator = '|' ifTrue: [^UnionType unifying: {l. r}].
	^errorType
)
public genericInvocationNode: node <GenericType> = (
	| generic <ObjectType> tas <List[ObjectType]> |

	generic:: node generic apply: self.
	tas:: node arguments collect: [:a <AST> | a apply: self].
	^GenericType generic: generic typeArguments: tas
)
public messagePatternNode: node <MessagePatternAST> ^ <FunctionType> = (
	^FunctionType
		domain: (node parameters collect: [:p <VarDeclNode> | p type apply: self])
		range: ((returnTypeFor: node) apply: self)
)
public typeIdNode: node <TypeIdAST> ^ <ObjectType> = (
    |
    m  <MixinMirror | MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | TypeVariable | Nil> =
       type: node name at: surroundingClass.
    s <MessagePatternAST | SlotDefAST | ClassHeaderAST | Nil>
    |

     m isKindOfTypeVariable ifTrue: [^m].
     m isKindOfClassDeclarationMirror ifTrue: [
       ^ObjectType forMixin: m instanceSide
     ].
     m isKindOfSlotDeclarationMirror ifTrue: [
	   s:: signatureFor: m.
	   ^s type apply: self
	].
      m isKindOfMethodMirror ifTrue: [
	  s:: signatureFor: m.
	halt.
	  ^s returnType apply: self
	].
)
public unaryTypeOpNode: node <UnaryTypeOpAST> ^ <ObjectType> = (
      |
      operand = node operand apply: self.
      |
      ('unary type op ', node operator) out.
      operand out.
      node operator = #class ifTrue: [
	  ^ObjectType forMixin: operand mixin classMixin
	].

	^ObjectType forMixin: (type: node operator at: operand mixin) instanceSide
)
) : (
)
class TypeError message: s <String> start: p1 end: p2 = Error (|
public message = s.
public start = p1.
public end = p2.
|) (
public printString ^ <String> = (
  ^'Type error: ', message
)
) : (
)
class TypeVariable named: n <Symbol> bound: b <ObjectType> forType: t <ObjectType> = ObjectType forMixin: b mixin (
(* Type variables, such as Self, Instance or generics. *)
|
	public name = n.
	public bound <ObjectType> = b.
	owner <ObjectType>  = t.
|) (
public = o ^ <Boolean> = (
	o isKindOfTypeVariable ifFalse: [^false].
	^mixin = o mixin
)
public apply: v = (
  ^v typeVariable: self
)
public at: selector <Symbol> ^ <FunctionType> = (
	^bound at: selector
)
public isKindOfTypeVariable ^ <Boolean> = (
	^true
)
public subtypeOf: t <Type> ^ <Boolean> = (
	^bound subtypeOf: t
)
) : (
)
class UnionType unifying: ts <List[Type]> = Type (
(* The union of the types in ts *)
|
	public elements <List[Type]> = ts.
|) (
public = o = (
	o isKindOfUnionType ifFalse: [^false].
	^elements = o elements
)
public apply: v  = (
  ^v unionType: self
)
public asFunctionType ^ <FunctionType> = (
  ^FunctionType domain: List new range: self
)
public hash ^ <Integer> = (
	^elements hash bitXor: class hash
)
public isKindOfUnionType ^ <Boolean> = (
	^true
)
public subtypeOf: t <Type> ^ <Boolean> = (
	elements inject: true into: [:b <Boolean> :e <Type>  | b and: [e subtypeOf: t]]
)
) : (
)
anyMember: selector <Symbol> at: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
(* This routine is useful for delivering better errors. In cases where a member exists but is inaccessible, users may be confused
    as to why no member was found. If we can't find a legal member, we can call this routine to find out if an inacessible meber
    exists and give a more informative error message.
*)
  | result |
  result:: localMember: selector in: mixin.
  result ~= nil ifTrue: [^result].
  ^inheritedInaccessibleMember: selector in: (superclassOf: mixin)
)
public blockNode: node ^ <ObjectType> = (
| tas <VarOrdCltn[ObjectType]> = List(*[ObjectType]*)  new. |
  nestScope: Scope new.
  node parameters do: [:p <VarDecl> | tas add: (p apply: self)].
  tas addLast: (node body apply: self).
  popScope.
	^GenericType new generic: (TypeIdAST new setId: #Fun) typeArguments: tas.
)
public cascadedSendNode: node ^ <ObjectType> = (
	node previousSend apply: self.
	^unresolvedSendNode: node
)
public characterNode: node <CharacterAST> ^ <ObjectType> = (
	^literal: #Character
)
public codeBodyNode: node ^ <ObjectType> = (
	| lastStatementType <ObjectType> |

	(* pushScope (if we have a map) or just nest a new one *)
	nestScope.
	node temporaries do: [:t <VarDecl> | t apply: self].

	(* Parameters are not typechecked here. For method bodies, the parameters are
	copied from the signature and are checked there. For block bodies, the parameters
	are checked in blockNode. The copying hack should go away when the code
	scopes are factored out of the ASTs.*)

	lastStatementType:: (TypeIdAST new name: #Nil) apply: typeBuilder.
	node statements do: [:s <Statement> | lastStatementType:: s apply: self].
	popScope.
	^lastStatementType.
)
computeSuperclassOf: klass <MixinMirror> ^ <MixinMirror | Nil> = (
	|
	superclassClause <SendAST> = klass declaration header superclassClause.
	superclassClauseType <ObjectType>
	enclosing <MixinMirror | Nil> = klass enclosingMixin.
	result
	|
	'computing superclass of : ' out.
	klass out.
	^enclosing isNil
	   ifTrue: ['Found Object for top level class' out. objectMixin]
         ifFalse: [
	     superclassTable at: klass put: cycle.
	     setClass: enclosing.
	    (*must move one lexical level out before evaluating superclass clause *)
	     superclassClauseType:: superclassClause apply: self.
	     setClass: klass. (* reset lexical level *)
	     superclassClauseType mixin isMeta ifFalse: [
		  error: 'Class type expected' at: {superclassClause start. superclassClause end}.
		  'Error, non meta, returning object mixin' out.
		  ^objectMixin
	      ].	(* the type should be of the form T class *)
	      result:: superclassClauseType classMixin.
	      'found: ' out. result out.
	      superclassTable at: klass put: result
	    ].
)
currentConflictNamespace = (
	^namespace at: (currentTopLevelClass simpleName, ' conflicts') asSymbol ifAbsent: [Map new]
)
currentConflictNamespaceHasEntryFor: typeName <Symbol> = (
	namespace at: (currentTopLevelClass simpleName, ' conflicts') asSymbol ifAbsent: [^false].
	^true
)
currentScope ^ <Scope> = (
	^scopeStack last
)
declarationsForSignatureQuery: q <SignatureQuery> ^ <List[Mirror]> = (
| result <Mirror> truncated <Symbol> |
	^{localMember: q selector in: (q type mixin)}
)
declarationsForSubtypeQuery: q <SubtypeQuery> ^ <List[MixinMirror]> = (
	^{q subtype mixin. q supertype mixin}
)
error: msg <String> at: location <Pair[Integer]> = (
	errorSet add: (TypeError message: msg start: location first end: location last).
)
functionTypeOf: node <SendASTNode> ^ <MsgSignature> = (
	(* A query *)
	| query <Query> receiverType <ObjectType> cachedType <Type> selector <Symbol> |
	selector:: node message selector.
	receiverType:: node receiver apply: self.
	cachedType:: receiverType at: selector.
	(* disable query system for initial testing *)
(*	query:: SignatureQuery type: receiverType selector: selector.
	registerDependenciesOfQuery: query.
	cachedType:: cachedTypes at: query ifAbsent: [
		cachedTypes at: query put: (receiverType at: selector).
		].*)
	cachedType isKindOfAccessErrorType ifTrue: [
		error: selector, ' is defined, but is not accessible' at: {node concreteStart. node concreteEnd}
		] ifFalse: [
		cachedType isKindOfErrorType ifTrue: [
			error: selector, ' is not defined on type ', receiverType name at: {node start. node end}
			].
		].
	^cachedType.
)
public genericInvocationNode: node ^ <ObjectType> = (
	| myType <GenericApplicationType> |

(* This will have to change to accomodate generic terms that are not classes  - mixins, or (in the near future) reflective representatives of a types. We also need to verify that the target is a term. For the immediate future, this is sufficient to type generic classes only.
*)

myType:: UnaryTypeOpAST new target: (GenericApplicationType new apply: (TypeIdAST new setId: node target name) to: node actuals) selector: #class.
myType wellFormed.
^myType
)
public guaranteedNode: node ^ <Type> = (
(* not supported in the grammar or parser yet *)
	^node expr type.
)
hereMember: selector <Symbol> in: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
  | result |
  ('searching for here member ', selector, ' in: ') out.
  mixin out.
  result:: lexicalMember: selector inScopeOf: mixin.
  result ~= nil ifTrue: ['found: ' out. result out.^result].
  selector = #nil ifTrue: ['returned nil ' out.^nilMixin].
  ({#true. #false} includes: selector) ifTrue: ['returned bool ' out.^boolMixin].
  ^inheritedMember: selector in: (superclassOf: mixin)
)
inheritedInaccessibleMember: selector <Symbol> in: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
(* used by #anyMember:at: *)
	|
	actualType <MixinMirror | Nil>
	m <Mirror | Nil>
	|
	('searching for inherited inaccessible member ', selector, ' in: ') out.
	mixin out.
	actualType:: mixin.
	[actualType ~= nil] whileTrue: [
		m:: localMember: selector in: actualType.
		nil ~= m ifTrue: ['found: ' out. m out.^m].
		actualType:: superclassOf: actualType.
		].
	^nil
)
inheritedMember: selector <Symbol> in: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
(*
Note that we cannot just do a full lookup and filter out private results; those are supposed to be completely invisible to the
regular lookup, so that implementors can add or remove them at will. Hence, we must do the iteration up the class chain here,
using #localNonPrivateMember:in: as the building block.
*)
	|
	actualType <MixinMirror | Nil>
	m <Mirror | Nil>
	|
	('searching for inherited member ', selector, ' in: ') out.
	mixin out.
	actualType:: mixin.
	[actualType ~= nil] whileTrue: [
		m:: localNonPrivateMember: selector in: actualType.
		nil ~= m ifTrue: ['found: ' out. m out.^m].
		actualType:: superclassOf: actualType.
		].
	^nil
)
inheritedPublicMember: selector <Symbol> in: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
(* This routine is more subtle than what might think. In particuar, it would not be correct to iterate up the superclass chain
    Looking for public members. That woukd ignore any protected members along the path. But protected members can override
    public ones and so we use #inheritedMember:in: to find what the inherited member would be, and then check if it is public.
    We use #isPublic: to check this. It allows for the possibility that result is nil, and returns false in that case too.
   If the result of #isPublic: is false, there is no public member, and we return nil.
*)
	| result <Mirror | Nil> |
	result:: inheritedMember: selector in: mixin.
	(isPublic: result) ifTrue: [^result].
	^nil
)
public invalidateDeclaration: declaration <Declaration> ^ <Set[Declaration]> = (
(* To be called when declaration has changed.
(a) Wipe clean the set of queries declaration depends on, because they were derived from an old version.
(b) Invalidate all queries that depended on the old declaration and return the declarations that depend on them.
 *)
	removeDependenciesOf: declaration.
	^invalidateDependenciesOn: declaration.
)
invalidateDependenciesOn: declaration <Declaration> ^ <Set[Declaration]> = (
(* Will invalidate all queries that depended on the declaration. *)
	| queries <Set[Query]> invalidDeclarations <Set[Declaration]> = Set new. |
	queries:: dependentQueries at: declaration.
	queries do: [:q <Query> |
		q invalidate.
		invalidDeclarations addAll: (dependentDeclarations at: q)
		].
	^invalidDeclarations
)
isPublic: m <Mirror> ^ <Boolean> = (
	^m ~= nil and: [m accessModifier = #public]
)
lexicalMember: selector <Symbol> inScopeOf: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
(* Find the method named selector defined in this
type's classDeclaration. First check scope of mixin , otherwise climb the enclosing class hierarchy
(lexical scope)  *)
	| actualType <MixinMirror> m <MethodMirror>  |
	('searching for lexical member ', selector, ' in: ') out.
	mixin out.
	actualType:: mixin.

	 [nil ~= actualType] whileTrue: [
		m:: localMember: selector in: actualType.
		nil ~= m ifTrue: ['found: ' out. m out.^m].
		actualType:: actualType enclosingMixin.
		]. (* lexical scope *)
	^nil
)
literal: typeName <Symbol> ^ <ObjectType> = (
	^(TypeIdAST new name: typeName) apply: typeBuilder
	)
localMember: selector <Symbol> in: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
| result <Mirror> |
	('searching for local member ', selector, ' in: ') out.
	mixin out.
	result:: mixin methods findMirrorNamed: selector.
	result ~= nil ifTrue: ['found: ' out. result out.^result].
	mixin isMeta ifTrue: [
		mixin declaration header primaryFactory simpleName = selector ifTrue: [
			'found primary factory ', selector out.
			^mixin declaration header primaryFactory].
	].
	selector last asSymbol = ':' ifTrue: [
			result:: mixin slots findMirrorNamed: selector allButLast asSymbol.
			(* assume it's a setter and look for its slot *)
			(result ~= nil and: [result isMutable]) ifTrue: ['found: ' out. result out.^result]
			] ifFalse: [
				result:: mixin nestedClasses findMirrorNamed: selector.
				result ~= nil ifTrue: ['found: ' out. result out.  ^result].
				result:: mixin slots findMirrorNamed: selector.
				^result.
			].
	^nil
)
localNonPrivateMember: selector <Symbol> in: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
| result <Mirror> |
	('searching for local non-private member ', selector, ' in: ') out.
	mixin out.
	result:: localMember: selector in: mixin.
	(nonPrivate: result) ifTrue: ['found: ' out. result out.^result].
	^nil
)
localPublicMember: selector <Symbol> in: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
| result <Mirror> |
	('searching for local public member ', selector, ' in: ') out.
	mixin out.
	result:: localMember: selector in: mixin.
	(isPublic: result) ifTrue: ['found: ' out. result out.^result].
	^nil
)
public messageNode: node <MessageAST> ^ <List[ObjectType]> = (
	^node arguments collect: [:e <ExpressionAST> | e apply: self]
)
public messagePatternNode: node ^ <FunctionType> = (
	^node apply: typeBuilder
	)
public methodNode: node <MethodAST> ^ <MsgSignature> = (
	| signature <FunctionType> |
	pushScope: Scope new.
	signature:: node pattern apply: self.
	currentReturnType:: signature range.
	node body apply: self.
	popScope.
	^currentReturnType
	)
namespaceFor: typeName <Symbol> ^ <Map[Symbol, Object]> = (
	^namespace at: (typeName, ' conflicts') asSymbol ifAbsent: [namespace]
)
namespaceLookupPathForType: typeName <Symbol> ofType: toplevelTypeName <Symbol> ^ <List[Symbol]> = (
(* Given typeName, a simple name of a top level type
referenced by a top level class named toplevelTypeName,
compute a path for it.  Check if the namespace we are
typechecking against includes a conflict namespace for
toplevelTypeName, and if so if typeName is defined there.
Otherwise, check the main namespace.
*)
	|
	conflictNamespaceName <Symbol> = (toplevelTypeName, ' conflicts') asSymbol.
	conflictNamespace <Map[Symbol, Class] | Nil>
	conflictClass <Class | Nil>
	|
	conflictNamespace:: namespace at: conflictNamespaceName ifAbsent: [].
	nil = conflictNamespace ifFalse: [
		conflictClass:: conflictNamespace at: typeName ifAbsent: [].
		nil = conflictClass ifFalse: [^{conflictNamespaceName. typeName}].
		].
	namespace at: typeName ifAbsent: [^{}].
	^{typeName}
)
nestScope ^ <Scope> = (
	(* Hook up a new lexically nested scope, and push onto the scope stack *)
	| s =  Scope parent:  currentScope. |
	pushScope: s
)
nestScope: s <Scope> = (
	(* Hook up a new lexically nested scope, and push onto the scope stack *)
	s setSuperScope: currentScope.
	pushScope: s
)
nonPrivate: m <Mirror> ^ <Boolean> = (
	^m ~= nil and: [m accessModifier ~= #private]
)
public numberNode: node = (
	^literal: #Number
)
popScope ^ <Scope> = (
	^scopeStack removeLast
)
publicMember: selector <Symbol> at: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
  | result |
  result:: localPublicMember: selector in: mixin.
  result ~= nil ifTrue: [^result].
  ^inheritedPublicMember: selector in: (superclassOf: mixin)
)
pushScope: scope <Scope> = (
	scopeStack addLast: scope
)
registerDependenciesOfQuery: q <Query> = (
	(dependentDeclarations at: q ifAbsent: [dependentDeclarations at: q put: Set new]) add: currentDeclaration.
	(* BOGUS, since currentDeclaration is just a symbol *)
	q declarations do: [:d | (dependentQueries at: d ifAbsent: [dependentQueries at: d put: Set new]) add: q.].
	(queriesOfDeclaration at: currentDeclaration ifAbsent: [queriesOfDeclaration at: currentDeclaration put: Set new]) add: q.
	(* BOGUS, again since currentDeclaration is just a symbol *)
)
removeDependenciesOf: declaration = (
(* Wipe clean the set of queries  declaration depends on *)

	dependentDeclarations do: [:ds <Set[Declaration]> | ds remove: declaration].
)
public returnStatNode: node ^ <ObjectType> = (
	| returnType <ObjectType> eType <ObjectType> |

eType:: node expression apply: self.
^(type: eType isSubtypeOf: currentReturnType)
	ifTrue: [BottomType new]
	ifFalse: [error: 'Type of returned expression is not a subtype of declared return type' at: {node concreteStart. node concreteEnd}]
	)
returnTypeFor: node <MessagePatternAST> ^ <TypeAST> = (
	| returnType <TypeAST | Nil> |
	returnType:: node returnType.
	returnType = nil ifTrue: [^ TypeIdAST new name: #Self].
	^returnType
)
selfMember: selector <Symbol> at: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
  | result |
  result:: localMember: selector in: mixin.
  result ~= nil ifTrue: [^result].
  ^inheritedMember: selector in: (superclassOf: mixin)
)
setClass: klass <MixinMirror> = (
	currentClass:: klass.
	typeBuilder:: TypeBuilder forTypesIn: klass.
)
public setterSendNode: node ^ <Type> = (
	| etype <ObjectType> |

	etype:: node expr apply: self.
	(type: etype isSubtypeOf: (node var type apply: self))
	ifFalse: [error: etype name, ' is not a subtype of ', node var type name at: {node start. node end}].
	^etype
)
signatureFor: m <Mirror> ^ <MessagePatternAST | SlotDefAST | ClassHeaderAST | Nil> = (
(* Ugly.  This a case where Felix's pattern matching work would be nice *)
  m isKindOfMethodMirror ifTrue: [^parser parseMethodHeader: m source].
  m isKindOfTransientSlotMirror ifTrue: [^(parser parseTransientSlotDeclaration: m source) slotDecl type].
  m isKindOfSlotDeclarationMirror ifTrue: [^(parser parseSlotDefinition: m source) slotDecl type].
  m isKindOfMixinMirror ifTrue: [^parser parseTypeId: m name].
  m isKindOfClassDeclarationMirror ifTrue: [^parser parseTypeId: m name].
)
public stringNode: node = (
	^literal: #String
)
superMember: selector <Symbol> at: mixin <MixinMirror> ^ <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> = (
  ^inheritedMember: selector in: (superclassOf: mixin)
)
public superclassOf: klass <MixinMirror> ^ <MixinMirror | Nil> = (
     | result <MixinMirror | Nil>  |
      'looking for superclass of : ' out.
      klass out.
	klass isMeta ifTrue: ['found: ' out. klassMixin out.^klassMixin].
	klass  = objectMixin ifTrue: ['found nil' out. ^nil].
      result:: superclassTable at: klass ifAbsent: [computeSuperclassOf: klass].
      result = cycle
         ifTrue: [
	      error: 'Error: cycle in superclass chain for class ', klass name  at: {6. klass name size + 6}.
	      'Error, cycle : returning object mixin' out.
	      ^objectMixin
	   ]
         ifFalse: ['found: ' out. result out.^result]
)
public symbolNode: node = (
	^literal: #Symbol
)
public tupleNode: node ^ <ObjectType> = (
	|
sqTarget <TypeId>
sqActuals <VarOrdCltn[ObjectType]>
sqActual <ObjectType>
sqType <GenericTypeApplication>
tupleTarget <TypeId>
tupleActuals <VarOrdCltn[ObjectType]>
tupleType <TupleType>
|

sqTarget:: TypeIdAST new setId: #SeqCltn;  start: 0; end: 0.
sqActuals:: List(*[ObjectType]*)  new.
tupleActuals:: node value collect: [:e <Literal> | e apply: self].

tupleActuals isEmpty
   ifTrue: [tupleActuals add: (TypeIdAST new setId: #DoesNotMatter)].

sqActual:: UnionType unifying: tupleActuals asSet asOrderedCollection.

sqActuals add: sqActual.
sqType:: GenericApplicationType new apply: sqTarget to: sqActuals.

tupleTarget:: TypeIdAST new setId: #Tuple.
tupleType:: TupleAST new apply: tupleTarget to: tupleActuals.


^ProtocolMerge new type1: sqType type2: tupleType.
)
type: selector <Symbol> at: mixin <MixinMirror>
  ^ <MixinMirror | MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | TypeVariable | Nil> = (
  | result  <MethodMirror | ClassDeclarationMirror | SlotDeclarationMirror | Nil> |

  selector = #Self ifTrue: [^typeOfSelf].
  selector = #Nil ifTrue: [^nilMixin].
  result:: hereMember: selector in: mixin.
  result ~= nil ifTrue: [^result].
  ^ClassDeclarationMirror reflecting: (currentConflictNamespace at: selector ifAbsent: [namespace at: selector]) mixin
)
type: sub <Type> isSubtypeOf: sup <Type> ^ <Boolean> = (
	| query |
	query:: SubtypeQuery subtype: sub supertype: sup.
	registerDependenciesOfQuery: query.
	^trail at: query ifAbsent: [
		trail at: query put: (sub subtypeOf: sup).
		].
)
typeBuilderFor: klass <ClassDeclarationMirror> ^ <TypeBuilder> = (
(* really need to cache this somewhere *)
	^TypeBuilder forTypesIn: klass
)
typeOfHere ^ <ObjectType> = (
	^HereType forMixin: currentClass
)
typeOfLocal: varName <Symbol> ^ <ObjectType> = (
	 ^currentScope at: varName ifAbsent: []
)
typeOfOuter ^ <ObjectType> = (
	^OuterType forMixin: currentClass
)
typeOfSelf ^ <ObjectType> = (
	| currentType <ObjectType> = SelfType forMixin: currentClass. |
	^TypeVariable named: #Self bound: currentType forType: currentType.
)
typeOfSuper ^ <ObjectType> = (
	^SuperType forMixin: currentClass  superclass mixin: (superclassOf: currentClass)
)
public typecheckMethod: m <MethodAST> ofClass: c <Class> ^ <Set[TypeError]> = (
	| toplevelCandidate <MixinMirror> ::= MixinMirror reflecting: c mixin. |
	currentClass:: toplevelCandidate.
	typeBuilder:: TypeBuilder forTypesIn: toplevelCandidate.
	currentDeclaration:: m selector.
	[nil ~= toplevelCandidate enclosingMixin] whileTrue: [toplevelCandidate:: toplevelCandidate enclosingMixin].
	currentTopLevelClass:: toplevelCandidate.
	errorSet:: Set new.
	methodNode: m.
	^errorSet
)
public typecheckMethodSource: src <String> ofClass: c <Class> ^ <Set[TypeError]> = (
	| m <MethodAST> |
	m:: parser parseMethodDeclaration: src.
	^typecheckMethod: m ofClass: c.
)
public unresolvedSendNode: node <UnresolvedSendAST> ^ <ObjectType> = (
	| functionType <FunctionType> domain <List[ObjectType]> args <List[ObjectType]> |

functionType:: functionTypeOf: node.
domain:: functionType domain.
args:: node message apply: self.
1 to: args size do: [:i <Integer> |
	(type: (args at: i) isSubtypeOf: (domain at: i)) ifFalse: [
		error: 'Argument is not a subtype of corresponding formal'
		at: {(args at: i) concreteStart. (args at: i) concreteEnd}
		]
	].
^functionType range.
)
public varDeclNode: node = (
	^currentScope at: node name put: (node type apply: typeBuilder).
)
public variableNode: node <VariableAST> ^ <ObjectType> = (
	(* need to deal with #'@here', #self, #super, #outer *)
	| varName <Symbol> = node name. |
	varName = #'@here' ifTrue: [^typeOfHere].
	varName = #self ifTrue: [^typeOfSelf].
	varName = #super ifTrue: [^typeOfSuper].
	varName = #outer ifTrue: [^typeOfOuter].
	^assert: [false] message: varName, ' should never have been treated as a variable node'.
)
) : (
)
