Newspeak3
'Newspeak'
class NewspeakCompilation usingPlatform: p asts: asts = ((* Facilities common to each of the Newspeak compilers, such as scopes and the scope builder. A common Rewriter should eventually be located here as well.

It is intended that module definitions for each compilation target will be mixed-in to this module definition, and so inherit the facilities provided here. Until general mixin application is supported, the target-specific modules must use the same cheat used by BlocklessCombinatorialParsing of declaring a superclass clause matching the factory of the class it will be later mixed-in to.


This module is derived from Newspeak2SqueakCompilation, which is why the pre-2013 copyrights apply.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2010 Gilad Bracha, Felix Geller and Ryan Macnak
Copyright 2011 Matthias Kleine, Ryan Macnak and Cadence Design Systems
Copyright 2013 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 *)
|
	private Map = p collections Map.
	private List = p collections List.

	private AST = asts AST.
	private ASTTool = asts ASTTool.
	private BlockAST = asts BlockAST.
	private CascadedSendAST = asts CascadedSendAST.
	private CodeBodyAST = asts CodeBodyAST.
	private MessageAST = asts MessageAST.
	private MessagePatternAST = asts MessagePatternAST.
	private MethodAST = asts MethodAST.
	private UnresolvedSendAST = asts UnresolvedSendAST.
	private NumberAST = asts NumberAST.
	private ReturnStatAST = asts ReturnStatAST.
	private TupleAST = asts TupleAST.
	private VariableAST = asts VariableAST.

	public namer = Namer new.
|) (
class ClassEntry forDeclaration: cd atDepth: d = SymbolTableEntry forAST: cd atDepth: d (|
public enclosingClass <ClassEntry>
|) (
public isClassBinding ^<Boolean> = (
	^true
)
public name = (
	^ast selector
)
) : (
)
class Compiler = (| protected scopeMap <Map[AST, Scope]> ::= Map new. |) (
class Rewriter = ASTTool ((* This class is intended to become a common rewriter for the Squeak, Dart and JavaScript compilers. It should handle

*self/super/outer/implicitReceiver/ordinary send or local read/write.
*local/non-local return.
*implicit return self
*[] is [nil]
*slot initializers
*simultaneous slots
*setter temp
*inlined messages
*large tuples?

The common rewriter should be sufficient for Dart and JavaScript. Squeak will require a second rewrite phase for closure analysis, which should be simpler than the current implementation because determining which locals need to be indirected or copied down will be easier when the tree already has distinguished sends that are reads/writes to locals.
*)|
	currentScope <Scope> ::= nil.
	valueExpected <Boolean> ::= true.
	closureDepth <Integer> ::= 0.
|) (
public class BlockLocalReturnAST expression: e = ReturnAST expression: e () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool blockLocalReturnNode: self
)
) : (
)
public class BooleanAST withValue: b = AST (|
	public value = b.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool boolNode: self
)
public printOn: stream = (
	stream nextPutAll: 'BooleanAST: '.
	value printOn: stream.
)
) : (
)
public class ConditionalAST if: cond is: ifTrue_ then: t else: e = AST (|
	public condition <ExpressionAST> = cond.
	public ifTrue = ifTrue_.
	public then <CodeBodyAST> = t.
	public else <CodeBodyAST | nil> = e.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool conditionalNode: self
)
) : (
public if: cond <ExpressionAST> is: val <Boolean> then: t <BlockAST> forValue: forValue ^<Instance> = (
	^self if: cond is: val then: t else: (forValue ifTrue: [emptyBody])
)
)
class EnclosingObjectAST = AST ((* See mailing list for debate over 'outer Foo' as an expression. *)| 
	public depth <Integer>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool enclosingObjectNode: self
)
public isExplicitRcvrNode = (
	^true
)
) : (
)
public class ImplicitReceiverSendAST = SendAST (|
public depth <Integer> (* Used on targets that don't have implicit receiver lookup at runtime. *)
public binding <ClassEntry | SlotEntry | MethodEntry>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool implicitReceiverSendNode: self
)
public isImplicitReceiverSendNode ^<Boolean> = (
	^true
)
) : (
)
public class LocalReadAST of: var = AST (|
	public variable = var.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool localReadNode: self
)
public name = (
	^variable ast name
)
) : (
)
public class LocalWriteAST to: var assign: val = AST (|
	public variable = var.
	public value = val.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool localWriteNode: self
)
public name = (
	^variable ast name
)
) : (
)
public class LoopAST = AST ((* This node represents a while loop. The general form of the loop is:

prologue; while (cond = whileTrue) { body}

*)|
	public prologue <CodeBodyAST>
	public condition <CodeBodyAST>
	public isWhileTrue <Boolean>
	public body <CodeBodyAST>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool loopNode: self
)
public do: n <Integer> timesRepeat: b <BlockAST> = (
	|
	skope <Scope>
	loopVarName <Symbol>
	var <ParameterAST>
	|
	skope:: scopeMap at: b.

	(* introduce counter variable *)
	loopVarName:: '.i' asSymbol.
	var:: (ParameterAST name: loopVarName type: nil)
		start: b start; end: b end.	
	skope
		at: loopVarName
		put: (LocalEntry forDeclaration: var atDepth: 0).
	assert: [b parameters isEmpty].
	b parameters add: var.

	(* translate n timesRepeat: [blockBody]
	into 1 to: n do: [ :.i | blockBody] *)
	from: (NumberAST new value: 1; start: b start; end: b end) to: n do: b
)
public from: first <AST> to: last <AST> by: step <AST> do: block <BlockAST> = (
	|
	blockScope		<Scope>	
	counterVar		<TemporaryAST>
	counterEntry	
	counter		<TemporaryVariableAST>
	limitNeeded		<Boolean>
	limitName		<Symbol>
	limitVar		<TemporaryAST>
	limitEntry
	limit			<LiteralAST | VariableAST>
	condSel			<Symbol>
	condArg		<MutableList[ExpressionAST]>
	condExpr		<ExpressionAST>
	condBody		<CodeBodyAST>
	condStats		<MutableList[StatementAST]>
	incArg			<MutableList[ExpressionAST]>
	incExpr			<ExpressionAST>
	incStat			<StatementAST>
	|
	(* preliminaries *)
	assert: [ step isNumberNode and: [step value isKindOfInteger] ] message: 'Loop with non-integer step'.
	assert: [ block isBlockNode ] message: 'Loop with block that is not a BlockAST'.
	blockScope:: scopeMap at: block body.

	(* loop counter (= block parameter) *)
	counterVar:: TemporaryAST name: block parameters removeFirst name type: nil.
	counterEntry:: LocalEntry forDeclaration: counterVar atDepth: nil.
	counter:: (LocalReadAST of: counterEntry) start: block start; end: block end.
	
	(* introduce counter limit variable if needed *)
	prologue:: emptyBody.
	(limitNeeded:: last isLiteralNode not)
		ifFalse:
			[(* no limit variable needed - use last directly since there's no computation involved *)
			limit:: last]
		ifTrue:
			[limitName:: '.limit' asSymbol.
			 limitVar:: TemporaryAST name: limitName type: nil.
			 limitVar start: block start; end: block end.
			 limitEntry:: LocalEntry forDeclaration: limitVar atDepth: nil.
			 prologue temporaries add: limitVar.
			 blockScope at: limitName put: limitEntry.
			 limit:: (LocalReadAST of: limitEntry) start: block start; end: block end].
	
	(* setup loop condition => introduce condition block for whileTrue: loop *)
	condSel:: step value < 0 ifTrue: [ #<= ] ifFalse: [ #>= ].
	condArg:: List new add: counter; yourself.
	condExpr:: OrdinarySendAST to: limit send: (MessageAST new send: condSel with: condArg).
	(* limit <= counter OR limit >= counter *)
	condStats:: List new add: condExpr ; yourself.
	condBody::
		CodeBodyAST new
			parameters: List new;
			temporaries: List new;
			statements: condStats;
			start: block start; end: block end.
	scopeMap at: condBody put: nil.

	(* add counter increment to loop body *)
	incArg:: List new add: counter ; yourself.
	incExpr:: OrdinarySendAST to: step send: (MessageAST new send: #+ with: incArg).
	incExpr start: block start; end: block end.
	(* step + counter *)
	incStat:: LocalWriteAST to: counterEntry assign: incExpr. 
	incStat start: block start; end: block end.
	(* counter := step + counter *)
	block body statements add: incStat.

	(* setup prologue *)
	prologue temporaries add: counterVar.
	prologue statements add: (LocalWriteAST to: counterEntry assign: first).
	(* counter := first *)
	limitNeeded ifTrue: [
		(* initialize limit variable - note that this must be done *after* setting up the counter because of possible side effects *)
		prologue statements add: (LocalWriteAST to: limitEntry assign: last). (* .limit := last *)
	].
	
	(* initialize loop instance variables *)
	condition:: condBody.
	isWhileTrue:: true.
	body:: block body
)
public from: first <AST> to: last <AST> do: block <BlockAST> = (
	from: first to: last by: (NumberAST new value: 1) do: block
)
public repeat: b = (
    assert: [b isCodeBodyNode].
    condition:: b.
    condition statements add: ((BooleanAST withValue: true) start: condition end; end: condition end).
    isWhileTrue:: true.
)
public while: v <Boolean> do: b <BlockAST> = (
    assert: [b isCodeBodyNode].
    condition:: b.
    isWhileTrue:: v.
)
public while: b1  is: v <Boolean> do: b2 = (
    assert: [b1 isCodeBodyNode].
    assert: [b2 isCodeBodyNode].
    condition:: b1.
    isWhileTrue:: v.
    body:: b2.
)
) : (
)
public class MethodLocalReturnAST expression: e = ReturnAST expression: e () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool methodLocalReturnNode: self
)
) : (
)
public class NilAST = AST () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool nilNode: self
)
) : (
)
public class NonlocalReturnAST expression: e = ReturnAST expression: e () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool nonLocalReturnNode: self
)
) : (
)
public class OrdinarySendAST to: rcvr send: msg = SendAST (|
	public receiver = rcvr.
	public message = msg.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool ordinarySendNode: self
)
public isOrdinarySendNode = (
	^true
)
) : (
)
public class OuterSendAST = SendAST (|
public depth <Integer>
public binding <ClassEntry | SlotEntry | MethodEntry>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool outerSendNode: self
)
) : (
)
public class ParameterAST name: n type: t = AST (|
	public name = n.
	public type = t.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool parameterDeclNode: self
)
public printOn: stream = (
	stream nextPutAll: 'ParameterAST('; nextPutAll: name; nextPutAll: ')'.
)
) : (
)
class ReceiverAST = AST () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool receiverNode: self
)
public isReceiverNode ^<Boolean> = (
	^true
)
) : (
)
class ReturnAST expression: e = AST (|
	public expression <AST> = e.
|) (
public isReturnStatNode = (
	^true
)
) : (
)
public class SelfSendAST = SendAST (|
public binding <ClassEntry | SlotEntry | MethodEntry>
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool selfSendNode: self
)
public isSelfSendNode ^<Boolean> = (
	^true
)
public receiver = (
	^ReceiverAST new
)
) : (
)
class SendAST = AST (|
	public message <MessageAST>
|) (
public isSendNode = (^true)
) : (
)
public class SuperSendAST = SendAST () (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool superSendNode: self
)
public isSuperSendNode = (
	^true
)
) : (
)
public class TemporaryAST name: n type: t = AST (|
	public name = n.
	public type = t.
|) (
public apply: tool <ASTTool[T]> ^<T> = (
	^tool temporaryDeclNode: self
)
public printOn: stream = (
	stream nextPutAll: 'TemporaryAST('; nextPutAll: name; nextPutAll: ')'.
)
) : (
)
applyForEffectTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: false.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
applyForValueTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: true.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
public blockNode: node <BlockAST> = (
	| rewrittenBlock <BlockAST> last <AST> |
	closureDepth:: closureDepth + 1.
	rewrittenBlock:: rewriteBlockNode: node forValue: true.
	last:: rewrittenBlock body statements last.
	(last isReturnStatNode or: [last isBlockLocalReturnAST]) ifFalse:
		[(* The last expression in a block is returned by it. *)
		rewrittenBlock body statements removeLast.
		rewrittenBlock body statements add:
			((BlockLocalReturnAST expression: last) copyPositionFrom: last)].
	closureDepth:: closureDepth - 1.
	^rewrittenBlock
)
canInlineSeqexps ^<Boolean> = (
	^true (* No on JS and Dart *)
)
public cascadedSendNode: node <CascadedSendAST> = (
	| prevSend msg |
	prevSend:: node previousSend apply: self.
	msg:: node message apply: self.
	^CascadedSendAST new to: prevSend cascade: msg
)
public characterNode: node <CharacterAST> = (
	^node
)
public codeBodyNode: node <CodeBodyAST> = (
	(* Move slot initializers to statements. Simultaneous slots. *)
	
	| bodyScope temporaries setterEntry statements result |
	bodyScope:: pushScopeForNode: node.
	
	temporaries:: List new.
	node temporaries do: 
		[:varDecl <VarDeclAST> | | t |
		checkForReservedWord: varDecl name.
		t:: TemporaryAST name: varDecl name type: varDecl type.
		t copyPositionFrom: varDecl.
		temporaries add: t].

	setterEntry:: LocalEntry forDeclaration: (TemporaryAST name: namer setterTemp type: nil) atDepth: nil.
	bodyScope at: namer setterTemp put: setterEntry.
	bodyScope at: (namer setterTemp, ':') asSymbol put: setterEntry.
	temporaries add: setterEntry ast.
	
	statements:: List new.
	node temporaries do: 
		[:varDecl <VarDeclAST> |
		| initializer |
		initializer:: varDecl initializer.
		nil = initializer ifFalse: 
			[node isSeq ifFalse: 
				[initializer:: futureFor: initializer].
			statements add: (LocalWriteAST
				to: (bodyScope at: varDecl name)
				assign: (self applyForValueTo: initializer))]].

	node statements keysAndValuesDo:
		[:index :statement | 
		| rewritten |
		rewritten:: (index = node statements size and: [valueExpected])
			ifTrue: [applyForValueTo: statement]
			ifFalse: [applyForEffectTo: statement].
		statements add: rewritten].
	
	setterEntry used ifFalse: 
		[bodyScope at: namer setterTemp put: nil.
		bodyScope at: (namer setterTemp, ':') asSymbol put: nil.
		temporaries remove: setterEntry ast].

	popScope.
	result:: CodeBodyAST new
		parameters: node parameters
		temporaries: temporaries
		statements: statements.
	result literalMessages: node literalMessages.
	scopeMap at: result put: bodyScope.
	^result
)
depthOfEnclosingClass: name <Symbol> ^<Integer> = (
	| entry <ClassEntry> |
	entry:: currentScope at: #'@currentClass'.
	[entry isNil] whileFalse:
		[entry name = name ifTrue: [
			^entry depth].
		entry:: entry enclosingClass].
	Error signal: 'No enclosing class named "', name, '"'
)
emptyBody = (
	| body |
	#BOGUS. (* Should be able to use immutable collections. *)
	body:: CodeBodyAST new
		parameters: List new;
		temporaries: List new;
		statements: (List new add: NilAST new; yourself).
	scopeMap at: body put: nil.
	^body
)
futureFor: expression <ExpressionAST> ^<ExpressionAST> = (
	(* @here Future computing: [expression] *)
	| 
	scope <Scope>
	block <BlockAST>
	codebody <CodeBodyAST>
	futureExp <ExpressionAST>
	|
	
	scope:: Scope parent: currentScope.
	
	futureExp:: UnresolvedSendAST new
		receiver: (UnresolvedSendAST new
			receiver: implicitReceiverNode;
			message: (MessageAST new selector: #Future; arguments: {}));
		message: (MessageAST new selector: #computing:; arguments: {
			block:: BlockAST new body: (
				 codebody:: CodeBodyAST new
					parameters: List new;
					temporaries: List new;
					statements: {expression})}).

	scopeMap at: codebody put: scope.
	scopeMap at: block put: scope.
	^futureExp
)
implicitReceiverNode ^<VariableAST> = (
	^VariableAST new name: #'@here'
)
isImplicitReceiverNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #'@here'
)
isInlineableConditional: node <NormalSendAST> ^<Boolean> = (
	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].
	node message isEventual ifTrue: [^false].
	({#ifTrue:. #ifFalse:. #ifTrue:ifFalse:. #ifFalse:ifTrue:} includes: node message selector)
	     ifFalse: [^false].
	node message arguments do: [:arg <AST> | (isRemovableBlock: arg withArgs: 0) ifFalse: [^false]].
	^true
)
isInlineableLoop: node <NormalSendAST> ^<Boolean> = (
	| selector <Symbol>  args |
	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].
	node message isEventual ifTrue: [^false].
	selector:: node message selector.
	args:: node message arguments.
	({#whileTrue. #whileFalse. #whileTrue:. #whileFalse:. #repeat} includes: selector) ifTrue:
		[args do:
			[:each |
			(isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
		^isRemovableBlock: node receiver withArgs: 0].
	
	(selector = #timesRepeat:) ifTrue: [^isRemovableBlock: args last withArgs: 0].
	({#to:do:. #to:by:do:} includes: selector) ifFalse: [^false].
	(isRemovableBlock: args last withArgs: 1) ifFalse: [^false].
	(selector = #to:do:) ifTrue: [^true].
	^args size = 3
)
isOuterNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #outer
)
isRemovableBlock: block <BlockAST> withArgs: numArgs <Integer> ^<Boolean> = (
	(* Answers true if block can be removed (inlined) within another block. *)
	block isBlockNode ifFalse: [^false].
	block parameters size = numArgs ifFalse: [^false].
	^true
)
isSelfNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #self 
)
isSuperNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #super 
)
public messageNode: node <MessageAST> ^<MessageAST> = (
    ^MessageAST new
		send: node selector
		with: (node arguments collect: [:arg | applyForValueTo: arg]);
		isEventual: node isEventual;
		start: node start;
		end: node end
)
public messagePatternNode: node <MessagePatternAST> ^<MessagePatternAST> = (
	| params <List[ParameterAST]> |
	checkForReservedWord: node selector.
	params:: node parameters collect:
		[:p <VarDeclAST> | 
		checkForReservedWord: p name. 
		p].
	^MessagePatternAST new
		selector: node selector parameters: params;
		start: node start;
		end: node end.
)
public methodNode: node <MethodAST> = (
	(* Need setter temp? Implicit ^self? *)
	| pattern body accessModifier result |
	closureDepth:: 0.
	pattern:: node pattern apply: self.
	(* We add the implicit ^self before rewritting the body to ensure the last non-return statment is rewritten for effect. *)
	(node body statements isEmpty or: [node body statements last isReturnStatNode not])
		ifTrue: [node body statements add:
					(ReturnStatAST new expression: (VariableAST new name: #self))].
	body:: self applyForEffectTo: node body.
	body parameters: pattern parameters.
	result:: MethodAST new
		pattern: pattern
		body: body
		accessModifier: node accessModifier.
	scopeMap at: result put: (scopeMap at: node).
	^result
)
public numberNode: node <NumberAST> = (
	^node
)
offsetOfEnclosingObjectForClass: name <Symbol> ^<Integer> = (
	| entry <ClassEntry> |
	entry:: currentScope at: #'@currentClass'.
	[entry isNil] whileFalse:
		[entry name = name ifTrue: [
			| offset = outer Compiler currentDepth - entry depth - 1. |
			assert: [offset >= 0] message: 'Invalid enclosing object index'.
			^offset].
		entry:: entry enclosingClass].
	Error signal: 'No enclosing class named "', name, '"'
)
offsetOfImplicitReceiverTarget: binding <SymbolTableEntry> ^<Integer> = (
	(* Note this calculation differs from the one used by explicit outer sends by a factor of one. This is because an explicit outer send needs the depth of the enclosing object with for a class whose name is a given selector, whereas an implicit receiver send needs the depth of the enclosing object for the class that defined a given selector. *)
	| depth |
	depth:: outer Compiler currentDepth - binding depth.
	assert: [depth >= 0] message: 'Invalid enclosing object index'.
	^depth
)
public popScope ^<Scope> = (
	currentScope:: currentScope parent.
)
processEventualSend: node <NormalSendAST> = (
	subclassResponsibility
)
processImplicitReceiverSend: node <UnresolvedSendAST> = (
	| 
	message = node message.
	selector = message selector. 
	binding <SymbolTableEntry>
	|
	
	selector = #self ifTrue:
		[^ReceiverAST new copyPositionFrom: message].
	selector = #nil ifTrue:
		[^NilAST new copyPositionFrom: message].
	selector = #false ifTrue:
		[^(BooleanAST withValue: false) copyPositionFrom: message].
	selector = #true ifTrue:
		[^(BooleanAST withValue: true) copyPositionFrom: message].
	
	binding:: currentScope at: selector ifAbsent: [nil].
	
	(* Nothing is lexically visible. *) 
	binding isNil ifTrue:
		[^processImplicitReceiverSend: message binding: nil].
	
	binding isLocalBinding ifTrue: 
		[^processLocalAccess: message of: binding].

	binding isDebugMappedLocalEntry ifTrue: 
		[^processMappedVariable: message decl: binding].

	^processImplicitReceiverSend: message binding: binding
)
processImplicitReceiverSend: msg <MessageAST> binding: binding <ClassEntry | SlotEntry | MethodEntry> = (
	| depth = binding isNil ifTrue: [0] ifFalse: [offsetOfImplicitReceiverTarget: binding]. |
	^(ImplicitReceiverSendAST new
		depth: depth;
		binding: binding;
		message: (msg apply: self))
		copyPositionFrom: msg
)
processInlineableConditional: node <NormalSendAST> = (
	|
	receiver = node receiver apply: self.
	selector = node message selector.
	numArgs = node message arguments size.
	arg1 = numArgs > 0 ifTrue:
		[(rewriteInlinedBlockNode: (node message arguments at: 1) forValue: valueExpected) body].
	arg2 = numArgs > 1 ifTrue:
		[(rewriteInlinedBlockNode: (node message arguments at: 2) forValue: valueExpected) body].
	|
	selector = #ifTrue:
		ifTrue: [^ConditionalAST if: receiver is: true then: arg1 forValue: valueExpected].
	selector = #ifFalse:
		ifTrue: [^ConditionalAST if: receiver is: false then: arg1 forValue: valueExpected].
	selector = #ifTrue:ifFalse:
		ifTrue: [^ConditionalAST if: receiver is: true then: arg1 else: arg2].
	selector = #ifFalse:ifTrue: 
		ifTrue: [^ConditionalAST if: receiver is: false then: arg1 else: arg2].
	assert: [false] message: 'Unknown conditional selector'
)
processInlineableLoop: node <NormalSendAST> ^<LoopAST> = (
	|
	rcvr = node receiver.
	msg = node message.
	sel = msg selector.
	numArgs = msg arguments size.
	arg1 = numArgs >= 1 ifTrue: [msg arguments at: 1].
	arg2 = numArgs >= 2 ifTrue: [msg arguments at: 2].
	arg3 = numArgs >= 3 ifTrue: [msg arguments at: 3].
	|
	
	sel = #whileTrue ifTrue: [^LoopAST new
		while: true
		do: (rewriteInlinedBlockNode: rcvr forValue: true) body].
	sel = #whileFalse ifTrue: [^LoopAST new
		while: false
		do: (rewriteInlinedBlockNode: rcvr forValue: true) body].
	sel = #whileTrue: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) body
		is: true
		do: (rewriteInlinedBlockNode: arg1 forValue: false) body].
	sel = #whileFalse: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) body
		is: false
		do: (rewriteInlinedBlockNode: arg1 forValue: false) body].
	
	sel = #repeat ifTrue: [^LoopAST new
		repeat: (rewriteInlinedBlockNode: rcvr forValue: false) body].
	
	sel = #timesRepeat: ifTrue: [^LoopAST new
		do: (rcvr apply: self)
		timesRepeat: (rewriteInlinedBlockNode: arg1 forValue: false)].
	
	sel = #to:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		do: (rewriteInlinedBlockNode: arg2 forValue: false)].
	
	sel = #to:by:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		by: (arg2 apply: self)
		do: (rewriteInlinedBlockNode: arg3 forValue: false)].
	
	assert: [false] message: 'Unknown loop selector'
)
processLocalAccess: msg <MessageAST> of: decl <SlotEntry> = (
	^msg selector last = ":"
		ifTrue: [processLocalWrite: msg to: decl]
		ifFalse: [processLocalRead: msg from: decl]
)
processLocalRead: message <MessageAST> from: declaration <LocalEntry> = (
	assert: [message arguments isEmpty] message: ''.
	assert: [declaration isNil not] message: ''.
	^(LocalReadAST of: declaration)
		start: message start;
		end: message end
)
processLocalWrite: message <MessageAST> to: declaration <LocalEntry> = (
	assert: [message arguments size = 1] message: ''.
	^(LocalWriteAST
		to: declaration assign: (applyForValueTo: message arguments first))
		copyPositionFrom: message
)
public processOrdinarySend: node <UnresolvedSendAST> ^<AST> = (
	(isInlineableConditional: node)
		ifTrue: [^processInlineableConditional: node].
	(isInlineableLoop: node)
		ifTrue: [^processInlineableLoop: node].

	(* And lo, we really have a normal send. *)
	^(OrdinarySendAST
		to: (node receiver apply: self) send: (node message apply: self))
		copyPositionFrom: node
)
processOuterExpression: node <UnresolvedSendAST> = (
	^EnclosingObjectAST new
		depth: (offsetOfEnclosingObjectForClass: node message selector);
		start: node receiver start;
		end: node message end
)
processOuterSend: node <UnresolvedSendAST> = (
	(* +1 because we're looking for members of the enclosing class, not the siblings of the enclosing class. *)
	| binding = currentScope
		at: node message selector
		depth: (depthOfEnclosingClass: node receiver message selector) + 1. |
	^OuterSendAST new
		depth: (offsetOfEnclosingObjectForClass: node receiver message selector);
		binding: binding;
		message: (node message apply: self);
		start: node receiver receiver start;
		end: node message end
)
processSelfSend: node <UnresolvedSendAST> = (
	| binding = currentScope at: node message selector depth: outer Compiler currentDepth. |
	^SelfSendAST new
		message: (node message apply: self);
		binding: binding;
		copyPositionFrom: node
)
processSetterSend: node <SetterSendAST> binding: binding ^<AST> = (
	|
	setterTempBinding <LocalEntry>
	setterTempRead
	setterTempWrite
	message <MessageAST> 
	send <NormalSendAST>
	depth
	body <CodeBodyAST>  
	|
	valueExpected
		ifFalse: [^processImplicitReceiverSend: node message binding: binding].
	
	setterTempBinding:: currentScope at: namer setterTemp.
	setterTempBinding used: true.
	
	(* t := exp *)
	setterTempWrite:: LocalWriteAST
		to: setterTempBinding
		assign: (node message arguments first apply: self). 

	(* setter: t *)
	setterTempRead:: LocalReadAST of: setterTempBinding. 
	message:: MessageAST new selector: node message selector; arguments: {setterTempRead}.
	assert: [isImplicitReceiverNode: node receiver] message: 'Setter send receiver should be implicit'.
	depth:: binding isNil ifTrue: [0] ifFalse: [offsetOfImplicitReceiverTarget: binding].
	send:: ImplicitReceiverSendAST new
		depth: depth;
		binding: binding;
		message: message. (* Do not rewrite message twice *)

	(* t:=exp. setter: t. t *)
	body:: CodeBodyAST new 
		parameters: List new;
		temporaries: {};
		statements: {setterTempWrite. send. setterTempRead}.
	scopeMap at: body put: currentScope.
	^body
)
processSuperSend: node <UnresolvedSendAST> = (
	^SuperSendAST new
		message: (node message apply: self);
		copyPositionFrom: node
)
public pushScope: scope <Scope> = (
	^currentScope:: scope
)
pushScopeForNode: node <AST> = (
	^pushScope: (scopeMap at: node)
)
public returnStatNode: node <ReturnStatAST> = (
	^((closureDepth > 0 ifTrue: [NonlocalReturnAST] ifFalse: [MethodLocalReturnAST])
		expression: (applyForValueTo: node expression))
		copyPositionFrom: node
)
rewriteBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <BlockAST> = (
(* An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined. *)
	| 
	rewrittenNode <BlockAST> 
      params <Collection[ParameterAST]>  
	| 
	(* this shouldn't be handled here, but I'm not sure where the block / codebody 
	comes from. *)
	node body start isNumber
		ifFalse: [node body start: node start. node body end: node end].
	
	params:: node parameters collect:
		[:p <VarDeclAST> |
		checkForReservedWord: p name.
		p].
	rewrittenNode:: BlockAST new body: 
		(forValue ifTrue: [applyForValueTo: node body] ifFalse: [applyForEffectTo: node body]).
	rewrittenNode start: node start; end: node end.
	rewrittenNode body parameters: params.
	node body statements isEmpty ifTrue:
		[rewrittenNode body statements add: (NilAST new start: node body start; end: node body end)].
	scopeMap at: rewrittenNode put: (scopeMap at: node).
	^rewrittenNode
)
rewriteInlinedBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <CodeBodyAST> = (
(* An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined. *)
	^rewriteBlockNode: node forValue: forValue
)
public setterSendNode: node <SetterSendAST> ^<AST> = (
	| 
	message = node message.
	selector = message selector. 
	binding <SymbolTableEntry>
	|
	
	binding:: currentScope at: selector ifAbsent: [nil].
	
	(* Nothing is lexically visible. *) 
	binding isNil ifTrue:
		[^processSetterSend: node binding: nil].
	
	binding isLocalBinding ifTrue:
		[^processLocalAccess: message of: binding].

	binding isDebugMappedLocalEntry ifTrue:
		[^processMappedVariable: message decl: binding].
	
	^processSetterSend: node binding: binding
)
public stringNode: node <StringAST> = (
	^node
)
public symbolNode: node <SymbolAST> = (
	^node
)
public tupleNode: node <TupleAST> = (
	^TupleAST new elements: (node elements collect: [:element | applyForValueTo: element])
)
public unresolvedSendNode: node <UnresolvedSendAST> ^<AST> = (
	(node message isEventual) ifTrue: 
		[^processEventualSend: node].
	(isImplicitReceiverNode: node receiver) ifTrue: 
		[^processImplicitReceiverSend: node].
	(isSelfNode: node receiver) ifTrue: 
		[^processSelfSend: node].	
	(isSuperNode: node receiver) ifTrue: 
		[^processSuperSend: node].	
	(isOuterNode: node receiver) ifTrue: 
		[^processOuterExpression: node].
	(node receiver isSendNode and: [isOuterNode: node receiver receiver]) ifTrue: 
		[^processOuterSend: node].
	^processOrdinarySend: node
)
public variableNode: node <VariableAST> = (
	node name = #self ifTrue:
		[^ReceiverAST new copyPositionFrom: node].
	node name = #nil ifTrue:
		[^NilAST new copyPositionFrom: node].
	node name = #true ifTrue:
		[^(BooleanAST withValue: true) copyPositionFrom: node].
	node name = #false ifTrue:
		[^(BooleanAST withValue: false) copyPositionFrom: node].
	assert: [(node name = #super) not] message: '"super" is not a valid expression'.
	assert: [(node name = #outer) not] message: '"outer" is not a valid expression'.
	halt.
	^node
)
) : (
)
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = ASTTool ((* The scope builder is a visitor on the AST. It computes a tree of scopes that shadows the AST itself. More precisely, it computes a mapping from ASTs to their scopes. This allows us to get to the appropriate scope for an abstract syntax node without polluting the AST with extraneous data like scopes.

We could associate each node in the AST with the scope in which it is found, but this would be overkill. Instead, only nodes that actually introduce new scopes (such as class sides, message patterns, code bodies and blocks) actually get mapped in this manner. The intent is that later phases of compilation will visit the tree and look up the scopes at the points where they are introduced.

The builder starts at a given node, in the context of some mixin, described by a mirror. This is because, in an incremental environment, we may not have the complete AST for a module, but instead be asked to process a part of that module, such as a nested class, slot definition or method. The surrounding scope can be computed from the mirror representing the immediately enclosing mixin.

Then we traverse the tree, creating and populating new scopes as needed. We maintain a stack of scopes (scopeStack) that initially contains only the surrounding scope. Scopes get pushed on to the stack when we encounter a node that introduces a scope, and popped when we finish with that node. The scopes are chained to their super scopes (the scope below them on the stack).

A possible optimization is to avoid a traversal of an entire side of a class.
One can process only a side without its subtrees (i.e., methods and nested classes). These can be visited later, as long as we ensure that the processing of the subtree begins with a proper super scope on top of the scope stack. *)| 
currentScope ::= initialScope.
currentDepth <Integer> ::= initialDepth. (* The lexical nesting level of the class declaration currently being visited; top-level classes are level 0. *)
|
) (
public blockNode: aNode <BlockAST> = (
	| parameterScope <Scope> |
	parameterScope:: Scope parent: currentScope.
	(* establish parameter scope *)
	aNode parameters do:
		[:parameter <VarDeclAST> | 
		 parameterScope
			at: parameter name
			put: (LocalEntry
				forDeclaration: parameter
				atDepth: currentDepth)].
	pushScope: parameterScope.
	
	(* visit body *)
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).
	
	popScope (* pop the parameter scope, ps *)
)
public buildScopeFor: mm <MixinMirror> ^<Scope> = (
	assert: [mm isKindOfMixinMirror] message: ''.
	^incrementalScopeFor: mm.
)
public cascadedSendNode: node <CascadedSendAST> = (
	node previousSend apply: self.
	node message apply: self.
)
public characterNode: aNode <CharacterAST> = (
	(* leaf, do nothing *)
)
public classHeaderNode: aNode = (

	aNode constructor apply: self.
	aNode slots do: [:s | s initializer ifNotNil: [:i | i apply: self]].
	aNode initExprs do: [:e | e apply: self].
)
public classNode: aNode <ClassDeclarationAST> = (
	| thisClass <ClassEntry> instanceSideScope <Scope> classSideScope <Scope> |
	
	thisClass:: ClassEntry forDeclaration: aNode atDepth: currentDepth.
	thisClass enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).
	
	currentScope at: aNode name put: thisClass.
		
	currentDepth:: currentDepth + 1.
	
	instanceSideScope:: Scope parent: currentScope. (* establish instance side scope *)
	pushScope: instanceSideScope.
	aNode header slots do: [:v <SlotDeclAST> | 
		| se = SlotEntry forDeclaration: v atDepth: currentDepth. |
		instanceSideScope at: v name put: se. (* getter *)
		instanceSideScope at: (namer initializerSelectorForSlot: v) put: se.
		v isMutable ifTrue: [instanceSideScope at: (namer setterSelectorFor: v) put: se]. (* setter *)].
	instanceSideScope at: #'@currentClass' put: thisClass.
	aNode instanceSide apply: self.
	popScope.

	classSideScope:: (Scope parent: currentScope). (* establish class side scope *)
	pushScope: classSideScope.
	classSideScope at: #'@currentClass' put: thisClass.
	aNode classSide apply: self.
	popScope.

	currentDepth:: currentDepth - 1.
)
public codeBodyNode: aNode <CodeBodyAST> = (
	| bodyScope <Scope> |

	bodyScope:: Scope parent: currentScope.
	aNode temporaries do: 
		[:t <SlotDefAST> | | local |
		 local:: LocalEntry forDeclaration: t slotDecl atDepth: currentDepth.
		 bodyScope at: t name put: local. (* getter *)
		 bodyScope at: (namer initializerSelectorForSlot: t) put: local. (* setter *)
		 t isMutable ifTrue: [bodyScope at: (setterSelectorFor: t) put: local. (* setter *)]].

	pushScope: bodyScope.
	scopeMap at: aNode put: bodyScope.
	(* visit statements *)
	aNode temporaries do: [:t | t initializer isNil ifFalse: [t initializer apply: self]].
	aNode statements do: [:statement | statement apply: self].
	popScope.
)
incrementalScopeFor: mm <MixinMirror> ^<Scope> = (
	|
	enclosingMixin
	enclosingScope <Scope>
	scope <Scope>
	currentClass <ClassEntry>
	depth
	|
	enclosingMixin:: mm declaration enclosingClass.
	nil = enclosingMixin 
		ifTrue: [enclosingScope:: Scope new]
		ifFalse: [enclosingScope:: incrementalScopeFor: enclosingMixin instanceSide].
	scope:: Scope parent: enclosingScope.
	depth:: scope depth.
	currentClass:: ClassEntry 
		forDeclaration: (MessagePatternAST new selector: mm declaration name)
		atDepth: depth.
	currentClass enclosingClass: (scope at: #'@currentClass' ifAbsent: [nil]).
	scope at: #'@currentClass' put: currentClass.
	depth:: depth + 1.
	mm slots do: [:s <SlotMirror> | 
		| se = SlotEntry
			forDeclaration: (MessagePatternAST new selector: s name; accessModifier: s accessModifier)
			atDepth: depth. |
		scope at: s name put: se. (* getter *)
		scope at: (namer initializerSelectorForSlot: s) put: se.
		s isMutable ifTrue: [scope at: (namer setterSelectorFor: s) put: se. (* setter *)]].
	mm methods do: [:m <MethodMirror> | 
		| me = MethodEntry
			forDeclaration: (MessagePatternAST new selector: m name; accessModifier: m accessModifier)
			atDepth: depth. |
		scope at: m name put: me].
	mm nestedClasses do: [:c <ClassDeclarationMirror> | 
		| ce = ClassEntry
			forDeclaration: (MessagePatternAST new selector: c name; accessModifier: c accessModifier)
			atDepth: depth. |
		ce enclosingClass: currentClass.
		scope at: c name put: ce].
	^scope
)
public messageNode: node <MessageAST> = (
	node arguments do: [:argument | argument apply: self]
)
public messagePatternNode: aNode <MessagePatternAST> = (

	| parameterScope <Scope> |
	parameterScope:: Scope parent: currentScope.
	(* establish parameter scope *)
	aNode parameters do:
		[:parameter <VarDeclAST> | 
		parameterScope
		at: parameter name
		put: (LocalEntry
			forDeclaration: parameter
			atDepth: currentDepth)].
	
	pushScope: parameterScope.
	scopeMap at: aNode put: parameterScope.
	(* the pattern scope, ps, must be popped by the caller *)
	(* establish type parameter scope - skip for now *)
)
public methodNode: node <MethodAST> = (

	(* register method in current scope *)
	currentScope
		at: node selector
		put: (MethodEntry forDeclaration: node atDepth: currentDepth).

	(* visit pattern *)
	node pattern apply: self.
	
	(* visit body *)
	node body apply: self.
	scopeMap at: node put: (scopeMap at: node body).

	popScope (* Pop pattern scope *)
)
public mixinApplication: node <MixinApplicationAST> = (
	node mixinExpr apply: self.
	node superclassExpr apply: self
)
public mixinApplicationClass: node <MixinApplicationClassAST> = (
	| thisClass <ClassEntry> |
	#BOGUS yourself. (* WIP *)
	thisClass:: ClassEntry forDeclaration: node atDepth: node.
	thisClass enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).
	
	currentScope at: node name put: thisClass.
	scopeMap at: node put: currentScope.
)
public mixinClassNode: aNode = (
	(* leaf, do nothing *)
)
public numberNode: aNode <NumberAST> = (
	(* leaf, do nothing *)
)
popScope ^<Scope> = (
	^currentScope:: currentScope parent
)
pushScope: scope <Scope> = (
	^currentScope:: scope
)
public returnStatNode: node <ReturnStatAST> = (
	node expression apply: self
)
public setterSendNode: node <SetterSendAST> = (
	node receiver apply: self.
	node message apply: self.
)
public sideNode: aNode <SideAST> = (

	scopeMap at: aNode put: currentScope.

	(* visit methods *)
	aNode methods do:
		[:m <MethodAST> | m apply: self].
	
	(* visit nested classes *)
	aNode nestedClasses do:
		[:nc <ClassDeclarationAST> | nc apply: self].
)
public stringNode: aNode <StringAST> = (
	(* leaf, do nothing *)
)
public symbolNode: aNode <SymbolAST> = (
	(* leaf, do nothing *)
)
public tupleNode: node <TupleAST> = (
	node elements do: [:element | element apply: self]
)
public unresolvedSendNode: node <UnresolvedSendAST> = (
	node receiver apply: self.
	node message apply: self.
)
public varDeclNode: aNode <VarDeclAST> = (
	(* Do nothing. It could arguably add aNode's data to current scope - but in practice, the context knows better how to do this. *)
)
public variableNode: aNode <VariableAST> = (
)
) : (
public new ^<Instance> = (
	^self nestedIn: Scope new atLevel: 0
)
)
public Scope = (
	^outer NewspeakCompilation Scope
)
checkForReservedWord: selector = (
	(namer isReservedWord: selector) ifTrue:
		[Error signal: '"', selector, '" is a reserved word'].
)
public compileClassHeader: source <String>
 within: enclosingDeclIR <IntermediateClassDeclaration> = (
	subclassResponsibility
)
public compileClassSource: source <ReadStream> within: enclosing <MixinMirror> ^<IntermediateClassDeclaration> = (
	subclassResponsibility
)
public compileExpressionSource: source <ReadStream> inContext: aContext <MethodContext> inMixin: enclosing <MixinMirror> allowBlackMarket: allowBlackMarket <Boolean> ^<IntermediateMethod> = (
	subclassResponsibility
)
public compileMethodSource: source <String> within: enclosing <MixinMirror> ^<IntermediateMethod> = (
	subclassResponsibility
)
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	subclassResponsibility
)
) : (
)
class LocalEntry forDeclaration: decl <VarDeclAST> atDepth: d <Integer> = SymbolTableEntry forAST: decl atDepth: d ((* Semantic info for a parameter or temporary. *)|
public offset <Integer>
public remote <Boolean> ::= false.
public remoteVector <LocalEntry>

public used ::= false.
|) (
public isLocalBinding ^<Boolean> = (
	^true
)
public name = (
	^ast name
)
) : (
)
class MethodEntry forDeclaration: decl atDepth: d = SymbolTableEntry forAST: decl atDepth: d (|
|) (
public isMethodBinding ^<Boolean> = (
	^true
)
) : (
)
class Namer = () (
public fullyQualifiedNameToSimple: name = (
	| index = name lastIndexOf: "`". |
	index = 0 ifTrue: [^name].
	^(name copyFrom: 1 + index to: name size) asSymbol
)
public fullyQualifySimpleName: sn with: fqp = (
	^(fqp, syntheticNameSeparator, sn) asSymbol
)
public initializerSelectorForSlot: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^('init`', slot name, ':') asSymbol
)
public isReservedWord: selector = (
	^{#self. #super. #outer. #true. #false. #nil} includes: selector
)
public mixinNameOfClassNamed: className = (
	(* |
	simpleNames
	rawNames
	result
	|
	rawNames:: className subStrings: syntheticNameSeparator. 
	rawNames size =1 ifTrue:[^className].
	simpleNames:: rawNames select: [:n | n initialIntegerOrNil isNil].
	assert: [simpleNames size >= 2] message: ''.
	^(simpleNames fold: [:sn1 :sn2 | sn1, syntheticNameSeparator, sn2]) asSymbol. *)
	^className
)
public mixinSlotNameFor: nestedName = (
	| mixinName |
	mixinName:: self mixinNameOfClassNamed: nestedName.
	^(mixinName, syntheticNameSeparator, 'slot') asSymbol
)
public setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	slot isMutable ifFalse: [self warnObsolete].
	^((slot isMutable ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
public setterTemp = (
	^#'@setterTemp'
)
public syntheticNameSeparator = (
	^'`'
)
) : (
)
public class Scope parent: p = (|
	public parent <Scope> = p.
	protected bindings <Map[Symbol, SymbolTableEntry]> = Map new.
|) (
public at: key <Symbol> ^<SymbolTableEntry> = (
	(* Answers the value associated with aKey in this or one the super scopes or fails if aKey is absent. *)
	^self at: key ifAbsent: [Error signal: 'Key ', key, ' not found!']
)
public at: key depth: d = (
	depth = d ifFalse: [
		nil = parent
			ifTrue: [^nil]
			ifFalse: [^parent at: key depth: d]].
	^bindings at: key ifAbsent: [nil]
)
public at: key <Symbol> ifAbsent: blk <[X def]> ^<SymbolTableEntry | X> = (
	(* Answers the value associated with aKey in this or one of the superScopes or the value of aBlock if aKey is absent. *)
	(* Optimization note: This is written using [nil] blocks to avoid passing non-clean blocks dynamically down the scope structure. *)

	| val <T> |
	val:: self bindings at: key ifAbsent: [nil].
	nil = val ifFalse: [^val].
	nil = self parent ifTrue: [^blk value].
	val:: self parent at: key ifAbsent: [nil].
	nil = val ifFalse: [^val].
	^blk value
)
public at: key <Symbol> put: value <SymbolTableEntry> = (
	^self bindings at: key put: value
)
public depth ^<Integer> = (
	parent isNil ifTrue: [^0].
	^parent depth + 1.
)
public printOn: stm = (
	stm nextPutAll: 'Scope('.
	bindings keys
		do: [:key | stm nextPutAll: key]
		separatedBy: [ stm nextPutAll: ', '].
	stm nextPutAll: ') in '.
	parent printOn: stm.
)
) : (
public new = (
	^self parent: nil
)
)
class SlotEntry forDeclaration: decl <VarDeclAST> atDepth: d <Integer> = SymbolTableEntry forAST: decl atDepth: d () (
public isSlotBinding ^<Boolean> = (
	^true
)
public name = (
	^ast name
)
) : (
)
class SymbolTableEntry forAST: tree atDepth: d = ((* An entry in a scope. *)|
public ast <AST> = tree.
public depth <Integer> = d.
|) (
public isClassBinding ^<Boolean> = (
	^false
)
public isDebugMappedLocalEntry = (
	^false
)
public isLocalBinding ^<Boolean> = (
	^false
)
public isMethodBinding ^<Boolean> = (
	^false
)
public isSlotBinding ^<Boolean> = (
	^false
)
) : (
)
) : (
)
