Newspeak3
'Minitest'
class MinitestUI usingPlatform: platform minitest: minitest ide: ide = (
(* Hopscotch UI for unit testing using Minitest. *)
|
	private Gradient = platform graphics Gradient.

	private Presenter = platform hopscotch core Presenter.
	private Subject = platform hopscotch core Subject.
	private Color = platform graphics Color.

	private AssortedMethodsPresenter = ide browsing AssortedMethodsPresenter.
	private ExpandableMethodPresenter = ide browsing ExpandableMethodPresenter.
	private ExemplarMethodPresenter = ide browsingNS ExemplarMethodPresenter.
	private MethodReference = platform squeak MethodReference.
	private MethodSubject = ide browsing MethodSubject.
	private ProgrammingPresenter = ide tools ProgrammingPresenter.

	private List = platform collections List.
	private Map = platform collections Map.

	private TestCatalog = minitest TestCatalog.

	private ide = ide.
	private platform = platform.
	private minitest = minitest.

	(* ungood imports *)
	private Exception = platform squeak Exception.
|) (
class TestResultListPresenter onSubject: s = AssortedMethodsPresenter onSubject: s (
(* A presenter for a list of TestResults, such as a list of successes or failures of a test run. *)
) (
public collapseAll = (
  respondToCollapse: content presenters
)
contentPresenters ^ <Collection[Presenter]> = (
	| sortedTestResults |
	sortedTestResults:: subject results asSortedList:
		[:a :b | a testCase selector < b testCase selector].
	^sortedTestResults collect:
		[:each <TestResult> |
		(TestResultPresenter onSubject: (TestResultSubject onModel: each)) showIndicatorBar: false]
)
public expandAll = (
  respondToExpand: content presenters.
)
runAll = (
	sendUp respondToRunAll: content presenters
)
) : (
)
class TestResultListSubject onModel: list = Subject onModel: list (
(* The subject of a list of test results, such as a list of successes or failures of a test run. The model is a list of TestResult instances. *)
) (
public createPresenter = (
	^TestResultListPresenter onSubject: self
)
isEmpty ^ <Boolean> = (
	^model isEmpty
)
public results = (
	^model
)
) : (
)
class TestResultPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Shows a single TestResult as an expandable selector of the method defining the test. If the result is a failure, also shows the description of the failure. *)
|
	public showIndicatorBar <Boolean> ::= true.
	methodPresenterSlot <ExpandableMethodPresenter>
|) (
public collapse = (
	methodPresenter collapse
)
definition ^ <Fragment> = (
	^showIndicatorBar
		ifTrue: [row: {indicatorBar. elastic:: resultColumn}]
		ifFalse: [resultColumn]
)
exceptionFragment ^ <Fragment> = (
	| link |
	link::
		(link: subject exception printString
		action: [sendUp runWithNoExceptionHandling: subject testCase])
			color: footnoteColor.
	^row: {
		blank: 12.
		elastic: link.
		}
)
public expand = (
	methodPresenter expand
)
failureFragment ^ <Fragment> = (
	^row: {
		blank: 12.
		(link: subject failureDescription
		action: [sendUp runToDebugFailure: subject testCase])
			color: footnoteColor
		}
)
footnoteColor ^ <Color> = (
	^Color gray: 0.7
)
indicatorBar = (
	^(row: {blank: 5} ) color: statusColor.
)
methodPresenter ^ <ExpandableMethodPresenter> = (
	methodPresenterSlot isNil ifTrue: [methodPresenterSlot:: methodPresenterDefinition].
	^methodPresenterSlot
)
methodPresenterDefinition ^ <ExpandableMethodPresenter> = (
	^subject methodSubject createPresenter
		showClassName: true
)
resultColumn ^ <Fragment> = (
	^column:{
		methodPresenter.
		subject isFailure ifTrue: [failureFragment].
		subject hasException ifTrue: [exceptionFragment].
		(* subject hasNoData ifTrue: [noDataFragment] *)
	}
)
statusColor ^ <Color> = (
	(* subject passed ifTrue: [^Color green].
	subject failed ifTrue: [^Color red].
	subject error ifTrue: [^Color black]. *)
	^Color gray.
)
) : (
)
class TestResultSubject onModel: m <TestResult> = Subject onModel: m (
(* The subject for presenting a single TestResult. *)
) (
public = x <Object> ^ <Boolean> = (
	x class = class ifFalse: [^false].
	^selector = x selector and: [className = x className]
)
classDeclarationMirror = (
	^testCase environment classDeclarationMirror
)
public className = (
	^classDeclarationMirror qualifiedName
)
public exception = (
(* If the model is a test error, return the exception associated with the result. Otherwise return nil. *)
	^model isError
		ifTrue: [model exception]
		ifFalse: [nil]
)
public failureDescription ^<String> = (
(* If the model is a failure, return the description of the failure. Otherwise return an empty string. *)
	^isFailure
		ifTrue: [model description]
		ifFalse: ['']
)
public hasException ^<Boolean> = (
(* True if the test result has an exception associated with it, or in other words, the result is a test error. *)
	^model isError
)
public hash = (
	^selector hash * 37 + className hash
)
public isFailure = (
	^model isFailure
)
public methodSubject = (
	^MethodSubject onMethod: (testCase environment classDeclarationMirror instanceSide methods findMirrorNamed: selector)
)
public selector ^ <Symbol> = (
	^testCase selector
)
public testCase = (
	^model testCase
)
) : (
)
class TestingInProgressPresenter onSubject: subject = Presenter onSubject: subject (
(* Presents a Tester in the process of running tests. *)
|
	progressBar
	currentSelector
	errorCountHolder
	failureCountHolder
|) (
definition = (
	errorCountHolder:: holder: [nothing].
	failureCountHolder:: holder: [nothing].
	progressBar:: progress.
	currentSelector:: label: 'no tests yet'.
	^column: {
		progressBar.
		row: {label: 'Running '. currentSelector . label: '...'}.
		errorCountHolder.
		failureCountHolder.
	}
)
forkTests = (
	tester prepare.
	fork:
		[[runTests] ensure:
			[tester haveAllTestsSucceeded ifTrue: [tester cleanUp]]]
	thenUpdateUI:
		[enterSubject:: TestingOutcomeSubject tester: tester configClass: subject configClass]
)
public isTransient = (
	(* Should not be recorded in navigation history. *)
	^true
)
public noticeVisualCreation = (
	super noticeVisualCreation.
	forkTests.
)
runTests = (
	(* This is not running in the UI process. *)
	| errorCount failureCount |
	errorCount:: 0.
	failureCount:: 0.
	[tester atEnd] whileFalse:
		 [| result |
		currentSelector text: tester peekSelector.
		result:: tester step.
		result isFailure ifTrue: [failureCount:: failureCount + 1].
		result isError ifTrue: [errorCount:: errorCount + 1].
		progressBar percentComplete: tester completedRatio * 100.
		schedule:
			[(failureCountHolder hasVisual and: [failureCount ~= 0]) ifTrue:
				[failureCountHolder content: [row: {label: 'Failures: ', failureCount printString}]].
			(errorCountHolder hasVisual and: [errorCount ~= 0]) ifTrue:
				[errorCountHolder content: [row: {label: 'Errors: ', errorCount printString}]]]]
)
tester = (
	^subject tester
)
) : (
)
public class TestingInProgressSubject tester: tester <Tester> configClass: configClass = Subject onModel: tester (
(* Represents a Tester instance, in the process of running tests. *)
|
	public configClass = configClass.
|) (
public createPresenter = (
	^TestingInProgressPresenter onSubject: self
)
public refreshmentSubject = (
	^self class tester: model configClass: configClass.
)
public tester = (
	^model
)
public title = (
	^'Running Tests'
)
) : (
public onConfiguration: configClass <Class> platform: platform minitest: minitest = (
	| config modules tester |
	config:: configClass packageTestsUsing: ide namespacing manifestForSqueak.
	modules:: config testModulesUsingPlatform: platform minitest: minitest.
	tester:: minitest Tester testModules: modules.
	^self tester: tester configClass: configClass.
)
)
class TestingOutcomePresenter onSubject: s <TestingOutcomeSubject> = ProgrammingPresenter onSubject: s (
(* Shows an outcome of running a suite of tests, as a page with separate sections for errors, failures and successes. *)
) (
definition ^ <Fragment> = (
	^column:{
	      headingDefinition.
		blank: 2.
		errors.
		blank: 1.
		failures.
		blank: 1.
		successes.
	}
)
didAllTestsPass = (
	^didNoTestsFail (* not tracking incomplete for now, so no difference from didNoTestsFail *)
)
didNoTestsFail ^ <Boolean> = (
	^subject failures isEmpty and: [subject errors isEmpty]
)
errors ^ <Fragment> = (
	^section: 'Errors'
		with: subject errors
		status: #error
		color: errorsSectionColor
)
errorsSectionColor = (
	^Gradient from: (Color h: 0 s: 0.15 v: 1) to: (Color h: 0 s: 0.15 v: 0.9)
)
failureHeadingColor = (
	^Gradient from: (Color h: 0 s: 0.5 v: 0.8) to: (Color h: 0 s: 0.5 v: 0.6)
)
failures ^ <Fragment> = (
	^section: 'Failures'
		with: subject failures
		status: #failure
		color: failuresSectionColor
)
failuresSectionColor = (
	^Gradient from: (Color h: 50 s: 0.3 v: 1) to: (Color h: 50 s: 0.3 v: 0.9)
)
headingBlock: fragment color: aColor = (
	^(padded: fragment with: {10. 5. 5. 5}) color: aColor
)
headingContentsDefinition ^ <Presenter> = (
	| statusMessage |
	statusMessage::
		didAllTestsPass
			ifTrue: ['Passed']
			ifFalse:
				[didNoTestsFail
					ifTrue: ['Incomplete test results']
					ifFalse: ['Failed ']].
	^row: {
		(link: subject configurationName asText allBold
			action: [browseClass: subject configClass]) color: Color white.
		smallBlank.
		(label: statusMessage asText allBold) color: Color white.
		filler.
		button: 'Run Again' action: [respondToRunAgain].
(*		smallBlank.
		button: 'Forget' action: [respondToForget] *)
		}.
)
headingDefinition ^ <Presenter> = (
	^headingBlock: headingContentsDefinition
	color: (
		didNoTestsFail
			ifFalse: [failureHeadingColor]
			ifTrue:
				[successHeadingColor])
)
public noticeAbandonment = (
	subject tester haveAllTestsSucceeded ifFalse: [subject tester cleanUp].
	super noticeAbandonment.
)
respondToRunAgain = (
	| newPresenter |
	subject tester cleanUpResults.
	subject tester haveAllTestsSucceeded ifFalse: [subject tester cleanUp].
	newPresenter:: (TestingInProgressSubject
		onConfiguration: subject configClass
		platform: platform
		minitest: minitest) presenter.
	parent
		replaceChild: self
		with: newPresenter
)
respondToRunAll: testCases = (
(* Run the set of test cases given by testCases.  The UI uses this to re-run just the failures, or errors or successes. However, tests have shared state, which one has to tear down and re-initialize.

Other sections that hold test results should be pointing at different shared state so that they can be re-examined  It doesn't look like things are set up to support this. *)
	halt.
)
public runToDebugFailure: testCase = (
	subject tester runToDebugFailure: testCase
)
public runWithNoExceptionHandling: testCase = (
	subject tester runWithNoExceptionHandling: testCase
)
section: label <String> with: testCases <Collection[TestCase]> status: aSymbol <Symbol> color: aColor <Color | Gradient> ^ <Fragment> = (
	| testedMethodsPresenter |
	testedMethodsPresenter:: TestResultListPresenter onSubject: (TestResultListSubject onModel: testCases).
	^column: {
		headingBlock: (row: {
			label: (label, ' (', testCases size printString, ')') asText allBold.
			largeBlank.
			(* (link: 'run all' action: [testedMethodsPresenter runAll]) tinyFont. *)
			filler.
			expandButtonWithAction: [testedMethodsPresenter expandAll].
			blank: 3.
			collapseButtonWithAction: [testedMethodsPresenter collapseAll].
			}
			)
			color: aColor.
		blank: 3.
		testedMethodsPresenter.
		}
)
section: label <String> withHidden: testCases <Collection[TestCase]> status: aSymbol <Symbol> color: aColor <Color | Gradient> ^ <Fragment> = (
	| contentHolder testedMethodsPresenter |
	testedMethodsPresenter:: TestResultListPresenter onSubject: (TestResultListSubject onModel: testCases).
	contentHolder:: holder:
		(row: {
			blank: 10.
			testCases isEmpty ifFalse:
				[(link: 'Show details...'
				action: [majorUpdate: [contentHolder content: testedMethodsPresenter]]) tinyFont]
			}).
	^column: {
		headingBlock: (row: {
			label: (label, ' (', testCases size printString, ')') asText allBold.
			largeBlank.
			(* (link: 'run all' action:
				[contentHolder content == testedMethodsPresenter
					ifTrue: [testedMethodsPresenter runAll]
					ifFalse: [respondToRunAll: testCases]
				]) tinyFont. *)
			filler.
			expandButtonWithAction:
				 	[contentHolder content == testedMethodsPresenter
					    ifTrue: [testedMethodsPresenter expandAll]].
			blank: 3.
			collapseButtonWithAction:
				[contentHolder content == testedMethodsPresenter
					 ifTrue: [testedMethodsPresenter collapseAll]].
			}
			)
			color: aColor.
		blank: 3.
		contentHolder.
		}
)
successHeadingColor = (
	^Gradient from: (Color h: 120 s: 0.5 v: 0.7) to: (Color h: 120 s: 0.5 v: 0.5)
)
successes ^ <Fragment> = (
	^section: 'Successes'
		withHidden: subject successes
		status: #success
		color: successesSectionColor
)
successesSectionColor = (
	^Gradient from: (Color h: 90 s: 0.3 v: 1) to: (Color h: 90 s: 0.3 v: 0.9)
)
) : (
)
class TestingOutcomeSubject tester: tester <Tester> configClass: configClass = Subject onModel: tester (|
	public configClass = configClass.
|) (
public configurationName = (
	^configClass name
)
public createPresenter = (
	^TestingOutcomePresenter onSubject: self
)
public errors = (
	^tester errors
)
public failures = (
	^tester failures
)
public refreshmentSubject = (
	^self class tester: tester configClass: configClass
)
public successes = (
	^tester successes
)
public tester = (
	^model
)
public title = (
	^'Test Results for ', configurationName
)
) : (
)
) : (
)
