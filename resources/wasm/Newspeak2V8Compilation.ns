Newspeak3
'Root'
class Newspeak2V8Compilation usingPlatform: platform asts: asts parsing: parsing generation: generation = NewspeakCompilation usingPlatform: platform asts: asts (
(*
This module provides a Newspeak-to-Javascript cross-compiler. It is a descendent of Newspeak2Javascript which takes care to generate code that is easier for V8 to optimize and which is easier to maintain because of a simpler bootstrapping story and strategy for including bits that need to be written directly in Javascript.

The output is not V8-specific and should run in any Javascript implementation that supports apply(), call() and bind().

The current compilation scheme does not address async sends or reified activation records. It provides only limited support for refection. Also,  it does not provide generalized mixin application.

At runtime, a Newspeak object O is represented as a Javascript object J with properties that correspond directly to the Newspeak slots. The prototype of J is a runtime-class JRC, whose properties correspond to the instance methods of O's class, including any necessary synthetic methods. The prototype of JRC is another runtime class object corresponding to the superclass of O's class, and so on up to Object. The prototype of the runtime class of Object is ImplementationBase, which is hand-written and contains stub implementations to end the upward recursion in basicNew and the instance initializers.JRC includes synthetic slots that refer to its runtime mixin, its enclosing object chain, and its metaclass or non-metaclass counterpart.

The main output of the compiler is an object containing all of the runtime mixins corresponding to the top-level class declarations. A runtime mixin has properties containing the definitions of its Newspeak and synthetic methods and its nested mixins. It also has a function that takes a runtime superclass and produces a runtime class that represents the application of the mixin. This function produces either a runtime class or a runtime metaclass, not the pair.

One synthetic method deserves particular attention: basicNew(). The prototype of basicNew is the runtime class. The body of basicNew calls the basicNew of the superclass using call(), then initializes properties corresponding to each Newspeak slot to nil.

All mixin applications share the same Newspeak and synthetic functions, except basicNew.

[PERFORMANCE NOTE] It is important that objects have all their slots initialized up front, rather than lazily. This ensures that all instances of the same Newspeak class go through the same transitions in the same order so V8 will give them all the same "hidden class" (what Self called a map).

[PERFORMANCE NOTE] It is important that an object's methods are defined in a prototype, rather than in the constructor call. If they were defined in the constructor, they would be different objects with different contexts.

[PERFORMANCE NOTE] The current structure where the functions for methods are defined in other deeply nested functions may produce functions that perform slower than if they had been defined at the top level. This is because of a need to give them contexts, even if they never access their free variables. This used to be an issue in V8, but it was fixed under pressure from dart2js (who wanted to nest all of their code at least one level to avoid polluting the global scope). It may still be the case in other Javascript engines.Object creation follows the same pattern as the Squeak and Dart implementations: basicNew is followed by running a synthetic instance initializer.

Mixin application is implemented by a hand-written method on VMMirror. First a pair of runtime class and runtime metaclass are produced by applying the runtime mixin and runtime metamixin to the runtime class of the superclass and the runtime class of Class, respectively. Then an instance of Metaclass is created to represent the Newspeak metaclass, and an instance of the metaclass is created to represent the Newspeak class. Newspeak objects never directly interact with runtime classes or runtime mixins; the objects answered by #class are the Newspeak class or metaclass.

Self sends and ordinary sends map to Javascript method invocation. Outer sends map to an invocation on an entry in the enclosing objects array at the correct depth. Implicit receiver sends are resolved either as the self sends or outer sends at compile-time. Super sends are implemented as call() applied to the corresponding property of the runtime superclass.

Newspeak selectors are mangled into legal Javascript identifiers. The mangling differs according to the accessibility of the selector. Public selectors are always prefixed with $. In addition,  keyword selectors have each colon replaced with dollar. For binary selectors, they are the concatenation of a mapping for each of the special characters. Examples:

yourself maps to $yourself.

with:with: maps to $with$with$. +- maps to $$plus$minus.

For protected selectors, the public mangling is preceded with an underscore. Hence yourself maps to _$yourself.with:with: maps to _$with$with$. +- maps to _$$plus$minus.The selector #doesNotUnderstand: is treated specially and mapped to dnu.

A full description of the access control scheme is available at:

https://docs.google.com/document/d/1CHTjsOsamXv9AwGTvkhe871QVY5vpZP9sDfz6I40gaA/

[PERFORMANCE NOTE] It is important that we use legal identifiers for our property names. The earlier NS2JS did not mangle selectors and instead used square bracket notation to access properties. For example, foo at: 1 put: 2 would become foo["#at:put:"](1,2) rather than foo.at$put$(1,2). V8 eagerly transitions objects like these to dictionary mode, which means they do not have fast property access. This is the most important difference between NS2JS and NS2V8.

Non-local return is implemented using exceptions. The body of a method containing an NLR is wrapped in a try-catch block. At the beginning, an object is created to represent the current activation. When there is a non-local return, the return value is assigned to a property of this object and the object is thrown. The catch clause checks if the object thrown corresponds to its NLR object, and if so extracts the value and does a Javascript (local) return. Otherwise the object is re-thrown.

[ENGINEERING NOTE]This is buggy, because if a closure returns after its home context has completed, the exception will not be caught and the entire program will crash (even when debugging in the IDE).  A method that contains an NLR must invalidate its NLR exception object when it exits, and closures must check the validity of the NLR exception before throwing; if it is in valid, a CannotReturn must be signaled. The best way to accomplish all this is to set the variable holding the NLR exception to nil upon home context exit, so that the closure can test for nil when executing an NLR. This will have very minor performance impact.

Newspeak closures map to Javascript functions. Accesses to self do *not* map directly to "this". Rather the receiver must be captured in a local at the beginning of a method, and access must be through this local to get proper lexical scope.

[UNIMPLEMENTED] This representation is not suitable for closure mirrors as there is no way in Javascript to get at the closure's free variables. To support closure mirrors, we would have create objects for each closure that took free variables and the enclosing context as arguments and stored them as slots that reflection could later access. dart2js follows this approach (but I believe this is to ensure they cannot be called with the wrong arity).

To implement #doesNotUnderstand:, for every message sent the compiler emits a DNU catcher that creates a Message object from the arguments and forwards to #doesNotUnderstand:.  At bootstrap, these handlers are all installed into ImplementationBase under both the public and protected manglings of the selector.

[PERFORMANCE NOTE] It is important that these prototypes are all installed up-front, rather than the subset needed at each mixin application, to ensure the prototype chain is stable during the program's execution. Installing these catchers later would trigger deoptimizations.

The basic types (number, array, block, boolean, string) are represented directly as their Javascript counterparts. Where the Javascript behavior differs from the Newspeak behavior, we monkey patch the Javascript prototypes.

[ENGINEERING NOTE] These patches are all defined in classes of KernelForV8, using the js intrinsic described below. Unlike NS2JS, there is no need to look through several places and bootstrapping phases to find where such behavior is defined. Adding or modifying behavior for the basic types is as easy as adding or changing methods in these classes.

[PERFORMANCE NOTE] It is important that these patches are labelled for strict mode to avoid automatic boxing.

[ENGINEERING NOTE] We simply label the whole program for script mode, but if our output got wrapped in or otherwise mixed with other scripts, it wouldn't run in script mode.

[ENGINEERING NOTE] dart2js does not use this technique because they want to interoperate with other Javascript code. Instead they use a technique called interceptors, and can avoid the cost in the common case through fancy type inference and inlining that make runtime modification very difficult. Newspeak doesn't want to go there and is content to monkey patch.

[ENGINEERING NOTE] Like dart2js, we cave on the semantics of integers by directly representing our numbers as Javascript numbers, which are doubles.

Nil is not represented as Javascript's null. We use a singleton instance of the Newspeak class UndefinedObject.

Source code is not stored with the methods. Instead, each runtime class has an associated metadata structure that contains an index into an array of method sources. The metadata is stored in an array accessed via the property 'methods'. Each method has an entry with properties 'name', 'isSynthetic' and 'source'. This array is stored in the Javascript global variable 'sources'.  The deployment tools can place the code for initializing this array in a separate file, so deployments that do not wish to support debugging can easily avoid the space penalty for the source.

Bootstrapping: the compiled Javascript starts by hand-initializing the classes of Kernel to deal with the circular references. Then a namespace is populated with the applications of each of the top-level mixins to Object. This namespace is passed to the factory of RuntimeForV8, and the returned object is passed the VMMirror. This causes the platform object to be created and initialized. As part of this process, the DNU catchers and basic type monkey patches are installed. The application configuration is then passed the namespace, and the returned app object is sent #main:args: with the platform.  (Newspeak2Dart follows the same pattern, though without DNU catcher or basic type patches.)

[ENGINEERING NOTE] This is *way* simpler than whatever multi-phase thing NS2JS is doing.

The js intrinsic: When compiling the platform sources, we evaluate sends to "js" at compile-time against a factory for Javascript ASTs (an instance of JavascriptGeneration`Factory). For instance,

at: index = (	^js propertyOf: (js ident: 'this') at: index - 1)

translates to

function $at$(index) { return this[index - 1]; }

Note that arguments in messages to "js" can be arbitrary expressions (index - 1), which will be compiled like any other ordinary expression, allowing one to write implementations partially in the target language and partially in ordinary Newspeak in the same method.

This scheme allows the implementations of primitives to be written in the methods they are implementing and without special language support like pragmas, externs or native clauses, which I think is pretty cool :)

[UNIMPLEMENTED] Async sends

[UNIMPLEMENTED] Reflective modification

This brings up several issues.

(1) Because implicit sends are resolved statically to self sends or outer sends, it is not sufficient to just add or remove methods. Potentially, the entire class must be recompiled if the change hides/unhides a method in the surrounding scope.

(2) Adding a new selector requires adding a new DNU catcher in ImplementationBase, which may have very negative effects on performance.  We could try and rely on the ES6 handlers if we only care about new browsers.

[UNIMPLEMENTED] Reified activation records
These are needed to provide a proper live debugger.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.
Copyright 2013 Ryan Macnak
Copyright 2014-2017 Google Inc.
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)
|
	Collection = platform collections Collection.
	Map = platform collections Map.
	List = platform collections List.	Set = platform collections Set.
	StringBuilder = platform kernel StringBuilder.
	Parser = parsing Parser.
	javascriptGeneration = generation.
	JavascriptWriter = javascriptGeneration Writer.
	js = javascriptGeneration factory.
	public names = NameMangler new.
	ASTTool = asts ASTTool.
	AST = asts AST.
	BlockAST = asts BlockAST.
	CascadedSendAST = asts CascadedSendAST.
	CodeBodyAST = asts CodeBodyAST.
	MessageAST = asts MessageAST.
	MessagePatternAST = asts MessagePatternAST.
	MethodAST = asts MethodAST.
	UnresolvedSendAST = asts UnresolvedSendAST.
	NumberAST = asts NumberAST.
	ReturnStatAST = asts ReturnStatAST.
	SendAST = asts SendAST.
	SymbolAST = asts SymbolAST.
	TupleAST = asts TupleAST.
	VarDeclAST = asts VarDeclAST.
	VariableAST = asts VariableAST.
	public parser = Parser new.
	cachedCompilations = Map new.
	sourcesList ::= List new. (* Ick, should really belong to ProgramBuilder. *)
|
) (
class CachedCompilation = (|
	public source <String>
	public enableIntrinsics <Boolean>
	public ir <ClassDeclarationIR>
	public sentSelectors <Set[Symbol]>
|) (
) : (
)
public class Compiler = super Compiler (
(* Compiler reimplementation, with Javascript AST as the output. This makes automated testing easier and provides control over formatting (for example, placing every expression on its own line to allow for precise breakpoint placement in substandard JS debugger implementations). *)
|
	protected scopeMap <Map[AST, Scope]> ::= Map new.
	scopeStack ::= List new.
	input
	public sentSelectors ::= Set new.

	rewriter = Rewriter new.
	translator = Translator new.
	currentScope
	currentDepth 
	currentMixinUID
	jsWriter = JavascriptWriter new.
	public supportDoesNotUnderstand ::= true.
	public inlineOperators ::= true.
	public enableIntrinsics ::= true.
|) (
class PropertyCallAST = MessageAST (
(* Sepcialized node to represent applications of JS properties. In some cases (well, at least one) we need to generate ASTs that call javascript methods directly. These calls need to be translated slightly differently (their names must not be mangled). To distinguish these form normal message sends, we use this node. *)
) (
public apply: tool <ASTTool> = (
	^tool propertyCallNode: self
)
) : (
)
class Rewriter = super Rewriter (|
	protected inlinableOperators <Map[String, String]> = Map new.
	protected inlinableNumericOperators <Map[String, String]> = Map new.
|inlinableOperators
		at: #+ put: '+';
		at: #- put: '-';
		at: #* put: '*';
		at: #/ put: '/';
		at: #'==' put: '==='.
	inlinableNumericOperators
		at: #'<' put: '<';
		at: #'<=' put: '<=';
		at: #'>' put: '>';
		at: #'>=' put: '>=') (
class InlinedOperatorAST = SendAST (
(* When the inlineOperators mode is on, message sends with certain selectors are replaced with this node. Javascript code generated for those nodes uses native Javascript operators instead of real message sends. The selector of the message of this AST is not a real Newspeak selector but rather the Javascript operator such as &&. *)
|
	public receiver <ExpressionAST>
|) (
public apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinedOperatorNode: self
)
public to: anExpression <ExpressionAST> send: aMessage <MessageAST> = (
	self receiver: anExpression; message: aMessage
)
public to: receiver send: selector with: arguments = (
	to: receiver send: (MessageAST new send: selector with: arguments)
)
) : (
)
class SchedulerAST = AST () (
public apply: visitor <ASTVisitor> = (
	^visitor schedulerNode: self
)
) : (
)
public applyTo: node withScope: scope = (
	| result |
	self pushScope: scope.
	result:: node apply: self.
	self popScope.
	^result
)
canInlineSeqexps ^<Boolean> = (
	^false
)
currentScope = (
	^super currentScope
)
inline: node as: sendClass selector: selector rewriteArgsAs: argRewriteBlock = (
	| receiver message |
	receiver:: applyForValueTo: node receiver.
	message:: MessageAST new
		send: selector
		with: (node message arguments collect: argRewriteBlock).
	^sendClass new
		to: receiver send: message;
		start: node start;
		end: node end
)
isInlinableBooleanOperator: node <NormalSendAST> = (
	| selector |
	selector:: node message selector.
	^(selector = 'or:' or: [selector = 'and:'])
		and: [node message arguments size = 1
		and: [node message arguments first isKindOfBlockNode
		and: [node message arguments first body statements size = 1]]]
)
isInlinableNumericOperator: node <NormalSendAST> = (
	| args |
	args:: node message arguments.
	args size = 1 ifFalse: [^false].
	(inlinableNumericOperators includesKey: node message selector) ifFalse: [^false].
	(node receiver isKindOfLiteralNode and: [node receiver value isKindOfNumber]) ifTrue: [^true].
	(args first isKindOfLiteralNode and: [args first value isKindOfNumber]) ifTrue: [^true].
	^false
)
isInlinableOperator: node <NormalSendAST> = (
	^(inlinableOperators includesKey: node message selector)
		and: [node message arguments size = 1]
)
processEventualSend: node <NormalSendAST> = (
	| scheduler receiver selector arguments |
	scheduler:: SchedulerAST new.

	receiver:: node receiver apply: self.
	selector:: (SymbolAST new value: node message selector) apply: self.
	arguments:: (TupleAST new elements: node message arguments) apply: self.

	^(OrdinarySendAST
		to: scheduler
		send: ((MessageAST new
			send: #eventualSendTo:selector:arguments:
			with: {receiver. selector. arguments})
				copyPositionFrom: node message))
		copyPositionFrom: node
)
processMappedVariable: msg decl: binding = (
	^((msg selector endsWith: ':')
		ifTrue: [binding setterAst: msg arguments first]
		ifFalse: [binding getterAst])
			apply: self
)
public propertyCallNode: node <PropertyCallAST> ^ <PropertyCallAST> = (
	| args |
	assert: [node isKindOfMessageNode].
	args:: List new.
	node arguments do: [:each | args add: (applyForValueTo: each)].
	^PropertyCallAST new
		send: node selector with: args;
		start: node start;
		end: node end
)
setterBlockArgName = (
	^('setter_arg') asSymbol
)
public setterSendNode: node <SetterSendAST> ^ <AST> = (
(* Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send. *)
	| binding block blockArg blockParam blockScope send rewrittenSetterSend |
	binding:: currentScope at: node message selector ifAbsent: [MessageAST new].
	binding isLocalBinding ifTrue:
		(* This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned. *)
		[^processLocalAccess: node message of: binding].
	valueExpected ifFalse:
		(* The parent ignores the expression value; use a plain cheap here message send. *)
		[^processImplicitReceiverSend: node].

	(* The value is used by the parent; rewrite the whole thing as
		setter:: expr => [:a | setter: a. a] value: expr *)
	(* a -- ok to use a constant name as long as it cannot collide with a user's name *)
	blockArg:: UnresolvedSendAST new
		to: implicitReceiverNode
		send: (MessageAST new send: setterBlockArgName with: {}).
	blockParam:: ParameterAST name: setterBlockArgName type: nil.
	(* setter: a *)
	send:: UnresolvedSendAST new to: node receiver send:
		(MessageAST new selector: node message selector; arguments: {blockArg};
		start: node message start; end: node message end; yourself);
		start: node start; end: node end.
	(* [:a | setter: a. a] *)
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {blockParam}
			temporaries: {}
			statements: {
				send.
				blockArg
			};
			start: node start; end: node end);
			start: node start; end: node end.
	blockScope:: Scope parent: currentScope.
	blockScope
		at: setterBlockArgName put: (LocalEntry forDeclaration: blockParam atDepth: nil).
	scopeMap at: block put: blockScope.
	scopeMap at: block body put: blockScope.
	(* [:a | setter: a. a] value: expr *)
	rewrittenSetterSend::
		UnresolvedSendAST new
			to: block
			send: (MessageAST new
				selector: #value:;
				arguments: {node message arguments first};
				start: node message start; end: node message end);
				start: node start; end: node end.
	^applyForValueTo: rewrittenSetterSend
)
public unresolvedSendNode: node <UnresolvedSendAST> ^ <AST> = (
	#BOGUS. (* Eventual sends trump inlining, but we shouldn't need to duplicate the eventual send check. Maybe the inlining should be deferred until we know it is an immediate ordinary send? *)
	(node message isEventual)
		ifTrue: [^processEventualSend: node].

	(inlineOperators and: [isInlinableNumericOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableNumericOperators at: node message selector)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableOperators at: node message selector)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableBooleanOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (node message selector = 'and:' ifTrue: ['&&'] ifFalse: ['||']) (* BOGUS *)
			rewriteArgsAs: [:each <BlockAST> | applyForValueTo: each body statements first]].

	^super unresolvedSendNode: node
)
) : (
)
class Translator = ASTTool (
(* Visits nodes of an NS AST to produce a Javascript AST. The usual translation unit is a method. Translation is initiated by sending the translateMethodNode: message. The argument is the method to translate, the returned value is the translation. *)
|
	scopeStack
	public currentSelector
	protected containsNonLocalReturn <Boolean> (* Set to false at the beginning of translating a method. The code that emits a non-local return sets this to true. The top-level code checks the value to see whether to emit a try-catch wrapper for an NLR. *)
	protected methodIsPrivate <Boolean>
|) (
addCascadedSend: node to: statements = (
	node isKindOfCascadedSendNode ifTrue:
		[addCascadedSend: node previousSend to: statements].
	statements add:
		(js call: (js propertyOf: (js ident: 'cascadeReceiver') at: (publicMessage: node message))
			with: (node message arguments collect: [:each | each apply: self]) asArray).
)
public beginNewTranslationCycle = (
	scopeStack:: List new.
	containsNonLocalReturn:: false.
)
public blockLocalReturnNode: node <BlockLocalReturnAST> = (
	^js return: (node expression apply: self)
)
public blockNode: node <BlockAST> = (
	^js functionOf: (node parameters collect: [:each | self parameterDeclNode: each]) asArray
			body: (node body apply: self).
)
public boolNode: node <BoolAST> = (
	^js literal: node value
)
public cascadedSendNode: node <CascadedSendAST> = (
	| statements |
	statements:: List new.
	addCascadedSend: node to: statements.
	statements at: statements size put: (js return: statements last).
	^js call: (js functionOf: {'cascadeReceiver'} body: (js block: statements))
		with: {node receiver apply: self}
)
public characterNode: node <CharAST> = (
	(* Javascript has no characters, only strings. *)
	^js literal: node value asString
)
public codeBodyNode: node <CodeBodyAST> = (
	| locals statements |
	locals:: node temporaries collect: [:each | self temporaryDeclNode: each].
	statements:: node statements collect: [:each | each apply: self].
	^js block: (locals asArray, statements) asArray
)
public conditionalNode: node <ConditionalAST> = (
	^inlinableConditionalNode: node
)
public enclosingObjectNode: node <EnclosingObjectAST> = (
	^processOuterReceiverAtDepth: node depth
)
public implicitReceiverSendNode: node <ImplicitReceiverSendAST> = (
	| receiver = processOuterReceiverAtDepth: node depth. |
	^processLexicalSend: node message to: receiver binding: node binding
)
public inlinableAsExpressionConditionalNode: node <InlinableConditionalAST> = (
	| truePath falsePath condition |

	condition:: (node receiver apply: self).

	node message selector = 'ifTrue:' ifTrue:
		[truePath:: (node message arguments at: 1) body statements first apply: self.
		falsePath:: js ident: 'nil'].
	node message selector = 'ifFalse:' ifTrue:
		[truePath:: js ident: 'nil'.
		falsePath:: (node message arguments at: 1) body statements first apply: self].
	node message selector = 'ifTrue:ifFalse:' ifTrue:
		[truePath:: (node message arguments at: 1) body statements first apply: self.
		falsePath:: (node message arguments at: 2) body statements first apply: self].
	node message selector = 'ifFalse:ifTrue:' ifTrue:
		[truePath:: (node message arguments at: 2) body statements first apply: self.
		falsePath:: (node message arguments at: 1) body statements first apply: self].

	^js ternaryIf: condition then: truePath else: falsePath
)
public inlinableConditionalNode: node <InlinableConditionalAST> = (
	| inverseCondition hasElseClause condition |
	inverseCondition:: node ifTrue not.
	hasElseClause:: node else isNil not.
	condition:: node condition apply: self.
	^js if: (inverseCondition ifTrue: [js prefixOperator: '!' on: condition] ifFalse: [condition])
		then: (node then apply: self)
		else: (hasElseClause ifTrue: [node else apply: self] ifFalse: [nil])
)
public inlinedOperatorNode: node <InlinedOperatorAST> = (
	(* We are not modeling JS operator precedence, so just parenthesize everything. *)
	^js operator: node message selector
		with: (node receiver apply: self)
		and: (node message arguments first apply: self)
)
public localReadNode: node <LocalReadAST> = (
	^js ident: (names mangleLocal: node name)
)
public localWriteNode: node <LocalWriteAST> = (
	^js assign: (js ident: (names mangleLocal: node name)) toBe: (node value apply: self)
)
public loopNode: node <LoopAST> = (
	(* prologue; while(cond==whileTrue) {body}; *)

	|
	prologue = node prologue ifNil: [js block: {}] ifNotNil: [:it | it apply: self].
	cond = node condition apply: self.
	body = node body ifNil: [js block: {}] ifNotNil: [:it | it apply: self].

	(* Split the condition is it isn't a single expression *)
	condExpression ::= cond statements last.
	condPrologue = cond statements asOrderedCollection removeLast; yourself.
	|

	node isWhileTrue ifFalse: [
		condExpression:: js prefixOperator: '!' on: condExpression].

	(* Flatten prologue so its declarations are in scope for the loop *)

	^js block:
		prologue statements,
		condPrologue, {
		js
			for: (js verbatim: '')
			while: condExpression
			step: (js verbatim: '')
			do: (js block: body statements, condPrologue)}
)
maybeCaptureReceiver = (
	methodIsPrivate
		ifTrue: [^{}]
		ifFalse: [^{js var: selfName value: (js ident: 'this')}].
)
public messageNode: node = (
	halt.
	sentSelectors add: node selector.
	^js literal: (names mangleSelector: node selector)
)
public messagePatternNode: node <MessagePatternAST> ^<List[String]> = (
	| jsParameters = List new. |
	currentSelector:: node selector.
	methodIsPrivate:: node accessModifier = #private.
	methodIsPrivate ifTrue: [jsParameters add: selfName].
	node parameters do: [:each | jsParameters add: (self parameterDeclNode: each)].
	^jsParameters
)
public methodLocalReturnNode: node <MethodLocalReturnAST> = (
	containsNonLocalReturn ifFalse:
		[^js return: (node expression apply: self)].

	^js block: {
		js var: 't' value: (node expression apply: self).
		js assign: (js ident: nlrName) toBe: (js ident: 'null').
		js return: (js ident: 't')
	}
)
public methodNode: node <MethodAST> ^<Node> = (
	| translatedBody |
	node body apply: self. (* Translate once to compute containsNonLocalReturn. Method-local returns that appear before the non-local return are incorrectly compiled. *)
	translatedBody:: node body apply: self.
	^js functionOf: (node pattern apply: self) asArray
		body: (containsNonLocalReturn
			ifTrue: [wrapBodyForNlrHandling: translatedBody]
			ifFalse: [wrapBodyNoNlrHandling: translatedBody]).
)
public nilNode: node = (
	^js ident: 'nil'
)
nlrName = (
	^'NLR'
)
nlrValuePropertyName = (
	^'value'
)
public nonLocalReturnNode: node <NonlocalReturnAST> = (
	^returnStatNode: node
)
public numberNode: node <NumberAST> = (
	^js literal: node value
)
public ordinarySendNode: node <OrdinarySendAST> = (
	enableIntrinsics ifTrue:
		[node receiver isKindOfImplicitReceiverSendNode ifTrue:
			[node receiver message selector = 'js' ifTrue:
				[^processIntrinsic: node message]]].

	^js
		call: (js propertyOf: (node receiver apply: self) at: (publicMessage: node message))
		with: (node message arguments collect: [:each | each apply: self]) asArray
)
public outerSendNode: node <OuterSendAST> = (
	| receiver = processOuterReceiverAtDepth: node depth. |
	^processLexicalSend: node message to: receiver binding: node binding
)
public parameterDeclNode: node <ParameterAST> = (
	^names mangleLocal: node name
)
processIntrinsic: msg <MessageAST> = (
	^js perform: msg selector
		withArguments: (msg arguments collect: [:arg | processIntrinsicArg: arg]) asArray.
)
processIntrinsicArg: arg <AST> = (
	arg isKindOfTupleNode ifTrue: [^(arg elements collect: [:el | processIntrinsicArg: el]) asArray].
	arg isKindOfLiteralNode ifTrue: [^arg value].
	^arg apply: self
)
processOuterReceiverAtDepth: depth <Integer> = (
	| slotName |
	depth = 0 ifTrue: [^js ident: 'self'].
	slotName:: names mangleSynthetic: 'enclosingObjects`', currentMixinUID.
	^js propertyOf: (js propertyOf: (js ident: 'self') at: (js literal: slotName))
		at: (js literal: depth - 1) (* Adjust for self not being in the enclosing objects array. *)
)
public propertyCallNode: node <PropertyCallAST> = (
	^js literal: (names mangleSelector: node selector)
)
protectedMessage: node = (
	sentSelectors add: node selector.
	^js literal: (names mangleProtected: node selector)
)
publicMessage: node = (
	sentSelectors add: node selector.
	^js literal: (names manglePublic: node selector)
)
public receiverNode: node <ReceiverNode> = (
	^js ident: selfName
)
public returnStatNode: node <ReturnAST> = (
	containsNonLocalReturn:: true.
	^js block: {
		js var: 't' value: (node expression apply: self).
		js if: (js operator: '===' with: (js ident: nlrName) and: (js ident: 'null'))
			then: (js call: (js propertyOf: (js ident: selfName) at: (js literal: names privateCannotReturn)) with: {js ident: selfName. js ident: 't'}).
		js assign: (js propertyOf: (js ident: nlrName) at: (js literal: nlrValuePropertyName)) toBe: (js ident: 't').
		js throw: (js ident: nlrName)
	}
)
public schedulerNode: node <SchedulerAST> = (
	^js ident: 'currentActor'
)
selfName = (
	^'self'
)
public selfSendNode: node <SelfSendAST> = (
	| receiver = js ident: selfName. |
	^processLexicalSend: node message to: receiver binding: node binding
)
public stringNode: node <StringAST> = (
	^js literal: node value
)
public superSendNode: node <SuperSendAST> = (
	| superSlotName args |
	superSlotName:: names mangleSlot: 'super`', currentMixinUID.
	args:: List new.
	args add: (js ident: 'self').
	node message arguments do: [:each | args add: (each apply: self)].
	^js call:
			(js propertyOf:
				(js propertyOf: (
					js propertyOf: (js ident: 'self')
						at: (js literal: superSlotName))
					at: (protectedMessage: node message))
				at: (js literal: 'call')) with: args
)
public symbolNode: node <SymbolAST> = (
	^js literal: node value
)
public temporaryDeclNode: node <ParameterAST> ^<String> = (
	^js var: (names mangleLocal: node name)
		value: (js ident: 'nil')
)
public tupleNode: node <TupleAST> = (
	^js array: (node elements collect: [:ea | ea apply: self])
)
public varDeclNode: node <VarDeclNode> = (
	(* Produce the corresponding local decl. *)
	^js var: (names mangleLocal: node name)
)
wrapBodyForNlrHandling: body <Block> = (
	| nlrVarNode nlrParamName nlrParamNode |
	nlrVarNode:: js ident: nlrName.
	nlrParamName:: nlrName, '_exception'.
	nlrParamNode:: js ident: nlrParamName.
	^js block: maybeCaptureReceiver,
		{js var: nlrName value: (js new: (js ident: 'Object') with: {}).
		js try: body catch: nlrParamName with:
			(js block: {
				js if: (js operator: '===' with: nlrVarNode and: nlrParamNode)
					then: (js return: (js propertyOf: nlrParamNode at: (js literal: nlrValuePropertyName)))
					else: (js throw: nlrParamNode)
			})
	}
)
wrapBodyNoNlrHandling: body <Block> = (
	^js block: maybeCaptureReceiver, body statements
)
processLexicalSend: message to: jsReceiver binding: binding = (
	(binding isNil not and: [binding ast accessModifier = #private]) ifTrue: [
		(* Do early binding. *)
		|
		definingMixinDepth = binding depth - 1.
		definingMixin = js ident: '$', definingMixinDepth printString.
		targetMethod = js propertyOf: definingMixin at: (publicMessage: message).
		|
		^js call: targetMethod (*(js propertyOf: targetMethod at: (js literal: 'call'))*)
			with: {jsReceiver}, (message arguments collect: [:each | each apply: self]) asArray
	].

	^js
		call: (js propertyOf: jsReceiver at: (protectedMessage: message))
		with: (message arguments collect: [:each | each apply: self]) asArray
)
) : (
)
accessorForNestedClassNamed: simpleName <String> in: mixinName <String> superCall: superAccessor <Node> ^ <String> = (
(* Build  a method that will lazily create a nested class 'simpleName' with superclass defined by 'superAccessor' via mixin application, and cache it.  Maybe replace null slot with self-replacing function that computes class and stores in its closure? *)

	| nestedName <String> nestedSlotName <String> nestedSlotNode <Node> enclosingObjectsName <String> |
	nestedName:: names mangleSynthetic: mixinName, '`', simpleName.
	nestedSlotName:: names mangleSlot: mixinName, '`', simpleName.
	nestedSlotNode:: js propertyOf: (js ident: 'this') at: (js literal: nestedSlotName).
	enclosingObjectsName:: names mangleSynthetic: 'enclosingObjects`', mixinName.
	^js functionOf: {} body: (js block: {
		js if: (js operator: '===' with: (js ident: 'nil') and: nestedSlotNode)
			then: (js block: {
				js var: 'self' value: (js ident: 'this').
				js var: 'superclass' value: superAccessor.
				js var: 'enclosingObjects' value:
					(js call: (js propertyOf: (js array: {js ident: 'this'}) at: (js literal: 'concat'))
						with: {js propertyOf: (js ident: 'this') at: (js literal: enclosingObjectsName)}).
				js var: 'mixin' value: (js propertyOf: (js ident: '$') at: (js literal: nestedName)).
				js assign: nestedSlotNode toBe:
					(js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: '$applyMixin$toSuperclass$withEnclosingObjects$'))
						with: {(js ident: 'mixin'). js ident: 'superclass'. js ident: 'enclosingObjects'}).
			}).
		js return: nestedSlotNode.
		})
)
accessorForSuperclass: superclassCall <AST> inScope: s <Scope> ^<Node> = (
	| send |
	send:: rewriter applyTo: superclassCall withScope: s.

	translator beginNewTranslationCycle.
	^send apply: translator
)
buildIncrementalScopeFor: mm <MixinMirror> = (
	| enclosingClass thisClass |
	enclosingClass:: mm declaration enclosingClass.
	nil = enclosingClass ifFalse: [buildIncrementalScopeFor: enclosingClass instanceSide].

	thisClass:: ClassEntry
		forDeclaration: (MessagePatternAST new selector: mm declaration name)
		atDepth: currentDepth.
	thisClass enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).

	pushScope:: Scope parent: currentScope.
	currentDepth:: currentDepth + 1.

	currentScope at: #'@currentClass' put: thisClass.

	mm slots do:
		[:s <SlotMirror> |
		| se = SlotEntry
			forDeclaration: (MessagePatternAST new selector: s name; accessModifier: s accessModifier)
			atDepth: currentDepth. |
		currentScope at: (namer selectorForSlotInitializer: s) put: se.
		currentScope at: (namer selectorForSlotGetter: s) put: se.
		s isMutable ifTrue:
			[currentScope at: (namer selectorForSlotSetter: s) put: se]].

	mm methods do:
		[:m <MethodMirror> |
		| me = MethodEntry
			forDeclaration: (MessagePatternAST new selector: m name; accessModifier: m accessModifier)
			atDepth: currentDepth. |
		currentScope at: m name put: me].

	mm nestedClasses do:
		[:c <ClassDeclarationMirror> |
		| ce = ClassEntry
			forDeclaration: (MessagePatternAST new selector: c name; accessModifier: c accessModifier)
			atDepth: currentDepth. |
		ce enclosingClass: thisClass.
		currentScope at: c name put: ce].
)
checkForDuplicateNames: aNode = (
	| namesWithDuplicates names duplicateNames |

	namesWithDuplicates:: List new.
	aNode instanceSide methods do: [:each | namesWithDuplicates add: each selector].

	aNode header slots do: [:each |
		namesWithDuplicates add: each name.
		each isMutable ifTrue: [namesWithDuplicates add: each name, ':']].

	namesWithDuplicates
		addAll: (aNode instanceSide nestedClasses collect: [:each | each name]).

	names:: Set new.
	duplicateNames:: Set new.
	namesWithDuplicates do: [:each | | present |
		present:: true.
		names include: each ifNew: [present:: false].
		present ifTrue: [duplicateNames add: each]].

	duplicateNames isEmpty ifFalse: [ | message |
		message:: String streamContents: [:s |
			s
				nextPutAll: 'Class ';
				nextPutAll: aNode name;
				nextPutAll: '" has multiple definitions for '.
			duplicateNames
				do: [:each | s nextPutAll: each asString]
				separatedBy: [ s nextPutAll: ','].
			s nextPutAll: '.'.].
		assert: false message: message].
)
checkForReservedWord: selector = (
	^super checkForReservedWord: selector
)
classNode: aNode <ClassDeclarationAST> within: mixinIR ^ <IntermediateClassDeclaration> = (
	| ir <IntermediateClassDeclaration> priorMixinUID <String> |
	aNode name = #Newspeak2V8Compilation ifTrue: [
		#BOGUS. (* The flaw in the js intrinsic scheme. *)
		enableIntrinsics: false].
	checkForDuplicateNames: aNode.
	ir:: computeMixinFrom: aNode header within: mixinIR.
	ir accessModifier: aNode accessModifier.
	priorMixinUID:: currentMixinUID.
	currentMixinUID:: ir qualifiedName.
	currentDepth:: currentDepth + 1.
	processInstanceSideOf: aNode ofMixin: ir instanceSide.
	generateSlotAccessorsFor: ir instanceSide.
	(* must be called after nested classes are processed, so all synthetic slots have been added *)
	processClassSideOf: aNode ofMixin: ir classSide.
	currentDepth:: currentDepth - 1.
	currentMixinUID:: priorMixinUID.
	^ir
)
public compileClassSource: source <String> within: enclosingIR <IntermediateMixin> ^<IntermediateClassDeclaration> = (
	| tree <AST> intermediate <IntermediateClassDeclaration> |
	
	setInput: source.
	currentScope:: Scope new.
	currentDepth:: 0.
	
	tree:: nil = enclosingIR
		ifTrue:
			[parser compilationUnit parseString: source]
		ifFalse:
			[buildIncrementalScopeFor: enclosingIR builder.
			 parser classDecl parseString: source].

	toScope: currentScope addClass: tree.

	(*sentSelectors:: Set new.*)
	intermediate:: nil = enclosingIR
		ifTrue: [classNode: tree within: nil]
		ifFalse: [compileNestedClassAST: tree into: enclosingIR].

	^intermediate
)
public compileExpressionSource: expression <String> inMixin: enclosing <MixinMirror> withScope: withScope <Map> ^<MethodIR> = (
	|
	body <CodeBodyAST>
	method <MethodAST>
	result <LowLevelMethodMirror>
	|

	input:: expression.
	currentScope:: Scope new.
	currentDepth:: 0.

	buildIncrementalScopeFor: enclosing.
		
	(* Parse as a code body *)
	body:: parser doItExpression parseString: expression.

	(* Ensure last statement is a return statement *)
	body statements isEmpty ifFalse:
		[body statements last isKindOfReturnStatNode ifFalse:
			[| last |
			last:: body statements removeLast.
			body statements add: (ReturnStatAST new
				expression: last; start: last start; end: last end)]].

	(* Put into a method *)
	method:: MethodAST new
		pattern: (MessagePatternAST new
			selector: #DoItWith:
			parameters: {VarDeclAST name: namer scopeArgumentName type: nil});
		body: body;
		accessModifier: #public;
		start: 1;
		end: expression size.

	(* Build scope *)
	pushScope:: Scope parent: currentScope.
	currentMixinUID: enclosing declaration qualifiedName.
	nil = withScope ifFalse:
		[withScope keysAndValuesDo:
			[:key <Symbol> :value |
			 | entry = WithMappedEntry name: key asSymbol. |
			 currentScope at: key asSymbol put: entry.
			 currentScope at: (key,':') asSymbol put: entry]].

	(* Rewrite and compile *)
 	^methodNode: method
)
public compileMethodSource: source <String> within: enclosing <MixinMirror> ^<IntermediateMethod> = (
	| tree <AST> jsTree <IntermediateMethod> |

	setInput: source.
	currentScope:: Scope new.
	currentDepth:: 0.
	
	buildIncrementalScopeFor: enclosing.
	
	tree:: parser methodDecl parseString: source.

	currentMixinUID: enclosing declaration qualifiedName.
	^methodNode: tree
)
compileNestedClassAST: tree <ClassDeclarationAST | MixinApplicationClassAST>
 into: enclosingIR <IntermediateMixin> ^<IntermediateClassDeclaration> = (
	^(compileNestedClasses: {tree} within: enclosingIR) first
)
compileNestedClasses: nestedClasses <Collection[ClassDeclarationAST]> within: mixinIR <IntermediateMixin> = (
	nestedClasses do:
		[:nc <ClassDeclarationAST> |
		| nSlotName <String> nSlot <InstanceVariableMirror> |
		nSlotName:: mixinIR declaration qualifiedName, '`', nc name.
		nSlot:: IntermediateSlotDeclaration named: nSlotName mutable: true accessModifier: #public (* questionable*).
		nSlot isSynthetic: true.
		mixinIR slots add: nSlot.
		mixinIR nestedClasses add: (classNode: nc within: mixinIR).
		createNestedClassAccessorFrom: nc within: mixinIR].
)
compileNestedClassesOf: aNode <SideAST> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	(* where do we check that nested classes do not conflict with each other, or with methods or slots? *)
	^compileNestedClasses: aNode nestedClasses within: mixinMirror
)
computeMethod: aNode <MethodAST> inScope: s <Scope> = (
	(* | scopeBuilder <ScopeBuilder> |
	scopeBuilder:: ScopeBuilder nestedIn: s atLevel: currentDepth.
	aNode apply: scopeBuilder. *)
	(* need to build scope for method before visiting it *)
	^methodNode: aNode.
)
computeMixinFrom: aNode <ClassHeaderAST> within: mixinIR <IntermediateMixin> ^<IntermediateClassDeclaration> = (
	|
	ir = IntermediateClassDeclaration new.
	|
	nil = mixinIR
		ifTrue: [ir qualifiedName: aNode name]
		ifFalse: [ir qualifiedName: (mixinIR qualifiedName, '`', aNode name)].
	aNode slots do: [:s |
		ir instanceSide slots add:
			(IntermediateSlotDeclaration
				named: s name
				mutable: s isMutable
				accessModifier: s accessModifier)].
	ir headerSource: (input copyFrom: aNode start to: aNode end).
	ir depth: currentDepth.
	ir factoryName: aNode constructor selector.
	^ir
)
createNestedClassAccessorFrom: classDecl <ClassDeclarationAST> within: mixinMirror <LowLevelMixinMirror> = (
(* Create an accessor method for the nested class represented by the incoming class tree.
This accessor will lazily generate the nested class when its enclosing instance is first asked for it. *)

	| n <String> accessorString <String> methodAST hdr <ClassHeaderAST> accessor <MethdMirror> |
	hdr:: classDecl header.
	n:: hdr name.
	methodAST::
		accessorForNestedClassNamed: n
		in: mixinMirror qualifiedName
		superCall: (accessorForSuperclass: hdr superclassCall inScope: currentScope).
	accessor:: IntermediateMethod
		named: classDecl name
		accessModifier: classDecl accessModifier
		function: methodAST
		source: nil.
	accessor isSynthetic: true.
	mixinMirror methods add: accessor.
)
public dnuHandlers = (
	(* We used to generate a separate function for each selector. Now we are recycling the same code for each selector and using the JS magic 'arguments' to handle the variable number of arguments in an attempt to reduce the amount of code the must be compiled at start-up (recall DNU handlers must be installed up front). *)
	|
	sortedSelectors = sentSelectors asArray sort: [:a :b | string: a compare: b].
	mangledSelectors = js array: (sortedSelectors collect: [:sel | js literal: (names manglePublic: sel)]).
	catcher = js call: (js ident: 'dnuCatcher') with: {js ident: 'sel'}.
	|
	^js function: 'installDnuHandlersOn' of: {js ident: 'p'} body: (js block: {
		js call: (js propertyOf: mangledSelectors at: (js literal: 'forEach'))
		with: {js functionOf: {'sel'} body: (js block: {
			js assign: (js propertyOf: (js ident: 'p') at: (js operator: '+' with: (js literal: '_') and: (js ident: 'sel'))) toBe: catcher.
			js assign: (js propertyOf: (js ident: 'p') at: (js ident: 'sel')) toBe: catcher.
			(* Make DNU handlers non-enumerable.*)
			(js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'defineProperty')) with: {
				js ident: 'p'.
				js operator: '+' with: (js literal: '_') and: (js ident: 'sel').
				js objectLiteralSlotNames: {js literal: 'enumerable'} values: {js literal: false}.
			}).
			(js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'defineProperty')) with: {
				js ident: 'p'.
				js ident: 'sel'.
				js objectLiteralSlotNames: {js literal: 'enumerable'} values: {js literal: false}.
			}).
		})}
	}).
	(* function() {  this.dnu(kernel.Message().selector$arguments$(selector, arguments) )  } *)
)
generateSlotAccessorsFor: mixinIR <MixinIR> = (
	mixinIR slots do:
		[:slotIR |
		generateSlotInitializerFor: slotIR in: mixinIR.
		generateSlotGetterFor: slotIR in: mixinIR.
		generateSlotSetterFor: slotIR in: mixinIR].
)
generateSlotGetterFor: slotIR <IntermediateSlot> in: mixinIR <IntermediateMixin> = (
	|
	slotName <String> fieldName <String>
	getter <MethodMirror> getterJS <Node>
	|
	slotName:: slotIR name.
	fieldName:: names mangleSlot: slotName.

	slotIR accessModifier = #private
		ifTrue:
			[getterJS:: js functionOf: {'self'} body: (js block: {
				js return: (js propertyOf: (js ident: 'self') at: (js literal: fieldName))})]
		ifFalse:
			[getterJS:: js functionOf: {} body: (js block: {
				js return: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))})].

	getter:: IntermediateMethod
		named: slotName
		accessModifier: slotIR accessModifier
		function: getterJS
		source: nil.
	getter isSynthetic: true.
	mixinIR methods add: getter.
)
generateSlotInitializerFor: slotIR <IntermediateSlot> in: mixinIR <IntermediateMixin> = (
	|
	slotName <String> fieldName <String>
	initializer <MethodMirror> initializerJS <Node>
	|
	slotName:: slotIR name.
	fieldName:: names mangleSlot: slotName.

	slotIR accessModifier = #private
		ifTrue:
			[initializerJS:: js functionOf: {'self'. 'v'} body: (js block: {
				(js assign: (js propertyOf: (js ident: 'self') at: (js literal: fieldName))
					toBe: (js ident: 'v')).
				js return: (js ident: 'self')})]
		ifFalse:
			[initializerJS:: js functionOf: {'v'} body: (js block: {
				(js assign: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))
					toBe: (js ident: 'v')).
				js return: (js ident: 'this')}).].

	initializer:: IntermediateMethod
		named: (selectorForSlotInitializer: slotIR)
		accessModifier: slotIR accessModifier (* Should be private. The scope representation needs to be adjusted to allow this to differ from the slot's access modifier. *)
		function: initializerJS
		source: nil.
	initializer isSynthetic: true.
	mixinIR methods add: initializer.
)
generateSlotSetterFor: slotIR <IntermediateSlot> in: mixinIR <IntermediateMixin> = (
	|
	slotName <String> fieldName <String>
	setter <MethodMirror> setterJS <JavascriptGeneration Syntax Node>
	|

	slotIR isMutable ifFalse: [^self].

	slotName:: slotIR name.
	fieldName:: names mangleSlot: slotName.

	slotIR accessModifier = #private
		ifTrue:
			[setterJS:: js functionOf: {'self'. 'v'} body: (js block: {
				(js assign: (js propertyOf: (js ident: 'self') at: (js literal: fieldName))
					toBe: (js ident: 'v')).
				js return: (js ident: 'self')})]
		ifFalse:
			[setterJS:: js functionOf: {'v'} body: (js block: {
				(js assign: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))
					toBe: (js ident: 'v')).
				js return: (js ident: 'this')})].

	setter:: IntermediateMethod
		named: (selectorForSlotSetter: slotIR)
		accessModifier: slotIR accessModifier
		function: setterJS
		source: nil.
	setter isSynthetic: true.
	mixinIR methods add: setter.
)
hereNode ^<VariableAST> = (
	(* Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier *)

	^VariableAST new name: #'@here'; start: 0; end: 0.
)
hereSendFrom: arg <VarDeclAST> ^<MessageNode> = (
	^UnresolvedSendAST new
		to: hereNode
		send: (MessageAST new
			send: arg name
			with: {};
			start: arg start; end: arg end);
		start: arg start; end: arg end
)
initializerFor: aNode <ClassHeaderAST> ^ <MethodAST> = (
|
stmts <Collection[StatementAST]>
start <Integer>
end <Integer>
initHdr <MessagePatternAST>
body <CodeBodyAST>
params <List[VarDeclAST]>
|

	start:: aNode superConstructorCall start.
	end:: aNode superConstructorCall end.
	params:: aNode constructor parameters collect:
		[:formal | formal].
	initHdr:: MessagePatternAST new
		selector: #'instance`initializer' parameters: params;
		start: start; end: end.

	(* set up scope with constructor parameters *)
 	stmts:: List new.

	stmts add: (superConstructorCallFor: aNode).

	(aNode slots reject: [:ea | ea initializer isNil])
		do: [:slot <SlotDefAST> | | aMsg <MessageAST> |
	aMsg:: MessageAST new send: (selectorForSlotInitializer: slot)
					   with: {slot initializer};
					   start: slot start; end: slot end.
	stmts add: (UnresolvedSendAST new message: aMsg;
				receiver: hereNode;
	                start: aMsg start; end: aMsg end).
	].

 stmts addAll: (aNode initExprs collect: [:ie | ie]).
 body:: CodeBodyAST new temporaries: List new
	                             statements: stmts;
	                             start: start; end: end.
 ^MethodAST new pattern: initHdr
	                  body: body
	                  accessModifier: #public;
	                  start: start; end: end.
)
methodNode: aNode <MethodAST> ^ <IntermediateMethod> = (
	| tree <AST> jsTree |
	tree:: rewriter methodNode: aNode inScope: currentScope. (* rewrite ast *)
	translator beginNewTranslationCycle.
	jsTree:: tree apply: translator. (* final pass: visit rewritten ast *)
	(* pop scope? *)
	^IntermediateMethod
		named: translator currentSelector
		accessModifier: aNode accessModifier
		function: jsTree
		source: ([sourceForNode: aNode] on: Error do: [nil])
)
popScope = (
	currentScope:: currentScope parent.
)
processClassSideOf: classNode <ClassDeclarationAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	| thisClass <ClassEntry> |
	thisClass:: currentScope at: classNode name.
	pushScope:: Scope parent: currentScope.
	currentScope at: #'@currentClass' put: thisClass.
	classNode instanceSide methods do:
		[:methodNode <MethodAST> | toScope: currentScope addMethod: methodNode].

	processFactoryFor: classNode in: mixinMirror.
	processSide: classNode classSide ofMixin: mixinMirror. (* compile class methods *)
	
	popScope.
)
processFactoryFor: aNode <ClassAST> in: mixinIR <MixinIR> = (
	| accessor <MethdMirror> argNames ast |
	argNames:: (aNode header constructor parameters collect: [:each | names mangleLocal: each name]) asArray.
	ast:: js functionOf: argNames body: (js block: {
		js var: 't' value: (js verbatim: 'new this.nonMeta.basicNew()').
		js
			call: (js propertyOf: (js ident: 't') at: (js literal: '$instance$initializer'))
			with: (argNames collect: [:each | js ident: each]).
		js return: (js ident: 't').
		}).
	accessor:: IntermediateMethod
		named: aNode header constructor selector
		accessModifier: #public
		function: ast
		source: nil.
	accessor isSynthetic: true.
	accessor isFactory: true.
	mixinIR methods add: accessor.
)
processInitializerFor: aNode <ClassAST> in: mixinIR <MixinIR> = (
	processMethod: (superConstructorMethodFor: aNode header) inScope: currentScope in: mixinIR.
	(*makeCreateSlotsFor: aNode hdr within: mixinIR.*)
	processMethod: (initializerFor: aNode header) inScope: currentScope in: mixinIR.
)
processInstanceSideOf: classNode <ClassDeclarationAST> ofMixin: mixinIR <MixinIR> ^ <Collection[MixinRep]> = (
	| thisClass <ClassEntry> |
	thisClass:: currentScope at: classNode name.
	pushScope:: Scope parent: currentScope.
	currentScope at: #'@currentClass' put: thisClass.
	classNode header slots do:
		[:slotNode <SlotDefAST> | toScope: currentScope addSlot: slotNode].
	classNode instanceSide methods do:
		[:methodNode <MethodAST> | toScope: currentScope addMethod: methodNode].
	classNode instanceSide nestedClasses do:
		[:nestedClassNode <ClassDeclarationAST> | toScope: currentScope addClass: nestedClassNode].

	processInitializerFor: classNode in: mixinIR.
	processSide: classNode instanceSide ofMixin: mixinIR. (* compile instance methods *)
	compileNestedClassesOf: classNode instanceSide within: mixinIR. (* gather nested classes *)
	
	popScope.
)
processMethod: aNode <MethodAST> inScope: s <Scope> in: mixinIR <MixinIR> = (
	| method <MethodMirror> |
	method:: computeMethod: aNode inScope: s.
	method isSynthetic: true.
	mixinIR methods add: method.
)
processSide: side <SideAST> ofMixin: mixinIR <MixinIR> = (
	side methods do:
		[:methodNode | mixinIR methods add: (methodNode: methodNode)].
)
pushScope: scope <Scope> = (
	currentScope:: scope
)
selectorForSlotInitializer: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^('init`', slot name, ':') asSymbol
)
selectorForSlotSetter: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	slot isMutable ifFalse: [self warnObsolete].
	^((slot isMutable ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
selfNode ^ <VariableAST> = (
	(* generate a an AST representing self; used for implicit self sends *)
	^VariableAST new name: #self; start: 0; end: 0
)
setInput: source <ReadStream> = (
	input: source. (* save the input *)
)
sourceForNode: node <AST> ^ <String> = (
	| savedPos <Integer> pos <Integer> len <Integer> s <String> |
	^input copyFrom: node start to: node end
)
string: a compare: b = (
	1 to: a size do:
		[:i |
		i > b size ifTrue: [^false].
		(a runeAt: i) < (b runeAt: i) ifTrue: [^true].
		(a runeAt: i) > (b runeAt: i) ifTrue: [^false]].
	^true
)
superConstructorCallFor: aNode <ClassHeaderAST> ^<NormalSendAST> = (
	(* create call to super constructor method *)
	|
	var <VariableAST>
	send <NormalSendAST>
	start <Integer>
	end <Integer>
	superMsg <MessageAST>
	args <List[VariableAST]>
	|

	start:: aNode superConstructorCall start.
	end:: aNode superConstructorCall end.
	var:: VariableAST new name: #self; start: start; end: end.
	args:: aNode constructor parameters collect:
		[:p <VarDeclAST> | hereSendFrom: p].
	superMsg:: MessageAST new
		send: (superConstructorNameFor: aNode) with: args;
		start: start; end: end.
	send:: UnresolvedSendAST new to: var send: superMsg; start: start; end: end.
	^send
)
superConstructorMethodFor: aNode <ClassHeaderAST> ^ <MethodAST> = (
|
start <Integer>
end <Integer>
stmts <List[StmtAST]>
var <VariableAST>
initHdr <MessagePatternAST>
superMsg <MessageAST>
send <NormalSendAST>
body <CodeBodyAST>
params <List[VarDeclAST]>
args <List>
|

	start:: aNode superConstructorCall start.
	end:: aNode  superConstructorCall end.
	params:: aNode constructor parameters collect: [:formal | formal].
	initHdr:: MessagePatternAST new selector: (superConstructorNameFor: aNode) parameters: params;
				start: start; end: end.
	(* set up scope with constructor parameters *)
	(* create call to superclass initializer *)
	stmts:: List new.
	var:: VariableAST new name: #super; start: start; end: end.
	args:: aNode superConstructorCall arguments collect: [:actual | actual].
	superMsg:: PropertyCallAST new send: 'instance`initializer' with: args;
				start: start; end: end.
	(* only copy actual args *)
	(* send these as a tuple? to super instance initializer? *)
	send:: UnresolvedSendAST new to: var send: superMsg; start: start; end: end.
	stmts addFirst: send.
	body:: CodeBodyAST new temporaries: List new
	                             	statements: stmts;
	                            	start: start; end: end.
	^MethodAST new pattern: initHdr
	                  body: body
	                  accessModifier: #protected;
	                  start: start; end: end
)
superConstructorNameFor: aNode <ClassHeaderAST> ^ <Symbol> = (
	#BOGUS. (* Should not rely on this running after currentMixinUID is set. *)
	^'superInit`', currentMixinUID
)
toScope: scope <Scope> addClass: nestedClassNode <ClassDeclarationAST> = (
	| entry = ClassEntry forDeclaration: nestedClassNode atDepth: currentDepth. |
	checkForReservedWord: nestedClassNode selector.
	entry enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).
	scope
		at: nestedClassNode selector
		put: entry
)
toScope: scope <Scope> addMethod: methodNode <MethodAST> = (
	checkForReservedWord: methodNode selector.
	currentScope
		at: methodNode selector
		put: (MethodEntry forDeclaration: methodNode atDepth: currentDepth).
)
toScope: scope <Scope> addSlot: slotNode <SlotDeclAST> = (
	| entry = SlotEntry forDeclaration: slotNode atDepth: currentDepth. |
	checkForReservedWord: slotNode name.
	scope at: (namer selectorForSlotInitializer: slotNode) put: entry.
	scope at: (namer selectorForSlotGetter: slotNode) put: entry.
	slotNode isMutable ifTrue:
		[scope at: (namer selectorForSlotSetter: slotNode) put: entry].
)
) : (
)
public class IntermediateClassDeclaration = (|
	public qualifiedName <String>
	public headerSource <String>
	public factoryName <Symbol>
	public instanceSide <IntermediateMixin> = IntermediateMixin for: self isMeta: false.
	public classSide <IntermediateMixin> = IntermediateMixin for: self isMeta: true.
	public depth <Integer>
	public accessModifier <Symbol>
|) (
basicNew = (
	^js functionOf: {} body: (js block: (
		{
		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.
		},
		(instanceSide slots collect: [:s |
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: s name))) toBe: (js ident: 'nil')])
	))
)
basicNewMeta = (
	^js functionOf: {} body: (js block: (
		{
		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.
		}
	))
)
classMethodsMetadata = (
	^js array: (classSide methods collect:
		[:method | js new: (js ident: 'MM') with: {
			js literal: method name.
			js literal: method accessModifier.
			js literal: method isSynthetic.
			encodeSource: method source.
		}])
)
copyMethods: methods = (
	| stmts = List new. |
	methods do: [:m |
		| mixinFunction assignProtected |
		mixinFunction:: js propertyOf: (js ident: '$') at: (js literal: (names manglePublic: m name)).
		assignProtected::
			(js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleProtected: m name)))
				toBe: mixinFunction).

		m isPublic ifTrue: [
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name)))
					toBe: assignProtected).
		].
		m isProtected ifTrue: [
			stmts add: assignProtected.
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name)))
					toBe: (dnuCatcherFor: (names manglePublic: m name))).
		].
		m name = #doesNotUnderstand: ifTrue: [
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: names privateDnu)) toBe: mixinFunction).
		].
		(qualifiedName = 'KernelForV8`Object' and: [m name = #cannotReturn:]) ifTrue: [
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: names privateCannotReturn)) toBe: mixinFunction).
		].
	].
	^stmts
)
dnuCatcherFor: publicMangling = (
	^js call: (js ident: 'dnuCatcher') with: {js literal: publicMangling}
)
encodeSource: source = (
	source isNil ifTrue: [^js literal: 0].
	sourcesList add: source.
	^js literal: sourcesList size.
)
invoke = (
	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'} body: (js block: {
		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime class for ', qualifiedName).
			},
			(copyMethods: instanceSide methods),
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'enclosingObjects`',qualifiedName)))
				toBe: (js ident: 'enclosingObjects').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: 'super`',qualifiedName)))
				toBe: (js ident: 'runtimeSuperclass').
			(* This first assignment causes devtools to use the class's name as the short name for its instances. *)
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: qualifiedName)) toBe: basicNew.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: (js propertyOf: (js ident: 'this') at: (js literal: qualifiedName)).
			js verbatim: 'this.basicNew.prototype = this'.
			js verbatim: 'this.meta = null'.
			js verbatim: 'this.newspeakClass = null'.
			}
		)).
		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.
		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.
	})
)
invokeMeta = (
	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'.} body: (js block: {
		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta class for ', qualifiedName).
			},
			(copyMethods: classSide methods),
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'enclosingObjects`',qualifiedName)))
				toBe: (js ident: 'enclosingObjects').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: 'super`',qualifiedName)))
				toBe: (js ident: 'runtimeSuperclass').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: basicNewMeta.
			js verbatim: 'this.basicNew.prototype = this'.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nonMeta')) toBe: (js ident: 'null').
			js verbatim: 'this.newspeakClass = null'.
			}
		)).
		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.
		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.
	})
)
makeMixin: rm = (
	^js call: (js propertyOf: (js ident: 'Mixin') at: (js literal: 'fromRuntimeMixin')) with: {rm}
)
methodsMetadata = (
	^js array: (instanceSide methods collect:
		[:method | js new: (js ident: 'MM') with: {
			js literal: method name.
			js literal: method accessModifier.
			js literal: method isSynthetic.
			encodeSource: method source.
		}])
)
nestedClassesMetadata = (
	^js array: (instanceSide nestedClasses collect: [:nc | js literal: nc qualifiedName])
)
public printOn: stm = (
	stm nextPutAll: 'ClassDeclarationIR:'.
	stm nextPutAll: qualifiedName.
)
runtimeMetamixin = (
	^js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'meta')) toBe: (
	js new: (js functionOf: {} body: (js block: (
		{
		js var: '$' value: (js ident: 'this').
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta mixin for ', qualifiedName).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'slots')) toBe: (js array: {}).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'methods')) toBe: classMethodsMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nestedClasses')) toBe: (js array: {}).
		},
		(classSide methods collect: [:m |
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name))) toBe: m function]),
		{
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invokeMeta.
		}
	))) with: {})
)
public runtimeMixin = (
	^js new: (js functionOf: {} body: (js block: (
		{
		js var: '$' value: (js ident: 'this').
		js var: '$', depth printString value: (js ident: 'this').
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime mixin for ', qualifiedName).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'name')) toBe: (js literal: qualifiedName).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'header')) toBe: (encodeSource: headerSource).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'slots')) toBe: slotsMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'methods')) toBe: methodsMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nestedClasses')) toBe: nestedClassesMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'applications')) toBe: (js array: {}).
		},
		(instanceSide methods collect: [:m |
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name))) toBe: m function]),
		(instanceSide nestedClasses collect: [:ncd |
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: ncd qualifiedName))) toBe: ncd runtimeMixin]),
		(instanceSide nestedClasses collect: [:ncd |
			js assign: (js propertyOf: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: ncd qualifiedName))) at: (js literal: 'enclosingMixin')) toBe: (js ident: 'this')]),
		{
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invoke.
		runtimeMetamixin.
		js assign: (js propertyOf: (js propertyOf: (js ident: 'this') at: (js literal: 'meta')) at: (js literal: 'nonMeta')) toBe: (js ident: 'this').
		}
	))) with: {}
)
slotsMetadata = (
	^js array: (instanceSide slots collect:
		[:slot | js new: (js ident: 'SM') with: {
			js literal: slot name.
			js literal: slot accessModifier.
			js literal: slot isMutable.
			js literal: slot isSynthetic
	}]).
)
) : (
)
public class IntermediateMethod named: n accessModifier: am function: f source: s = (|
	public name <Symbol> = n.
	public function <JavascriptGeneration Syntax Node> = f.
	public source <String> = s.
	public isSynthetic ::= false.
	public isFactory ::= false.
	public accessModifier <Symbol> = am.
|) (
public isPrivate ^ <Boolean> = (
	^#private = accessModifier
)
public isProtected ^ <Boolean> = (
	^#protected = accessModifier
)
public isPublic ^ <Boolean> = (
	^#public = accessModifier
)
public printOn: stm = (
	stm nextPutAll: 'MethodIR:'.
	stm nextPutAll: name.
)
) : (
)
public class IntermediateMixin for: d <IntermediateClassDeclaration> isMeta: m <Boolean> = (|
	public declaration <IntermediateClassDeclaration> = d.
	public isMeta <Boolean> = m.
	public slots <List[IntermediateSlotDeclaration]> = List new.
	public methods <List[IntermediateMethod]> = List new.
	public nestedClasses <List[IntermediateClassDeclaration]> = List new.
|) (
public qualifiedName = (
	^declaration qualifiedName
)
) : (
)
public class IntermediateSlotDeclaration named: n mutable: m accessModifier: am = (|
	public name = n.
	public isMutable = m.
	public accessModifier = am.
	public isSynthetic ::= false.
|) (
public printOn: stm = (
	stm nextPutAll: 'SlotIR:'.
	stm nextPutAll: name.
)
) : (
)
class NameMangler = (|
	private specialCharacterManglings = Map new.
|specialCharacterManglings
		at: "+" put: '$plus';
		at: "-" put: '$minus';
		at: "*" put: '$times';
		at: "/" put: '$over';
		at: "\" put: '$back';
		at: "<" put: '$less';
		at: ">" put: '$greater';
		at: "~" put: '$tilde';
		at: "=" put: '$equal';
		at: "@" put: '$at';
		at: "%" put: '$percent';
		at: "|" put: '$pipe';
		at: "&" put: '$amp';
		at: "?" put: '$question';
		at: "!" put: '$bang';
		at: "," put: '$comma') (
public fullyQualifiedNameToSimple: fullName <String> = (
	| parts |

	parts:: splitFullyQualifiedName: fullName.
	^parts last asSymbol
)
public mangleLocal: selector <String> ^ <String> = (
	^_mangleSelector: selector
)
public mangleProtected: selector = (
	^'_', (_mangleSelector: selector)
)
public manglePublic: selector = (
	^_mangleSelector: selector
)
public mangleSlot: selector <String> ^ <String> = (
	^(_mangleSelector: selector), '$slot'
)
public mangleSynthetic: selector = (
	^_mangleSelector: selector
)
public privateCannotReturn = (
	^'cannotReturn'
)
public privateDnu = (
	^'dnu'
)
protected _mangleSelector: selector <String> ^ <String> = (
	(* Convert a Newspeak selector into a JS identifer. *)
		 | sb = StringBuilder new. |
	(* Binary *)
	('+-*/\<>~=@%|&?!,' indexOf: (String with: selector last)) ~= 0 ifTrue:
		[
		sb add: '$'.
		selector do: [:specialCharacter | sb add: (specialCharacterManglings at: specialCharacter)].
		^sb asString asSymbol].


		sb add: '$'.
		selector do: [:e | ( '.:`@' indexOf: (String with: e)) ~= 0 ifTrue: [sb add: '$'] ifFalse: [sb addByte: e]].
		^sb asString asSymbol.
)
) : (
)
public class ProgramBuilder = (|
private compiler = Compiler new.
private mixins <List[ClassDeclarationIR]> = List new.
private sentSelectors = Set new.
private runtimeConfiguration <ClassDeclarationIR>
private applicationConfiguration <ClassDeclarationIR>
private resources <List[Node]> = List new.
|) (
public addImageResource: relativeUrl under: name = (
	| r i |
	i:: js verbatim:
	'vmmirror.kernel.$Future().$computing$(
		function(){return vmmirror.platform.$js().$yourself()._$alienate$(
			function(){ var i = new Image(); i.src ="', relativeUrl,'"; return i;}() );})'.
	r:: js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: name)))
				toBe: (js functionOf: {} body: (js block: {js return: i})).
	resources add: r.
)
public addStringResource: string under: name = (
	| r |
	r:: js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: name)))
				toBe: (js functionOf: {} body: (js block: {js return: (js literal: string)})).
	resources add: r.
)
public applicationSources: sources <List[String]> = (
	| results |
	results:: sources collect: [:source | compileSource: source enableIntrinsics: false].
	applicationConfiguration: results first.
)
compileSource: source <String> enableIntrinsics: flag <Boolean> ^<ClassDeclarationIR> = (
	| compilation |
	compilation:: cachedCompilations
		at: {source. flag}
		ifAbsentPut:
			[ | newCompilation = CachedCompilation new. |
			newCompilation source: source.
			newCompilation enableIntrinsics: flag.
			compiler enableIntrinsics: flag.
			compiler sentSelectors: Set new.
			newCompilation ir: (compiler compileClassSource: source within: nil).
			newCompilation sentSelectors: compiler sentSelectors].
	mixins add: compilation ir.
	sentSelectors addAll: compilation sentSelectors.
	^compilation ir
)
private main = (
	^js verbatim:
'var runtime = ns.$',runtimeConfiguration qualifiedName,'().$packageUsing$(ns);
vmmirror.platform = runtime.$using$(vmmirror);
var app = ns.$',applicationConfiguration qualifiedName,'().$packageUsing$(ns);
app.$main$args$(vmmirror.platform, [])'
)
private namespace = (
	^js var: 'ns' value: (js new: (js functionOf: {} body: (js block: (
		(mixins asArray collect: [:cd |
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd qualifiedName)))
				toBe: (js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: 'applyTopLevelMixin'))
						with: {js propertyOf: (js ident: 'mixins') at: (js literal: (names manglePublic: cd qualifiedName))})]),
		(mixins asArray collect: [:cd |
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: cd qualifiedName)))
				toBe: (js functionOf: {} body: (js block: {js return:
					(js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd qualifiedName)))}))]),
		resources asArray
	))) with: {})
)
public outputProgram ^<String> = (
	| sb = StringBuilder new. |
	JavascriptWriter new generateSourceFor: script on: sb.
	^sb asString
)
public outputSources ^<String> = (
	| sb = StringBuilder new. |
	JavascriptWriter new generateSourceFor: sourcesScript on: sb.
	^sb asString
)
private runtimeMixinNamespace = (
	^js new: (js functionOf: {} body: (js block: (
		mixins collect: [:cd |
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: cd qualifiedName))) toBe: cd runtimeMixin]
	))) with: {}
)
public runtimeSources: sources <List[String]> = (
	| results |
	results:: sources collect: [:source | compileSource: source enableIntrinsics: true].
	runtimeConfiguration: results first.
)
private script = (
	compiler sentSelectors: sentSelectors.
	sourcesList:: List new.
	^js script:
		{js literal: 'use strict'.
		js var: 'nil' value: (js literal: 'patch me with nil').
		js var: 'currentActor'.
		js var: 'theGlobalObject' value: (js ident: 'this').
		js verbatim: 'function SM(n,am,m,s){this.name=n; this.accessModifier = am; this.isMutable=m; this.isSynthetic=s; }'.
		js verbatim: 'function MM(n,am,sy,src){this.name=n; this.accessModifier = am; this.isSynthetic=sy; this.source=src; }'.
		js verbatim: 'function dnuCatcher(s){ return function() {
return this.dnu(vmmirror.kernel.$Message().$mangledSelector$arguments$(s, Array.prototype.slice.call(arguments)));
} }'.
		js var: 'mixins' value: runtimeMixinNamespace.
		vmmirror.
		namespace.
		compiler dnuHandlers.
		main}
)
private sourcesScript = (
	| elements = List new. |
	elements add: (js ident: 'null').
	sourcesList do: [:source | elements add: (js literal: source)].
	^js var: 'sources' value: (js array: elements)
)
private vmmirror = (
	^js verbatim:
'
var vmmirror = new function(){

	this.ImplementationBase$slot = new function(){
		this.debug = "ImplementationBase";
		this.$runtimeClass$slot = new function(){
			this.debug = "Runtime class for ImplementationBase";
			this.basicNew = function(){ this.hashCode = 0; };
			this.$instance$initializer = function(){};
			this._$instance$initializer = function(){};
			this.toString = function(){ return this.$printString(); }
		};
	};
	this.$ImplementationBase = function(){return this.ImplementationBase$slot;};
	this.$Array = function(){return Array;};
	this.$String = function(){return String;};
	this.$printString = function(){return "VMMirrorForV8"};

	this.createKernel = function(){

		var enclosingObjects = ["patch me with kernel", "patch me with nil"];
		var enclosingObjects2 = ["patch me with nil"];

		var Object$runtimeClass = mixins.$KernelForV8.$KernelForV8$Object.invoke(this.$ImplementationBase().$runtimeClass$slot, enclosingObjects);
		var Class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Class.invoke(Object$runtimeClass, enclosingObjects);
		var Metaclass$runtimeClass = mixins.$KernelForV8.$KernelForV8$Metaclass.invoke(Object$runtimeClass, enclosingObjects);
		var Mixin$runtimeClass = mixins.$KernelForV8.$KernelForV8$Mixin.invoke(Object$runtimeClass, enclosingObjects);
		var UndefinedObject$runtimeClass = mixins.$KernelForV8.$KernelForV8$UndefinedObject.invoke(Object$runtimeClass, enclosingObjects);
		var Kernel$runtimeClass = mixins.$KernelForV8.invoke(Object$runtimeClass, enclosingObjects2);

		var Object$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Object.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Class$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Class.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Metaclass$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Metaclass.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Mixin$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Mixin.meta.invoke(Class$runtimeClass, enclosingObjects);
		var UndefinedObject$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$UndefinedObject.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Kernel$class$runtimeClass = mixins.$KernelForV8.meta.invoke(Class$runtimeClass, enclosingObjects2);

		Object$runtimeClass.meta = Object$class$runtimeClass;
		Class$runtimeClass.meta = Class$class$runtimeClass;
		Metaclass$runtimeClass.meta = Metaclass$class$runtimeClass;
		Mixin$runtimeClass.meta = Mixin$class$runtimeClass;
		UndefinedObject$runtimeClass.meta = UndefinedObject$class$runtimeClass;
		Kernel$runtimeClass.meta = Kernel$class$runtimeClass;

		Object$class$runtimeClass.nonMeta = Object$runtimeClass;
		Class$class$runtimeClass.nonMeta = Class$runtimeClass;
		Metaclass$class$runtimeClass.nonMeta = Metaclass$runtimeClass;
		Mixin$class$runtimeClass.nonMeta = Mixin$runtimeClass;
		UndefinedObject$class$runtimeClass.nonMeta = UndefinedObject$runtimeClass;
		Kernel$class$runtimeClass.nonMeta = Kernel$runtimeClass;

		nil = new UndefinedObject$runtimeClass.basicNew();

		var Object = new Object$class$runtimeClass.basicNew();
		var Class = new Class$class$runtimeClass.basicNew();
		var Metaclass = new Metaclass$class$runtimeClass.basicNew();
		var Mixin = new Mixin$class$runtimeClass.basicNew();
		var UndefinedObject = new UndefinedObject$class$runtimeClass.basicNew();
		var Kernel = new Kernel$class$runtimeClass.basicNew();

		var Object$class = new Metaclass$runtimeClass.basicNew();
		var Class$class = new Metaclass$runtimeClass.basicNew();
		var Metaclass$class = new Metaclass$runtimeClass.basicNew();
		var Mixin$class = new Metaclass$runtimeClass.basicNew();
		var UndefinedObject$class = new Metaclass$runtimeClass.basicNew();
		var Kernel$class = new Metaclass$runtimeClass.basicNew();

		Object$class$runtimeClass.newspeakClass = Object$class;
		Class$class$runtimeClass.newspeakClass = Class$class;
		Metaclass$class$runtimeClass.newspeakClass = Metaclass$class;
		Mixin$class$runtimeClass.newspeakClass = Mixin$class;
		UndefinedObject$class$runtimeClass.newspeakClass = UndefinedObject$class;
		Kernel$class$runtimeClass.newspeakClass = Kernel$class;

		Object$runtimeClass.newspeakClass = Object;
		Class$runtimeClass.newspeakClass = Class;
		Metaclass$runtimeClass.newspeakClass = Metaclass;
		Mixin$runtimeClass.newspeakClass = Mixin;
		UndefinedObject$runtimeClass.newspeakClass = UndefinedObject;
		Kernel$runtimeClass.newspeakClass = Kernel;

		var kernel = Kernel.$usingVmMirror$(this);

		//superclass$slot
		Object.$superclass$slot = nil;
		Class.$superclass$slot = Object;
		Metaclass.$superclass$slot = Object;
		Mixin.$superclass$slot = Object;
		UndefinedObject.$superclass$slot = Object;
		Kernel.$superclass$slot = Object;

		Object$class.$superclass$slot = Class;
		Class$class.$superclass$slot = Class;
		Metaclass$class.$superclass$slot = Class;
		Mixin$class.$superclass$slot = Class;
		UndefinedObject$class.$superclass$slot = Class;
		Kernel$class.$superclass$slot = Class;

		//mixin$slot
		Object.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Object);
		Class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Class);
		Metaclass.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Metaclass);
		Mixin.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Mixin);
		UndefinedObject.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$UndefinedObject);
		Kernel.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8);

		Object$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Object.meta);
		Class$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Class.meta);
		Metaclass$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Metaclass.meta);
		Mixin$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Mixin.meta);
		UndefinedObject$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$UndefinedObject.meta);
		Kernel$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.meta);

		//enclosingObject$slot
		Object.$enclosingObject$slot = kernel;
		Class.$enclosingObject$slot = kernel;
		Metaclass.$enclosingObject$slot = kernel;
		Mixin.$enclosingObject$slot = kernel;
		UndefinedObject.$enclosingObject$slot = kernel;
		Kernel.$enclosingObject$slot = nil;

		Object$class.$enclosingObject$slot = kernel;
		Class$class.$enclosingObject$slot = kernel;
		Metaclass$class.$enclosingObject$slot = kernel;
		Mixin$class.$enclosingObject$slot = kernel;
		UndefinedObject$class.$enclosingObject$slot = kernel;
		Kernel$class.$enclosingObject$slot = nil;

		enclosingObjects[0] = kernel;
		enclosingObjects[1] = nil;
		enclosingObjects2[0] = nil;

		//name$slot
		Object.$name$slot = "Object";
		Class.$name$slot = "Class";
		Metaclass.$name$slot = "Metaclass";
		Mixin.$name$slot = "Mixin";
		UndefinedObject.$name$slot = "UndefinedObject";
		Kernel.$name$slot = "Kernel";

		Object$class.$name$slot = "Object class";
		Class$class.$name$slot = "Class class";
		Metaclass$class.$name$slot = "Metaclass class";
		Mixin$class.$name$slot = "Mixin class";
		UndefinedObject$class.$name$slot = "UndefinedObject class";
		Kernel$class.$name$slot = "Kernel class";

		//runtimeClass
		Object.runtimeClass = Object$runtimeClass;
		Class.runtimeClass = Class$runtimeClass;
		Metaclass.runtimeClass = Metaclass$runtimeClass;
		Mixin.runtimeClass = Mixin$runtimeClass;
		UndefinedObject.runtimeClass = UndefinedObject$runtimeClass;
		Kernel.runtimeClass = Kernel$runtimeClass;

		Object$class.runtimeClass = Metaclass$runtimeClass;
		Class$class.runtimeClass = Metaclass$runtimeClass;
		Metaclass$class.runtimeClass = Metaclass$runtimeClass;
		Mixin$class.runtimeClass = Metaclass$runtimeClass;
		UndefinedObject$class.runtimeClass = Metaclass$runtimeClass;
		Kernel$class.runtimeClass = Metaclass$runtimeClass;

		//thisClass$slot
		Object$class.$thisClass$slot = Object;
		Class$class.$thisClass$slot = Class;
		Metaclass$class.$thisClass$slot = Metaclass;
		Mixin$class.$thisClass$slot = Mixin;
		UndefinedObject$class.$thisClass$slot = UndefinedObject;
		Kernel$class.$thisClass$slot = Kernel;

		kernel.$KernelForV8$Object$slot = Object;
		kernel.$KernelForV8$Class$slot = Class;
		kernel.$KernelForV8$Metaclass$slot = Metaclass;
		kernel.$KernelForV8$Mixin$slot = Mixin;
		kernel.$KernelForV8$UndefinedObject$slot = UndefinedObject;

		return kernel;
	};
	this.kernel = this.createKernel();

	this.applyTopLevelMixin = function(runtimeMixin){
		return this.$applyMixin$toSuperclass$withEnclosingObjects$(runtimeMixin, this.kernel._$Object(), [nil]);
	};

	this.$applyMixin$toSuperclass$withEnclosingObjects$ = function(runtimeMixin, newspeakSuperclass, enclosingObjects){
		var Class = this.kernel.$Class();
		var Metaclass = this.kernel.$Metaclass();
		var Mixin = this.kernel.$Mixin();
		
		if (newspeakSuperclass.newspeakClass === Metaclass)
			this.kernel.$Error().$signal("Invalid superclass");  // [newspeakClass] is a Metaclass
		if (newspeakSuperclass.newspeakClass.newspeakClass !== Metaclass)
			this.kernel.$Error().$signal("Invalid superclass");  // [newspeakClass] is an instance

		var runtimeSuperclass = newspeakSuperclass.runtimeClass;
		var runtimeClass = runtimeMixin.invoke(runtimeSuperclass, enclosingObjects);
		var runtimeMetaclass = runtimeMixin.meta.invoke(Class.runtimeClass, enclosingObjects);
		runtimeClass.meta = runtimeMetaclass;
		runtimeMetaclass.nonMeta = runtimeClass;

		var newspeakMetaclass = Metaclass.$new();
		var newspeakClass = new runtimeMetaclass.basicNew();

		runtimeClass.newspeakClass = newspeakClass;
		runtimeMetaclass.newspeakClass = newspeakMetaclass;//Class;

		newspeakMetaclass.$superclass$slot = Class;
		newspeakMetaclass.$mixin$slot = Mixin.$fromRuntimeMixin$(runtimeMixin.meta);
		newspeakMetaclass.$enclosingObject$slot = enclosingObjects[0];
		newspeakMetaclass.$enclosingObjects$slot = enclosingObjects;
		newspeakMetaclass.$name$slot = runtimeMixin.name + " class";
		newspeakMetaclass.$thisClass$slot = newspeakClass;
		newspeakMetaclass.runtimeClass = runtimeMetaclass;

		newspeakClass.$superclass$slot = newspeakSuperclass;
		newspeakClass.$mixin$slot = Mixin.$fromRuntimeMixin$(runtimeMixin);
		newspeakClass.$enclosingObject$slot = enclosingObjects[0];
		newspeakClass.$enclosingObjects$slot = enclosingObjects;
		newspeakClass.$name$slot = runtimeMixin.name;
		newspeakClass.runtimeClass = runtimeClass;

		runtimeMixin.applications.push(runtimeClass);
		return newspeakClass;
	};

	var specialCharacters = new Object();
	specialCharacters["plus"] = "+";
	specialCharacters["minus"] = "-";
	specialCharacters["times"] = "*";
	specialCharacters["over"] = "/";
	specialCharacters["back"] = "\\";
	specialCharacters["less"] = "<";
	specialCharacters["greater"] = ">";
	specialCharacters["tilde"] = "~";
	specialCharacters["equal"] = "=";
	specialCharacters["at"] = "@";
	specialCharacters["percent"] = "%";
	specialCharacters["pipe"] = "|";
	specialCharacters["amp"] = "&";
	specialCharacters["question"] = "?";
	specialCharacters["bang"] = "!";
	specialCharacters["comma"] = ",";

	this.$unmangleSelector$ = function(s) {
		if(s[0] != "$") return "<jsSelector:"+s+">";
		if(s[s.length-1] == "$")
			// Keyword
			return s.substring(1).replace(/\$/g,":");
		if(s[1] == "$")
			// Binary
			return s.substring(2).split("$").map(function(x) {return specialCharacters[x];}).join("");
		// Unary / qualified
	   	return s.substring(1).replace(/\$/g,"`");
	};

	this.$mangleSelector$ = function(s) {
		return "$" + s.replace(/\:/g,"$").replace(/\`/g,"$");
	};
};
'
)
) : (
)
class WithMappedEntry name: nom = SymbolTableEntry forAST: nil atDepth: nil (|
	public name = nom.
|) (
public getterAst = (
	^UnresolvedSendAST new
		receiver: mapAst;
		message: (MessageAST new
			selector: #at:;
			arguments: {SymbolAST new value: name})
)
public isMappedBinding = (
	^true
)
private mapAst = (
	^UnresolvedSendAST new
		receiver: (VariableAST new name: #'@here');
		message: (MessageAST new
			selector: namer scopeArgumentName;
			arguments: {})
)
public setterAst: newVal = (
	^UnresolvedSendAST new
		receiver: mapAst;
		message: (MessageAST new
			selector: #at:put:;
			arguments: {SymbolAST new value: name. newVal})
)
) : (
)
ClassEntry = (
	^super ClassEntry
)
LocalEntry = (
	^super LocalEntry
)
MethodEntry = (
	^super MethodEntry
)
Scope = (
	^super Scope
)
SlotEntry = (
	^super SlotEntry
)
assert: block <[Boolean]> = (
	super assert: block message: 'assertion failed'.
	(* block value ifFalse: [error: 'assertion failed'] *)
)
mixinSlotNameFor: nestedName <String> = (
	^nestedName
)
namer = (
	^super namer
)
split: aString at: aCharacter = (
	| parts start |
	parts:: List new.
	start:: 1.
	1 to: aString size do:
		[:index |
		(aString at: index) = aCharacter ifTrue:
			[parts add: (aString copyFrom: start to: index - 1).
			start:: index + 1]].
	parts add: (aString copyFrom: start to: aString size).
	^parts
)
splitFullyQualifiedName: fqn = (
	(* Make sure we pass only the first character, so that the code works in image and on JS *)
	^split: fqn at: syntheticNameSeparator first
)
syntheticNameSeparator ^<String> = (
	^'`'
)
) : (
)
