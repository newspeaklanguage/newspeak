Newspeak3
'Root'
class Browsing usingPlatform: p ide: webIde = (
(* An IDE for Newspeak on the web.
    Copyright 2016-2017 Google Inc.
    Copyright 2018-2020 Gilad Bracha.
*)
|	(* imports *)
    StringBuilder = p kernel StringBuilder.
    Subject = p hopscotch Subject.
    Presenter = p hopscotch Presenter.	
    SearchFieldFragment = p hopscotch fragments SearchFieldFragment.
    Window = p hopscotch Window.
    Color = p graphics Color.
    Gradient = p hopscotch Gradient.
    List = p collections List.
    Map = p collections Map.
    Set = p collections Set.   
    OrderedMap = [p collections OrderedMap] on: Error do: [:e | Map].
    Exception = p kernel Exception.
    ClassMirror = p mirrors ClassMirror.
    ObjectMirror = p mirrors ObjectMirror.
    Message = p kernel Message.
    ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
    Snapshotter = p operatingSystem = 'emscripten' ifTrue: [p victoryFuel Snapshotter].
    JSObject = p js global at: 'Object'.
    JSArray = p js global at: 'Array'.
    JSMath = p js global at: 'Math'.
    JSPromise = p js global at: 'Promise'.
    Date = p js global at: 'Date'.
    (* module variables *)
    body = (p js global at: 'document') at: 'body'.
    localStorage = (p js global at: 'window') at: 'localStorage'.
    atomicInstaller = p mirrors installer.
    compiler = p mirrors compiler.
    cachedPlatform = p.
    ide = webIde.
    detailAreaRatio = 3 asFloat.
    captionColor = Color h: 240 s: 0.05 asFloat v: 0.9 asFloat.
    cssConverter = cssConversionTable.
    objectViews <Map[Class, Presenter]> = Map new.

    (* Style *)    
	styleHeaderPadRight <Float> = 0.0.
    styleButtonSize <Float> = 30.

|

p hopscotch homeSubjectClass: HomeSubject.
initializeObjectViews.
) (
public class AssortedMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* The subject is a collection of MethodSubjects that can come from diverse sources (in the sense that they do not have to belong to the same class). The presenter displays them as a column of expandable method presenters and takes care of reasonably handling the various creation and deletion requests coming from them.  I group my methods by their containing package.
	
Because the method presenters are grouped by package, if we need to expand or collapse those presenters, we only want to expand or collapse the method presenters.  The group heading is not expandable (or collapsable). *)
|
	public title ::= 'Assorted Methods'. (* The title to use for the presenter *)
	methodPresenters <List[ExpandableMethodPresenter]> ::= List new.
|) (
addButton = (
  ^nothing
)
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	shouldNotImplement
)
contentPresenters = (
      #BOGUS.
	^subject methodSubjects collect: [:each | (each presenter) showClassName: true]
)
definitionListMenu = (
  	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
public isKindOfAssortedMethodsPresenter ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfAssortedMethodsPresenter
)
) : (
)
public class AssortedMethodsSubject onModel: m = Subject onModel: m (|
	public title ::= 'Assorted Methods'.
|) (
public createPresenter = (
	^(AssortedMethodsPresenter onSubject: self) title: title
)
public isKindOfAssortedMethodsSubject ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfAssortedMethodsSubject
)
public methodSubjects = (
	^model
)
public methodTemplateText ^ <String> = (
^
'messageSelector = (
)'
)
) : (
)
class BasicView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public definition = (
	^column:
		(subject slots collect:
			[:slot <SlotSubject> | slot presenter])
)
public isKindOfBasicView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfBasicView
)
public title = (
	^'Basic'
)
) : (
)
public class BitOfWisdom text: s <String> actionLabel: l <String> actionBlock: b <[]> image: i = (|
	public text <String> = s.
	public image <Image> = i.
	public actionLabel <String> = l.
	public actionBlock <[]> = b.
|) (
) : (
public text: s <String> ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: nil
)
public text: s <String> actionLabel: l <String> actionBlock: b <[]> ^ <BitOfWisdom> = (
	^self
		text: s
		actionLabel: l
		actionBlock: b
		image: nil
)
public text: s image: i ^ <BitOfWisdom> = (        
	^text: s 
        actionLabel: nil 
        actionBlock: nil 
        image: i
)
)
class ClassActionsPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public isKindOfClassActionsPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassActionsPresenter
)
deployAsWebPageWithMirrorBuilders = (
#BOGUS yourself.
 (ide deployment jsPackagerForPlatform: cachedPlatform)
		packageApplicationConfiguration: (ide namespacing Root at: subject name)
		withRuntimeConfiguration: ide deployment RuntimeWithMirrorBuilders
		usingNamespace: ide namespacing Root.
)
deployAsWebPage = (
#BOGUS yourself.
 (ide deployment jsPackagerForPlatform: cachedPlatform)
		packageApplicationConfiguration: (ide namespacing Root at: subject name)
		withRuntimeConfiguration: ide deployment Runtime
		usingNamespace: ide namespacing Root.
)
testActions = (
	subject isTestConfiguration ifFalse: [^nothing].
	^row: {
		link: '[run tests]' action: [enterSubject:: subject testingSubject]. 
		link: '[show tests]' action: [enterSubject:: subject inactiveTestingSubject]}.
)
respondToRunApp: paused = (
	(* bogus: The subject might not be in the root namespace. *)
	| appConfig manifest platform args thread |
	appConfig:: ide namespacing Root at: subject name.
	manifest:: ide namespacing manifest.
	platform:: cachedPlatform.
	args:: {}.
	thread:: platform mirrors ActivationMirror invokeSuspended:
		[(appConfig packageUsing: manifest) main: platform args: args].
	paused ifFalse: [thread resume].
	thread isFulfilled ifFalse:
		[enterSubject:: ide debugging ThreadSubject onModel: thread].
)
runAppAction = (
	subject isApplicationConfiguration ifFalse: [^nothing].
    ^row: {
			link: '[run]' action: [respondToRunApp: false].
			link: '[debug]' action: [respondToRunApp: true].
		}
)
definition = (
	^(row: {
        testActions.
        mediumBlank.
        deployAction.
        mediumBlank.
        editDeploymentsAction.
        mediumBlank.
        runAppAction.
        })
		mainAxisAlignToEnd.
)
editDeploymentsAction = (
| DeploymentConfigurationSubject = ide deployment DeploymentConfigurationSubject. |
	subject isApplicationConfiguration ifFalse: [^nothing].
	^link: '[configurations]' action: [
			openMenu:: menuWithLabelsAndActions:
               ((ide deployment configurations) collect: [:dc <DeploymentConfiguration> |
                   {dc name. [enterSubject:: DeploymentConfigurationSubject onModel: dc]}]), 
                {{'Create New Deployment'. [enterSubject:: DeploymentConfigurationSubject onModel: ide deployment defaultConfiguration]}}
		]
)
deployAsVictoryFuel = (
	| bytes = subject bytesForVictoryFuel. |
  	ide webFiles downloadFileName: subject name, '.vfuel' fromBytes: bytes.
)
deployAsVictoryFuelWithMirrors = (
      | bytes = subject bytesForVictoryFuelWithMirrors. |
  	ide webFiles downloadFileName: subject name, '.vfuel' fromBytes: bytes.
)
deployAction = (
	subject isApplicationConfiguration ifFalse: [^nothing].
	^(link: '[deploy]' action: [
			openMenu:: menuWithLabelsAndActions: {
				{'as VictoryFuel'. [deployAsVictoryFuel]}.
				{'as VictoryFuel with Mirrors'. [deployAsVictoryFuelWithMirrors]}.				
				{'as Web Page'. [deployAsWebPage]}.
				{'as Web Page with Mirror Builders'. [deployAsWebPageWithMirrorBuilders]}.
			}
		]).
)
future_deployAction = (
(* Eventually, we'll use the deployment manager for deployment.
    At that point, this method will replace the current #deployAction
    implementation. Alas, this will take a while, as we need to implement
    a general strategy for reconstituting serialized aliens for this to work.
*)
	subject isApplicationConfiguration ifFalse: [^nothing].
	^link: '[deploy]' action: [
			openMenu:: menuWithLabelsAndActions: (
               ide deployment configurations collect: [:dc <DeploymentConfiguration> |
                   {'to ', dc name. 
                   [ide deployment deploy: (ide namespacing Root at: subject name) on: dc]}]
			)
		]
)
) : (
)
class ClassEntryPresenter onSubject: s <ClassSubject> = EntryPresenter onSubject: s () (
accessIndicator = (
	^image: (iconForAccessModifier: subject accessModifier) size: styleButtonSize.
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
entryActionsMenu = (
	^nothing
)
expandedDefinition = (
	^subject presenter
)
public tag ^ <String> = (
  ^subject name
)
collapsedDefinition = (
	^row1: {
        defaultBlank.
		image: ide images classIcon size: styleButtonSize.
        defaultBlank.
		accessIndicator.
        defaultBlank.
		link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror].
	} row2: {
		(row: {deferred: [(label: subject classCommentSummary)
			smallFont;
			color: secondaryTextColor]})
				compressibility: 1.
		filler
			compressibility: 0.

		(ClassActionsPresenter onSubject: subject) elasticity: 1.
		mediumBlank.
		entryActionsMenu.
	}
)
) : (
)
class ClassFactoryPresenter onSubject: s <ClassFactorySubject> = MethodPresenter onSubject: s (
(* Present the factory method, colorized. *)
 | toggle <ToggleComposer>  public showClassName <Boolean> ::= false. |
) (
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
	 ]
)
collapsedDefinition ^ <Fragment> = (
  ^column: {
      headerDefinition.
      label: subject classCommentSummary.
      mediumBlank.
	slotList.
	}
)
colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeHeader: s fromClass: subject classMirror via: (colorizingBlockFor: cm)
)
definition = (
	toggle:: collapsed: [collapsedDefinition]
			 expanded: [expandedDefinition].
	^toggle
)
expandedDefinition = (
  ^column: {
      headerDefinition.
	editorDefinition.
	}
)
headerDefinition ^ <Fragment> = (
  ^row: {
      defaultBlank.
      image: (iconForAccessModifier: subject accessModifier) size: styleButtonSize.
      defaultBlank.
      (link: subject name action: [toggle toggle]) color: actionLinkColor.
	showClassName
			ifTrue: [nestingInformationLine]
			ifFalse: [nothing].
	filler.
	dropDownMenu: [messagesMenu] image: ide images itemReferencesImage.
    smallBlank.
	dropDownMenu: [methodMenuFor: subject name]
   }.
)
public isKindOfClassFactoryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassFactoryPresenter
)
nestingInformationLine ^ <Fragment> = (
	| enclosingClasses rowElements |
	enclosingClasses:: subject enclosingClasses.
	rowElements:: List new.
	enclosingClasses do:
		[:each |
		rowElements add: ((label: ' in ') color: tertiaryTextColor).
		rowElements add: (linkToBrowseEnclosingClass: each)].
	^row: rowElements asArray
)
slotList ^ <Fragment> = (
  | sl |
	^column: {
           (sl:: subject classMirror instanceSide slots) size > 0
		   ifTrue: [
			column: {
				label: 'Slots' weight: #bold.
				smallBlank.
				row: {
					(column: (sl collect: [:ea | 
						row: {
                            defaultBlank.
							image: (iconForAccessModifier: ea accessModifier) size: styleButtonSize. 
                            defaultBlank.
							label: ea name.
						}
					])) elasticity: 1.
				}
			}.
		] ifFalse: [nothing].
		}
)
editorDefinition = (
	| 
	src = crToLf: subject classHeaderSource. 
	editor = codeMirror: src. 
	|
	editor 
		changeResponse: changeResponse;
        cancelResponse: cancelResponse;
		acceptResponse: acceptResponse.
	colorizeHeaderSource: src withEditor: editor.
	^editor
)
cancelResponse ^ <[:CodeMirrorFragment]> = (
	^[:ed <CodeMirrorFragment> |
        ed text: subject classHeaderSource.
		colorizeHeaderSource: (crToLf: subject classHeaderSource) withEditor: ed.
		ed leaveEditState.
	 ]
)
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <ClassDeclarationBuilder> = subject classMirror asBuilder. |
		updateGUI: [
			[b header source: ed textBeingAccepted.
			ide installFromBuilders: {b}.
			colorizeHeaderSource: (crToLf: ed textBeingAccepted)  withEditor: ed.
			ed leaveEditState] on: Error do:  [:ex <Exception> | ed showMessage: ex printString] .
		].
		ed editor focus.
	]
)
) : (
)
class ClassFactorySubject onModel: m <ClassDeclarationMirror> = MethodSubject onModel: m (
) (
public accessModifier ^ <Symbol> = (
	^#public
)
public classCommentSummary ^ <String> = (
	|
	fullComment <String> = classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
classCommentText ^<String> = (
	| comment = classMirror header classComment. |
	nil = comment ifTrue: [^''].
	^comment
)
public classDeclaration ^ <ClassDeclarationMirror> = (
  ^model
)
public classHeaderSource = (
	^classMirror header source
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model
)
public createPresenter ^ <ClassFactoryPresenter> = (
	^ClassFactoryPresenter onSubject: self
)
public delete = (
	Error signal: 'cannot delete primary class factory'
)
public enclosingClasses ^ <List[ClassDeclarationMirror]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| 
	classes <List[ClassDeclarationMirror]> = List new.
	currentClass <ClassDeclarationMirror> ::= classMirror.
	|
	[currentClass isNil]
		whileFalse: [
			classes add: currentClass.
			currentClass:: currentClass enclosingClass
			].
	^classes
)
public isKindOfClassFactorySubject ^ <Boolean> = (
  true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfClassFactorySubject
)
public messages   ^ <List[Symbol]> = (
  | result <List[Symbol]> = List new. |
  #BOGUS yourself. 
  classMirror instanceSide slots do: [:slot <SlotDeclarationMirror> |
	result add: slot name.
	slot isMutable ifTrue: [result add: slot name, ':']
	].
(*TODO: extract messages from factory. 
 *)
  ^result
)
public name ^ <Symbol> = (
 ^classMirror primaryFactorySelector
)
) : (
)
class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
  |
  public nestedClassesPresenter <NestedClassGroupPresenter>
  public instanceMethodsPresenter <MethodGroupPresenter>
  public classMethodsPresenter <MethodGroupPresenter>
  |
) (
accessIndicator = (
	^image: (iconForAccessModifier: subject accessModifier) size: styleButtonSize.
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event>  |
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
	  ]
)
classActionsMenu = (
	^menuWithLabelsAndActions: {
	 	{'Save to File'. [respondToSave]}.
		 #separator.
		{'Inspect Mirror'. [inspectObject: subject classMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
		#separator.
		{'Delete'. [respondToDelete]}.
	}
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
classNameAndContainmentDefinition ^ <Fragment> = (
	^column: {
		classNameAndHierarchySummary.
		preambleLine.
		label: subject classCommentSummary.
	}
)
classSourceDefinition = (
	| src = crToLf: subject classHeaderSource. editor =  codeMirror: src. |
	editor 
		changeResponse: changeResponse;
		acceptResponse: acceptResponse.
		colorizeHeaderSource: src withEditor: editor.
	^editor
)
colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeHeader: s fromClass: subject classMirror via: (colorizingBlockFor: cm)
)
expandedHeadingDefinition ^ <Fragment> = (
  ^column: {
      classNameAndHierarchySummary.
      (ClassFactorySubject onModel: subject classMirror) presenter
   }
)
headingDefinition ^ <Fragment> = (
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [classNameAndHierarchySummary].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
initializerDefinition ^ <Fragment> = (
	^nothing
)
inspectSelf ^ <Fragment> = (
	^row: {
		filler. 
		link: 'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]
	}
)
public isKindOfClassPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassPresenter
)
minorClassHeadingBlock: body = (
	^(padded: body with: {10. 5. styleHeaderPadRight. 5.})
		color: minorClassHeadingColor
)
minorClassHeadingColor = (
	^Gradient
		from: (Color h: 240 s: 0.02 v: 0.94)
		to: (Color h: 240 s: 0.02 v: 0.9)
)
nestedClass: cdm = (
	^collapsed: [row: {
                    defaultBlank.
					image: (iconForAccessModifier: cdm accessModifier) size: styleButtonSize.
					defaultBlank.
					link: cdm simpleName action: [enterSubject:: ClassSubject onModel: cdm]
					}
				]
	expanded: [(ClassSubject onModel: cdm) presenter]
)
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble <String> equalIndex <Integer> prefix <String> suffix <String> |
	preamble:: subject classMirror header preamble.
	equalIndex:: preamble indexOf: "=".
	equalIndex = 0
		ifTrue:
			[prefix:: preamble.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1).
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)].
	^suffix isEmpty
		ifTrue:
			[label: prefix]
		ifFalse:
			[row: {
				label: prefix, ' = '.
				link: suffix action: [respondToBrowseSuperclass]
				}]
)
respondToDelete = (
	| enclosing = subject enclosingClassSubject. |
	updateGUI: [
    	subject deleteClass.
		enclosing isNil
    		ifFalse: [enterSubject: enclosing]
        	ifTrue: [enterSubject: NamespaceSubject new]
        ]
)
public addMethodTemplate: t = (
  subject methodsSubject presenter addNewItemTemplate: t.
  refresh
)
respondToSave = (
	ide webFiles downloadFileName: subject name, '.ns' fromString: subject compilationUnitSource. 
)
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <ClassDeclarationBuilder> = subject classMirror asBuilder. |
		(*('ed text:', ed textBeingAccepted) out.*)
		b header source: ed textBeingAccepted.
		ide  installFromBuilders: {b}.
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed leaveEditState.
		]
)
classNameAndHierarchySummary = (
	| parts <List[Fragment]> |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^column: {
		row: {
			smallBlank.
			image: ide images classIcon size: styleButtonSize.
			smallBlank.
			row: parts.
			filler.
            (ClassActionsPresenter onSubject: subject) elasticity: 1.
			smallBlank.
			itemReferencesButtonWithAction: [browseSelector: subject name].
			smallBlank.
			saveButtonWithAction: [respondToSave].
			smallBlank.
			refreshButton.			
			smallBlank.
            helpButton.
			smallBlank.
			dropDownMenu: [classActionsMenu].
		}
	}
)
public definition ^ <Fragment> = (
	^column: {
        helpSection.
		headingDefinition.
		nestedClassesPresenter:: subject nestedClassesSubject presenter.
		instanceMethodsPresenter:: subject methodsSubject presenter.
		classMethodsPresenter:: subject classMethodsSubject presenter.
	}
)
helpText ^ <Fragment> = (
  | 
  mapping = Map new. 
  menuImage = Utilities uriForIconNamed: #hsDropdownImage. 
  referenceImage = Utilities uriForIconNamed: #itemReferencesImage.
  |
  mapping 
    at: #hopscotchClassActionsMenuButton put: (dropDownMenu: [classActionsMenu]);
    at: #hopscotchClassReferencesButton put: (itemReferencesButtonWithAction: [browseSelector: subject name]);
    at: #hopscotchHelpButton put: helpButton;
    at: #hopscotchRefreshButton put: refreshButton;
    at: #hopscotchSaveButton put: (saveButtonWithAction: [respondToSave]).

  ^ampleforth: 'A class presenter provides a structured view of a class. The first line tells you the class name and what classes, if any, it is nested in. It also provides the following buttons:
  <ul>
  <li> <div class="hopscotchClassReferencesButton"> </div>Allows you to find references to it. </li>
  <li><div class="hopscotchSaveButton"> </div> Downloads it (i.e., saves it to a file)
   .</li>
 <li><div class="hopscotchRefreshButton"> </div> Refreshes the display</li>
    <li><div class="hopscotchHelpButton"> </div> Shows this help message.</li>
   <li> <div class="hopscotchClassActionsMenuButton"> </div> Opens a menu of additional operations, such as deleting the class or inspecting this presenter or a mirror on this class declaration.</ul> <br>
  The line below provides access to the class'' primary factory. You can access senders and implementers of the factory and the slots it defines via  <img src="', referenceImage , '" alt="" width="30" height="30">, or access the menu via <img src="', menuImage, '" alt="" width="30" height="30">. <br>
  The following three sections manage nested classes, instance and class methods respectively. '  mapping: mapping
)
) : (
)
public class ClassSubject onModel: m <ClassDeclarationMirror> = ProgrammingSubject onModel: m (
) (
public accessModifier = (
	^classMirror accessModifier
)
public classCommentSummary ^ <String> = (
	|
	fullComment <String> = classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
public classCommentText ^<String> = (
	| comment = model header classComment. |
	nil = comment ifTrue: [^''].
	^comment
)
public classHeaderSource = (
	^classMirror header source
)
public classMethodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror classSide methods within: classMirror classSide
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model
)
public createPresenter = (
	^ClassPresenter onSubject: self
)
public enclosingClassSubject ^ <ClassSubject> = (
	^isTopLevel ifFalse: [ClassSubject onModel: model enclosingClass]
)
public enclosingClassSubjects ^ <List[ClassSubject]> = (
	| them = List new. c |
	c:: model.
	[c isNil] whileFalse: [them add: (ClassSubject onModel: c). c:: c enclosingClass].
	^them
)
public isApplicationConfiguration ^ <Boolean> = (
  ^isTopLevel and: [
	classMirror primaryFactorySelector = #packageUsing: or: [
		classMirror classSide methods includesMirrorNamed: #packageUsing:
		]
	]
)
public isKindOfClassSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfClassSubject
)
public isTopLevel = (
	^nil = model enclosingClass
)
public methodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror instanceSide methods within: classMirror instanceSide
)
public name = (
	^model name
)
public nestedClassesSubject ^ <NestedClassGroupSubject> = (
	^NestedClassGroupSubject onModel: classMirror instanceSide nestedClasses within: classMirror instanceSide
)
public testingSubject = (
	#NAMESPACEBOGUS.
	^ide minitestUI TestingInProgressSubject
		onConfiguration: (ide namespacing Root at: name)
		platform: cachedPlatform
		minitest: ide minitest
)
public title = (
	^name
)
public runApp = (
	| appDef <Class> app <Object> |
	appDef:: ide namespacing Root at: name.
	app:: appDef packageUsing: ide namespacing manifest.
	app main: cachedPlatform args: {}
)
public bytesForVictoryFuel ^ <ByteArray> = (
	^bytesForVictoryFuelWithRuntime: ide psoupDeploymentRuntime
)
public bytesForVictoryFuelWithMirrors ^ <ByteArray> = (
	^bytesForVictoryFuelWithRuntime: ide psoupWithMirrorsDeploymentRuntime
)
public bytesForVictoryFuelWithRuntime: runtimeClass ^ <ByteArray> = (
	| appDef <Class> =  ide namespacing Root at: name. |
	^ide deployment PSoupPackager packageApplicationConfiguration: appDef withRuntimeConfiguration: runtimeClass  usingNamespace: ide namespacing Root
)
public compilationUnitSource ^ <String> = (
  isTopLevel ifTrue: [
	^compilationUnitFromSource: classMirror source
	].
  ^classMirror source
)
public inactiveTestingSubject = (
	#NAMESPACEBOGUS.
	^ide minitestUI TestingOutcomeSubject
		onConfiguration: (ide namespacing Root at: name)
		platform: cachedPlatform
		minitest: ide minitest
)
public isTestConfiguration = (
  ^isTopLevel and: [
	classMirror primaryFactorySelector = #packageTestsUsing: or: [
		classMirror classSide methods includesMirrorNamed: #packageTestsUsing:
		]
	]
)
public deleteClass = (
	| builder |
	nil = model enclosingClass ifTrue: [
    		^deleteTopLevelClassNamed: name.
    	].
	builder:: model enclosingClass asBuilder.
	builder instanceSide nestedClasses removeMirrorNamed: model name.
	ide installFromBuilders: {builder}
)
) : (
)
public class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* 
DefinitionListPresenter is an abstract superclass of presenters that displays helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added. 
*)

| 
stateSlot <DefinitionListPresenterState> 
contentListSlot <ToggleList>
|
) (
addButton = (
  ^addButtonWithAction: [updateGUI: [respondToAdd]].
)
public addNewItemTemplate = (
	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)

	subclassResponsibility
)
public collapseAll = (
	(* Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	contentList childrenDo: [:each <ToggleComposer> | each collapse]
)
contentList = (
   contentListSlot isNil ifTrue: [
	contentListSlot:: toggleList: contentPresenters
	].
  ^contentListSlot.
)
definitionListMenu = (
  subclassResponsibility
)
public expandAll = (
	(* Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	contentList childrenDo: [:each <ToggleComposer> | each expand]
)
public isKindOfDefinitionListPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfDefinitionListPresenter
)
respondToAdd = (
  addNewItemTemplate
)
public state = (
  stateSlot isNil ifTrue: [stateSlot:: DefinitionListPresenterState new].
  ^stateSlot
)
public title = (
  subclassResponsibility
)
updateVisualsFromSameKind: oldPresenter <Self> ^ <Alien[Element]> = (
  stateSlot:: oldPresenter state.
  substanceSlot:: nil.
  ensureSubstance.
  ^super updateVisualsFromSameKind: oldPresenter
)
definition ^ <Fragment> = (
	^column: {
		minorHeadingBlock: (
			row: {
				label: title weight: #bold.
				defaultBlank.
				addButton.
				filler.
				expandButtonWithAction: [expandAll].
				defaultBlank.
				collapseButtonWithAction: [collapseAll].
				defaultBlank.
				refreshButton.
				defaultBlank.
				dropDownMenu: [definitionListMenu].								
				}
			).
		state prefixHolder.
		contentList.		
	}
)
) : (
)
public class DefinitionListPresenterState = (
  | 
  prefixes <List[DefinitionTemplate]> = List new. 
  prefixPresenter = PrefixPresenter new.
  public prefixHolder <HolderComposer> = prefixPresenter holder: fragmentForPrefixes. 
  |
) (
class PrefixPresenter = Presenter onSubject: nil (
(*
A trick/hack to give the enclosing object access to the the fragment factories it needs.
The only way to create fragments outside the Hopscotch module is via the factories inherited from Presenter.
DefinitionListPresenterState is not a presenter, and yet it manufactures bits of presentation. Hence, we create
this presenter class, which publicizes the required inherited factories. Each factory has a single instance of this class,
which it uses to access the needed factories.
*)
) (
public column: ds  <List[Fragment]> ^ <ColumnComposer>  = (
  ^super column: ds
)
public holder: c <Fragment> ^ <HolderComposer> = (
  ^super holder: c
)
public isKindOfPrefixPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfPrefixPresenter
)
) : (
)
public addPrefix: p <DefinitionTemplate> = (
  prefixes add: p.
  updatePrefixes.
)
fragmentForPrefixes ^ <Fragment> = (
  ^prefixPresenter column: prefixes
)
public isKindOfDefinitionListPresenterState ^ <Boolean> = (
  ^true
)
public removePrefix: p <DefinitionTemplate>  = (
  prefixes remove: p.
  updatePrefixes.
)
updatePrefixes = (
  prefixHolder isNil ifFalse: [prefixHolder content: fragmentForPrefixes]
)
) : (
)
public class DefinitionListSubject onModel: m = Subject onModel: m (
(* DefinitionListSubject manages helper ''transient'' subjects, for example is a method list  which can at times include presenters for methods being added or residue presenters of removed methods. *)
| 
public prefixes <List[Fragment]> = List new.
public content <List[Subject]>  = List new. 
|
) (
public createPresenter ^ <DefinitionListPresenter> = (
  ^DefinitionListPresenter onSubject: self.
)
public isKindOfDefinitionListSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfDefinitionListSubject
)
) : (
)
public class DefinitionTemplate
   caption: c <String>
   initialText: t <String | Text>
   colorizerBlock: cb <[:String :CodeMirrorFragment]>
   acceptResponse: onAccept <[DefinitionTemplate]>
   cancelResponse: onCancel <[DefinitionTemplate]>
 = ProgrammingPresenter onSubject: nil (|
	public caption = c.
	public initialText = t.
	public initiallyInEditState ::= true.
	public acceptResponse = onAccept.
	public cancelResponse = onCancel.
	public editor
	public colorizerBlock = cb.
|) (
public = other <Object>^ <Boolean> = (
  other isKindOfDefinitionTemplate ifFalse: [^false].
  ^other text = text
)
definition ^ <Fragment> = (
	^(row: {
		mediumBlank.
		elastic:
			(column: {
				smallBlank.
				label: caption.
				editorDefinition.
				mediumBlank.
 			}).
		smallBlank.
		}) color: (Gradient from: (Color h: 100 s: 0.3 v: 0.9) to: (Color h: 100 s: 0.3 v: 0.8))
)
editorDefinition ^ <Fragment> = (
	editor:: (codeMirror: initialText)
	(*	acceptLabelText: 'save';
		cancelLabelText: 'cancel';*)
		acceptResponse: [acceptResponse value: self];
		changeResponse: [:cm <CodeMirrorFragment> :event <Event>  | colorizerBlock value: cm textBeingAccepted value: cm];
		cancelResponse: [cancelResponse value: self].
	initiallyInEditState ifTrue: [editor updateEditState].
	colorizerBlock value: initialText value: editor.
	^editor
)
public hash ^ <Integer> = (
  ^text hash
)
public isKindOfDefinitionTemplate ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfDefinitionTemplate
)
public tag ^ <String> = (
  ^printString
)
public text = (
	^editor textBeingAccepted
)
) : (
)
class EntryPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public collapse = (
	substance collapse
)
definition = (
	^collapsed: [collapsedDefinition] expanded: [expandedDefinition]
)
public expand = (
	substance expand
)
public isKindOfEntryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfEntryPresenter
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.
	}
)
) : (
)
public class EvaluationViewState onModel: m <ObjectMirror | ActivationMirror> = (
(* An evaluator maintains a list of results of prior evaluations. *)
  | 
  public mirror <ObjectMirror | ActivationMirror> = m. 
  results_slot <List[ThreadMirror]> ::= List new. 
  lastEvalWasLive <Boolean> ::= false. 
  public isLive <Boolean> ::= false.
  |
) (
public clear = (
  results do: [:t | (t isBroken or: [t isSuspended])  ifTrue: [t terminate]].
  lastEvalWasLive:: false.
  results_slot:: List new
)
public isKindOfEvaluationViewState ^ <Boolean> = (
  ^true
)
public results  ^  <List[ThreadMirror]> = (
  ^results_slot
)
public evaluate: e <String> ^ <ThreadMirror>  = (
  lastEvalWasLive:: false.
  ^results_slot add: ([mirror evaluate: e] on: Error do: [:ce | ce])
)
public evaluateLive: e <String> ^ <ThreadMirror>  = (
  | result = [mirror evaluate: e] on: Error do: [:ce | ce]. |
  ^lastEvalWasLive ifTrue: [
	(e isEmpty not and: [e last = '.' last]) ifTrue: [lastEvalWasLive:: false].
	results_slot at: results_slot size put: result.
	]  ifFalse: [lastEvalWasLive:: e last  ~= '.' last. results_slot add: result]
)
public = another <Object> ^<Boolean> = (
	^(another isKindOfEvaluationViewState) and:
		[mirror = another mirror]
)
public hash ^<Integer> = (
	^self class hash bitXor: mirror hash
)
) : (
)
class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
aboutSystemDefinition = (
	^(link: 'About this system' action: [respondToAboutSystem]) smallFont.
)
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter'. [respondToInspectPresenter]}.
	}
)
column1: definitions1 column2: definitions2 column3: definitions3 = (
	^row: {
		(column: definitions1) width: 0 elasticity: 1.
		(column: definitions2) width: 0 elasticity: 1.
		(column: definitions3) width: 0 elasticity: 1.
	}
)
didYouKnow = (
	| wisdom |
	wisdom:: subject randomBitOfWisdom.
	nil = wisdom actionLabel ifFalse:
		[^textAndActionWisdom: wisdom].
	nil = wisdom image ifFalse:
		[^textAndImageWisdom: wisdom].
	^textDisplay: wisdom text
)
public isKindOfHomePresenter ^ <Boolean> = (
  ^true
)
navigateToNamespace = (
	enterSubject:: NamespaceSubject new.
)
navigateToWorkspaces = (
	enterSubject:: ide theWorkspaceManager AllWorkspacesSubject new.
)
respondToAboutSystem = (
	alert: 'WebIDEApp version 0.1984'
)
textAndActionWisdom: wisdom = (
	^column: {
		textDisplay: wisdom text.
		(link: wisdom actionLabel action: wisdom actionBlock) smallFont
	}
)
textAndImageWisdom: wisdom = (
	^row: {
		image: wisdom image size: styleButtonSize.
		mediumBlank.
		elastic:
			(textDisplay: wisdom text).
	}
)
definition = (
	^column: {
		helpSection.
		majorHeadingBlock: (
			row: {
				label: 'Navigation' weight: #bold.
				filler.
				helpButton.
				dropDownMenu: [actionsMenu].				
			}
		).
		mediumBlank.

		indentedBlock:
			(column1: {
				link: 'Newspeak Source' action: [navigateToNamespace].
			}
			column2: {
				link: 'Workspaces' action: [navigateToWorkspaces].
			}
			column3: {
			}).
		mediumBlank.

(*		majorHeadingBlock: (label: 'Recently Visited' asText allBold).
		mediumBlank.
		indentedBlock:
			(holder: [recentStuffDefinition]).
		largeBlank.*)

		majorHeadingBlock: (label: 'Did you know?' weight: #bold).
		mediumBlank.

		indentedBlock:
			(holder: [didYouKnow]).
		mediumBlank.
		indentedBlock: aboutSystemDefinition.
	}
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfHomePresenter
)
public helpText ^<Fragment> = (
  | goldenIcon = Utilities uriForIconNamed: #languageNewspeak3. |
  ^html: 'This is the home page.<br><br>
The home page includes links to a variety of useful places, like the IDE''s root namespace, which lists all top level classes, and the workspace manager, where you can evaluate code.<br>
The <img src=''',  goldenIcon, ''' alt="" width="18" height="30"> icons represent Newspeak3, which is the currently operational dialect of Newspeak.'
)
) : (
)
public class HomeSubject onModel: m = ProgrammingSubject onModel: m (
(* The Home screen is stateful.  The state is simply whether the
    help text is displayed or not. 
 *)
) (
public = anotherSubject <Subject> ^ <Boolean> = (
	(* As there is just one possible logical home of the system, all subjects representing it are considered equal. *)
	^anotherSubject isKindOfHomeSubject
)
bitsOfWisdom = (
	(* This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random. *)
	^{
	[BitOfWisdom
		text: 'This is the "expand all" button which appears in headers of expandable item groups.'
		image: ide images expandImage].

	[BitOfWisdom
		text: 'This is the "collapse all" button which appears in headers of expandable item groups.'
		image: ide images collapseImage].

	[BitOfWisdom
		text: 'This is the "add" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'
		image: ide images addImage].

	[BitOfWisdom
		text: 'Expressions evaluated in debuggers and inspectors can access a workspace via the name _. This allows you to bypass modularity during development and access values you forgot to import, e.g. _ collections List.'].

	[BitOfWisdom
		text: 'This icon identifies Newspeak classes.'
		image: ide images classIcon].

	[BitOfWisdom
		text: 'This icon identifies namespaces.'
		image: ide images classPresenterIcon].

	[BitOfWisdom
		text: 'War is peace. Freedom is slavery. Ignorance is strength.'].
	}
)
public isKindOfHomeSubject ^ <Boolean> = (
	^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfHomeSubject
)
public randomBitOfWisdom = (
	| bits = bitsOfWisdom. |
	^(bits at: (JSMath random * bits size) floor asInteger + 1) value
)
public hash ^<Integer> = (
	^self class hash
)
public createPresenter = (
	^HomePresenter onSubject: self
)
public title = (
	^'Newspeak Home'
)
) : (
public new = (
	^onModel: nil
)
)
class IntegerView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public definition = (
	^column: {
		label: 'binary' radix: 2.
		label: 'octal' radix: 8.
		label: 'decimal' radix: 10.
		label: 'hex' radix: 16.
	}
)
public isKindOfIntegerView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfIntegerView
)
label: label radix: radix = (
	^row: {
		smallBlank.
		(label: label)
			width: 0 elasticity: 1.
		smallBlank.
		(label: (subject objectMirror reflectee asStringRadix: radix))
			width: 0 elasticity: detailAreaRatio.
	}
)
) : (
)
class KeysAndValuesView title: t onSubject: s = ProgrammingPresenter onSubject: s (
	|
	public title <String> = t.
	|
) (
public definition = (
	^column:
		(subject keysAndValues collect:
			[:slot <SlotSubject> | slot presenter])
)
public isKindOfKeysAndValuesView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfKeysAndValuesView
)
updateVisualsFromSameKind: oldFragment <KeysAndValuesView> ^ <Alien[Element]> = (
  subject keysAndValues do: [:slot <SlotSubject> | 
    | oldSlotPresenter <SlotPresenter>  = findSlotMatching: slot in: oldFragment. |
    oldSlotPresenter isNil  ifFalse: [slot presenter updateVisualsFrom: oldSlotPresenter]
  ].
  ^replaceVisual: oldFragment visual with: visual
)
findSlotMatching: slot <SlotSubject> in: oldFragment <KeysAndValuesView> ^ <SlotPresenter> = (
   ^oldFragment substance definitions detect: [:def <SlotPresenter> | def subject = slot] ifNone: [].
)
) : (
public onSubject: s = (
  ^title: s classMirror mixin name onSubject: s
)
)
class MethodGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)
| groupedByCategory <Boolean> ::=false. |
) (
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	addNewItemTemplate: subject methodTemplateText
)
createNewMethodFromTemplate: template <DefinitionTemplate> = (
| prefixState <DefinitionListPresenterState> = state. |
	subject
		compileSource: template text
		ifSuccess:
			[:newMethod <MethodMirror> |
			|
			(* newSubject <MethodSubject> = MethodSubject onModel: newMethod.
			newPresenter <MethodPresenter> = createPresenterForSubject: newSubject.*)
			(*newToggle <ToggleComposer> = newPresenter visual; substance.*)
			|

			prefixState removePrefix: template.
			updateGUI: []
			]
		ifFailure:
			[:message | template editor showMessage: message]
)
public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	updateGUI: [
		subject deleteMethodWithSubject: presenter subject.
		successResponse value
		]
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^MethodPresenter
)
public title = (
  | side = subject definingMixin isMeta ifTrue: ['Class'] ifFalse: ['Instance'].|
  ^side, ' Methods'
)
public addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template prefixState <DefinitionListPresenterState> = state. |
	template:: DefinitionTemplate
		caption: 'Adding new method:'
		initialText: src
		colorizerBlock:
			[:text <String> :cm <CodeMirrorFragment> | subject colorizeSource: text editor: cm]
		acceptResponse:
			[:ed | createNewMethodFromTemplate: template]
		cancelResponse:
			[:ed | updateGUI: [prefixState removePrefix: template]].
	updateGUI: [prefixState addPrefix: template]
)
) : (
)
public class MethodGroupSubject onModel: m <MirrorGroup[MethodMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (
(* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)
) (
public colorizeSource: source <String> editor: cm <CodeMirrorFragment> ^ <TextFragment> = (
	^ide colorizer
		colorizeMethod: source
		fromClass: definingMixin declaration
		via: (colorizingBlockFor: cm)
)
public createPresenter = (
	^MethodGroupPresenter onSubject: self
)
elementSubjectClass ^ <MethodSubject class> = (
	^MethodSubject
)
public isKindOfMethodGroupSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfMethodGroupSubject
)
public methodTemplateText ^ <String> = (
^
'messageSelector = (
)'
)
modelMirrorCollection ^ <Collection[MethodMirror]> = (
	^super modelMirrorCollection (*asSortedList: [:a :b | a simpleName < b simpleName]*)
)
public compileSource: source <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <MethodBuilder> newMirror <MethodMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder methods addFromSource: source.
	ide  installFromBuilders: {builder declaration}.
	newMirror:: definingMixin methods findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public deleteMethodWithSubject: methodSubject <MethodSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder methods removeMirrorNamed: methodSubject selector.
	ide installFromBuilders: {builder declaration}
)
) : (
)
public class MethodPresenter onSubject: s <MethodSubject> = ProgrammingPresenter onSubject: s (
	(* A presenter for a single method. *)
	|
	public showClassName ::= false.
	|
) (
public collapse = (
	^substance collapse
)
colorizeMethodSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeMethod: s fromClass: subject classDeclaration via: (colorizingBlockFor: cm)
)
public expand = (
	^substance expand
)
messagesMenu = (
	| messagesAndActions messageItems classItems |
	messagesAndActions:: List new.
	messagesAndActions add:
		{subject name. [browseSelector: subject name]}.
	messageItems:: referencesMenuMessageItems.
	messageItems isEmpty not ifTrue:
		[messagesAndActions
			add: #separator;
			addAll: messageItems].
	^menuWithLabelsAndActions: messagesAndActions
)
public isKindOfMethodPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfMethodPresenter
)
linkToBrowseEnclosingClass: klass <ClassDeclarationMirror> = (
	^(link: klass simpleName
		action: [enterSubject:: ClassSubject onModel: klass])
		color: secondaryTextColor
)
methodMenuFor: methodName <String> = (
	^menuWithLabelsAndActions: {
		{'Delete #', methodName. [updateGUI: [subject delete]]}.
		#separator.
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}
)
nestingInfo = (
		^showClassName
			ifTrue: [nestingInformationLine]
			ifFalse: [nothing].
)
nestingInformationLine = (
	| enclosingClasses rowElements |
	enclosingClasses:: subject enclosingClasses.
	rowElements:: List new.
	enclosingClasses do:
		[:each |
		rowElements add: ((label: ' in ') color: tertiaryTextColor).
		rowElements add: (linkToBrowseEnclosingClass: each)].
	^row: rowElements asArray
)
public tag ^ <String> = (
  ^subject name
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
	 ]
)
cancelResponse ^ <[:CodeMirrorFragment]> = (
	^[:ed <CodeMirrorFragment> |
        ed text: subject source.
		colorizeMethodSource: (crToLf: subject source) withEditor: ed.
		ed leaveEditState.
	 ]
)
errorDisplay: msg <String> ^ <Fragment> = (
  ^row: {label: msg. button: 'Clear' action: [subject errorMessages remove: msg] }
)
errorMessages ^ <Array[Fragment]> = (
  ^(subject errorMessages collect: [:msg <String> |
       errorDisplay: msg
    ]) asArray.
)
public definition ^ <Fragment> = (
	| toggle |
	toggle::
		collapsed: [row: {
			image: (iconForAccessModifier: subject accessModifier) size: styleButtonSize.
			defaultBlank.
			(link: subject name action: [toggle expand]) color: actionLinkColor.
		      nestingInfo.
	            filler.
	            dropDownMenu: [messagesMenu] image: ide images itemReferencesImage.
	            smallBlank.
	            dropDownMenu: [methodMenuFor: subject name]
			}
		]
		expanded: [ |  src = crToLf: subject source. cm = codeMirror: src. |
			cm changeResponse: changeResponse; 
                  cancelResponse: cancelResponse;
                  acceptResponse: acceptResponse.
			colorizeMethodSource: src withEditor: cm.
			column: {
			row: {
			  image: (iconForAccessModifier: subject accessModifier) size: styleButtonSize.
			  defaultBlank.
			  (link: subject name action: [toggle collapse]) color: actionLinkColor.
				nestingInfo.
				filler.
				dropDownMenu: [messagesMenu] image: ide images itemReferencesImage.
				smallBlank.
				dropDownMenu: [methodMenuFor: subject name]
			}.
			cm.
            column: errorMessages.
		}].
	^toggle
)
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^ [:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		updateGUI: [
			[b methods addFromSource: ed textBeingAccepted.
			ide  installFromBuilders: {b declaration}.
			colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
			ed leaveEditState] on: Error do:  [:ex <Exception> | ed showMessage: ex printString]
			].
		ed editor focus.
		]
)
referencesMenuMessageItems = (
	| items sortedMessages|
	items:: List new.
	sortedMessages:: subject messages sort: [:m1 :m2 | 
       lexicallyLessOrEqual: m1 than: m2
     ].
	sortedMessages do:
		[:selector |
		selector == subject name ifFalse:
			[items add:
				{selector. [browseSelector: selector]}]].
	^items
)
) : (
)
public class MethodSubject onModel: mm <MethodMirror> = Subject onModel: mm (
(* Manages the UI for a method. *)
| public errorMessages <Set[String]> = Set new. |
) (
public accessModifier ^ <Symbol> = (
	^methodMirror accessModifier
)
public classDeclaration ^ <ClassDeclarationMirror> = (
	^methodMirror definingMixin declaration
)
public createPresenter ^ <Presenter> = (
	^MethodPresenter onSubject: self
)
public enclosingClasses ^ <List[ClassDeclarationMirror]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| 
	classes <List[ClassDeclarationMirror]> = List new.
	currentClass <ClassDeclarationMirror> ::= classDeclaration.
	|
	[currentClass isNil]
		whileFalse: [
			classes add: currentClass.
			currentClass:: currentClass enclosingClass
			].
	^classes
)
public messages   ^ <List[Symbol]> = (
  ^methodMirror selectors
)
public methodMirror ^ <MethodMirror> = (
	^model
)
public name ^ <Symbol> = (
	^methodMirror name
)
public source ^ <String> = (
	^methodMirror source
)
public clearErrors = (
  errorMessages removeAll: errorMessages
)
public delete = (
	| b <MixinBuilder> = methodMirror definingMixin asBuilder. |
	b methods removeMirrorNamed: methodMirror name.
	ide installFromBuilders: {b declaration}
)
public compileSource: src <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <MethodBuilder> newMirror <MethodMirror> |
	builder:: methodMirror definingMixin asBuilder.
	newBuilder:: builder methods addFromSource: src.
	ide installFromBuilders: {builder declaration}.
	newMirror:: definingMixin methods findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public isKindOfMethodSubject ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfMethodSubject
)
) : (
)
class MirrorGroupPresenter onSubject: s <Subject> = DefinitionListPresenter onSubject: s (
) (
createPresenterForSubject: aSubject <Subject> ^ <ProgrammingPresenter> = (
	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)
	nil = elementPresenterClass ifTrue: [^aSubject presenter].
	^elementPresenterClass onSubject: aSubject
)
definitionListMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	(* A subclass must redefine this to define the class of presenter it will be using. *)
	subclassResponsibility
)
contentPresenters ^ <Collection[ProgrammingPresenter]> = (
	^(subject elements collect:
		[:each <ProgrammingPresenter> | createPresenterForSubject: each]) 
        sort: [:p1 <ProgrammingPresenter> :p2 <ProgrammingPresenter> | 
            lexicallyLessOrEqual: p1 subject name than: p2 subject name
          ]
)
) : (
)
class MirrorGroupSubject onModel: m <MirrorGroup> within: dm <MixinMirror> = ProgrammingSubject onModel: m (
	|
	public definingMixin <MixinMirror> = dm.
	|
) (
elementSubjectClass = (
	(* Answer the class of the subjects we create on individual elements of our subject group. *)
	subclassResponsibility
)
public elements ^<Collection[Subject]> = (
	(* Answer a collection of subjects on individual elements of the group which is our subject. *)
	^modelMirrorCollection collect: [:each | elementSubjectClass onModel: each]
)
public isKindOfMirrorGroupSubject ^ <Boolean> = (
  ^true
)
public mirrorGroup ^ <MirrorGroup> = (
	^model
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^List withAll: model
)
) : (
)
class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (
) (
class ClassEntryPresenter onSubject: s <ClassSubject> = outer Browsing ClassEntryPresenter onSubject: s () (
accessIndicator = (
	^nothing
)
entryActionsMenu = (
	^dropDownMenu: [entryActionsMenuFor: subject name].
)
) : (
)
class NamespaceEntryPresenter onSubject: s = EntryPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
        defaultBlank.
		image: ide images classPresenterIcon size: styleButtonSize.
		defaultBlank.
		row: {link: subject key action: [
			(*ide defaultPopularityRecord
			rememberNamespaceVisit: subject key. (* Should be the namespace itself, but non-strings break the home page. *)*)
			enterSubject:: subject refreshmentSubject]}.
	} row2: {
		(label: subject summaryText)
				smallFont;
				compressibility: 1;
				color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject key]
	}.
)
expandedDefinition = (
	^subject presenter
)
public tag ^ <String> = (
  ^subject key
)
) : (
)
class ValueEntryPresenter onSubject: s = EntryPresenter onSubject: s (|
	public key
|) (
collapsedDefinition = (
	^row1: {
        defaultBlank.
		image: ide images classUnknownIcon size: styleButtonSize.
		defaultBlank.
		link: key action: [enterSubject:: subject].
	} row2: {
		(label: subject title)
			smallFont;
			compressibility: 1;
			color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: key]
	}
)
definition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^collapsed: [collapsedDefinition]
	expanded: [subject presenter selfCaption: key]
)
expandedDefinition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^subject presenter selfCaption: key
)
public isKindOfValueEntryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfValueEntryPresenter
)
public tag ^ <String> = (
  ^key
)
) : (
)
acceptNewClassDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[updateGUI: [prefixState removePrefix: aTemplate]]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
acceptNewNamespaceDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addNamespaceFromDefinition: aTemplate text
		ifSuccess:
			[updateGUI: [prefixState removePrefix: aTemplate]]
		ifFailure:
			[:msg | aTemplate editor text: msg]
)
addButton = (
		^(*subject namespace isKindOfCategoryNamespace
				ifTrue: [*)addButtonWithMenu: [addCategoryMenu](*]
				ifFalse: [addButtonWithAction: [respondToAddForRoot]]*).
)
addCategoryMenu = (
	^ {
		{'Add Class'. [addClassTemplate]}.
		{ 'Add Namespace'. [addNamespaceTemplate]}.
		(*{'Add Image From File'. [respondToAddImage].}.
		{'Add Text From File'. [respondToAddText]}.
		 'Add Value' -> [Error signal: 'Unimplemented']. *)
	}
)
addClassTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock:
				[:text <String> :cm <CodeMIrrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]])].
)
addNamespaceTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new namespace:'
			initialText: 'NewNamespace'
			colorizerBlock:
				[:text <String> :cm <CodeMIrrorFragment> | ]
			acceptResponse:
				[:template | acceptNewNamespaceDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]])].
)
contentList ^ <PresenterList> = (
	^zebra: super contentList
)
contentPresenters ^ <List[Presenter]> = (
	| lexicalOrder <[:Symbol :Symbol | Boolean]> |
	lexicalOrder:: [:a <Symbol> :b <Symbol> |
		lexicallyLessOrEqual: a than: b
	].
	^(subject namespace keys asArray sort: lexicalOrder) collect: [:key | presenterForEntryAt: key]
)
definitionListMenu = (
  ^namespaceMenu
)
entryActionsMenuFor: key = (
	^menuWithLabelsAndActions: {
		{'Remove ', key. [updateGUI: [ide namespacing removeKey: key.]]}.
	}
)
public isKindOfNamespacePresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfNamespacePresenter
)
namespaceMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}.
		#separator.
		{'Compile File(s)'. [respondToCompileFiles]}
	}
)
presenterForEntryAt: key <Symbol> ^ <EntryPresenter> = (
	| entry = subject namespace at: key. |
	entry isKindOfBehavior
		ifTrue: [^ClassEntryPresenter onSubject: (ClassSubject onModel: (ClassMirror reflecting: entry) mixin declaration)].

	entry isKindOfNamespace
		ifTrue: [^NamespaceEntryPresenter onSubject: (NamespaceSubject onModel: entry key: key)].

	^(ValueEntryPresenter onSubject: (objectSubjectFor: entry)) key: key
)
respondToAddForRoot = (
	openMenuWithLabelsAndActions: {
		{'Add Namespace'. [addNamespaceTemplate]}.
	}
)
respondToAddImage = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key form |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		form:: PNGReadWriter formFromFileNamed: fn.
		subject namespace at: key asSymbol put: form.
	].
)
respondToAddText = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key text |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		text:: ((MultiByteFileStream oldFileNamed: fn)
			converter: (TextConverter newForEncoding: 'utf8')) contents.
		subject namespace at: key asSymbol put: text.
	].
)
public tag ^ <String> = (
  ^title
)
public title = (
  ^subject key (*asText allBold*)
)
respondToCompileFiles = (
   multipleFileChooser chooseFileList: [:fl | 
	    subject compileFiles:  fl
		ifSuccess:
			[updateGUI: []]
		ifFailure:
			[:msg | alert: msg. nil]
	]
)
) : (
)
public class NamespaceSubject onModel: m <Map[Symbol, Object]> key: k <Symbol> = ProgrammingSubject onModel: m (|
	public key = k.
|ide namespacing refreshCategoryNamespaces) (
public = other ^<Boolean> = (
	^other isKindOfNamespaceSubject
		and: [namespace = other namespace
		and: [key = other key]].
)
public addNamespaceFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| selector <Symbol> = definition asSymbol. |
	(*model = ide namespacing Categories ifFalse: (* ? *)
		[Error signal: 'Not supported yet, only categories for now.'].*)

	(*selector isUnary ifFalse:
		[^failureBlock value: 'Must be a unary selector'].*)
	(namespace includesKey: selector) ifTrue:
		[^failureBlock value: 'A class named ', definition, ' already exists in this namespace'].
	(* ide namespacing categoryNamespace: selector.*)
	namespace at: selector put: (ide namespacing freshNamespace).
	successBlock value
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
	|
	slot1
	slot2
	|
) ()'
)
public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment>  = (
	^ide colorizer
		colorizeClassDeclaration: source
		fromClass: nil
		via: (colorizingBlockFor: cm)
)
public createPresenter ^ <NamespacePresenter> = (
	^NamespacePresenter onSubject: self
)
public hash ^<Integer> = (
	^model hash bitXor: key hash
)
public isKindOfNamespaceSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfNamespaceSubject
)
public namespace ^ <Map[Symbol, Object]> = (
	^self model
)
public refreshmentSubject = (
	^self class onModel: model key: key
)
public summaryText = (
	| sb = StringBuilder new. |
	namespace keys
		do: [:k | sb add: k]
		separatedBy: [sb add: ', '].
	^sb asString
)
public title ^<String> = (
	^key
)
public compileFiles: fs <List[Alien[File]]> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:List[String]]> = (
  | ps <List[Alien[Promise[[String]]]]>  = JSArray new: fs size. |
  1 to: fs size do: [:i <Integer> | ps at: i - 1 put: (fs at: i) text].
  (JSPromise all: ps) then: [:sources <JSArray[String]> |
	  [|  mixins <List[MixinMirror]> bs <List[ClassDeclarationBuilder]> = List new: fs size. |
	  0 to: fs size - 1 do: [:i <Integer> |
          bs add: (ClassDeclarationBuilder fromUnitSource: (sources at: i))
		  ].
        mixins:: ide installFromBuilders: bs into: namespace.
        mixins do: [:m <MixinMirror> | namespace at: m name ifAbsent: [namespace at: m name put: m declaration applyToObject reflectee]].
        successBlock value.] on: Error do:  [:ex | failureBlock value: ex printString]
	] onError: [:ex | failureBlock value: ex printString].
)
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| builder <ClassDeclarationBuilder> klass |
	[builder:: ClassDeclarationBuilder fromSource: definition]
		on: Error
		do: [:ex | ^failureBlock value: ex printString].
	(namespace includesKey: builder name) ifTrue:
		[^failureBlock value: 'A class named ', builder name, ' already exists in this namespace'].
	klass:: (ide installFromBuilders: {builder}) first declaration applyToObject.
	namespace at: klass mixin name put: klass reflectee.
	successBlock value
)
) : (
public new = (
	#NAMESPACEBOGUS.
	^self onModel: ide namespacing Root key: 'Root'
)
)
class NestedClassGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, a NestedClassGroupSubject, as a column of presenters for the nested classes in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS nested classes goes here. *)
) (
public deleteClassInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteClassWithSubject: presenter subject.
	successResponse value
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^ClassEntryPresenter
)
public title = (
  ^'Classes'
)
public addNewItemTemplate = (
   addNewItemTemplate: subject classTemplateText
)
public addNewItemTemplate: src <String> = (
	(* Handle a user's request to create a new nested class by displaying a new class template
      based on src. *)
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [ prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: src
			colorizerBlock:
				[:text <String> :cm <CodeMirrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]]).
			]
)
acceptNewClassDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[:newClass <ClassDeclarationMirror> |
			|
			newSubject <ClassSubject> = ClassSubject onModel: newClass.
			|
			updateGUI: [
				prefixState removePrefix: aTemplate
				]
			]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
) : (
)
public class NestedClassGroupSubject onModel: m <MirrorGroup[ClassDeclarationMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (
(* Represents the collection of nested classes of a Newspeak class. Holds onto the mirror group for the classes. *)
) (
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
	|
	slot1
	slot2
	|
) ()'
)
public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment> = (
	^ide colorizer
		colorizeClassDeclaration: source
		fromClass: definingMixin declaration
		via: (colorizingBlockFor: cm)
)
public createPresenter = (
	^NestedClassGroupPresenter onSubject: self
)
elementSubjectClass ^ <ClassSubject class> = (
	^ClassSubject
)
public isKindOfNestedClassGroupSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfNestedClassGroupSubject
)
public addClassFromDefinition: source <String> ifSuccess: successBlock <[:ClassDeclarationMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <ClassDeclarationBuilder> newMirror <ClassDeclarationMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder nestedClasses addFromSource: source.
	ide installFromBuilders: {builder declaration}.
	newMirror:: definingMixin nestedClasses findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public deleteClassWithSubject: classSubject <ClassSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder nestedClasses removeMirrorNamed: classSubject name.
	ide installFromBuilders: {builder declaration}
)
) : (
)
class ObjectPresenter onSubject: s = ProgrammingPresenter onSubject: s (
	|
	public selfCaption ::= 'self'.
	|
) (
captionBar: body = (
	^(padded: body with: {5. 5. styleHeaderPadRight. 5}) color: captionColor
)
classInfoLine = (
	^row: {
		(label: 'class')
			width: 0 elasticity: 1.
		(link: subject className action: [navigateToClass])
			width: 0 elasticity: detailAreaRatio.
	}
)
enclosingInfoLine = (
	^row: {
		(label: 'enclosingObject')
			width: 0 elasticity: 1.
		(link: subject enclosingObjectName action: [navigateToEnclosingObject])
			width: 0 elasticity: detailAreaRatio.
	}
)
public isKindOfObjectPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfObjectPresenter
)
navigateToClass = (
	enterSubject: subject classSubject.
)
navigateToEnclosingObject = (
	inspectObjectMirror: subject classMirror enclosingObject
)
navigateToSelf = (
	enterSubject: subject
)
respondToInspectMirror = (
	inspectObject: subject objectMirror.
)
public title = (
	^'Inspector on ', subject title
)
availableObjectViews  ^ <List[Presenter]> = (
(*
Return a list of presenters that are available for the object we are presenting.

We determine these by establishing what interfaces/protocols the object
supports, based on its classes' isKindOf selectors. These are computed by
the subject's kindOfSelectors method, and returned in priority order,
higher priority to subclasses.
A mixin might have multiple isKindOfX methods. The highest priority
within a mixin named M goes to isKindOfM. 

For a given isKindOf selector, the available presenter classes are given, in 
descending priority, in objectViews. We collect these, preserving
order, and eliminating duplicates. If there are none, BasicView is used.
We then instantiate these classes a and return.
*)
   | 
   (* The list of available viewers we'll return *)
   viewClasses <Set[Presenter class]> = List new.
   (* A set of viewers already in the result, so we avoid duplicates *)
   alreadySeen <Set[Presenter]> = Set new. 
   |
   subject kindOfSelectors do: [:sel <String> | 
       (objectViews at: sel ifAbsent: [{}]) do: [:v <Presenter> | 
       (alreadySeen includes: v) ifFalse: [viewClasses add: v. alreadySeen add: v]
       ]
   ].
   (* If no specialized views were set up, use the default *)
   viewClasses isEmpty ifTrue: [viewClasses add: BasicView].
   (* compute presenters for this object based on the identifed classes *)
   ^viewClasses collect: [:v <Presenter class> | v onSubject: subject]
)
objectDetails = (
	| views = availableObjectViews. currentView switchers |
	views size = 1 ifTrue: [^views first].
	currentView:: holder: ( 
      subject preferredViewName isNil 
        ifTrue: [
          subject  preferredViewName: views first title.
	  views first
          ] ifFalse: [views detect: [:v | v title = subject preferredViewName]]).
	switchers:: List new.
	views do:
		[:view |
		 switchers add: mediumBlank.
		 switchers add: ((link: '[', view title, ']' action: [subject preferredViewName: view title. currentView content: view]) color: actionLinkColor)].
	^column: {
		row: switchers.
		currentView.
	}
)
selfInfoLine = (
	^row: {
		(label: selfCaption weight: #bold) width: 0 elasticity: 1.
		(row: {
			(link: subject title action: [navigateToSelf]) compressibility: 1.
			filler compressibility: 0.
			mediumBlank.
            helpButton.
			dropDownMenu: [actionsMenu].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public definition = (
	^column: {
        helpSection.
		captionBar: (column: {
			selfInfoLine.
			enclosingInfoLine.
			classInfoLine.
			smallBlank.
			subject evaluator presenter
		}).
		objectDetails.
	}
)
helpText ^ <Fragment> = (
  ^textDisplay: 'This is an object presenter (aka  inspector). You can enter and evaluate Newspeak expressions in the editor pane below. They will be evaluated in the scope of the object being inspected. Shift-Return evaluates the currently selected text; if no text is selected, the current line (i.e., the line where the cursor is) is evaluated.
  
The results of evaluation are displayed below the editor pane. Each result is a link; clicking on it takes you an object inspector on the result.  You can clear the results list by pressing the clear button to its right.

Below the results list you will typically see the slots of the object listed; this the basic view of objects. Some objects, such as integers or strings, have customized views. An object can have multiple views (and you can define new views as well). If there are multiple views, tab links appear underneath the results list, and you can select between them.'
)
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Mirror'. [respondToInspectMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
        {'Make InspectIt Button'. [subject evaluator presenter respondToMakeButton]}.
	}
)
) : (
)
public class ObjectSubject onModel: m <ObjectMirror> evaluator: e <EvaluationViewState> = ProgrammingSubject onModel: m (
  | 
  public evaluator <EvaluatorSubject> = EvaluatorSubject onModel: e. 
  slotMap <Map[Symbol, SlotSubject]> ::= Map new.
  public preferredViewName <String>
  |
) (
public = another <Object> ^<Boolean> = (
	^(another isKindOfObjectSubject) and:
		[objectMirror = another objectMirror]
)
public classMirror ^<ClassMirror> = (
	^model getClass
)
public className ^<String> = (
	^classMirror mixin name
)
public classSubject = (
	^ClassSubject onModel: classMirror mixin declaration
)
computeArraySlots = (
  | 
  array = objectMirror reflectee.
  variableLengthSlots = Array new: array size.
  newMap <Map[Symbol, SlotSubject]> = Map new.
  |
  1 to: array size do: [:index | | slot |
	      slot:: arraySlotSubjectFor: index value: (ObjectMirror reflecting: (array at: index)).
	      newMap at: slot name put: slot.
		variableLengthSlots at: index put: slot
		].
				
  slotMap:: newMap.
  ^variableLengthSlots
)
computeSlots = (
  | 
  newMap <Map[Symbol, SlotSubject]> = Map new.
  slotList<List[SlotSubject]> =   classMirror slots collect: [:slot <SlotDeclarationMirror> |  
	newMap at: slot name put: (slotSubjectFor: slot)
	].
  |
  slotMap:: newMap.
  ^slotList
)
public createPresenter = (
	^ObjectPresenter onSubject: self
)
public enclosingObjectName = (
	^classMirror enclosingObject reflectee printString
)
public evaluate: expression <String> ^<ThreadMirror> = (
	(* The IDE provides ambient access to the platform object during development. *)
	| scope <Map[Symbol, ObjectMirror]> = Map new. |
	scope at: #_ put: (ObjectMirror reflecting: cachedPlatform).
	^objectMirror evaluate: expression with: scope
)
public hash ^<Integer> = (
	^self class hash bitXor: objectMirror hash
)
public isKindOfObjectSubject = (
  ^true
)
public isModelKindOfArray ^<Boolean> = (
	^classMirror = (ClassMirror reflecting: Array)
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfObjectSubject
)
public objectMirror ^<ObjectMIrror> = (
	^model
)
public slots ^ <Sequence[SlotSubject]> = (
	(* Arrays have slots that aren't defined by their class. *)
	(* :todo: Push this down to `ObjectMirror slots` because which classes this applies to is implementation specific. *)
	isModelKindOfArray ifTrue:
		[^computeArraySlots].
      ^computeSlots.
)
public title = (
	^objectMirror reflectee printString
)
slotSubjectForKey: k <Object> withValue: v <Object> ^ <SlotSubject> = (
  | 
  name = 'at: ', k printString.
  val <ObjectMirror> = ObjectMirror reflecting: v. 
  entry <SlotSubject> ::= slotMap at: name ifAbsentPut: [
    SlotSubject name: name value: val
    ].
  |
  val = entry objectMirror ifFalse: [
    entry:: slotMap at: name put: (SlotSubject name: name value: val)
    ].
  ^entry
)
slotSubjectFor: slot <SlotDeclarationMirror> ^ <SlotSubject> = (
  | 
  val <ObjectMirror> = objectMirror getSlot: slot name. 
  entry <SlotSubject> ::= slotMap at: slot name ifAbsent: [
    SlotSubject name: slot name value: val
    ].
  |
  val = entry objectMirror ifFalse: [
    entry:: SlotSubject name: slot name value: val
    ].
  ^entry
)
arraySlotSubjectFor: index <Integer> value: val <ObjectMirror> = (
  | 
  name = 'at:', index asString. 
  entry <SlotSubject> ::= slotMap at: name ifAbsent: [
    SlotSubject name: name value: val
    ].
  |
  val = entry objectMirror ifFalse: [
    entry:: SlotSubject name: name value: val
    ].
  ^entry
)
public keysAndValues ^<Collection[SlotSubject]> = (
	| result |
	result:: List new: objectMirror reflectee size.
	objectMirror reflectee keysAndValuesDo:
		[:key :value | result add:
			(slotSubjectForKey: key printString
				withValue: value)].	
	^result
)
allMixinsOf: c <ClassMirror> ^ <List[MixinMirror]> = (
  (* Return mirrors on all mixins of c, in superclass chain order,  subclasses first *)
  c isNil ifTrue: [^List new].
  ^(allMixinsOf: c superclass) addFirst: c mixin; yourself
)
kindOfSelectorsForMixin: mixinMirror <MixinMirror> ^ <List[String]> = (
(* Get the isKindOf selectors of mixinMirror. If there are several, make sure that one specific to the mixin,
    if defined,  is placed first in the result.
*)
  | 
  result = (mixinMirror methods select: [:m <MethodMirror> |
      (1 = (m name indexOf: 'isKindOf'))
    ]) collect: [:m <MethodMirror> | m name].
    mostSpecific = 'isKindOf', mixinMirror name.
 |
 result remove: mostSpecific ifAbsent: [].
 result addFirst: mostSpecific.
 ^result   
)
public kindOfSelectors  ^ <List[String]> = (
(*
  Produce a list of the isKindOf selectors of the class of the model's reflectee,
  in superclass chain order,  subclasses first. If any mixin in the chain has several,
  those are ordered among themselves by kindOfSelectorsForMixin.
*)
 | result <List[String]> = List new. |
 (allMixinsOf: classMirror) do: [:m <MixinMirror> |
        (kindOfSelectorsForMixin: m) do: [:s <String> | result add: s]
    ].
  ^result
)
) : (
public onModel: m  = (
  ^onModel: m evaluator: (EvaluationViewState onModel: m)
)
public onEvaluator: e <EvaluationViewState>  = (
  ^onModel: e mirror evaluator: e
)
)
public class ProgrammingPresenter onSubject: s <Subject> = Presenter onSubject: s (
(* Common superclass for presenters of programming constructs. *)
) (
actionLinkColor = (
	^Color black
)
addButtonWithAction: aBlock = (
	^imageButton: ide images addImage action: aBlock size: styleButtonSize
)
addButtonWithMenu: menu = (
	^dropDownMenu: menu image: ide images addImage
)
browseMixinMirror: mixin <MixinMirror> = (
	enterSubject:: ClassSubject onModel: mixin declaration.
)
browseSelector: selector = (
	enterSubject: (SelectorSubject onModel: selector)
)
collapseButtonWithAction: aBlock = (
	^imageButton: ide images collapseImage action: aBlock size: styleButtonSize
)
expandButtonWithAction: aBlock = (
	^imageButton: ide images expandImage action: aBlock size: styleButtonSize
)
iconForAccessModifier: am = (
	#private = am ifTrue: [^ide images privateAccessImage].
	#protected = am ifTrue: [^ide images protectedAccessImage].
	^ide images publicAccessImage
)
indentedBlock: body = (
	^column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		}
)
inspectObject: object <Object> = (
	enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: object).
)
inspectObjectMirror: object <ObjectMirror> = (
	enterSubject:: ObjectSubject onModel: object.
)
itemReferencesButtonWithAction: aBlock = (
	^imageButton: ide images itemReferencesImage action: aBlock size: styleButtonSize
)
saveButtonWithAction: aBlock = (
	^imageButton: ide images downloadImage action: aBlock size: styleButtonSize
)
defaultBlank = (
	^blank: 3
)
largeBlank = (
	^blank: 20
)
majorHeadingBlock: body = (
	^(padded: body with: {10. 10. styleHeaderPadRight. 10.})
	color: majorHeadingColor
)
majorHeadingColor = (
	(* This color is used for major definitions such as class headings. *)
	^Gradient
		from: (Color h: 240 s: 0.05 v: 0.92)
		to: (Color h: 240 s: 0.05 v: 0.86)
)
minorHeadingBlock: body = (
	^(padded: body with: {10. 5. styleHeaderPadRight. 5.})
		color: minorHeadingColor
)
minorHeadingColor = (
	^Gradient
		from: (Color h: 240 s: 0.02 v: 0.94)
		to: (Color h: 240 s: 0.02 v: 0.9)
)
public objectSubjectFor: anObject = (
	^objectSubjectForMirror: (ObjectMirror reflecting: anObject)
)
objectSubjectForMirror: objectMirror <ObjectMirror> = (
	^ObjectSubject onModel: objectMirror
)
refreshButton = (
	^imageButton: ide images refreshImage action: [shell refresh] size: styleButtonSize
)
respondToInspectPresenter = (
	inspectObject: self.
)
secondaryTextColor ^ <Color> = (
	^Color gray: 0.6
)
tertiaryTextColor = (
	^Color gray: 0.8
)
linkToBrowseSelector: selector = (    
    ^row: {
        defaultBlank.
	    link: selector action: [browseSelector: selector]
    }
)
linkToBrowseNamespace: ns key: key = (
	^row: {
        defaultBlank.
		image: ide images classPresenterIcon size: styleButtonSize.
		defaultBlank.
		link: key
		action: [enterSubject:: NamespaceSubject onModel: ns key: key]}.
)
linkToBrowseClass: aClass = (
    ^row: {
        defaultBlank.
	    link: aClass name action: [browseClass: aClass]
    }
)
browseClass: klass <Behavior | ClassDeclarationMirror> = (
  | decl <ClassDeclarationMirror> = klass isKindOfClassDeclarationMirror ifTrue: [klass] ifFalse: [(ClassMirror reflecting: klass) mixin declaration]. |
	enterSubject:: ClassSubject onModel: decl.
)
helpButton = (
	^imageButton: ide images helpImage 
				  action: [updateGUI: [subject helpActive: true]] 
				  size: styleButtonSize
)
closeHelpButton = (
	 ^imageButton: ide images clearImage 
	 			   action: [updateGUI: [subject helpActive: false]] 
	  			   size: styleButtonSize
)
helpText ^ <Fragment> = (
  ^textDisplay: 'No help text defined for this presenter. Sorry.'
)
helpSection = (
  ^subject helpActive ifTrue: [
	column: {
		row: {
		      filler.
              closeHelpButton.
		}.
	   helpText.
	}
	] ifFalse: [nothing]
)
) : (
)
public class SelectorPresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
definition = (
^column: {
		implementorsPart.
		sendersPart
	}
)
implementorsPart = (
	^partNamed: 'implementors' model: subject implementorSubjects
)
public isKindOfSelectorPresenter ^ <Boolean> = (
  ^true
)
isMyKind: other <Subject> ^ <Boolean> = (
  ^other isKindOfSelectorPresenter
)
partNamed: t <String> model: m ^ <Fragment> = (
	^column: {
		majorHeadingBlock: (
				row: {
					label: subject selector.
					smallBlank.
					label: t.
				}).
		mediumBlank.
		row: {
				mediumBlank.
				elastic: (AssortedMethodsSubject onModel: m) presenter.
			}.
		mediumBlank.
		}
	)
sendersPart = (
	^partNamed: 'senders' model: subject senderSubjects
	)
) : (
)
public class SelectorSubject onModel: m = Subject onModel: m asSymbol (
(* Holds onto a selector (a Symbol) and retrieves its senders and implementors. *)
) (
public createPresenter = (
	^SelectorPresenter onSubject: self
)
public implementorSubjects ^ <Collection[MethodSubject | ClassFactorySubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^implementors collect: [:each <MethodMirror | ClassDeclarationMirror> |
			each isKindOfMethodMirror ifTrue: [MethodSubject onModel: each] 
				ifFalse: [ClassFactorySubject onModel: each]
			]
)
implementors ^ <List[MethodMirror | ClassDeclarationMirror]> = (
	(* Answer a collection of implementors of our selector (as MethodReferences). *)
  	| results <List[MethodMirror | ClassDeclarationMirror]> = List new. |
	systemScope implementorsOf: selector do: [:mirror <MethodMirror | ClassDeclarationMirror>  | 
		results add: mirror
		].
	^results
)
public isKindOfSelectorSubject ^ <Boolean> = (
  ^true
)
isMyKind: other <Subject> ^ <Boolean> = (
  ^other isKindOfSelectorSubject
)
public selector = (
	^model
)
public senderSubjects ^ <Collection[MethodSubject | ClassFactorySubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^senders collect: [:each <MethodMirror | ClassDeclarationMirror> |
		each isKindOfMethodMirror ifTrue: [MethodSubject onModel: each] 
			ifFalse: [ClassFactorySubject onModel: each]
			]
)
senders ^ <List[MethodMirror | ClassDeclarationMirror]> = (
	(* Answer a collection of senders of our selector (as MethodReferences). *)
  	| results <List[MethodMirror | ClassDeclarationMirror]> = List new. |
	systemScope sendersOf: selector do: [:mirror <MethodMirror | ClassDeclarationMirror> | results add: mirror].
	^results
)
public title = (
	^selector printString
)
) : (
)
class SlotPresenter onSubject: s <SlotSubject> = ProgrammingPresenter onSubject: s (
) (
caption ^<Fragment> = (
	^row: {        
		(link: subject name action: [substance toggle])
			width: 0 elasticity: 1;
			color: actionLinkColor.
		smallBlank.
		(link: subject reflecteePrintString action: [inspectObjectMirror: subject objectMirror])
			width: 0 elasticity: detailAreaRatio.
	}
)
public definition ^<Fragment> = (
	^collapsed: [caption] expanded: [details]
)
details ^<Fragment> = (
	^subject objectSubject presenter selfCaption: subject name
)
public isKindOfSlotPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfSlotPresenter
)
) : (
)
public class SlotSubject name: n value: v = Subject onModel: v (
	|
	public name = n.
	public objectSubject <ObjectSubject> = ObjectSubject onModel: objectMirror.
	|
) (
public createPresenter = (
	^SlotPresenter onSubject: self
)
public hash ^ <Integer> = (
  ^model hash bitXor: name hash
)
public isKindOfSlotSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfSlotSubject
)
public objectMirror ^<ObjectMirror> = (
	^model
)
public reflecteePrintString = (
	^model reflectee printString
)
public = other <Object> ^ <Boolean> = (
  other isKindOfSlotSubject ifFalse: [^false].
  ^model = other model and: [name = other name].
)
) : (
)
class StringView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public definition = (
	| cm |
	cm:: codeMirror: subject objectMirror reflectee.
	cm readOnly: true.
	^column: {
		cm
	}
)
public isKindOfStringView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfStringView
)
) : (
)
public class EvaluatorPresenter onSubject: s <ObjectSubject | ActivationSubject> = ProgrammingPresenter onSubject: s (
| cm <CodeMirrorFragment> |
) (
deadChangeResponse = (
    ^[:editor <CodeMirrorFragment>  | 
        | src <String> =  editor textBeingAccepted. |
        ide colorizer colorizeDoIt: src fromClass: nil via: (colorizingBlockFor: editor).
        editor isInEditState: true.
        editor editor focus.
    ].
)
linkForCompileError: error <Exception> = (
	^column: {
		(link: error printString action:
			[inspectObjectMirror: (ObjectMirror reflecting: error)])
				color: (Color r: 1 g: 0 b: 0).
	}
)
linkForError: thread <ThreadMirror> = (
	^column: {
		(link: thread result reflectee printString action:
			[enterSubject:: ide debugging ThreadSubject onModel: thread])
				color: (Color r: 1 g: 0 b: 0).
	}
)
linkForEvaluation: r ^ <Fragment> = (
  r isKindOfError ifTrue: [:e | ^linkForCompileError: e].
  r isFulfilled ifTrue: [^linkForResult: r].
  r isBroken ifTrue: [^linkForError: r]. 
 'result is neither error nor fulfilled nor broken!' out.
)
linkForResult: r ^ <Fragment> = (
	^column: {
		(link: r result reflectee printString action:
			[enterSubject:: ObjectSubject onModel: r result]).
	}
)
linkForThread: thread <ThreadMirror> ^ <Fragment> = (
	thread isFulfilled ifTrue: [^linkForResult: thread].
	thread isBroken ifTrue: [^linkForError: thread].
	^nothing
)
withoutNbsp: string = (
	('a' at: 1) isKindOfInteger
		ifTrue:
			[ | bytes = ByteArray withAll: string. |
			1 to: bytes size do: [:index | (bytes at: index) = 160 ifTrue: [bytes at: index put: 32]].
			^bytes asString]
		ifFalse:
			[ | nonbreakingSpace = String fromRune: 160.
			space = String fromRune: 32. |
			^string replaceAll: nonbreakingSpace with: space]
)
public isKindOfEvaluatorPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfEvaluatorPresenter
)
definition = (
  ^definitionForEvaluator
)
changeResponse = (
  ^subject isLive ifTrue: [liveChangeResponse] ifFalse: [deadChangeResponse]
)
clearResultsButton ^ <Fragment> = (
    ^imageButton: ide images clearImage 
            action: [updateGUI: [subject clear]] 
            size: styleButtonSize
)
results ^ <List[Fragment]> = (
    ^subject results collect: [:r | 
        r isKindOfThreadMirror 
            ifTrue: [linkForThread: r] 
            ifFalse: [linkForCompileError: r]
        ]
)
liveChangeResponse = (
  ^[:editor <CodeMirrorFragment>  | | src <String> =  editor textBeingAccepted. |
	updateGUI: [
		subject evaluateLive: (withoutNbsp: src).
		ide colorizer colorizeDoIt: src fromClass: nil via: (colorizingBlockFor: editor).
		editor isInEditState: true.
    ].
	editor editor focus.
   ].
)
definitionForEvaluator = (
    | items <List[Fragment]> = results. |
	^column: {
		editorDefinition.
        row: {
            (column: items) elasticity: 1.
            items isEmpty
                ifTrue: [smallBlank]
                ifFalse: [clearResultsButton].
        }.		
	}
)
editorDefinition ^ <CodeMirrorFragment> = (
	| initialSource |
	initialSource:: subject initialSource.
	cm:: (codeMirror: initialSource) 
        changeResponse: changeResponse;
        evaluateResponse: evaluateResponse;
		useEditControls: false.

	(* ide colorizer colorizeDoIt: initialSource fromClass: nil via: (colorizingBlockFor: cm).*)
	^cm
)
evaluateResponse ^ <[:CodeMirrorFragment]> = (
    ^[:ed <CodeMirrorFragment>  | 
        | src <String> ::=  ed editor getSelection. |
        src isEmpty ifTrue: [
            src:: ed currentLine.
        ].
        src isEmpty ifFalse: [
            updateGUI: [ 
                subject evaluate: (withoutNbsp: src).                 
            ].
            ed editor focus.
        ].
    ].
)
public respondToMakeButton = (
        | src <String> ::=  cm editor getSelection. |
        src isEmpty ifTrue: [
            |
            line = cm currentLine.
            lineNumber = cm currentLineNumber.
            start = JSObject new.
            end = JSObject new.
            |            
            src:: line.
            start 
                at: 'line' put: lineNumber;
                at: 'ch' put: 0.
            end 
                at: 'line' put: lineNumber;
                at: 'ch' put: src size.
                
            cm editor setSelection: start end: end.
        ].
        src isEmpty ifFalse: [
            | 
            button <ButtonFragment> = button: src action: [ 
               updateGUI: [subject evaluate: (withoutNbsp: src)]].
            |
            cm replace: button.         
            cm editor focus.
        ].
)
) : (
)
public class SearchResultsSubject onModel: searchTerm <String> = Subject onModel: searchTerm (
	|
	includeSynthetics <Boolean> = (searchTerm indexOf: "`") isNil not.
	public classMatches <Array[ClassDeclarationMirror]>
	public selectorMatches <Array[Symbol]>
	public namespaceMatches <Array[{String. Namespace}]>
	public searchSuggestions <List[Symbol]>
	|    
    findClassMatches.
    findSelectorMatches.
    findNamespaceMatches.
    createSuggestions.
) (
public createPresenter = (
	^SearchResultsPresenter onSubject: self
)
public title = (
	^'Search for "', model, '"'
)
properlySorted: selectors <Collection[String]> = (
	| lower <List[String]>  upper <List[String]> |
	lower:: List new: selectors size.
	upper:: List new: selectors size // 2.
	selectors do:
		[:each <String> |
		each first isUppercase
			ifTrue: [upper add: each ]
			ifFalse: [lower add: each]].
      lower sort:  [:a :b | a key < b key].
      upper sort:  [:a :b | a key < b key].
	^lower asArray, upper 
)
public isKindOfSearchResultsSubject ^ <Boolean> = (
  ^true
)
isMyKind:  s <Subject> ^ <Boolean> = (
  ^s isKindOfSearchResultsSubjecr
)
createSuggestions = (
	| foundNoResults <Boolean> names <Set[String]> |

	foundNoResults:: true.
	classMatches isEmpty ifFalse: [foundNoResults:: false].
	selectorMatches isEmpty ifFalse: [foundNoResults:: false].
	namespaceMatches isEmpty ifFalse: [foundNoResults:: false].
	foundNoResults ifFalse: [searchSuggestions:: Set new. ^self].
    searchSuggestions:: Set new. ^self (* hack *)
	(*names:: Set new: 200.
	systemScope allClassesDo: [:each <ClassDeclarationMirror> | 
      names add: (each simpleName)
      ].
	searchSuggestions:: (model correctAgainst: names).*)
)
findSelectorMatches = (
	| collected <Set[String]> patterns <Array[String]> |
	collected:: Set new: 20.
    patterns:: searchPatterns. (* compute once *)
    systemScope allSelectorsDo: [:sel <String> |
	  patterns do:
	    [:each <String> |
		  (pattern: each match: sel) ifTrue: [collected add: sel].
        ].
    ].
	includeSynthetics ifFalse:
		[collected removeAllSuchThat: [:each | (each indexOf: "`") ~= 0].
		collected removeAllSuchThat: [:each | (each indexOf: " ") ~= 0]].
	selectorMatches:: (*properlySorted:*) collected asArray.
)
findNamespaceMatches = (
	| 
    collected <Set[Association[String, Namespace]]> = Set new: 20.
    patterns <Array[String]> = searchPatterns.
    root = ide namespacing Root. 
    |
    addMatchesOfPatterns: patterns inNamespace: root to: collected.
	namespaceMatches:: collected (*sort: [:a :b | a first < b first]*) asArray.
)
addMatchesOfPatterns: ps <Array[String]> inNamespace: ns <Namespace> to: collected <Set[Association[String, Namespace]]> = (
	ns keysAndValuesDo:
		[:k :v |
        v isKindOfNamespace ifTrue: [
          addMatchesOfPatterns: ps inNamespace: v to: collected.
		  ps do:
			[:pattern <String> | 
              (pattern: pattern match: k) ifTrue:
				[collected add: {k. v}]]]].
)
searchPatterns ^ <Array[String]> = (
	(* Produce a collection of the specific search pattern to use. The model is the raw input provided by the user and may include multiple patterns. *)
	| parts <Array[String]> |
	parts:: {model} (*findTokens: ';' - forget about multiple patterns for now*).
	parts:: parts collect: [:each <String> | each withBlanksTrimmed].
	parts:: parts select: [:each <String> | each isEmpty not].
	(*parts:: parts collect:
		[:each <String> |
		((each indexOf: "*") ~= 0 or: [(each indexOf: "#") ~= 0])
			ifTrue: [each]
			ifFalse: [(pattern: '"*"' match: each)
					ifTrue: [each copyFrom: 2 to: each size - 1]
					ifFalse: ['*', each, '*']]].*)
	^parts
)
findWildcardsIn: p <String> ^ <List[Integer]> = (
(* Return an ordered list of indices in p where the wildcard indicator, *, appears.*)
  | index <Integer> ::= 1. wildcardIndices = List new. nextIndex |
  p isEmpty ifTrue: [^wildcardIndices].
  [index <= p size] whileTrue: [
     (* if not found, we get 0 *)
     nextIndex:: p indexOf: '*' startingAt: index. 
     (* If no wildcard found, set index so we exist the loop; otherwise, add the position we found
         (nextIndex) and increment index so we continue looking at the rest the the pattern p *)
     index:: nextIndex = 0 ifFalse: [wildcardIndices add: nextIndex. nextIndex + 1] ifTrue:  [p size  + 1].
  ].
  ^wildcardIndices.
)
prepareSegments: p <String> ^ <List[Integer]> = (
(* Return a list of segment markers in p, i.e., indices that immediately precede or follow
    wildcard-free substrings p. This amounts to the position of wildcards,
    plus markers for imaginary wildcards before and after p.
*)
| wildcardIndices <List[Integer]> = findWildcardsIn: p. |
  wildcardIndices isEmpty ifTrue: [^List withAll: {0.  p size + 1}]. (* no wildcards found *)
  wildcardIndices first = 1 ifFalse: [wildcardIndices addFirst: 0].
  wildcardIndices last = p size ifFalse: [wildcardIndices add: p size  + 1].
  ^wildcardIndices
)
findClassMatches = (
	| collected <Set[ClassDeclarationMirror]> patterns <Array[String]> |
	collected:: Set new: 20.
	patterns:: searchPatterns. (* compute once *)
	systemScope allClassesDo:
		[:cls <ClassDeclarationMirror> |
		patterns do:
			[:pattern | (pattern: pattern match: cls simpleName) ifTrue: [collected add: cls]]].
	classMatches:: (collected (*sort:
		[:a :b | a simpleName < b simpleName]*)) asArray
)
pattern: p <String> match: s <String>  ^ <Boolean> = (
  | 
  index <Integer> ::= 1.
  nextIndex 
  segmentMarkers = prepareSegments: p. 
  segments <List[String]> ::= List new.
  isFirst <Boolean> ::= true.
  res
  |
  (* collect the wild-card free strings - those prior to, between, or after wildcards *)
  segmentMarkers reduce: [:i <Integer> :j <Integer> |
     segments add: (p copyStringFrom: i + 1 to: j - 1).
     j
  ].
  (* eliminate effects of adjacent wildcards *)
  segments:: segments select: [:seg | seg isEmpty not]. 
  segments do: [:seg <String> |
    nextIndex:: s indexOf: seg startingAt: index.
    nextIndex = 0 ifTrue: [^false].
    isFirst ifTrue: [
      isFirst:: false.
      (*unless there's a wildcard at the start of the pattern, 
      the first segment needs to start at the beginning of s *)      
      (nextIndex = 1 or: [segmentMarkers first = 1]) ifFalse: [^false] 
      ].
    index:: nextIndex + seg size.
  ].
(* If the last segment doesn't extend to the end of s, the pattern must end with a wildcard *)
  ^index > s size or: [segmentMarkers last = p size].
)
) : (
)
class SearchResultsPresenter onSubject:s = ProgrammingPresenter onSubject: s (
) (
namespacesSection = (
	^subject namespaceMatches isEmpty
		ifTrue: [nothing]
		ifFalse: [sectionWithHeader: 'Namespaces' andContents: namespaceSearchResults].
)
searchSuggestions = (
	^incrementalList: [:s |
		subject searchSuggestions do: [:suggestion |
			s nextPut:
				(link: suggestion
				action: [ enterSubject: (SearchResultsSubject onModel: suggestion)])]].
)
selectorSearchResults  ^ <Array[Fragment]> = (
	^subject selectorMatches collect: [:each <Symbol> |
				  collapsed: (linkToBrowseSelector: each)
				  expanded: [SelectorPresenter onSubject: (SelectorSubject onModel: each)]
                ]
)
isMyKind:  f <Fragment> ^ <Boolean> = (
  ^f isKindOfSearchResultsPresenter
)
public isKindOfSearchResultsPresenter ^ <Boolean> = (
  ^true
)
classesSection = (
	^subject classMatches isEmpty
		ifTrue: [nothing]
		ifFalse: [sectionWithHeader: 'Classes' andContents: classSearchResults]
)
selectorsSection = (
	^subject selectorMatches isEmpty
		ifTrue: [nothing]
		ifFalse: [sectionWithHeader: 'Selectors' andContents: selectorSearchResults]
)
searchResultsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}
)
sectionWithHeader: theHeader andContents: theContents = (
^ column: {minorHeadingBlock: (label: theHeader). indentedBlock: (column: theContents). }
)
classSearchResults ^ <Array[Fragment]> = (
^subject classMatches collect:
			[:each <ClassDeclarationMirror> | 
				collapsed: (linkToBrowseClass: each)
				expanded: [(ClassSubject onModel: each) presenter]
            ]
)
namespaceSearchResults  ^ <Array[Fragment]> = (
	^subject namespaceMatches collect: [:assoc <{String. Namespace}> |
			  linkToBrowseNamespace: assoc last key: assoc first
            ]
)
definition = (
	^column: {
        row: {filler. dropDownMenu: [searchResultsMenu]}.
		( deferred: [searchFeedback]).
		( initially: (label: 'Searching namespaces') deferred: [namespacesSection] ).
        ( initially: (label: 'Searching classes') deferred: [classesSection] ).
		( initially: (label: 'Searching selectors') deferred: [selectorsSection] ).
		}
)
searchFeedback = (
 subject searchSuggestions isEmpty
	ifTrue: [^ nothing]
	ifFalse: [
		^sectionWithHeader: 'Did you mean?' andContents: searchSuggestions.
	].
)
) : (
)
public class EvaluatorSubject onModel: e <EvaluationViewState> = Subject onModel: e  (
  | initialSource_slot  <String> |
) (
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfEvaluatorSubject
)
public isKindOfEvaluatorSubject ^ <Boolean> = (
  ^true
)
public results  ^  <List[ThreadMirror]> = (
  ^model results
)
public evaluate: e <String> ^ <ThreadMirror>  = (
  ^model evaluate: e
)
public evaluateLive: e <String> ^ <ThreadMirror>  = (
  ^model evaluateLive: e
)
public clear = (
  model clear
)
public isLive ^ <Boolean> = (
  ^model isLive
)
public isLive: b <Boolean> = (
  ^model isLive: b
)
public createPresenter ^ <EvaluatorPresenter> = (
  ^EvaluatorPresenter onSubject: self
)
public initialSource ^ <String> = (
  initialSource_slot isNil ifTrue: [^''].
  ^initialSource_slot
)
public initialSource: s  <String> = (
  initialSource_slot:: s
)
) : (
)
public class IDEWindow into: b openSubject: s <Subject> = Window into: b openSubject: s (
) (
class ToolbarPresenter = super ToolbarPresenter (
  | textView <SearchFieldFragment> |
) (
find = (
  find: textView textBeingAccepted
)
find: s <String> = (
  enterSubject: (SearchResultsSubject onModel: s)
)
searchField ^ <Fragment> = (
    textView:: SearchFieldFragment new.
    textView acceptResponse: [:editor | find: editor textBeingAccepted].
    ^textView
)
saveAll = (
    ^imageButton: ide images saveImage action: [saveSources] size: styleButtonSize
)
toolbarItems ^ <Array[Fragment]>  = (
 ^super toolbarItems, {saveAll. smallBlank. searchField}
)
) : (
)
) : (
public openSubject: s = (
	^into: body openSubject: s
)
)
class SetView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public title ^ <String> = (
  ^'Set'
)
public isKindOfSetView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfSetView
)
public definition = (
	^column: (
         (subject objectMirror reflectee collect: [:e <Object> | 
           link: e printString action: [enterSubject: (ObjectSubject onModel: (ObjectMirror reflecting: e))]]) 
         asArray
         )
)
) : (
)
class ImageView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public isKindOfImageView ^ <Boolean> = (
  ^true
)
isMyKind: other ^ <Boolean> = (
  ^other isKindOfImageView
)
public definition ^ <Fragment> = (
  ^image: subject model reflectee size: styleButtonSize
)
) : (
)
public class Utilities = (
) (
) : (
public lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (
  ^outer Browsing lexicallyLessOrEqual: a than: b
)
public trimBlanksOff: s <String> ^ <String> = (
(* This doesn't work with every encoding *)
  | startIndex ::=1.  endIndex ::= size. |
  s isEmpty ifTrue: [^s].
  [(s at: startIndex) <= 32] whileTrue: [startIndex:: startIndex + 1].
  [(s at: endIndex) <= 32] whileTrue: [endIndex:: endIndex - 1].
  ^s copyFrom: startIndex to: endIndex
)
public uriForIconNamed: iconName <String> ^ <String> = (
  ^((ide namespacing manifest Icons) at: iconName) at: #src
)
)
class ProgrammingSubject onModel: m = Subject onModel: m (
	|
	public helpActive ::= false.
	|
) (
public isKindOfProgrammingSubject ^ <Boolean> = (
  ^true
)
) : (
)
colorizingBlockFor: cm <CodeMirrorFragment> = (
      cm resetStyles.
	^[:r | | style <Alien[JSObject]> = JSObject new. |
	style at: 'css' put: (cssFor: r kind).
	cm style: style from: r start to: r end]
)
crToLf: string = (
	('a' at: 1) isKindOfInteger
		ifTrue:
			[ | bytes = ByteArray withAll: string. |
			1 to: bytes size do: [:index | (bytes at: index) = 13 ifTrue: [bytes at: index put: 10]].
			^bytes asString]
		ifFalse:
			[ | cr = String fromRune: 13. lf = String fromRune: 10. |
			^string replaceAll: cr with: lf]
)
cssConversionTable ^ <Map[Symbol, String]> = (
(* compute a mapping from 'kinds', which are symbols denoting logical categories of code, to CSS properties used to colorize them*)
	|
	redBoldUnderlined <String> = 'color:Red; font-weight:bold; text-decoration: underline'.
	redUnderlined <String> = 'color:Red; text-decoration: underline'.
	orangeBoldUnderlined <String> = 'color:Orange; font-weight:bold; text-decoration: underline'.
	underlined <String> = 'text-decoration: underline'.
	gray <String> = 'color:Gray'.
	blue <String> = 'color:Blue'.
	grayBold <String> = 'color:Gray; font-weight:bold'.
	blackBold <String> = 'color:Black; font-weight:bold'.
	blueBold <String> = 'color:Blue; font-weight:bold'.
	magentaBold <String> = 'color:Magenta; font-weight:bold'.
	bold <String> = 'font-weight:bold'.
	|
      ^Map new
		at: #error put: redBoldUnderlined;
		at: #undefinedUnary put: redUnderlined;
		at: #undefinedBinary put: redUnderlined;
		at: #undefinedKeyword put: redUnderlined;
		at: #shadowingTempVar put: orangeBoldUnderlined;
		at: #obsoleteMessage put: orangeBoldUnderlined;
		at: #whitespaceWarning put: orangeBoldUnderlined;
		at: #incompleteUnary put: underlined;
		at: #incompleteBinary put: underlined;
		at: #incompleteKeyword put: underlined;
		at: #self put: gray;
		at: #super put: gray;
		at: #outer put: gray;
		at: #true put: gray;
		at: #false put: gray;
		at: #nil put: gray;
		at: #string put: gray;
		at: #symbol put: gray;
		at: #number put: gray;
		at: #character put: gray;
		at: #public put: gray;
		at: #protected put: gray;
		at: #private put: gray;
		at: #tempVar put: grayBold;
		at: #blockTempVar put: grayBold;
		at: #blockPatternArg put: grayBold;
		at: #patternArg put: grayBold;
		at: #slotDecl put: grayBold;
		at: #patternTempVar put: grayBold;
		at: #methodTempBar put: blackBold;
		at: #leftParenthesis put: blackBold;
		at: #rightParenthesis put: blackBold;
		at: #leftParenthesis3 put: blackBold;
		at: #rightParenthesis3 put: blackBold;
		at: #leftParenthesis6 put: blackBold;
		at: #rightParenthesis6 put: blackBold;
		at: #blockStart put: blackBold;
		at: #blockEnd put: blackBold;
		at: #blockStart3 put: blackBold;
		at: #blockEnd3 put: blackBold;
		at: #blockStart6 put: blackBold;
		at: #blockEnd6 put: blackBold;
		at: #leftBrace put: blackBold;
		at: #rightBrace put: blackBold;
		at: #leftBrace3 put: blackBold;
		at: #rightBrace3 put: blackBold;
		at: #leftBrace6 put: blackBold;
		at: #rightBrace6 put: blackBold;
		at: #messagePatternDecl put: bold;
		at: #class put: gray;
		at: #className put: bold;
		at: #comment put: blue;
		at: #type put: blueBold;
		at: #return put: blueBold;
		at: #leftParenthesis1 put: blueBold;
		at: #rightParenthesis1 put: blueBold;
		at: #leftParenthesis4 put: blueBold;
		at: #rightParenthesis4 put: blueBold;
		at: #leftParenthesis7 put: blueBold;
		at: #rightParenthesis7 put: blueBold;
		at: #blockStart1 put: blueBold;
		at: #blockEnd1 put: blueBold;
		at: #blockStart4 put: blueBold;
		at: #blockEnd4 put: blueBold;
		at: #blockStart7 put: blueBold;
		at: #blockEnd7 put: blueBold;
		at: #leftBrace1 put: blueBold;
		at: #rightBrace1 put: blueBold;
		at: #leftBrace4 put: blueBold;
		at: #rightBrace4 put: blueBold;
		at: #leftBrace7 put: blueBold;
		at: #rightBrace7 put: blueBold;
		at: #leftParenthesis2 put: magentaBold;
		at: #rightParenthesis2 put: magentaBold;
		at: #leftParenthesis5 put: magentaBold;
		at: #rightParenthesis5 put: magentaBold;
		at: #blockStart2 put: magentaBold;
		at: #blockEnd2 put: magentaBold;
		at: #blockStart5 put: magentaBold;
		at: #blockEnd5 put: magentaBold;
		at: #leftBrace2 put: magentaBold;
		at: #rightBrace2 put: magentaBold;
		at: #leftBrace5 put: magentaBold;
		at: #rightBrace5 put: magentaBold;
		yourself
)
cssFor: k <Symbol> ^ <String> = (
        ^cssConverter at: k ifAbsent: [ 'color:Black; font-family: serif']
)
public launch: s <Subject> inWindow: w <HopscotchShell> = (
  w openSubject: s (*(RegisterDebugger onSubject: s)*).
)
systemScope = (
	^ide namespacing systemScope.
)
public compilationUnitFromSource: src <String> ^ <String> = (
	^'Newspeak3', String newline,  'Root' printString, String newline, src
)
initializeObjectViews = (
  objectViews 
    at: 'isKindOfInteger' put: {IntegerView};
    at: 'isKindOfArray' put: {BasicView};
    at: 'isKindOfString' put: {StringView};
    at: 'isKindOfList' put: {KeysAndValuesView. BasicView};
    at: 'isKindOfMap' put: {KeysAndValuesView. BasicView};
    at: 'isKindOfSet' put: {SetView. BasicView};
    at: 'isKindOfImage' put: {ImageView. BasicView}
)
public addViews: vs <List[Presenter]>  for: interface <String> = (
  | key =  'isKindOf', interface. entry = objectViews at: key ifAbsent: []. |
  objectViews at: interface put: (entry isNil 
    ifTrue: [vs]
    ifFalse: [entry, vs ]
    ).
)
saveSources = (
   localStorage setItem:  #lastSaved to: (localStorage getItem: #backup).
   localStorage setItem: #lastSavedTime to: ide incrementedVersion.
)
deleteTopLevelClassNamed: cname <Symbol> = (
  | backup <Map[Symbol, Object] | Nil> |
  ide namespacing removeKey:  cname.
  backup:: ide json decode: ([localStorage getItem: 'backup'] on: Error do: [:e | ^self]).
  backup isNil ifTrue: [^self].
  backup removeKey: cname ifAbsent: [^self].
  localStorage setItem: 'backup' to: (ide json encode: backup)
)
lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (
    (* We should normalize the case, so upper case stuff does not appear first *)

	| length = a size min: b size. |
	('a' at: 1) isKindOfInteger ifTrue: 
		[1 to: length do:
			[:index |
			 (a at: index) < (b at: index) ifTrue: [^true].
			 (a at: index) > (b at: index) ifTrue: [^false]].
		^a size <= b size].

	1 to: length do:
		[:index |
		 (a runeAt: index) < (b runeAt: index) ifTrue: [^true].
		 (a runeAt: index) > (b runeAt: index) ifTrue: [^false]].
	^a size <= b size
)
) : (
)
