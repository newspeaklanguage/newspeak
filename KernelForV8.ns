Newspeak3
'NS2V8'
class KernelForV8 usingVmMirror: vmm = (
(*

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.
Copyright 2013 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
vmmirror = vmm.
public platform
|) (
public class Array uninstantiable = () (
'as yet unclassified'
public , otherSequence = (
	^js call: (js propertyOf: self at: (js literal: 'concat')) with: {otherSequence asArray}
)
public = other = (
	self == other ifTrue: [^true].
	other isArray ifFalse: [^false].
	self size = other size ifFalse: [^false].
	1 to: size do: [:index |
		(self at: index) = (other at: index) ifFalse: [^false]].
	^true
)
public asArray = (
	^self
)
public asOrderedCollection = (
	^platform collections OrderedCollection withAll: self
)
public at: index = (
	^js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1))
)
public at: index put: value = (
	^js assign: (js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1)))
	 toBe: value
)
public binarySearchFor: el between: start and: end toCompare: compare = (
	(* This does a binary search for the index such that if el was inserted before it
	  the receiver would remain sorted.  The receiver must be sorted relative to the
	  comparison block.  The comparison block should return true if the first block argument
	  cannot appear after the second block argument *)

	| low high |
	low:: start.
	high:: end.
	[ low <= high ]
		whileTrue:
				[	| mid |
					mid:: (low + high) // 2.
	  				(compare value: (self at: mid) value: el)
						ifTrue: [ low:: mid + 1 ]	
						ifFalse: [ high:: mid - 1 ].
				].
	^low
)
protected class = (
	^Array
)
public collect: block = (
	^js call: (js propertyOf: self at: (js literal: 'map')) with: {block}.
)
public copyFrom: start to: end = (
	^js call: (js propertyOf: self at: (js literal: 'slice')) with: {start - 1. end}
)
public copyWith: extraElement = (
	| newSize ::= self size + 1. a |
	a:: (Array new: newSize) replaceFrom: 1 to: self size with: self.
	a at: newSize put: extraElement.
	^a
)
public copyWithSize: s = (
	^(Array new: s) replaceFrom: 1 to: (s min: self size) with: self
)
public do: block = (
	js call: (js propertyOf: self at: (js literal: 'forEach')) with: {block}.
)
public do: block separatedBy: betweenBlock = (
	| firstTime ::= true. |

	self do: [:element |
		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].
		block value: element].
)
public doWithIndex: block = (
	1 to: size do: [:n | block value: (self at: n) value: n].
)
public first = (
	^self at: 1
)
public includes: element = (

	self do: [:each | each = element ifTrue: [^true]].
	^false
)
public inject: initialValue into: accumulator = (
	^js call: (js propertyOf: self at: (js literal: 'reduce')) with: {accumulator. initialValue}.
)
public isArray = (
	^true
)
public isCollection ^<Boolean> = (
	^true
)
public isEmpty = (
	^0 == size
)
public keysAndValuesDo: binaryBlock <[:Integer :E]> = (
	1 to: self size do: [:index | binaryBlock value: index value: (self at: index)]
)
public last = (
	^self at: self size
)
public printString = (
	| x ::= '{'. |
	#FLAG. (* This is not safe for arrays that contain themselves. *)
	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].
	^x , '}'
)
public replaceFrom: start to: stop with: replacement = (
	(* This destructively replaces elements from start to stop in the receiver. 
	Answer the receiver itself. Use copyReplaceFrom:to:with: for 
	insertion/deletion which may alter the size of the result. *)

	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)
public replaceFrom: start to: stop with: replacement startingAt: repStart = (
	(* This destructively replaces elements from start to stop in the receiver 
	starting at index, repStart, in the sequenceable collection, 
	replacementCollection. Answer the receiver. No range checks are 
	performed. *)

	| index repOff |
	repOff:: repStart - start.
	index:: start - 1.
	[(index:: index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)
public select: block = (
	^js call: (js propertyOf: self at: (js literal: 'filter')) with: {block}.
)
public size = (
	^js verbatim: 'this.length'
)
public sort: binaryBlock = (
	js
		call: (js propertyOf: self at: (js literal: 'sort'))
		with: {js functionOf: {'a'. 'b'} body: (js block: {
			js return: ((binaryBlock value: (js ident: 'a') value: (js ident: 'b'))
				ifTrue: [-1] ifFalse: [1])
		})}.
)
) : (
'as yet unclassified'
public new = (
	^js array: {}
)
public new: size = (
	^self new: size withAll: nil
)
public new: size withAll: initialElement = (
	|
	array = js new: (js ident: 'Array') with: {size}.
	i ::= 0.
	|	
	js 
		for: (js verbatim: '')
		while: (js operator: '<' with: i and: size) 
		step: (js postfixOperator: '++' on: i)
		do: (js block: {
			js assign: (js propertyOf: array at: i) toBe: initialElement}).
	^array
)
public with: element = (
	^{element}
)
)
public class Boolean uninstantiable = () (
'as yet unclassified'
public & other = (
	(* Evaluating conjunction. *)
	^js operator: '&&' with: self and: other
)
public ifFalse: else = (
	^js ternaryIf: self then: nil else: (js call: else with: {})
)
public ifFalse: else ifTrue: then = (
	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})
)
public ifTrue: onTrue = (
	^js ternaryIf: self then: (js call: onTrue with: {}) else: nil
)
public ifTrue: then ifFalse: else = (
	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})
)
public isBoolean = (
	^true
)
public not = (
	^js prefixOperator: '!' on: self.
)
public printString = (
	^self ifTrue: ['true'] ifFalse: ['false']
)
public value = (
	^self	
)
public | other = (
	(* Evaluating disjunction. *)
	^js operator: '||' with: self and: other
)
) : (
)
public class Class = (|
public superclass
public mixin
public enclosingObject (* Remove me *)
public enclosingObjects 
public name
|) (
'as yet unclassified'
public isBehavior = (
	^true
)
public isMeta = (
	^true
)
public mixinApply: newSuperclass = (
	^vmmirror 
		applyMixin: (js propertyOf: self mixin at: (js literal: 'runtimeMixin'))
		toSuperclass: newSuperclass
		withEnclosingObjects: self enclosingObjects
)
public simpleName = (
	^mixin name
)
) : (
)
public class Closure uninstantiable = () (
'as yet unclassified'
public cull: a1 = (
	^js call: (js ident: 'this') with: {a1}
)
public ensure: onUnwind = (
	| result |
	js try: (js block: {
		result:: self value.
	})
	catch: (js ident: 'e')
	with: (js block: {
		onUnwind value.
		js throw: (js ident: 'e').
	}).
	onUnwind value.
	^result
)
public isBlock = (
	^true
)
public numArgs ^<Integer> = (
	^js propertyOf: self at: (js literal: 'length')
)
public on: errorClass do: handler = (
	(* Perhaps we should match on mixin instead of class... *)
	| c |
	js try: (js block: {js return: self value})
	catch: (js ident: 'e')
	with: (js block: {
		js for: (c:: classOf: (js ident: 'e')) while: (js operator: '!==' with: c and: nil) step: (js verbatim: '') do: (js block: {
			js if: (js operator: '===' with: c and: errorClass)
			then: (js block: {js return: (handler value: (js ident: 'e'))}).
			c:: c superclass.
		}) .
		js throw: (js ident: 'e').
	})
)
public value = (
	^js call: (js ident: 'this') with: {}
)
public value: a1 = (
	^js call: (js ident: 'this') with: {a1}
)
public value: a1 value: a2 = (
	^js call: (js ident: 'this') with: {a1. a2}
)
public value: a1 value: a2 value: a3 = (
	^js call: (js ident: 'this') with: {a1. a2. a3}
)
public valueWithArguments: args = (
	^js call: (js propertyOf: (js ident: 'this') at: (js literal: 'apply')) with: {js ident: 'this'. args}
)
public whileFalse: aBlock = (
	[self value] whileFalse: [aBlock value].
	^nil
)
) : (
)
public class Exception description: d <String> = (| public description = d. |) (
'as yet unclassified'
public isError = (
	^true
)
public printString = (
	^description
)
public signal = (
	js verbatim: 'this.trace = new Error().stack'.
	js throw: self.
)
) : (
'as yet unclassified'
public signal: description = (
	^(self description: description) signal
)
)
public class Future computing: block <[E]> = (
(* The simplest possible future. It evalutes its closure in response to nearly every message. *)|
	private blockOrValue000 <[E] | E> ::= block.
	private state000 <Symbol> ::= #unresolved.
|) (
'as yet unclassified'
protected doesNotUnderstand: message = (
	^message sendTo: self resolve
)
public isFuture ^<Boolean> = (
	^true
)
resolve = (
	state000 = #resolving ifTrue: [
		Error signal: 'Divergent evaluation of ', blockOrValue000 printString].
	state000 = #unresolved ifTrue: [
		state000: #resolving.
		blockOrValue000: blockOrValue000 value.
		[blockOrValue000 isFuture] whileTrue:
			[blockOrValue000: blockOrValue000 resolve].
		state000: #resolved.
	].
	^blockOrValue000
)
public yourself = (
	(* See InstanceMixin>>apply:withName: *)
	^self resolve
)
) : (
)
public class Message mangledSelector: s arguments: a = (
(* FIXME: This factory should not be public. *)|
	public mangledSelector = s.
	public arguments = a.
|) (
'as yet unclassified'
public printString = (
	^'#',selector
)
public selector = (
	^vmmirror unmangleSelector: mangledSelector
)
public sendTo: receiver = (
	^js call: (js propertyOf: (js propertyOf: receiver at: mangledSelector) at: (js literal: 'apply')) with: {receiver. arguments}
)
) : (
'as yet unclassified'
mangle: selector = (
	^((('$', selector)
		replaceAll: $: with: $$) (* Keyword *)
		replaceAll: $` with: $$) (* Qualified *)
		replaceAll: $. with: $$ (* limit temp *)
)
public selector: selector = (
	^self mangledSelector: (mangle: selector) arguments: {}
)
public selector: selector arguments: arguments = (
	^self mangledSelector: (mangle: selector) arguments: arguments
)
)
public class MessageNotUnderstood receiver: r message: m = Error description: 'MessageNotUnderstood: ', (classOf: r) name, '>>', m selector (|
	public receiver = r.
	public message = m.
|) (
) : (
)
public class Metaclass = (
(* Describe the class in this comment. *)|
public superclass
public mixin
public enclosingObject
public name
public thisClass
|) (
'as yet unclassified'
public isBehavior = (
	^true
)
public isMeta = (
	^true
)
) : (
)
public class Mixin fromRuntimeMixin: rm = (js assign: (js propertyOf: self at: (js literal: 'runtimeMixin')) toBe: rm) (
'as yet unclassified'
public applyTo: superclass <Class> ^<Class> = (
	(* assert: [isTopLevel] message: 'Only top-level mixins may be applied directly' *)
	assert: [isMeta not] message: 'Only instance-side mixins may be applied directly'.
	^self applyTo: superclass withName: (superclass name, ' <: ', name)
)
public applyTo: superclass <Class> withName: name <String> ^<Class> = (
	^vmmirror 
		applyMixin: (js propertyOf: self at: (js literal: 'runtimeMixin'))
		toSuperclass: superclass
		withEnclosingObjects: {nil}
)
public isMeta ^<Boolean> = (
	^js operator: '===' with: (js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'meta')) and: (js ident: 'undefined')
)
public name ^<Symbol> = (
	^isMeta 
		ifTrue: [(js propertyOf: (js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'nonMeta')) at: (js literal: 'name')), ' class']
		ifFalse: [js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'name')].
)
public printString ^<String> = (
	^name, ' mixin'
)
) : (
)
public class Number uninstantiable = () (
'as yet unclassified'
public * other = (
	^js operator: '*' with: self and: other
)
public ** exponent = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'pow')) with: {self. exponent}
)
public + other = (
	^js operator: '+' with: self and: other
)
public - other = (
	^js operator: '-' with: self and: other
)
public / other = (
	^js operator: '/' with: self and: other
)
public // other = (
	^(self / other) floor
)
public < other = (
	^js operator: '<' with: self and: other
)
public << other = (
	^js operator: '<<' with: self and: other
)
public <= other = (
	^js operator: '<=' with: self and: other
)
public = other = (
	^js operator: '===' with: self and: other
)
public > other = (
	^js operator: '>' with: self and: other
)
public >= other = (
	^js operator: '>=' with: self and: other
)
public >> other = (
	^js operator: '>>' with: self and: other
)
public \\ other = (
	^self - (self // other * other)
)
public abs = (
	self >= 0 ifTrue: [^self] ifFalse: [^-1.0 * self]
)
public asFloat = (
	^self * 1.0
)
public asInteger = (
	^self truncated
)
public asString = (
	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}
)
public between: min and: max = (
	^self <= max and: [ self >= min ]
)
public bitAnd: other = (
	^js operator: '&' with: self and: other
)
public bitInvert = (
	^ -1 - self
)
public bitOr: other = (
	^js operator: '|' with: self and: other
)
public bitXor: other = (
	^js operator: '^' with: self and: other
)
public ceiling = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'ceil')) with: {self}
)
public cos = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'cos')) with: {self}
)
public exp = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'exp')) with: {self}
)
public floor = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'floor')) with: {self}
)
public hash = (
	^self rem: 16rFFFFFF
)
public isNumber = (
	^true
)
public ln = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'log')) with: {self}
)
public max: other = (
	^self > other ifTrue: [ self ] ifFalse: [ other ]
)
public min: other = (
	^self < other ifTrue: [ self ] ifFalse: [ other ]
)
public printString = (
	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}
)
public quo: other = (
	^(self / other) truncated
)
public rem: other = (
	^self - ((self quo: other) * other)
)
public sign = (
	self > 0 ifTrue: [^1].
	self < 0 ifTrue: [^-1].
	^0
)
public sin = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sin')) with: {self}
)
public sqrt = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sqrt')) with: {self}
)
public tan = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'tan')) with: {self}
)
public timesRepeat: block = (
	| i ::= 0. |	
	js 
		for: (js verbatim: '')
		while: (js operator: '<' with: i and: (js ident: 'this')) 
		step: (js postfixOperator: '++' on: i)
		do: (js block: {js call: block with: {}})
)
public to: stop = (
	^platform collections Interval from: self to: stop
)
public to: limit do: block = (
	| i ::= self. |	
	js 
		for: (js verbatim: '')
		while: (js operator: '<=' with: i and: limit) 
		step: (js postfixOperator: '++' on: i)
		do: (js block: {js call: block with: {i}})
)
public truncated = (
	(* ^self > 0 ifTrue: [self floor] ifFalse: [self ceiling] *)
	^js operator: '|' with: self and: (js literal: 0)
)
) : (
)
public class Object = ImplementationBase () (
'as yet unclassified'
public = other = (
	^js operator: '===' with: self and: other
)
public == other = (
	^js operator: '===' with: self and: other
)
Array = (
	^outer KernelForV8 Array
)
Character = (
	^outer KernelForV8 String
)
Error = (
	^outer KernelForV8 Error
)
Future = (
	^outer KernelForV8 Future
)
Object = (
	^outer KernelForV8 Object
)
String = (
	^outer KernelForV8 String
)
assert: condition <[Boolean]> message: message = (
	(* Raises an error with the given message if and only if condition evaluates to false. *)
	condition isBlock ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signal: 'Assertion failed: ', message]
)
protected class = (
	^js propertyOf: (js ident: 'this') at: (js literal: 'newspeakClass')
)
public clone = (
	| originalProto cloneConstructor newObject propNames |
	originalProto:: js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'getPrototypeOf')) with: {self}.
	cloneConstructor:: js functionOf: {} body: (js block: {}).
	js assign: (js propertyOf: cloneConstructor at: (js literal: 'prototype')) toBe: originalProto.
	newObject:: js new: cloneConstructor with: {}.
	propNames:: js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'getOwnPropertyNames')) with: {self}.
	js call: (js propertyOf: propNames at: (js literal: 'forEach')) with: {js functionOf: {'name'} body: (js block: {
		js assign: (js propertyOf: newObject at: (js ident: 'name'))
			toBe: (js propertyOf: self at: (js ident: 'name'))
	})}.
	^newObject
)
protected doesNotUnderstand: message = (
	((message selector startsWith: 'is') and: [message arguments size = 0])
		ifTrue: [^false].
	^(MessageNotUnderstood receiver: self message: message) signal
)
public hash = (
	^self identityHash
)
public identityHash = (
	(* It might be worth giving every object the hashCode field at instantiation to avoid map transitions. *)
	js verbatim: 'while(this.hashCode === 0) this.hashCode = Math.random() * 0x3FFFFFF | 0'.
	^js verbatim: 'this.hashCode'
)
public ifNil: nilBlock = (
	^self
)
public ifNil: nilBlock ifNotNil: notNilBlock = (
	^notNilBlock value: self
)
public ifNotNil: nonNilBlock = (
	^nonNilBlock value: self
)
public isAlien = (
	^false
)
public isBlock = (
	^false
)
public isExpat = (
	^false
)
public isFuture = (
	^false
)
public isNil = (
	^false
)
public notNil = (
	^true
)
public out = (
	print: self
)
public perform: selector withArguments: arguments = (
	^js call: (js propertyOf: (js propertyOf: self at: (vmmirror mangleSelector: selector))
			at: (js literal: 'apply')) 
	with: {self. arguments}
)
public print: obj = (
	js ternaryIf: ((js prefixOperator: 'typeof ' on: (js ident: 'console')) == 'undefined')
	then: (js call: (js ident: 'print') with: {obj printString})
	else: (js call: (js propertyOf: (js ident: 'console') at: (js literal: 'log')) with: {obj printString})
)
public printString = (
	^'instance of ', self class name
)
public yourself = (
	^self
)
public ~= other = (
	^(self = other) not
)
) : (
)
public class Stopwatch = (|
private cumulativeMillis ::= 0.
private startMillis
|) (
'as yet unclassified'
private currentMonotonicMillis = (
	^js verbatim: 'performance.now()'
)
public elapsedMicroseconds ^<Integer> = (
	^elapsedMilliseconds * 1000
)
public elapsedMilliseconds ^<Integer> = (
	nil = startMillis ifTrue: [^cumulativeMillis].
	^cumulativeMillis + (currentMonotonicMillis - startMillis)
)
public start = (
	nil = startMillis ifFalse: [^self (* Already running. *)].
	startMillis:: currentMonotonicMillis
)
public stop = (
	nil = startMillis ifTrue: [^self (* Already stopped. *)].
	cumulativeMillis:: cumulativeMillis + (currentMonotonicMillis - startMillis).
	startMicros:: nil.
)
) : (
)
public class String uninstantiable = () (
'as yet unclassified'
public , other = (
	^js call: (js propertyOf: self at: (js literal: 'concat')) with: {other}
)
public = other = (
	^js operator: '===' with: self and: other
)
public asNumber = (
	^js call: (js ident: 'parseInt') with: {self}
)
public asString = (
	^self
)
public asSymbol = (
	^self
)
public at: index = (
	^js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1))
)
public beginsWith: substring = (
	^js operator: '==' with: (js literal: 0) and: (js call: (js propertyOf: self at: (js literal: 'indexOf')) with: {substring})
)
protected class = (
	^String
)
public copyFrom: start to: end = (
	^js call: (js propertyOf: self at: (js literal: 'substring')) with: {start - 1. end}
)
public do: action = (
	|
	i ::= 0.
	len ::= js verbatim: 'this.length'.
	|
	js
		for: (js verbatim: '')
		while: (js operator: '<' with: i and: len)
		step: (js postfixOperator: '++' on: i)
		do: (js block: {
			js call: action with: {js propertyOf: self at: i}}).
)
public endsWith: substring = (
	^js call: (js propertyOf: self at: (js literal: 'endsWith')) with: {substring}
)
public first = (
	^self at: 1
)
public hash = (
	js var: 'l' value: (js propertyOf: (js ident: 'this') at: (js literal: 'length')).
	^js ternaryIf: (js operator: '==' with: (js ident: 'l') and: (js literal: 0))
		then: (js literal: 0)
		else: (js verbatim: '(l * 32 ^ this.charCodeAt(0)) * 32 ^ this.charCodeAt(l - 1)')
)
public identityHash = (
	^self hash
)
public includes: object = (
	self do: [:element | object = element ifTrue: [^true]].
	^false
)
public isString = (
	^true
)
public last = (
	^self at: self size
)
public printString = (
	^js verbatim: '"''"+this.toString()+"''"'
)
public replaceAll: substring with: newSubstring = (
	#BOGUS. (* Ought to be able to say this.replace(target, replacement, 'g'). *)
	js var: 'target' value: substring.
	js var: 'replacement' value: newSubstring.
	^js verbatim: 'this.replace(new RegExp(target.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement)'
)
public runeAt: index = (
	(* This is wrong for surrogate pairs. *)
	^js call: (js propertyOf: self at: (js literal: 'charCodeAt')) with: {index - 1}
)
public size = (
	^js verbatim: 'this.length'
)
public splitBy: str = (
	^js call: (js propertyOf: self at: (js literal: 'split')) with: {str}
)
public startsWith: substring = (
	^js call: (js propertyOf: self at: (js literal: 'startsWith')) with: {substring}
)
) : (
'as yet unclassified'
public cr = (
	^js verbatim: '"\r"'
)
public fromRune: rune = (
	^js call: (js propertyOf: (js ident: 'String') at: (js literal: 'fromCharCode')) with: {rune}
)
public fromRunes: runes = (
	^js call: (js propertyOf: (js propertyOf: (js ident: 'String') at: (js literal: 'fromCharCode')) at: (js literal: 'apply')) with: {js ident: 'null'. runes asArray}.
)
public lf = (
	^js verbatim: '"\n"'
)
public space = (
	^" "
)
public tab = (
	^js verbatim: '"\t"'
)
public withAll: characters = (
	^js call: (js propertyOf: characters asArray at: (js literal: 'join')) with: {js literal: ''}
)
)
public class UndefinedObject uninstantiable = () (
'as yet unclassified'
public ifNil: nilBlock = (
	^nilBlock value
)
public ifNil: nilBlock ifNotNil: notNilBlock = (
	^nilBlock value
)
public ifNotNil: notNilBlock = (
	^self
)
public isNil = (
	^true
)
public notNil = (
	^false
)
public printString = (
	^'nil'
)
) : (
)
'as yet unclassified'
public Error = (
	(* Squeak compatibility *)
	^Exception
)
public UnhandledError = (
	(* Squeak compatibility *)
	^Exception
)
augment: prototype withPropertiesOf: runtimeClass = (
	| keys = js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'keys')) with: {runtimeClass}. |
	js call: (js propertyOf: keys at: (js literal: 'forEach')) with: {js functionOf: {'key'} body: (js block: {
		js assign: (js propertyOf: prototype at: (js ident: 'key'))
			toBe: (js propertyOf: runtimeClass at: (js ident: 'key'))
	})}.
)
public augmentPrototypes = (
	js call: (js ident: 'installDnuHandlersOn') with: {js verbatim: 'Object.prototype'}.
	augment: (js verbatim: 'Array.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Array.prototype') withPropertiesOf: (js propertyOf: Array at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Boolean.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Boolean.prototype') withPropertiesOf: (js propertyOf: Boolean at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Function.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Function.prototype') withPropertiesOf: (js propertyOf: Closure at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Number.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Number.prototype') withPropertiesOf: (js propertyOf: Number at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'String.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'String.prototype') withPropertiesOf: (js propertyOf: String at: (js literal: 'runtimeClass')).
)
private classOf: object = (
	(js prefixOperator: 'typeof ' on: object) == 'string' ifTrue: [^String].
	(js prefixOperator: 'typeof ' on: object) == 'number' ifTrue: [^Number].
	(js prefixOperator: 'typeof ' on: object) == 'boolean' ifTrue: [^Boolean].
	(js prefixOperator: 'typeof ' on: object) == 'function' ifTrue: [^Closure].
	(js operator: 'instanceof' with: object and: (js ident: 'Array')) ifTrue: [^Array].
	^js propertyOf: object at: (js literal: 'newspeakClass')
)
) : (
)
