Newspeak3
'Samples'
class SimpleBrowsing usingPlatform: p ide: webIde = (
(* An IDE for Newspeak on the web.
    Copyright 2016-2017 Google Inc.
*)
|	(* imports *)
	StringBuilder = p kernel StringBuilder.
	Subject = p hopscotch core Subject.
	Presenter = p hopscotch core Presenter.
	TextEditorFragment = p hopscotch fragments TextEditorFragment.
	Color = p graphics Color.
	Gradient = p hopscotch Gradient.
	List = p collections List.
	Map = p collections Map.
	ClassMirror = p mirrors ClassMirror.
	ObjectMirror = p mirrors ObjectMirror.
	ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	JSObject = p js global at: 'Object'.
		(* module variables *)
	ide = webIde.
	detailAreaRatio = 1.6 asFloat.
	captionColor = Color h: 240 s: 0.05 asFloat v: 0.9 asFloat.
	cssConverter = cssConversionTable.
|
) (
public class BitOfWisdom text: s <String> actionLabel: l <String> actionBlock: b <[]> image: i = (|
	public text <String> = s.
	public image = i.
	public actionLabel <String> = l.
	public actionBlock <[]> = b.
|) (
) : (
public text: s <String> ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: nil
)
public text: s <String> actionLabel: l <String> actionBlock: b <[]> ^ <BitOfWisdom> = (
	^self
		text: s
		actionLabel: l
		actionBlock: b
		image: nil
)
public text: s image: i ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: i
)
)
class ClassCommentPresenter onSubject: s <ClassSubject> = ProgrammingPresenter onSubject: s (
|
  editor
  isEditing ::= false.
  showPartialIfLong ::= true.
  showingPartial
|
) (
= anotherPresenter = (
	^self == anotherPresenter
)
definition = (
	^holder:
		[isEditing
			ifTrue: [editorDefinition]
			ifFalse: [viewerDefinition]]
)
definitionText = (
	(* In this class, only used by the editor side of the presenter to get the text to show in the editor. *)

	^fullCommentText
)
editorDefinition = (
editor:: TextEditorFragment new.
editor
	text: definitionText;
	cancelResponse: [respondToCancel];
	acceptResponse: [respondToAccept];
	enterEditState.
^editor
)
enterEditState = (
	isEditing:: true.
	refresh
)
fullCommentText = (
	^subject classCommentText asString
)
hash = (
	^self identityHash
)
public leaveEditState = (
	isEditing:: false.
	refresh
)
maybePartialCommentText ^<String> = (
  ^fullCommentText size > 500 ifTrue: [
	showingPartial:: true.
	subject classCommentSummary
	] ifFalse: [
	showingPartial:: false.
	fullCommentText
	]
)
presentationDefinition = (
	| textToDisplay |
	textToDisplay:: retrieveComment.
	textToDisplay isEmpty ifTrue:
		[textToDisplay:: '(no comment)'].
	^column:
		{textDisplay: textToDisplay.
		showingPartial
			ifTrue: [(link: 'show full comment' action: [showFullComment])]
			ifFalse: [(link: 'hide full comment' action: [showLessComment])].
		}
)
respondToAccept = (
	subject classCommentText: editor textBeingAccepted. leaveEditState.
)
respondToCancel = (
	leaveEditState
)
respondToEdit = (
	enterEditState
)
retrieveComment ^<String> = (
	(* Get the text to display--either the whole thing or the first paragraph, depending on the text and the settings--and set the showingPartial slot accordingly. *)

	^showPartialIfLong
		ifTrue:
			[maybePartialCommentText]
		ifFalse:
			[showingPartial:: false.
			fullCommentText]
)
showFullComment = (
	showPartialIfLong:: false.
	refresh
)
showLessComment = (
	showPartialIfLong:: true.
	refresh
)
viewerDefinition = (
^
	row: {
		elastic:
			presentationDefinition.
		smallBlank.
		(* linkImage:  editImage action: [respondToEdit]*)
		}
)
) : (
)
class ClassEntryPresenter onSubject: s <ClassSubject> = EntryPresenter onSubject: s () (
accessIndicator = (
	^image: (iconForAccessModifier: subject accessModifier).
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: ('.' at: 1).
	(* Needed is needed to get this to work on Squeak, where Strings and Characters are not the same *)
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	#BOGUS. (* because of hacky use of at: to get characters on Squeak *)
	^firstSentence(* need to trim blanks *)
)
collapsedDefinition = (
	| part |
	#BOGUS. 	(* BOGUS: we are displaying the class's name. we should display its key *)
	part:: row1: {
		image: ide images classIcon.
		smallBlank.
		accessIndicator.
		smallBlank.
		row: {link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror]}.
	} row2: {
		(row: {deferred: [(label: subject classCommentSummary)
			smallFont;
			color: secondaryTextColor]})
				compressibility: 1.
		filler
			compressibility: 0.

		(* In the face of namespace nesting, should application and test configuration be invoked with the root namespace or the local namespace? If the local namespace, these links only make sense in the context of the namespace view and should not be part of the class presenter itself. *)
		(*ClassActionsPresenter onSubject: subject.*)
		mediumBlank.
		entryActionsMenu.
	}.
	(* subject isRecentlyVisited ifTrue: [part color: recentlyVisitedColor]. *)
	^part
)
entryActionsMenu = (
	^nothing
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class ClassFactoryPresenter onSubject: s <ClassFactorySubject> = MethodPresenter onSubject: s (
(* WIP. Present the factory method, colorized *)
) (
acceptResponse ^ <[:TextEditorFragment :Event]> = (
	^[:ed <TextEditorFragment> :event <Event> |
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		b addFactoryFromSource: ed textBeingAccepted.
		b declaration install.
		ed text: (colorizeMethodSource: (crToLf: ed textBeingAccepted)).
		ed setCursor.
		ed leaveEditState.
		]
)
colorizeMethodSource: s <String> ^ <TextFragment> = (
	^text: (ide colorizer parseClassHeader: s fromClass: subject classDeclaration)
)
) : (
)
class ClassFactorySubject onModel: m <ClassDeclarationMirror> = MethodSubject onModel: m (
(* WIP. *)
) (
public accessModifier ^ <Symbol> = (
	^#public
)
public createPresenter ^ <ClassFactoryPresenter> = (
	^ClassFactoryPresenter onSubject: self
)
) : (
)
class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
|
descriptionOrSourceSwitcherHolder
descriptionOrSourceHolder
|
) (
acceptResponse ^ <[:TextEditorFragment :Event]> = (
	^[:ed <TextEditorFragment> :event <Event> |
		| b <ClassDeclarationBuilder> = subject classMirror declaration asBuilder. |
		(*('ed text:', ed textBeingAccepted) out.*)
		b header source: ed textBeingAccepted.
		b install.
		ed text: (colorizeMethodSource: (crToLf: ed textBeingAccepted)).
		ed setCursor.
		ed leaveEditState.
		]
)
accessIndicator = (
	^image: (iconForAccessModifier: subject accessModifier).
)
changeResponse ^ <[:TextEditorFragment :Event]> = (
	^[:ed <TextEditorFragment> :event <Event>  |  | cp <Integer> |
		ed textBeingAccepted out.
		cp:: ed cursorPosition.
		ed text: (colorizeMethodSource: (crToLf: ed textBeingAccepted)).
		ed setCursor: cp.
		ed enterEditState.
	  ]
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: ('.' at: 1).
	(* Needed is needed to get this to work on Squeak, where Strings and Characters are not the same *)
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	#BOGUS. (* because of hacky use of at: to get characters on Squeak *)
	^firstSentence(* need to trim blanks *)
)
classDescriptionDefinition = (
	| slotList <Fragment> |
	^column: {
		preambleLine.
		mediumBlank.
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
           (slotList:: subject classMirror instanceSide slots) size > 0
		   ifTrue: [
			column: {
				label: 'Slots'.
				row: {
					mediumBlank.
					column: (slotList collect: [:ea | label: ea name]).
				}
			}.
		] ifFalse: [nothing].
		initializerDefinition.
		}
)
classSourceDefinition = (
	| editor init <InitializerMethodSubject> |
	^column: {
		editor:: TextEditorFragment new
		text: (colorizeMethodSource: (crToLf: subject classHeaderSource));
				changeResponse: changeResponse;
				acceptResponse: acceptResponse
	}
)
collapsedHeadingDefinition = (
	^row: {
		blank: 5.
		image: ide images classIcon.
		blank: 5.
		link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror (* Why do we need a copy? *)]
		}.
)
colorizeMethodSource: s <String> ^ <TextFragment> = (
	^text: (ide colorizer parseClassHeader: s fromClass: subject classMirror)
)
public definition ^ <Fragment> = (
	^column: {
		headingDefinition.
		sectionLabelled: 'Classes' presenting: subject nestedClassesSubject.
		sectionLabelled: 'Methods' presenting: subject methodsSubject.
		sectionLabelled: 'Class Methods' presenting: subject classMethodsSubject.
	}
)
expandedHeadingDefinition ^ <Fragment> = (
	| parts <List[Fragment]> slotList <Fragment> |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^(column: {
		blank: 5.
		row: {blank: 5. image: ide images classIcon. blank: 5. row: parts. filler. homeButton}.
		inspectSelf.
		preambleLine.
		label: subject classCommentSummary.
		blank: 15.
		descriptionOrSourceSwitcherHolder:: holder: (switcherShowingSource: false).
		(row: {}) color: (Color gray: 0.8).
		mediumBlank.
		descriptionOrSourceHolder:: holder: classDescriptionDefinition
	})
	(*^column: {
		blank: 5.
		row: {blank: 5. image: ide images classIcon. blank: 5. row: parts. filler. homeButton}.
		inspectSelf.
		preambleLine.
		label: classCommentSummary.
		(slotList:: subject classMirror instanceSide slots) size > 0
		   ifTrue: [
			column: {
				label: 'Slots'.
				row: {
					mediumBlank.
					column: (slotList collect: [:ea | label: ea name]).
				}
			}.
		] ifFalse: [nothing].
	}*)
)
headingDefinition ^ <Fragment> = (
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [collapsedHeadingDefinition].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
initializerDefinition ^ <Fragment> = (
	^nothing
)
inspectSelf ^ <Fragment> = (
	^row: {filler. link: 'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
minorClassHeadingBlock: body = (
	^(padded: body with: {10. 5. 5. 5.})
		color: minorClassHeadingColor
)
minorClassHeadingColor = (
	^Gradient
		from: (Color h: 240 s: 0.02 v: 0.94)
		to: (Color h: 240 s: 0.02 v: 0.9)
)
nestedClass: cdm = (
	^collapsed: [row: {
					image: (iconForAccessModifier: cdm accessModifier).
					blank: 3.
					link: cdm simpleName action: [enterSubject:: ClassSubject onModel: cdm]
					}
				]
	expanded: [(ClassSubject onModel: cdm) presenter]
)
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble <String> equalIndex <Integer> prefix <String> suffix <String> |
	preamble:: subject classMirror header preamble.
	equalIndex:: preamble indexOf: "=".
	equalIndex = 0
		ifTrue:
			[prefix:: preamble.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1).
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)].
	^suffix isEmpty
		ifTrue:
			[label: prefix]
		ifFalse:
			[row: {
				label: prefix, ' = '.
				link: suffix action: [respondToBrowseSuperclass]
				}]
)
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> = (
	| groupPresenter |
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				}
			).
		groupPresenter:: groupSubject presenter.
		}
)
switchToDescription = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: false).
	descriptionOrSourceHolder content: classDescriptionDefinition.
)
switchToSource = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: true).
	descriptionOrSourceHolder content: classSourceDefinition
)
switcherShowingSource: showingSourceNow <Boolean> ^ <Fragment> = (
	^showingSourceNow
		ifTrue:
			[row: {
				(link: 'Description' action: [switchToDescription]).
				mediumBlank.
				(label: 'Source').
			}]
		ifFalse:
			[row: {
				(label: 'Description').
				mediumBlank.
				(link: 'Source' action: [switchToSource]).
			}]
)
) : (
)
public class ClassSubject onModel: m <ClassDeclarationMirror> = Subject onModel: m (
) (
public accessModifier = (
	^classMirror accessModifier
)
public classCommentSummary ^ <String> = (
	|
	fullComment <String> = classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: ('.' at: 1).
	(* Needed is needed to get this to work on Squeak, where Strings and Characters are not the same *)
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	#BOGUS. (* because of hacky use of at: to get characters on Squeak *)
	^firstSentence(* need to trim blanks *)
)
public classCommentText ^<String> = (
	^model header classComment ifNil: ['']
)
public classHeaderSource = (
	^classMirror header source
)
public classMethodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror asBuilder classSide methods
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model
)
public createPresenter = (
	^ClassPresenter onSubject: self
)
public enclosingClassSubjects = (
	| them = List new. c |
	c:: model.
	[c isNil] whileFalse: [them add: (ClassSubject onModel: c). c:: c enclosingClass].
	^them
)
public methodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror asBuilder instanceSide methods
)
public name = (
	^model simpleName
)
public nestedClassesSubject ^ <NestedClassGroupSubject> = (
	^NestedClassGroupSubject onModel: classMirror asBuilder instanceSide nestedClasses
)
public title = (
	^name
)
) : (
)
public class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* DefinitionListPresenter is an abstract superclass of presenters that displays helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added or residue presenters of removed methods. *)
| prefixes <PresenterList> content <PresenterList> suffixes <PresenterList> |) (
public collapseAll = (
	(* Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each collapse]
		(*]*)
)
contentList ^ <PresenterList> = (
	^list: [contentPresenters]
)
contentPresenters ^ <List[Presenter]> = (
	^List new
)
definition ^ <Fragment> = (
	prefixes:: list.
	content:: contentList.
	suffixes:: list.
	^column: {
		prefixes.
		content.
		suffixes.
		}
)
public expandAll = (
	(* Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each expand]
		(*]*)
)
) : (
)
public class DefinitionTemplate
   caption: c <String>
   initialText: t <String | Text>
   colorizerBlock: cb <[String | Text]>
   acceptResponse: onAccept <[DefinitionTemplate]>
   cancelResponse: onCancel <[DefinitionTemplate]>
 = ProgrammingPresenter onSubject: nil (|
	public caption = c.
	public initialText = t.
	public initiallyInEditState ::= true.
	public acceptResponse = onAccept.
	public cancelResponse = onCancel.
	public editor
	public colorizerBlock = cb.
|) (
public = anotherPresenter ^ <Boolean> = (
	^self == anotherPresenter
)
definition ^ <Fragment> = (
	^(row: {
		mediumBlank.
		elastic:
			(column: {
				smallBlank.
				label: caption.
				editorDefinition.
				mediumBlank.
 			}).
		smallBlank.
		}) color: (Gradient from: (Color h: 100 s: 0.3 v: 0.9) to: (Color h: 100 s: 0.3 v: 0.8))
)
editorDefinition ^ <Fragment> = (
	editor:: TextEditorFragment new
		text: initialText;
	(*	acceptLabelText: 'save';
		cancelLabelText: 'cancel';*)
		acceptResponse: [acceptResponse value: self];
		cancelResponse: [cancelResponse value: self].
		(*colorizerBlock: colorizerBlock.*)
	initiallyInEditState ifTrue: [editor enterEditState].
	^editor
)
public text = (
	^editor textBeingAccepted
)
) : (
public caption: c <String>
   acceptResponse: onAccept <[]>
   cancelResponse: onCancel <[]> = (
	^caption: c initialText: [:text | text asString asText] colorizerBlock: [:text | text asString asText] acceptResponse: onAccept cancelResponse: onCancel
)
public caption: c <String>
   colorizerBlock: cb <[String | Text]>
   acceptResponse: onAccept <[]>
   cancelResponse: onCancel <[]> = (
	^caption: c initialText: [:text | text asString asText] colorizerBlock: cb acceptResponse: onAccept cancelResponse: onCancel
)
)
class EntryPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public collapse = (
	substance collapse
)
definition = (
	^collapsed: [collapsedDefinition] expanded: [expandedDefinition]
)
public expand = (
	substance expand
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.
	}
)
) : (
)
class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (
| helpHolder |) (
aboutSystemDefinition = (
	^(link: 'About this system' action: [respondToAboutSystem]) smallFont.
)
column1: definitions1 column2: definitions2 column3: definitions3 = (
^row: {
	(column: definitions1) width: 0 elasticity: 1.
	(column: definitions2) width: 0 elasticity: 1.
	(column: definitions3) width: 0 elasticity: 1.
	}
)
definition = (
	helpHolder:: list.
^
	column: {
		helpHolder.
		majorHeadingBlock: (
			row: {
				label: 'Navigation'.
				filler.
				helpButton.
			}
		).
		mediumBlank.

		indentedBlock:
			(column1: {
				link: 'Newspeak Source'
					action: [enterSubject:: NamespaceSubject new].
				}
			column2: {
				link: 'Workspaces'
						action: [navigateToWorkspaces].
				}
			column3: {

				}
			).
		mediumBlank.

(*		majorHeadingBlock: (label: 'Recently Visited' asText allBold).
		mediumBlank.
		indentedBlock:
			(holder: [recentStuffDefinition]).
		largeBlank.*)

		majorHeadingBlock: (label: 'Did you know?').
		smallBlank.
		indentedBlock:
			(holder: [didYouKnow]).
		mediumBlank.
		indentedBlock: aboutSystemDefinition.
		}
)
didYouKnow = (
	| wisdom |
	^label: ''
	(*wisdom:: subject randomBitOfWisdom.
	wisdom actionLabel notNil ifTrue:
		[^textAndActionWisdom: wisdom].
	wisdom image notNil ifTrue:
		[^textAndImageWisdom: wisdom].
	^textDisplay: wisdom text*)
)
helpButton = (
^helpText isNil
	ifTrue: [nothing]
	ifFalse: [(link: '[?]' action: [respondToHelp]) smallFont]
)
helpText ^<String | nil> = (
(* If this method answers a string, a help button will appear on the Home page. Clicking on that button will display the string. *)
^'This is the home page.
The home page includes links to a variety of useful places, like the IDE''s root namespace, which lists all top level classes, and the workspace manager, where you can evaluate code.
Golden icons represent Newspeak3, which is the currently operational dialect of Newspeak.'
)
navigateToWorkspaces = (
	enterSubject:: ide theWorkspaceManager AllWorkspacesSubject new
)
respondToAboutSystem = (
	alert: 'WebIDEApp version 0.1984'
)
respondToHelp = (
helpHolder setPresenters: {
	row: {
		filler.
		(link: 'close help' action: [helpHolder setPresenters: {}]) smallFont.
	}.
	textDisplay: helpText.
}
)
textAndActionWisdom: wisdom = (
^
	column: {
		TextDisplayFragment new text: wisdom text.
		(link: wisdom actionLabel action: wisdom actionBlock) smallFont
		}
)
textAndImageWisdom: wisdom = (
^
	row: {
		image: wisdom image.
		mediumBlank.
		elastic:
			(textDisplay: wisdom text).
		}
)
) : (
)
public class HomeSubject onModel: m = Subject onModel: m () (
public = anotherSubject <Subject> ^ <Boolean> = (
(* As there is just one possible logical home of the system, all subjects representing it are considered equal. *)
	^anotherSubject isKindOfHomeSubject
)
bitsOfWisdom = (
	(* This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random. *)

^
	{
	[BitOfWisdom
		text: 'This is the "expand all" button which appears in headers of expandable item groups.'
		image: ide images expandImage].

	[BitOfWisdom
		text: 'This is the "collapse all" button which appears in headers of expandable item groups.'
		image: ide images collapseImage].

	[BitOfWisdom
		text: 'This is the "add" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'
		image: ide images addImage].

	[BitOfWisdom
		text: 'War is peace. Freedom is slavery. Ignorance is strength.'].
	}
)
public createPresenter = (
	^HomePresenter onSubject: self
)
isKindOfHomeSubject ^ <Boolean> = (
	^true
)
lateNightWisdom = (
	^BitOfWisdom
		text: 'It''s ', Time now printString, '. Go get some rest!'
)
public randomBitOfWisdom = (
	| bits |
	(*Time now hour < 5 ifTrue: [^lateNightWisdom].*)
	bits:: bitsOfWisdom.
	^bits atRandom value ifNil: [randomBitOfWisdom]
)
public title = (
	^'Home'
)
) : (
public new = (
	^onModel: nil
)
)
class MethodGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)
| groupedByCategory <Boolean> ::=false. |
) (
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	addNewItemTemplate: subject methodTemplateText
)
addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template |
	template:: DefinitionTemplate
		caption: 'Adding new method:'
		initialText: src
		colorizerBlock: [:text | subject colorizeSource: text]
		acceptResponse:
			[:ed | createNewMethodFromTemplate: template]
		cancelResponse:
			[:ed | prefixes remove: template].
	prefixes add: template.
	^template
)
createNewMethodFromTemplate: template <DefinitionTemplate> = (
	subject
		compileSource: template text
		ifSuccess:
			[:newMethod <MethodMirror> |
			| newSubject <MethodSubject> = MethodSubject onModel: newMethod. |
			prefixes remove: template.
			(* why would this presenter be there yet?  *)
			(content detectPresenter: [:some | some = newSubject presenter]) expand]
		ifFailure: [:message | template editor showMessage: message]
)
public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteMethodWithSubject: presenter subject.
	successResponse value
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
(* A subclass must redefine this to define the class of presenter it will be using. *)
	^MethodPresenter
)
) : (
)
public class MethodGroupSubject onModel: m <MutableMirrorGroup> = MirrorGroupSubject onModel: m (
(* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)
) (
public colorizeSource: s <String> ^ <TextFragment> = (
	^text: (ide colorizer parseMethod: s fromClass: subject classDeclaration)
)
public compileSource: s <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newMirror <MethodMirror> |
	builder:: model enclosingMixin.
	newMirror:: builder methods addFromSource: s.
	builder declaration install.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public createPresenter = (
	^MethodGroupPresenter onSubject: self
)
public deleteMethodWithSubject: methodSubject <MethodSubject> = (
	| builder <MixinBuilder> |
	builder:: model enclosingMixin.
	builder methods removeMirrorNamed: methodSubject selector.
	builder declaration install.
)
elementSubjectClass ^ <MethodSubject class> = (
	^MethodSubject
)
public methodTemplateText ^ <String> = (
^
'messageSelector = (
)'
)
modelMirrorCollection ^ <Collection[MethodMirror]> = (
	^super modelMirrorCollection (*asSortedList: [:a :b | a simpleName < b simpleName]*)
)
) : (
)
class MethodPresenter onSubject: s <MethodSubject> = ProgrammingPresenter onSubject: s (
(* A presenter for a single method. *)
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		(*('ed text:', ed textBeingAccepted) out.*)
		b methods addFromSource: ed textBeingAccepted.
		b declaration install.
		colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed leaveEditState.
		]
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> | | cp <Integer> |
		colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed enterEditState.
	 ]
)
public collapse = (
	^substance collapse
)
colorizeMethodSource: s <String> ^ <TextFragment> = (
	^text: (ide colorizer parseMethod: s fromClass: subject classDeclaration)
)
colorizeMethodSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeMethod: s fromClass: subject classDeclaration via: [:r | 
		| style <Alien[JSObject]> = JSObject new.  cssStyle <String> = cssFor: r kind. |
		style at: 'css' put: cssStyle.
		cm style: style from: r start -1 to: r end
		]
)
public definition ^ <Fragment> = (
	| toggle |
	toggle::
		collapsed: [row: {
			image: (iconForAccessModifier: subject accessModifier).
			blank: 3.
			(link: subject name action: [toggle expand]) color: Color black.
	        filler.
	        dropDownMenu: [methodMenuFor: subject name]
			}
		]
		expanded: [ |  src = crToLf: subject source. cm = codeMirror: src. |
			cm changeResponse: changeResponse; acceptResponse: acceptResponse.
			colorizeMethodSource: src withEditor: cm.
			column: {
			row: {
			  image: (iconForAccessModifier: subject accessModifier).
			  blank: 3.
			  (link: subject name action: [toggle collapse]) color: Color black.
	          filler.
	          dropDownMenu: [methodMenuFor: subject name]
			}.
			cm
		}].
	^toggle
)
public expand = (
	| e = substance expand. |
	e refresh.
	^e
)
methodMenuFor: methodName <String> = (
	^menuWithLabelsAndActions: {
		{'Delete ', methodName. [subject delete.  refresh]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}
)
) : (
)
public class MethodSubject onModel: mm <MethodMirror> = Subject onModel: mm (
(* Manages the UI for a method. *)
) (
public accessModifier ^ <Symbol> = (
	^methodMirror accessModifier
)
public classDeclaration ^ <ClassDeclarationMirror> = (
	^methodMirror definingMixin declaration
)
public createPresenter ^ <Presenter> = (
	^MethodPresenter onSubject: self
)
public delete = (
	| b <MixinBuilder> = methodMirror definingMixin asBuilder. |
	('Deleting ', name) out.
	b methods removeMirrorNamed: methodMirror name.
	b declaration install.
)
public methodMirror ^ <MethodMirror> = (
	^model
)
public name ^ <Symbol> = (
	^methodMirror name
)
public source ^ <String> = (
	^methodMirror source
)
) : (
)
class MirrorGroupPresenter onSubject: s <Subject> = DefinitionListPresenter onSubject: s (
) (
public addNewItemTemplate = (
	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)

	subclassResponsibility
)
contentPresenters ^ <Collection[ProgrammingPresenter]> = (
	^subject elements collect:
		[:each <ProgrammingPresenter> | createPresenterForSubject: each]
)
createPresenterForSubject: aSubject <Subject> ^ <ProgrammingPresenter> = (
	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)
	^elementPresenterClass
		ifNil: [aSubject presenter]
		ifNotNil: [:pclass <ProgrammingPresenter class> | pclass onSubject: aSubject]
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
(* A subclass must redefine this to define the class of presenter it will be using. *)
	subclassResponsibility
)
) : (
)
class MirrorGroupSubject onModel: m <MirrorGroup> = Subject onModel: m (
(* An abstract superclass of subjects on mirror groups. Registers to receive update events from the mirror group and broadcasts its own update events through its 'changedChannel' when that happens. The presenter will listen to those and update itself when needed. *)
|
(*mirrorGroupChangesOutlet
public changedChannel ::= Duct owner: self.*)
|
) (
elementSubjectClass = (
	(* Answer the class of the subjects we create on individual elements of our subject group. *)
	subclassResponsibility
)
public elements ^<Collection[Subject]> = (
	(* Answer a collection of subjects on individual elements of the group which is our subject. *)
	^modelMirrorCollection collect: [:each | elementSubjectClass onModel: each]
)
public mirrorGroup ^ <MirrorGroup> = (
	^model
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^(model collect: [:x | x]) asMutableArrayList
)
) : (
)
class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (
) (
class ClassEntryPresenter onSubject: s <ClassSubject> = outer SimpleBrowsing ClassEntryPresenter onSubject: s () (
accessIndicator = (
	^nothing
)
entryActionsMenu = (
	^dropDownMenu: [entryActionsMenuFor: subject name].
)
) : (
)
class NamespaceEntryPresenter onSubject: s = EntryPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
		image: ide images classPresenterIcon.
		smallBlank.
		row: {link: subject key action: [
			(*ide defaultPopularityRecord
			rememberNamespaceVisit: subject key. (* Should be the namespace itself, but non-strings break the home page. *)*)
			enterSubject:: subject refreshmentSubject]}.
	} row2: {
		(label: subject summaryText)
				smallFont;
				compressibility: 1;
				color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject key]
	}.
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class ValueEntryPresenter onSubject: s = EntryPresenter onSubject: s (|
	public key
|) (
collapsedDefinition = (
	^row1: {
		image: ide images classUnknownIcon.
		smallBlank.
		link: key action: [enterSubject:: subject].
	} row2: {
		(label: subject title)
			smallFont;
			compressibility: 1;
			color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: key]
	}
)
definition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^collapsed: [collapsedDefinition]
	expanded: [subject presenter selfCaption: key]
)
expandedDefinition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^subject presenter selfCaption: key
)
) : (
)
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor text: msg]
)
acceptNewNamespaceDefinitionFrom: aTemplate = (
	subject
		addNamespaceFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor text: msg]
)
addClassTemplate = (
	prefixes add:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock: [:text | subject colorizeClassSource: text]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | prefixes remove: template])
)
addNamespaceTemplate = (
	prefixes add:
		(DefinitionTemplate
			caption: 'Defining a new namespace:'
			initialText: 'NewNamespace'
			colorizerBlock: [:text | ]
			acceptResponse:
				[:template | acceptNewNamespaceDefinitionFrom: template]
			cancelResponse:
				[:template | prefixes remove: template])
)
contentList ^ <PresenterList> = (
	^zebra: super contentList
)
contentPresenters ^ <List[Presenter]> = (
	| lexicalOrder <[:Symbol :Symbol | Boolean]> |
	lexicalOrder:: [:a <Symbol> :b <Symbol> |
		lexicallyLessOrEqual: a than: b
	].
	^(subject namespace keys asArray sort: lexicalOrder) collect: [:key | presenterForEntryAt: key]
)
definition ^ <Fragment> = (
	^column: {
		minorHeadingBlock: (row: {
			label: subject key (*asText allBold*).
			largeBlank.
			(*subject namespace isKindOfCategoryNamespace
				ifTrue: [*)addButtonWithAction: [respondToAddForCategory](*]
				ifFalse: [addButtonWithAction: [respondToAddForRoot]]*).
			filler.
			expandButtonWithAction: [expandAll].
			blank: 3.
			collapseButtonWithAction: [collapseAll].
			blank: 3.
			dropDownMenu: [namespaceMenu].
			largeBlank.
			homeButton.
		}).
		smallBlank.
		super definition.
	}
)
entryActionsMenuFor: key = (
	^menuWithLabelsAndActions: {
		{'Remove ', key. [ide namespacing removeKey: key.  refresh]}.
	}
)
lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (
	(* BOGUS: This should be a utility somewhere *)
	| length = a size min: b size. |
	('a' at: 1) isKindOfInteger ifTrue: 
		[1 to: length do:
			[:index |
			 (a at: index) < (b at: index) ifTrue: [^true].
			 (a at: index) > (b at: index) ifTrue: [^false]].
		^true].

	1 to: length do:
		[:index |
		 (a runeAt: index) < (b runeAt: index) ifTrue: [^true].
		 (a runeAt: index) > (b runeAt: index) ifTrue: [^false]].
	^true
)
namespaceMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
presenterForEntryAt: key <Symbol> ^ <EntryPresenter> = (
	| entry = subject namespace at: key. |
	entry isBehavior
		ifTrue: [^ClassEntryPresenter onSubject: (ClassSubject onModel: (ClassMirror reflecting: entry) mixin declaration)].

	entry isKindOfNamespace
		ifTrue: [^NamespaceEntryPresenter onSubject: (NamespaceSubject onModel: entry key: key)].

	^(ValueEntryPresenter onSubject: (objectSubjectFor: entry)) key: key
)
respondToAddForCategory = (
	openMenuWithLabelsAndActions: {
		{'Add Class'. [addClassTemplate]}.
		{ 'Add Namespace'. [addNamespaceTemplate]}.
		(*{'Add Image From File'. [respondToAddImage].}.
		{'Add Text From File'. [respondToAddText]}.
		 'Add Value' -> [Error signal: 'Unimplemented']. *)
	}
)
respondToAddForRoot = (
	openMenuWithLabelsAndActions: {
		{'Add Namespace'. [addNamespaceTemplate]}.
	}
)
respondToAddImage = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key form |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		form:: PNGReadWriter formFromFileNamed: fn.
		subject namespace at: key asSymbol put: form.
	].
)
respondToAddText = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key text |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		text:: ((MultiByteFileStream oldFileNamed: fn)
			converter: (TextConverter newForEncoding: 'utf8')) contents.
		subject namespace at: key asSymbol put: text.
	].
)
) : (
)
public class NamespaceSubject onModel: m <Map[Symbol, Object]> key: k <Symbol> = Subject onModel: m (|
	public key = k.
|ide namespacing refreshCategoryNamespaces) (
public = other ^<Boolean> = (
	^class = other class (* class is not public *)
		and: [namespace = other namespace]
		and: [key = other key].
)
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| builder <ClassDeclarationBuilder> mixin <MixinMirror> klass |
	('adding top level class: ', definition) out.
	[builder:: ClassDeclarationBuilder fromToplevelSource: definition]
		on: Error
		do: [:ex | ^failureBlock value: ex printString].
	(namespace includesKey: builder simpleName) ifTrue:
		[^failureBlock value: 'A class named ', builder simpleName, ' already exists in this namespace'].
	mixin:: builder install instanceSide.
	klass:: mixin apply: Object withName: builder simpleName.
	namespace at: klass name put: klass reflectee.
	successBlock value
)
public addNamespaceFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| selector <Symbol> = definition asSymbol. |
	(*model = ide namespacing Categories ifFalse: (* ? *)
		[Error signal: 'Not supported yet, only categories for now.'].*)

	(*selector isUnary ifFalse:
		[^failureBlock value: 'Must be a unary selector'].*)
	(namespace includesKey: selector) ifTrue:
		[^failureBlock value: 'A class named ', definition, ' already exists in this namespace'].
	(* ide namespacing categoryNamespace: selector.*)
	namespace at: selector put: (ide namespacing freshNamespace).
	successBlock value
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
|
	slot1
	slot2
|
) ()'
)
public colorizeClassSource: sourceText <String | Text> ^<Text> = (
	^ide newspeakColorization NS3BrowserColorizer
		parseClassHeader: sourceText asString
		fromClass: Object mixin
)
public createPresenter ^ <NamespacePresenter> = (
	^NamespacePresenter onSubject: self
)
public hash ^<Integer> = (
	^model hash bitXor: key hash
)
public namespace ^ <Map[Symbol, Object]> = (
	^self model
)
public refreshmentSubject = (
	^self class onModel: model key: key
)
public summaryText = (
	| sb = StringBuilder new. |
	namespace keys
		do: [:k | sb add: k]
		separatedBy: [sb add: ', '].
	^sb asString
)
public title ^<String> = (
	^key
)
) : (
public new = (
	#NAMESPACEBOGUS.
	^self onModel: ide namespacing Root key: 'Root'
)
)
class NestedClassGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, a NestedClassGroupSubject, as a column of presenters for the nested classes in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS nested classes goes here. *)
) (
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor text: msg]
)
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	prefixes add:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock: [:text | subject colorizeClassSource: text]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | prefixes remove: template])
)
public deleteClassInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteClassWithSubject: presenter subject.
	successResponse value
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^ClassEntryPresenter
)
) : (
)
public class NestedClassGroupSubject onModel: m <MutableMirrorGroup> = MirrorGroupSubject onModel: m (
(* Represents the collection of nested classes of a Newspeak class. Holds onto the mirror group for the classes. *)
) (
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| builder <ClassDeclarationBuilder> mixin <MixinMirror> klass |
	(* WIP *)
	#BOGUS.
	[builder:: ClassDeclarationBuilder fromSource: definition]
		on: Error
		do: [:ex | ^failureBlock value: ex printString].
	(mirrorGroup includesMirrorNamed: builder simpleName) ifTrue:
		[^failureBlock value: 'A class named ', builder simpleName, ' already exists in this namespace'].
	mixin:: builder install instanceSide.
	klass:: mixin apply: Object withName: builder simpleName.
	mirrorGroup addMirror: klass.
	successBlock value
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
|
	slot1
	slot2
|
) ()'
)
public colorizeClassSource: sourceText <String | Text> ^<Text> = (
	^ide newspeakColorization NS3BrowserColorizer new
		parseText: sourceText asString
		fromClass: Object mixin
		usingSelector: #classDeclaration
)
public createPresenter = (
	^NestedClassGroupPresenter onSubject: self
)
public deleteClassWithSubject: classSubject <ClassSubject> = (
	| builder <MixinBuilder> |
	builder:: model enclosingMixin.
	builder nestedClasses removeMirrorNamed: classSubject name.
	builder declaration install.
)
elementSubjectClass ^ <ClassSubject class> = (
	^ClassSubject
)
) : (
)
class ObjectPresenter onSubject: s = ProgrammingPresenter onSubject: s (| resultHolder public selfCaption ::= 'self '. |) (
captionBar: body = (
	^(column: {
		smallBlank.
		row: {
			mediumBlank.
			body elasticity: 1.
			smallBlank
			}.
	}) color: captionColor
)
classInfoLine = (
	^row: {
		(label: 'class') width: 0 elasticity: 1.
		(row: {
			link: subject className action: [enterSubject: subject classSubject].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public definition = (
	^column: {
		captionBar: (column: {
			row: {selfInfoLine. filler. homeButton}.
			enclosingInfoLine.
			classInfoLine.
			smallBlank.
			inspectSelf.
			TextEditorFragment new
				changeResponse: [:editor | resultHolder content: (evaluate: editor textBeingAccepted asString)].
			smallBlank.
			resultHolder:: holder: [nothing].
		}).
		objectDetails.
	}
)
enclosingInfoLine = (
	^row: {
		(label: 'enclosingObject') width: 0 elasticity: 1.
		(row: {
			link: subject enclosingObjectName action: [enterSubject:: ObjectSubject onModel: subject classMirror enclosingObject].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
evaluate: expression <String> ^<Fragment> = (
	| thread <ThreadMirror> |
	[thread:: subject objectMirror evaluate: (withoutNbsp: expression)]
		on: Error do: [:e | ^linkForError: e].

	thread isFulfilled ifTrue: [^linkForResult: thread result].
	thread isBroken ifTrue: [^linkForError: thread result].
	^nothing
)
goToSelf = (
	enterSubject: (ObjectSubject onModel: subject objectMirror)
)
inspectSelf = (
	^row: {filler. link: 'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
linkForError: exception = (
	^(link: exception printString
	action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: exception)])
		color: (Color r: 1 g: 0 b: 0)
)
linkForResult: objectMirror = (
	^link: objectMirror reflectee printString
	action: [enterSubject:: ObjectSubject onModel: objectMirror]
)
objectDetails = (
	^row: {
	mediumBlank.
	(column: ((subject classMirror) slots collect: [:slot |
		| val = subject objectMirror getSlot: slot name. |
		row: {
			(label: slot name) width: 0 elasticity: 1.
			(row: {
				link: val reflectee printString action: [enterSubject:: ObjectSubject onModel: val].
			}) width: 0 elasticity: detailAreaRatio.
		}
	])) elasticity: 1.
	smallBlank
	}
)
selfInfoLine = (
	^row: {
		(label: selfCaption (*asText allBold*)) width: 0 elasticity: 1.
		(row: {
			(link: subject title action: [goToSelf]) compressibility: 1.
			filler compressibility: 0.
			mediumBlank.
			(*dropDownMenu: [actionsMenu]*)
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public title = (
	^'Inspector on ', subject title
)
withoutNbsp: string = (
	('a' at: 1) isKindOfInteger
		ifTrue:
			[ | bytes = ByteArray withAll: string. |
			1 to: bytes size do: [:index | (bytes at: index) = 160 ifTrue: [bytes at: index put: 32]].
			^bytes asString]
		ifFalse:
			[ | nonbreakingSpace = String fromRune: 160.
			space = String fromRune: 32. |
			^string replaceAll: nonbreakingSpace with: space]
)
) : (
)
public class ObjectSubject onModel: m = Subject onModel: m (
) (
public classMirror ^<ClassMirror> = (
	^model getClass
)
public className ^<String> = (
	^classMirror mixin name
)
public classSubject = (
	^ClassSubject onModel: classMirror mixin declaration
)
public createPresenter = (
	^ObjectPresenter onSubject: self
)
public enclosingObjectName = (
	^classMirror enclosingObject reflectee printString
)
public objectMirror ^<ObjectMIrror> = (
	^model
)
public title = (
	^objectMirror reflectee printString
)
) : (
)
class ProgrammingPresenter onSubject: s <Subject> = Presenter onSubject: s (
(* Common superclass for presenters of programming constructs. *)
) (
addButtonWithAction: aBlock = (
	^imageButton:
		{ide images addImage.
		ide images addOverImage.
		ide images addOutImage}
	action: aBlock
)
collapseButtonWithAction: aBlock = (
	^imageButton:
		{ide images collapseImage.
		 ide images collapseOverImage.
		 ide images collapseDownImage}
	action: aBlock
)
expandButtonWithAction: aBlock = (
	^imageButton:
		{ide images expandImage.
		 ide images expandOverImage.
		 ide images expandDownImage}
	action: aBlock
)
homeButton = (
	^imageButton: {
		ide images homeImage.
		ide images homeOutImage.
		ide images homeOverImage.
		ide images homeDownImage
		}
		action: [enterSubject: HomeSubject new].
)
iconForAccessModifier: am = (
	#private = am ifTrue: [^ide images privateAccessImage].
	#protected = am ifTrue: [^ide images protectedAccessImage].
	^ide images publicAccessImage
)
indentedBlock: body = (
	^column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		}
)
largeBlank = (
	^blank: 20
)
majorHeadingBlock: body = (
	^(padded: body with: {10. 10. 5. 10.})
		color: majorHeadingColor
)
majorHeadingColor = (
	(* This color is used for major definitions such as class headings. *)
	^Gradient
		from: (Color h: 240 s: 0.05 v: 0.92)
		to: (Color h: 240 s: 0.05 v: 0.86)
)
minorHeadingBlock: body = (
	^(padded: body with: {10. 5. 5. 5.})
		color: minorHeadingColor
)
minorHeadingColor = (
^Gradient
	from: (Color h: 240 s: 0.02 v: 0.94)
	to: (Color h: 240 s: 0.02 v: 0.9)
)
public objectSubjectFor: anObject = (
	^objectSubjectForMirror: (ObjectMirror reflecting: anObject)
)
objectSubjectForMirror: objectMirror <ObjectMirror> = (
	^ObjectSubject onModel: objectMirror
)
respondToInspectPresenter = (
	enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)
)
secondaryTextColor ^ <Color> = (
	^Color gray: 0.6
)
smallBlank = (
	^blank: 5
)
) : (
)
crToLf: string = (
	|
	cr = String fromRune: 13.
	lf = String fromRune: 10.
	|
	^string replaceAll: cr with: lf.
)
cssConversionTable ^ <Map[Symbol, String]> = (
(* compute a mapping from 'kinds', which are symbols denoting logical categories of code, to CSS properties used to colorize them*)
  |
  redBoldUnderlined <String> = 'color:Red; font-family: TimesNewRoman; font-weight:bold; text-decoration: underline'.
  redUnderlined <String> = 'color:Red; font-family: TimesNewRoman; text-decoration: underline'.
  orangeBoldUnderlined <String> = 'color:Orange; font-family: TimesNewRoman; font-weight:bold; text-decoration: underline'.
  underlined <String> = 'text-decoration: underline; font-family: TimesNewRoman'.
  gray <String> = 'color:Gray; font-family: TimesNewRoman'.
  blue <String> = 'color:Blue; font-family: TimesNewRoman'.
  grayBold <String> = 'color:Gray; font-family: TimesNewRoman; font-weight:bold'.
  blackBold <String> = 'color:Black; font-family: TimesNewRoman; font-weight:bold'.
  blueBold <String> = 'color:Blue; font-family: TimesNewRoman; font-weight:bold'.
  magentaBold <String> = 'color:Magenta; font-family: TimesNewRoman; font-weight:bold'.
  bold <String> = 'font-family: TimesNewRoman; font-weight:bold'.
 |

      ^Map new
		 at: #error put: redBoldUnderlined;
             at: #undefinedUnary put: redUnderlined;
             at: #undefinedBinary put: redUnderlined;
             at: #undefinedKeyword put: redUnderlined;
             at: #shadowingTempVar put: orangeBoldUnderlined;
             at: #obsoleteMessage put: orangeBoldUnderlined;
             at: #whitespaceWarning put: orangeBoldUnderlined;
             at: #incompleteUnary put: underlined;
             at: #incompleteBinary put: underlined;
             at: #incompleteKeyword put: underlined;
             at: #self put: gray;
             at: #super put: gray;
             at: #outer put: gray;
             at: #true put: gray;
             at: #false put: gray;
             at: #nil put: gray;
             at: #string put: gray;
             at: #symbol put: gray;
             at: #number put: gray;
             at: #character put: gray;
             at: #public put: gray;
             at: #protected put: gray;
             at: #private put: gray;
             at: #tempVar put: grayBold;
             at: #blockTempVar put: grayBold;
             at: #blockPatternArg put: grayBold;
             at: #patternArg put: grayBold;
             at: #slotDecl put: grayBold;
             at: #patternTempVar put: grayBold;
             at: #methodTempBar put: blackBold;
             at: #leftParenthesis put: blackBold;
             at: #rightParenthesis put: blackBold;
             at: #leftParenthesis3 put: blackBold;
             at: #rightParenthesis3 put: blackBold;
             at: #leftParenthesis6 put: blackBold;
             at: #rightParenthesis6 put: blackBold;
             at: #blockStart put: blackBold;
             at: #blockEnd put: blackBold;
             at: #blockStart3 put: blackBold;
             at: #blockEnd3 put: blackBold;
             at: #blockStart6 put: blackBold;
             at: #blockEnd6 put: blackBold;
             at: #leftBrace put: blackBold;
             at: #rightBrace put: blackBold;
             at: #leftBrace3 put: blackBold;
             at: #rightBrace3 put: blackBold;
             at: #leftBrace6 put: blackBold;
             at: #rightBrace6 put: blackBold;
             at: #messagePatternDecl put: bold;
             at: #className put: bold;
             at: #comment put: blue;
             at: #type put: blueBold;
             at: #return put: blueBold;
             at: #leftParenthesis1 put: blueBold;
             at: #rightParenthesis1 put: blueBold;
             at: #leftParenthesis4 put: blueBold;
             at: #rightParenthesis4 put: blueBold;
             at: #leftParenthesis7 put: blueBold;
             at: #rightParenthesis7 put: blueBold;
             at: #blockStart1 put: blueBold;
             at: #blockEnd1 put: blueBold;
             at: #blockStart4 put: blueBold;
             at: #blockEnd4 put: blueBold;
             at: #blockStart7 put: blueBold;
             at: #blockEnd7 put: blueBold;
             at: #leftBrace1 put: blueBold;
             at: #rightBrace1 put: blueBold;
             at: #leftBrace4 put: blueBold;
             at: #rightBrace4 put: blueBold;
             at: #leftBrace7 put: blueBold;
             at: #rightBrace7 put: blueBold;
             at: #leftParenthesis2 put: magentaBold;
             at: #rightParenthesis2 put: magentaBold;
             at: #leftParenthesis5 put: magentaBold;
             at: #rightParenthesis5 put: magentaBold;
             at: #blockStart2 put: magentaBold;
             at: #blockEnd2 put: magentaBold;
             at: #blockStart5 put: magentaBold;
             at: #blockEnd5 put: magentaBold;
             at: #leftBrace2 put: magentaBold;
             at: #rightBrace2 put: magentaBold;
             at: #leftBrace5 put: magentaBold;
             at: #rightBrace5 put: magentaBold;
              yourself
)
cssFor: k <Symbol> ^ <String> = (
        ^cssConverter at: k ifAbsent: [ 'color:Black; font-family: TimesNewRoman']
)
) : (
)
