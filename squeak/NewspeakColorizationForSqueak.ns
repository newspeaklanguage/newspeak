Newspeak3'HopscotchIDE'class NewspeakColorizationForSqueak usingPlatform: p = (|private Color = p graphics Color.private Map = p collections Map.private List = p collections List.private TypedNS3Grammar = p mirrors grammar TypedNS3Grammar.private ImplementationBase = p squeak ImplementationBase.private TextColor = p squeak TextColor.private TextEmphasis = p squeak TextEmphasis.|) (public class NS3BrowserColorizer = NS3Colorizer (|	coloredText|) (applyColor: kind from: start to: end = (	(* Hacked up to roughly match the table in SHTextStylerST80 newsqueakStyleTable.	The advantage is that this code is not dependent on Shout *)	({#error. #undefinedUnary. #undefinedKeyword. #undefinedBinary} includes: kind) ifTrue:		[coloredText addAttribute: TextColor red from: start to: end.		 coloredText addAttribute: TextEmphasis underlined from: start to: end.		 ^self].	({#shadowingTempVar. #obsoleteMessage. #whitespaceWarning} includes: kind) ifTrue:		[coloredText addAttribute: TextEmphasis bold from: start to: end.		 coloredText addAttribute: (TextColor color: Color orange) from: start to: end.		 coloredText addAttribute: TextEmphasis underlined from: start to: end.		 ^self].	({#incompleteKeyword. #incompleteBinary. #incompleteUnary} includes: kind) ifTrue:		[coloredText addAttribute: TextEmphasis underlined from: start to: end.		 ^self].	({#self. #super. #outer. #true. #false. #nil. #string. #symbol. #stringSymbol. #number. #character. #protected. #private. #public } includes: kind) ifTrue:		[coloredText addAttribute: TextColor gray from: start to: end.		 ^self].	({#tempVar. #blockTempVar. #blockPatternArg. #patternArg. #patternTempVar} includes: kind) ifTrue:		[coloredText addAttribute: TextEmphasis bold from: start to: end.		 coloredText addAttribute: TextColor gray from: start to: end.		 ^self].	({#methodTempBar. #leftParenthesis. #rightParenthesis.  #leftParenthesis3. #rightParenthesis3.  #leftParenthesis6. #rightParenthesis6. #blockStart. #blockEnd.  #blockStart3. #blockEnd3.  #blockStart6. #blockEnd6.  #leftBrace. #rightBrace.  #leftBrace3. #rightBrace3.  #leftBrace6. #rightBrace6} includes: kind) ifTrue:		[coloredText addAttribute: TextEmphasis bold from: start to: end.		 coloredText addAttribute: TextColor black from: start to: end.		 ^self].	#slotDecl = kind ifTrue:		[coloredText addAttribute: TextEmphasis bold from: start to: end.		 coloredText addAttribute: TextColor gray from: start to: end.		 ^self].	({#messagePatternDecl. #className} includes: kind) ifTrue:		[coloredText addAttribute: TextEmphasis bold from: start to: end.		 ^self].	kind = #comment ifTrue:		[coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.		^self].	({#type. #return. #leftParenthesis1. #rightParenthesis1. #leftParenthesis4. #rightParenthesis4. #leftParenthesis7. #rightParenthesis7. #blockStart1. #blockEnd1. #blockStart4. #blockEnd4.  #blockStart7. #blockEnd7. #leftBrace1. #rightBrace1.  #leftBrace4. #rightBrace4.  #leftBrace7. #rightBrace7} includes: kind) ifTrue:		[coloredText addAttribute: TextEmphasis bold from: start to: end.		 coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.		 ^self].	({#leftParenthesis2. #rightParenthesis2. #leftParenthesis5. #rightParenthesis5.   #blockStart2. #blockEnd2.  #blockStart5. #blockEnd5.  #leftBrace2. #rightBrace2.  #leftBrace5. #rightBrace5 } includes: kind) ifTrue:		[coloredText addAttribute: TextEmphasis bold from: start to: end.		 coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.		 ^self].)applyRanges = (	rangeMap do: [:blk | blk value ].	^coloredText)noteRange: kind from: start to: end = (	(* The range 0..size is degenerate and leads to errors in Squeak 5.0 Morphic layout of paragraphs. *)	rangeMap add: [ applyColor: kind from: (start max: 1) to: end ].)public parseText: s <String> fromClass: c <Class> usingSelector: selector <Symbol> ^<Text> = (	| parser |	inputSize:: s size.	klass:: c.	bracketDepth:: 0.	braceDepth:: 0.	parenDepth:: 0.	rangeMap:: List new.	cachedScopeStack: nil.	coloredText:: s asText.	parser:: (perform: selector), eoi.	parser parseString: s ifError: [:msg :pos |		noteRange: #error from: pos to: inputSize.		^applyRanges ].	^applyRanges)) : ()class NS3Colorizer = TypedNS3Grammar (|	cachedScopeStack	klass	rangeMap	inputSize	startComment	braceDepth	bracketDepth	parenDepth	isFirst ::= true.|) (accessModifier = (	^super accessModifier wrapper: [:mod :ws |		noteRange: mod value asSymbol from: mod start to: mod end.		mod])beginComment = (	^(TokenizingParser withSubparser: super beginComment) wrap:		[:t | self noteRange: #unfinishedComment from: t start to: self inputSize. t].)binaryMsgPattern = (	^super binaryMsgPattern wrapper:		[:sel <Token> :p <Tuple[Token, Token]> |		self pushScope.		self currentScope at: p first value put: #parameter.		self noteRange: #messagePatternDecl from: sel start to: sel end.		self noteRange: #patternArg from: p first start to: p first end].)binarySelector = (	^super binarySelector wrap:		[:t | | kind |		kind:: selector: t value			ifDefined: [#binary]			ifIncomplete: [#incompleteBinary]			ifUndefined: [#undefinedBinary]			ifObsolete: [#obsoleteMessage].		self noteRange: kind from: t start to: t end.		t].)block = (	^super block wrapper:		[:lb :params :cb :rb |		params isNil ifFalse: [params isEmpty ifFalse: [self popScope]].		{lb. params. cb. rb}])blockParameter = (	^super blockParameter wrapper:		[:cn :sd | (* blockParameter ::= colon, slotDecl *)		| kind |		checkBlockParameter: sd first.		kind:: (symbolInScope: sd first value) ifTrue: [#shadowingTempVar] ifFalse: [#blockPatternArg].		noteRange: kind from: sd first start to: sd first end.		sd])blockParameters = (	^super blockParameters wrapper:		[:ps :vb | self pushScope.		ps do: [:p | self currentScope at: p first value put: #parameter].		{ps. vb}])braceLevelString = (	^self braceDepth = 1 ifTrue: [''] ifFalse: [self braceDepth printString])bracketLevelString = (	^self bracketDepth = 1 ifTrue: [''] ifFalse: [self bracketDepth printString])characterConstant = (	^super characterConstant wrap:		[:t | self noteRange: #'$' from: t start to: t end. t].)checkBlockParameter: sd <Token> = (	(coloredText string runeAt: sd start - 1) = 58 ifTrue: [^self].	self noteRange: #whitespaceWarning from: sd start - 1 to: sd start -1)checkKeyword: kwd <Token> = (	kwd end >= inputSize ifTrue: [^self].	(coloredText string runeAt: kwd end + 1) <= 32 ifTrue: [^self].	self noteRange: #whitespaceWarning from: kwd start to: kwd end)public classHeader = (	^super classHeader		wrap:			[:tokens |			(tokens at: 9) = nil ifFalse:				[ | decs |					decs:: (tokens at: 9) size = 3 ifTrue: [						((tokens at: 9) at: 2) ] ifFalse: [(tokens at: 9) at: 3].					decs					do: [:each | noteRange: #slotDecl from: (each at: 2) first start to: (each at: 2) first end ] ].			tokens ])public codeBody = (	^super codeBody wrapper:		[:litMsg :tmps :stmts |		tmps isNil ifFalse: [tmps isEmpty ifFalse: [self popScope]].		{tmps. stmts}])comment = (	^super comment wrap:		[:token | self noteRange: #comment from: token start to: token end].)currentScope = (	self assert: [self scopeStack isEmpty not] message: 'Scope underflow'.	^self scopeStack last)decreaseBraceLevel = (	self braceDepth: (self braceDepth - 1) \\ 7.)decreaseBracketLevel = (	self bracketDepth: (self bracketDepth - 1) \\ 7.)decreaseParenLevel = (	self parenDepth: (self parenDepth - 1) \\ 7.)endComment = (	^(TokenizingParser withSubparser: super endComment) wrap:		[:t | self rangeMap removeLast. t].)extendedCanUnderstand: sel = (	| k |	k: klass.	[k isNil] whileFalse:		[(k canUnderstand: sel) ifTrue: [^true].		 k: k enclosingClass].	klass mixin applications do: [:any | ^any canUnderstand: sel].	^Object canUnderstand: sel)increaseBraceLevel = (	self braceDepth: (self braceDepth + 1) \\ 7.)increaseBracketLevel = (	self bracketDepth: (self bracketDepth + 1) \\ 7.)increaseParenLevel = (	self parenDepth: (self parenDepth + 1) \\ 7.)keywordHereSend = (	^super keywordHereSend wrap:		[:kws | | sel kind |		sel:: String streamContents:			[:s |			kws do: [:kwd |				self rangeMap removeLast.				s nextPutAll: kwd first value]].		kind:: symbol: sel			ifInScope: [#instVar]			ifNotInScope: [#undefinedKeyword]			ifObsolete: [#obsoleteMessage].		kws do:			[:kwp | self noteRange: kind from: kwp first start to: kwp first end]])keywordMsg = (	^super keywordMsg wrapper:		[:esend :kws |		| sel kind |		kws do: [:kwp | checkKeyword: (kwp at: 1)].		sel:: (kws inject: '' into: [:s :kwp | s, (kwp at: 1) value]) asString.		kind:: selector: sel			ifDefined: [#keyword]			ifIncomplete: [#incompleteKeyword]			ifUndefined: [#undefinedKeyword]			ifObsolete: [#obsoleteMessage].		kws do: [:kwp | self noteRange: kind from: kwp first start to: kwp first end]].)keywordMsgPattern = (	^super keywordMsgPattern wrap:		[:kws |		pushScope.		kws do: [:kwp | | kind |			kind:: (symbolInScope: kwp last first value)				ifTrue: [#shadowingTempVar]				ifFalse: [#patternArg].			currentScope at: kwp last first value put: #parameter.			noteRange: #messagePatternDecl from: kwp first start to: kwp first end.			noteRange: kind from: kwp last first start to: kwp last first end]])lbracket = (	^super lbracket wrap:		[:t |		| range |		self increaseBracketLevel.		range:: ('blockStart', self bracketLevelString) asSymbol.		self noteRange: range from: t start to: t end.		t])lcurly = (	^super lcurly wrap:		[:t | | range |		self increaseBraceLevel.		range:: ('leftBrace', self braceLevelString) asSymbol.		self noteRange: range from: t start to: t end.		t])lparen = (	^super lparen wrap:		[:t | | range |		self increaseParenLevel.		range:: ('leftParenthesis', self parenLevelString) asSymbol.		self noteRange: range from: t start to: t end.		t])method = (	| res |	self pushScope.	res:: super method.	self popScope.	^res)nestedClassDecl = (	^super nestedClassDecl wrap:		[:tokens | (* accessModifier opt, classDeclaration*)		noteRange: #className from: ((tokens last) at: 2) start to: ((tokens last) at: 2) end.		tokens])number = (	^super number wrap:		[:t | self noteRange: #number from: t start to: t end. t].)parenLevelString = (	^self parenDepth = 1 ifTrue: [''] ifFalse: [self parenDepth printString])pattern = (	^super pattern wrap:		[:tpl |		self noteRange: #string from: (tpl at: 1) start to: (tpl at: 3) end.		tpl at: 2])popScope = (	self scopeStack removeLast)pushScope = (	self scopeStack addLast: Map new)rbracket = (	^super rbracket wrap:		[:t |		| range |		range:: ('blockEnd', self bracketLevelString) asSymbol.		self decreaseBracketLevel.		self noteRange: range from: t start to: t end.		t])rcurly = (	^super rcurly wrap:		[:t | | range |		range:: ('rightBrace', self braceLevelString) asSymbol.		self decreaseBraceLevel.		self noteRange: range from: t start to: t end.		t])returnStatement = (	^super returnStatement wrapper:		[:h <Token> :expr :od <Token> |		self noteRange: #return from: h start to: h end.		expr].)returnType = (	^super returnType wrapper:		[:h <Token> :t | self noteRange: #type from: h start to: h end. t])rparen = (	^super rparen wrap:		[:t | | range |		range:: ('rightParenthesis', self parenLevelString) asSymbol.		self decreaseParenLevel.		self noteRange: range from: t start to: t end.		t])scopeStack = (	(* deal with forwarding reference *)	cachedScopeStack isCollection		ifFalse: [cachedScopeStack:: List new].	^cachedScopeStack)selector: sel ifDefined: definedAction ifIncomplete: incompleteAction ifUndefined: undefinedAction ifObsolete: obsoleteAction = (	({#isKindOf:. #out. #halt. #inspect. #flag:. #instVarAt:. #isMemberOf:. #~. #!=} includes: sel) ifTrue: [^obsoleteAction value].	Symbol hasInterned: sel ifTrue: [:s | ^definedAction value].	(Symbol thatStartsCaseSensitive: sel skipping: nil) isNil		ifTrue: [^incompleteAction value]		ifFalse: [^undefinedAction value])semicolon = (	^super semicolon wrap:		[:t | self noteRange: #cascadeSeparator from: t start to: t end. t].)setterKeyword = (	^super setterKeyword wrap: [:skw <Token> | | kind |		checkKeyword: skw.		kind:: (self symbolInScope: (skw value copyUpToLast: ":"))			ifTrue: [#instVar]			ifFalse: [#undefinedKeyword].		self noteRange: kind from: skw  start to: skw end.		skw])slotDef = (	^super slotDef wrap:		[:tokens | | sd kind |		sd:: (tokens at: 2) first.		noteRange: #slotDecl from: sd start to: sd end.		(* isFirst ifTrue: [pushScope. isFirst: false]. *)		tokens])slotName = (	^super slotName wrap:		[:n <Token> | | kind |		kind:: ({'self'. 'super'. 'outer'. 'true'. 'false'. 'nil'} includes: n value)			ifTrue: [n value asSymbol]	        ifFalse: [symbol: n value				ifInScope: [#instVar]				ifNotInScope: [#undefinedUnary]				ifObsolete: [#obsoleteMessage]].		noteRange: kind from: n start to: n end.		n])string = (	^super string wrap:		[:t | self noteRange: #string from: t start to: t end. t])symbol: aString <String> ifInScope: inScopeAction ifNotInScope: notInScopeAction ifObsolete: obsoleteAction = (	scopeStack do: [:s | (s includesKey: aString) ifTrue: [^inScopeAction value]].	Symbol hasInterned: aString ifTrue: [:sel <Symbol> |		scopeStack do: [:s | (s includesKey: sel) ifTrue: [^inScopeAction value]].		(extendedCanUnderstand: sel) ifTrue: [			(ImplementationBase canUnderstand: sel)				ifTrue: [^obsoleteAction value]				ifFalse: [^inScopeAction value]]].	^notInScopeAction value)symbolConstant = (	^super symbolConstant wrapper:		[:p <Token> :s |		self noteRange: #symbol from: p start to: s end.		s].)symbolInScope: aString <String> ^ <Boolean> = (	scopeStack do: [:s | (s includesKey: aString) ifTrue: [^true]].	^Symbol hasInterned: aString ifTrue: [:sel <Symbol> |		scopeStack do: [:s | (s includesKey: sel) ifTrue: [^true]].		(extendedCanUnderstand: sel) ifTrue: [^true].		^false])tempSlotDef = (	^super slotDef wrap: [:tokens | | sd kind |		sd:: (tokens at: 2) first.		noteRange: #slotDecl from: sd start to: sd end.		isFirst ifTrue: [pushScope. isFirst: false].		kind:: (symbolInScope: sd value) ifTrue: [#shadowingTempVar] ifFalse: [#tempVar].		currentScope at: sd value put: #temporary.		currentScope at: sd value, ':' put: #temporary.		noteRange: kind from: sd start to: sd end.		tokens])temporaries = (	|	tempSlotDefs = tempSlotDef star. 	tempSeqSlotDecls = vbar, tempSlotDefs, vbar. 	tempSimSlotDecls = vbar, vbar, tempSlotDefs, vbar, vbar. 	tempSlotDecls = tempSimSlotDecls | tempSeqSlotDecls.	|	^tempSlotDecls wrap:		[:parts | | vb1 vb2 vds vb3 vb4 |		parts size = 3			ifTrue:				[vb1:: parts at: 1.				vb2:: vb1.				vds:: parts at: 2.				vb3:: parts at: 3.				vb4:: vb3]			ifFalse:				[vb1:: parts at: 1.			vb2:: parts at: 2.			vds:: parts at: 3.			vb3:: parts at: 4.			vb4:: parts at: 5].		isFirst: true.		noteRange: #methodTempBar from: vb1 start to: vb2 end.		noteRange: #methodTempBar from: vb3 start to: vb4 end.		vds])type = (	^super type wrapper:		[:lb :te :rb | self noteRange: #type from: lb start to: rb end. te])unaryMsgPattern = (	^super unaryMsgPattern wrap:		[:sel <Symbol> |		self noteRange: #messagePatternDecl from: sel start to: sel end.		sel].)unarySelector = (	^super unarySelector wrap:		[:t | | kind |		kind:: selector: t value			ifDefined: [#unary]			ifIncomplete: [#incompleteUnary]			ifUndefined: [#undefinedUnary]			ifObsolete: [#obsoleteMessage].		self noteRange: kind from: t start to: t end.		t].)variableName = (	^super variableName wrap:		[:n <Token> |		n value = 'self' ifTrue: [self noteRange: #self from: n start to: n end]		ifFalse: [n value = 'super' ifTrue: [self noteRange: #super from: n start to: n end]		ifFalse: [n value = 'true' ifTrue: [self noteRange: #true from: n start to: n end]		ifFalse: [n value = 'false' ifTrue: [self noteRange: #false from: n start to: n end]		ifFalse: [n value = 'nil' ifTrue: [self noteRange: #nil from: n start to: n end]		ifFalse: []]]]].		n])) : ()) : ()