Newspeak3
'HopscotchIDE'
class SimpleBrowsing usingPlatform: p ide: webIde = (
(* An IDE for Newspeak on the web.
    Copyright 2016-2017 Google Inc.
*)
|	(* imports *)
	StringBuilder = p kernel StringBuilder.
	Subject = p hopscotch core Subject.
	Presenter = p hopscotch core Presenter.
	TextEditorFragment = p hopscotch fragments TextEditorFragment.
	Color = p graphics Color.
	Gradient = p hopscotch Gradient.
	List = p collections List.
	Map = p collections Map.
	ClassMirror = p mirrors ClassMirror.
	ObjectMirror = p mirrors ObjectMirror.
	ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	JSObject = p js global at: 'Object'.
	JSMath = p js global at: 'Math'.
		(* module variables *)
	ide = webIde.
	detailAreaRatio = 3 asFloat.
	captionColor = Color h: 240 s: 0.05 asFloat v: 0.9 asFloat.
	cssConverter = cssConversionTable.
|
) (
public class BitOfWisdom text: s <String> actionLabel: l <String> actionBlock: b <[]> image: i = (|
	public text <String> = s.
	public image = i.
	public actionLabel <String> = l.
	public actionBlock <[]> = b.
|) (
) : (
public text: s <String> ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: nil
)
public text: s <String> actionLabel: l <String> actionBlock: b <[]> ^ <BitOfWisdom> = (
	^self
		text: s
		actionLabel: l
		actionBlock: b
		image: nil
)
public text: s image: i ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: i
)
)
class ClassCommentPresenter onSubject: s <ClassSubject> = ProgrammingPresenter onSubject: s (
|
  editor
  isEditing ::= false.
  showPartialIfLong ::= true.
  showingPartial
|
) (
= anotherPresenter = (
	^self == anotherPresenter
)
definition = (
	^holder:
		[isEditing
			ifTrue: [editorDefinition]
			ifFalse: [viewerDefinition]]
)
definitionText = (
	(* In this class, only used by the editor side of the presenter to get the text to show in the editor. *)

	^fullCommentText
)
editorDefinition = (
	editor:: TextEditorFragment new.
	editor
		text: definitionText;
		cancelResponse: [respondToCancel];
		acceptResponse: [respondToAccept];
		enterEditState.
	^editor
)
enterEditState = (
	isEditing:: true.
	refresh
)
fullCommentText = (
	^subject classCommentText asString
)
hash = (
	^self identityHash
)
public leaveEditState = (
	isEditing:: false.
	refresh
)
maybePartialCommentText ^<String> = (
  ^fullCommentText size > 500 ifTrue: [
	showingPartial:: true.
	subject classCommentSummary
	] ifFalse: [
	showingPartial:: false.
	fullCommentText
	]
)
presentationDefinition = (
	| textToDisplay |
	textToDisplay:: retrieveComment.
	textToDisplay isEmpty ifTrue:
		[textToDisplay:: '(no comment)'].
	^column:
		{textDisplay: textToDisplay.
		showingPartial
			ifTrue: [(link: 'show full comment' action: [showFullComment])]
			ifFalse: [(link: 'hide full comment' action: [showLessComment])].
		}
)
respondToAccept = (
	subject classCommentText: editor textBeingAccepted. leaveEditState.
)
respondToCancel = (
	leaveEditState
)
respondToEdit = (
	enterEditState
)
retrieveComment ^<String> = (
	(* Get the text to display--either the whole thing or the first paragraph, depending on the text and the settings--and set the showingPartial slot accordingly. *)

	^showPartialIfLong
		ifTrue:
			[maybePartialCommentText]
		ifFalse:
			[showingPartial:: false.
			fullCommentText]
)
showFullComment = (
	showPartialIfLong:: false.
	refresh
)
showLessComment = (
	showPartialIfLong:: true.
	refresh
)
viewerDefinition = (
^
	row: {
		elastic:
			presentationDefinition.
		smallBlank.
		(* linkImage:  editImage action: [respondToEdit]*)
		}
)
) : (
)
class ClassEntryPresenter onSubject: s <ClassSubject> = EntryPresenter onSubject: s () (
accessIndicator = (
	^image: (iconForAccessModifier: subject accessModifier).
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
collapsedDefinition = (
	| part |
	#BOGUS. 	(* BOGUS: we are displaying the class's name. we should display its key *)
	part:: row1: {
		image: ide images classIcon.
		smallBlank.
		accessIndicator.
		smallBlank.
		row: {link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror]}.
	} row2: {
		(row: {deferred: [(label: subject classCommentSummary)
			smallFont;
			color: secondaryTextColor]})
				compressibility: 1.
		filler
			compressibility: 0.

		(* In the face of namespace nesting, should application and test configuration be invoked with the root namespace or the local namespace? If the local namespace, these links only make sense in the context of the namespace view and should not be part of the class presenter itself. *)
		(*ClassActionsPresenter onSubject: subject.*)
		mediumBlank.
		entryActionsMenu.
	}.
	(* subject isRecentlyVisited ifTrue: [part color: recentlyVisitedColor]. *)
	^part
)
entryActionsMenu = (
	^nothing
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class ClassFactoryPresenter onSubject: s <ClassFactorySubject> = MethodPresenter onSubject: s (
(* WIP. Present the factory method, colorized *)
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		b addFactoryFromSource: ed textBeingAccepted.
		b declaration install.
		colorizeHeaderSource: (crToLf: ed textBeingAccepted).
		ed leaveEditState.
		]
)
colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeHeader: s fromClass: subject classDeclaration via: (colorizingBlockFor: cm)
)
colorizeMethodSource: s <String> ^ <TextFragment> = (
	^text: (ide colorizer parseClassHeader: s fromClass: subject classDeclaration)
)
) : (
)
class ClassFactorySubject onModel: m <ClassDeclarationMirror> = MethodSubject onModel: m (
(* WIP. *)
) (
public accessModifier ^ <Symbol> = (
	^#public
)
public createPresenter ^ <ClassFactoryPresenter> = (
	^ClassFactoryPresenter onSubject: self
)
) : (
)
class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
|
descriptionOrSourceSwitcherHolder
descriptionOrSourceHolder
|
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <ClassDeclarationBuilder> = subject classMirror declaration asBuilder. |
		(*('ed text:', ed textBeingAccepted) out.*)
		b header source: ed textBeingAccepted.
		b install.
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed leaveEditState.
		]
)
accessIndicator = (
	^image: (iconForAccessModifier: subject accessModifier).
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event>  |  | cp <Integer> |
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed enterEditState.
	  ]
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
classDescriptionDefinition = (
	| slotList <Fragment> |
	^column: {
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
           (slotList:: subject classMirror instanceSide slots) size > 0
		   ifTrue: [
			column: {
				label: 'Slots'.
				row: {
					mediumBlank.
					column: (slotList collect: [:ea | label: ea name]).
				}
			}.
		] ifFalse: [nothing].
		initializerDefinition.
		}
)
classNameAndContainmentDefinition ^ <Fragment> = (
	| parts <List[Fragment]> |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^(column: {
		row: {blank: 5. image: ide images classIcon. blank: 5. row: parts. filler. homeButton}.
		inspectSelf.
		preambleLine.
		label: subject classCommentSummary.
	      }
	)		
)
classSourceDefinition = (
	| src = crToLf: subject classHeaderSource. editor =  codeMirror: src. |
	editor changeResponse: changeResponse;
		acceptResponse: acceptResponse.
	colorizeHeaderSource: src withEditor: editor.
	^editor
)
collapsedHeadingDefinition = (
	^row: {
		blank: 5.
		image: ide images classIcon.
		blank: 5.
		link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror (* Why do we need a copy? *)]
		}.
)
colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeHeader: s fromClass: subject classMirror via: (colorizingBlockFor: cm)
)
colorizeMethodSource: s <String> ^ <TextFragment> = (
	^text: (ide colorizer parseClassHeader: s fromClass: subject classMirror)
)
public definition ^ <Fragment> = (
	^column: {
		headingDefinition.
		sectionLabelled: 'Classes' presenting: subject nestedClassesSubject.
		sectionLabelled: 'Methods' presenting: subject methodsSubject.
		sectionLabelled: 'Class Methods' presenting: subject classMethodsSubject.
	}
)
expandedHeadingDefinition ^ <Fragment> = (
	|  slotList <Fragment> |
	^(column: {
		blank: 5.
		classNameAndContainmentDefinition.
		blank: 15.
		descriptionOrSourceSwitcherHolder:: holder: (switcherShowingSource: false).
		(row: {}) color: (Color gray: 0.8).
		mediumBlank.
		descriptionOrSourceHolder:: holder: (classDescriptionDefinition)
	})
)
headingDefinition ^ <Fragment> = (
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [collapsedHeadingDefinition].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
initializerDefinition ^ <Fragment> = (
	^nothing
)
inspectSelf ^ <Fragment> = (
	^row: {filler. link: 'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
minorClassHeadingBlock: body = (
	^(padded: body with: {10. 5. 10. 5.})
		color: minorClassHeadingColor
)
minorClassHeadingColor = (
	^Gradient
		from: (Color h: 240 s: 0.02 v: 0.94)
		to: (Color h: 240 s: 0.02 v: 0.9)
)
nestedClass: cdm = (
	^collapsed: [row: {
					image: (iconForAccessModifier: cdm accessModifier).
					blank: 3.
					link: cdm simpleName action: [enterSubject:: ClassSubject onModel: cdm]
					}
				]
	expanded: [(ClassSubject onModel: cdm) presenter]
)
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble <String> equalIndex <Integer> prefix <String> suffix <String> |
	preamble:: subject classMirror header preamble.
	equalIndex:: preamble indexOf: "=".
	equalIndex = 0
		ifTrue:
			[prefix:: preamble.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1).
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)].
	^suffix isEmpty
		ifTrue:
			[label: prefix]
		ifFalse:
			[row: {
				label: prefix, ' = '.
				link: suffix action: [respondToBrowseSuperclass]
				}]
)
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> = (
	| groupPresenter |
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				}
			).
		groupPresenter:: groupSubject presenter.
		}
)
switchToDescription = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: false).
	descriptionOrSourceHolder content: classDescriptionDefinition.
)
switchToSource = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: true).
	descriptionOrSourceHolder content: classSourceDefinition.
	descriptionOrSourceHolder refresh.
)
switcherShowingSource: showingSourceNow <Boolean> ^ <Fragment> = (
	^showingSourceNow
		ifTrue:
			[row: {
				(link: 'Description' action: [switchToDescription]).
				mediumBlank.
				(label: 'Source').
			}]
		ifFalse:
			[row: {
				(label: 'Description').
				mediumBlank.
				(link: 'Source' action: [switchToSource]).
			}]
)
) : (
)
public class ClassSubject onModel: m <ClassDeclarationMirror> = Subject onModel: m (
) (
public accessModifier = (
	^classMirror accessModifier
)
public classCommentSummary ^ <String> = (
	|
	fullComment <String> = classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
public classCommentText ^<String> = (
	| comment = model header classComment. |
	nil = comment ifTrue: [^''].
	^comment
)
public classHeaderSource = (
	^classMirror header source
)
public classMethodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror classSide methods within: classMirror classSide
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model
)
public createPresenter = (
	^ClassPresenter onSubject: self
)
public enclosingClassSubjects = (
	| them = List new. c |
	c:: model.
	[c isNil] whileFalse: [them add: (ClassSubject onModel: c). c:: c enclosingClass].
	^them
)
public methodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror instanceSide methods within: classMirror instanceSide
)
public name = (
	^model name
)
public nestedClassesSubject ^ <NestedClassGroupSubject> = (
	^NestedClassGroupSubject onModel: classMirror instanceSide nestedClasses within: classMirror instanceSide
)
public title = (
	^name
)
) : (
)
public class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* DefinitionListPresenter is an abstract superclass of presenters that displays helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added or residue presenters of removed methods. *)
| 
prefixes <PresenterList> 
content <PresenterList> 
suffixes <PresenterList> 
|
) (
public collapseAll = (
	(* Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each collapse]
		(*]*)
)
contentList ^ <PresenterList> = (
	^list: [contentPresenters]
)
contentPresenters ^ <List[Presenter]> = (
	^List new
)
definition ^ <Fragment> = (
	prefixes:: list.
	content:: contentList.
	suffixes:: list.
	^column: {
		prefixes.
		content.
		suffixes.
		}
)
public expandAll = (
	(* Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each expand]
		(*]*)
)
) : (
)
public class DefinitionTemplate
   caption: c <String>
   initialText: t <String | Text>
   colorizerBlock: cb <[:String :CodeMirrorFragment]>
   acceptResponse: onAccept <[DefinitionTemplate]>
   cancelResponse: onCancel <[DefinitionTemplate]>
 = ProgrammingPresenter onSubject: nil (|
	public caption = c.
	public initialText = t.
	public initiallyInEditState ::= true.
	public acceptResponse = onAccept.
	public cancelResponse = onCancel.
	public editor
	public colorizerBlock = cb.
|) (
definition ^ <Fragment> = (
	^(row: {
		mediumBlank.
		elastic:
			(column: {
				smallBlank.
				label: caption.
				editorDefinition.
				mediumBlank.
 			}).
		smallBlank.
		}) color: (Gradient from: (Color h: 100 s: 0.3 v: 0.9) to: (Color h: 100 s: 0.3 v: 0.8))
)
editorDefinition ^ <Fragment> = (
	editor:: (codeMirror: initialText)
	(*	acceptLabelText: 'save';
		cancelLabelText: 'cancel';*)
		acceptResponse: [acceptResponse value: self];
		changeResponse: [:cm <CodeMirrorFragment> :event <Event>  | colorizerBlock value: cm textBeingAccepted value: cm];
		cancelResponse: [cancelResponse value: self].
	initiallyInEditState ifTrue: [editor enterEditState].
	colorizerBlock value: initialText value: editor.
	^editor
)
public text = (
	^editor textBeingAccepted
)
) : (
)
class EntryPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public collapse = (
	substance collapse
)
definition = (
	^collapsed: [collapsedDefinition] expanded: [expandedDefinition]
)
public expand = (
	substance expand
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.
	}
)
) : (
)
public class EvaluationPresenter onSubject: s <ObjectSubject | ActivationSubject> = ProgrammingPresenter onSubject: s (
	|
	resultHolder
	|
) (
definition = (
	^column: {
		editorDefinition.
		resultHolder:: holder: [nothing].
	}
)
editorDefinition ^ <CodeMirrorFragment> = (
	| initialSource cm <CodeMirrorFragment> |
	initialSource:: ''.
	cm:: (codeMirror: initialSource) changeResponse:
		[:editor <CodeMirrorFragment>  |
		| src <String> =  editor textBeingAccepted. |
		resultHolder content: (evaluate: (withoutNbsp: src)).
		ide colorizer colorizeDoIt: src fromClass: nil via: (colorizingBlockFor: editor)].
	ide colorizer colorizeDoIt: initialSource fromClass: nil via: (colorizingBlockFor: cm).
	^cm
)
evaluate: expression <String> ^<Fragment> = (
	| thread <ThreadMirror> |
	expression isEmpty ifTrue: [^nothing].
	
	[thread:: subject evaluate: expression]
		on: Error do: [:e | ^linkForCompileError: e].

	thread isFulfilled ifTrue: [^linkForResult: thread].
	thread isBroken ifTrue: [^linkForError: thread].
	^nothing
)
linkForCompileError: error <Exception> = (
	^column: {
		smallBlank.
		(link: error printString action:
			[inspectObjectMirror: (ObjectMirror reflecting: error)])
				color: (Color r: 1 g: 0 b: 0).
	}
)
linkForError: thread <ThreadMirror> = (
	^column: {
		smallBlank.
		(link: thread result reflectee printString action:
			[enterSubject:: ide debugging ThreadSubject onModel: thread])
				color: (Color r: 1 g: 0 b: 0).
	}
)
linkForResult: thread <ThreadMirror> = (
	^column: {
		smallBlank.
		(link: thread result reflectee printString action:
			[enterSubject:: ObjectSubject onModel: thread result]).
	}
)
withoutNbsp: string = (
	('a' at: 1) isKindOfInteger
		ifTrue:
			[ | bytes = ByteArray withAll: string. |
			1 to: bytes size do: [:index | (bytes at: index) = 160 ifTrue: [bytes at: index put: 32]].
			^bytes asString]
		ifFalse:
			[ | nonbreakingSpace = String fromRune: 160.
			space = String fromRune: 32. |
			^string replaceAll: nonbreakingSpace with: space]
)
) : (
)
class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
column1: definitions1 column2: definitions2 column3: definitions3 = (
	^row: {
		(column: definitions1) width: 0 elasticity: 1.
		(column: definitions2) width: 0 elasticity: 1.
		(column: definitions3) width: 0 elasticity: 1.
	}
)
definition = (
	^column: {
		majorHeadingBlock: (label: 'Navigation').
		mediumBlank.

		indentedBlock:
			(column1: {
				link: 'Newspeak Source' action: [navigateToNamespace].
			}
			column2: {
				link: 'Workspaces' action: [navigateToWorkspaces].
			}
			column3: {
			}).
		mediumBlank.

(*		majorHeadingBlock: (label: 'Recently Visited' asText allBold).
		mediumBlank.
		indentedBlock:
			(holder: [recentStuffDefinition]).
		largeBlank.*)

		majorHeadingBlock: (label: 'Did you know?').
		mediumBlank.

		indentedBlock:
			(holder: [didYouKnow]).
	}
)
didYouKnow = (
	| wisdom |
	wisdom:: subject randomBitOfWisdom.
	nil = wisdom actionLabel ifFalse:
		[^textAndActionWisdom: wisdom].
	nil = wisdom image ifFalse:
		[^textAndImageWisdom: wisdom].
	^textDisplay: wisdom text
)
navigateToNamespace = (
	enterSubject:: NamespaceSubject new.
)
navigateToWorkspaces = (
	enterSubject:: ide theWorkspaceManager AllWorkspacesSubject new.
)
textAndActionWisdom: wisdom = (
	^column: {
		textDisplay: wisdom text.
		(link: wisdom actionLabel action: wisdom actionBlock) smallFont
	}
)
textAndImageWisdom: wisdom = (
	^row: {
		image: wisdom image.
		mediumBlank.
		elastic:
			(textDisplay: wisdom text).
	}
)
) : (
)
public class HomeSubject onModel: m = Subject onModel: m () (
public = anotherSubject <Subject> ^ <Boolean> = (
	(* As there is just one possible logical home of the system, all subjects representing it are considered equal. *)
	^anotherSubject isKindOfHomeSubject
)
bitsOfWisdom = (
	(* This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random. *)
	^{
	[BitOfWisdom
		text: 'This is the "expand all" button which appears in headers of expandable item groups.'
		image: ide images expandImage].

	[BitOfWisdom
		text: 'This is the "collapse all" button which appears in headers of expandable item groups.'
		image: ide images collapseImage].

	[BitOfWisdom
		text: 'This is the "add" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'
		image: ide images addImage].

	[BitOfWisdom
		text: 'Expressions evaluated in debuggers and inspectors can access a workspace via the name _. This allows you to bypass modularity during development and access values you forgot to import, e.g. _ collections List.'].

	[BitOfWisdom
		text: 'This icon identifies Newspeak classes.'
		image: ide images classIcon].

	[BitOfWisdom
		text: 'This icon identifies namespaces.'
		image: ide images classPresenterIcon].

	[BitOfWisdom
		text: 'War is peace. Freedom is slavery. Ignorance is strength.'].
	}
)
public createPresenter = (
	^HomePresenter onSubject: self
)
public isKindOfHomeSubject ^ <Boolean> = (
	^true
)
public randomBitOfWisdom = (
	| bits = bitsOfWisdom. |
	^(bits at: (JSMath random * bits size) floor asInteger + 1) value
)
public title = (
	^'Home'
)
) : (
public new = (
	^onModel: nil
)
)
class MethodGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)
| groupedByCategory <Boolean> ::=false. |
) (
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	addNewItemTemplate: subject methodTemplateText
)
addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template |
	template:: DefinitionTemplate
		caption: 'Adding new method:'
		initialText: src
		colorizerBlock: [:text <String> :cm <CodeMIrrorFragment> | subject colorizeSource: text editor: cm]
		acceptResponse:
			[:ed | createNewMethodFromTemplate: template]
		cancelResponse:
			[:ed | prefixes remove: template].
	prefixes add: template.
	prefixes refresh.
	^template
)
createNewMethodFromTemplate: template <DefinitionTemplate> = (
	subject
		compileSource: template text
		ifSuccess:
			[:newMethod <MethodMirror> |
			| 
			newSubject <MethodSubject> = MethodSubject onModel: newMethod. 
			newPresenter <MethodPresenter> = newSubject presenter.
			|
			prefixes remove: template.							
			content add: newPresenter; refresh.		
			newPresenter expand.			
			]
		ifFailure: [:message | template editor showMessage: message out]
)
public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteMethodWithSubject: presenter subject.
	successResponse value
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
(* A subclass must redefine this to define the class of presenter it will be using. *)
	^MethodPresenter
)
) : (
)
public class MethodGroupSubject onModel: m <MirrorGroup[MethodMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (
(* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)
) (
public colorizeSource: s <String> editor: cm <CodeMirrorFragment> ^ <TextFragment> = (
	^ide colorizer colorizeMethod: s fromClass: definingMixin declaration via: (colorizingBlockFor: cm)
)
public compileSource: s <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newMirror <MethodMirror> |
	builder:: definingMixin asBuilder.
	newMirror:: builder methods addFromSource: s.
	builder declaration install.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public createPresenter = (
	^MethodGroupPresenter onSubject: self
)
public deleteMethodWithSubject: methodSubject <MethodSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder methods removeMirrorNamed: methodSubject selector.
	builder declaration install.
)
elementSubjectClass ^ <MethodSubject class> = (
	^MethodSubject
)
public methodTemplateText ^ <String> = (
^
'messageSelector = (
)'
)
modelMirrorCollection ^ <Collection[MethodMirror]> = (
	^super modelMirrorCollection (*asSortedList: [:a :b | a simpleName < b simpleName]*)
)
) : (
)
class MethodPresenter onSubject: s <MethodSubject> = ProgrammingPresenter onSubject: s (
(* A presenter for a single method. *)
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		(*('ed text:', ed textBeingAccepted) out.*)
		b methods addFromSource: ed textBeingAccepted.
		b declaration install.
		colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed leaveEditState.
		]
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> | | cp <Integer> |
		colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed enterEditState.
	 ]
)
public collapse = (
	^substance collapse
)
colorizeMethodSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeMethod: s fromClass: subject classDeclaration via: (colorizingBlockFor: cm)
)
public definition ^ <Fragment> = (
	| toggle |
	toggle::
		collapsed: [row: {
			image: (iconForAccessModifier: subject accessModifier).
			blank: 3.
			(link: subject name action: [toggle expand]) color: actionLinkColor.
	        filler.
	        dropDownMenu: [methodMenuFor: subject name]
			}
		]
		expanded: [ |  src = crToLf: subject source. cm = codeMirror: src. |
			cm changeResponse: changeResponse; acceptResponse: acceptResponse.
			colorizeMethodSource: src withEditor: cm.
			column: {
			row: {
			  image: (iconForAccessModifier: subject accessModifier).
			  blank: 3.
			  (link: subject name action: [toggle collapse]) color: actionLinkColor.
	          filler.
	          dropDownMenu: [methodMenuFor: subject name]
			}.
			cm
		}].
	^toggle
)
public expand = (
	^substance expand
)
methodMenuFor: methodName <String> = (
	^menuWithLabelsAndActions: {
		{'Delete ', methodName. [subject delete.  refresh]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}
)
) : (
)
public class MethodSubject onModel: mm <MethodMirror> = Subject onModel: mm (
(* Manages the UI for a method. *)
) (
public accessModifier ^ <Symbol> = (
	^methodMirror accessModifier
)
public classDeclaration ^ <ClassDeclarationMirror> = (
	^methodMirror definingMixin declaration
)
public createPresenter ^ <Presenter> = (
	^MethodPresenter onSubject: self
)
public delete = (
	| b <MixinBuilder> = methodMirror definingMixin asBuilder. |
	('Deleting ', name) out.
	b methods removeMirrorNamed: methodMirror name.
	b declaration install.
)
public methodMirror ^ <MethodMirror> = (
	^model
)
public name ^ <Symbol> = (
	^methodMirror name
)
public source ^ <String> = (
	^methodMirror source
)
) : (
)
class MirrorGroupPresenter onSubject: s <Subject> = DefinitionListPresenter onSubject: s (
) (
public addNewItemTemplate = (
	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)

	subclassResponsibility
)
contentPresenters ^ <Collection[ProgrammingPresenter]> = (
	^subject elements collect:
		[:each <ProgrammingPresenter> | createPresenterForSubject: each]
)
createPresenterForSubject: aSubject <Subject> ^ <ProgrammingPresenter> = (
	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)
	nil = elementPresenterClass ifTrue: [^aSubject presenter].
	^elementPresenterClass onSubject: aSubject
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
(* A subclass must redefine this to define the class of presenter it will be using. *)
	subclassResponsibility
)
) : (
)
class MirrorGroupSubject onModel: m <MirrorGroup> within: dm <MixinMirror> = Subject onModel: m (
	|
	public definingMixin <MixinMirror> = dm.
	|
) (
elementSubjectClass = (
	(* Answer the class of the subjects we create on individual elements of our subject group. *)
	subclassResponsibility
)
public elements ^<Collection[Subject]> = (
	(* Answer a collection of subjects on individual elements of the group which is our subject. *)
	^modelMirrorCollection collect: [:each | elementSubjectClass onModel: each]
)
public mirrorGroup ^ <MirrorGroup> = (
	^model
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^List withAll: model
)
) : (
)
class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (
) (
class ClassEntryPresenter onSubject: s <ClassSubject> = outer SimpleBrowsing ClassEntryPresenter onSubject: s () (
accessIndicator = (
	^nothing
)
entryActionsMenu = (
	^dropDownMenu: [entryActionsMenuFor: subject name].
)
) : (
)
class NamespaceEntryPresenter onSubject: s = EntryPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
		image: ide images classPresenterIcon.
		smallBlank.
		row: {link: subject key action: [
			(*ide defaultPopularityRecord
			rememberNamespaceVisit: subject key. (* Should be the namespace itself, but non-strings break the home page. *)*)
			enterSubject:: subject refreshmentSubject]}.
	} row2: {
		(label: subject summaryText)
				smallFont;
				compressibility: 1;
				color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject key]
	}.
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class ValueEntryPresenter onSubject: s = EntryPresenter onSubject: s (|
	public key
|) (
collapsedDefinition = (
	^row1: {
		image: ide images classUnknownIcon.
		smallBlank.
		link: key action: [enterSubject:: subject].
	} row2: {
		(label: subject title)
			smallFont;
			compressibility: 1;
			color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: key]
	}
)
definition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^collapsed: [collapsedDefinition]
	expanded: [subject presenter selfCaption: key]
)
expandedDefinition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^subject presenter selfCaption: key
)
) : (
)
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor text: msg]
)
acceptNewNamespaceDefinitionFrom: aTemplate = (
	subject
		addNamespaceFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor text: msg]
)
addCategoryMenu = (
	^ {
		{'Add Class'. [addClassTemplate]}.
		{ 'Add Namespace'. [addNamespaceTemplate]}.
		(*{'Add Image From File'. [respondToAddImage].}.
		{'Add Text From File'. [respondToAddText]}.
		 'Add Value' -> [Error signal: 'Unimplemented']. *)
	}
)
addClassTemplate = (
	prefixes add:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock: [:text <String> :cm <CodeMIrrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | prefixes remove: template]).
	 prefixes refresh.
)
addNamespaceTemplate = (
	prefixes add:
		(DefinitionTemplate
			caption: 'Defining a new namespace:'
			initialText: 'NewNamespace'
			colorizerBlock: [:text <String> :cm <CodeMIrrorFragment> | ]
			acceptResponse:
				[:template | acceptNewNamespaceDefinitionFrom: template]
			cancelResponse:
				[:template | prefixes remove: template])
)
contentList ^ <PresenterList> = (
	^zebra: super contentList
)
contentPresenters ^ <List[Presenter]> = (
	| lexicalOrder <[:Symbol :Symbol | Boolean]> |
	lexicalOrder:: [:a <Symbol> :b <Symbol> |
		lexicallyLessOrEqual: a than: b
	].
	^(subject namespace keys asArray sort: lexicalOrder) collect: [:key | presenterForEntryAt: key]
)
definition ^ <Fragment> = (
	^column: {
		minorHeadingBlock: (row: {
			label: subject key (*asText allBold*).
			largeBlank.
			(*subject namespace isKindOfCategoryNamespace
				ifTrue: [*)addButtonWithMenu: [addCategoryMenu](*]
				ifFalse: [addButtonWithAction: [respondToAddForRoot]]*).
			filler.
			expandButtonWithAction: [expandAll].
			blank: 3.
			collapseButtonWithAction: [collapseAll].
			blank: 3.
			dropDownMenu: [namespaceMenu].
			largeBlank.
			homeButton.
		}).
		smallBlank.
		super definition.
	}
)
entryActionsMenuFor: key = (
	^menuWithLabelsAndActions: {
		{'Remove ', key. [ide namespacing removeKey: key.  refresh]}.
	}
)
lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (
	(* BOGUS: This should be a utility somewhere *)
	| length = a size min: b size. |
	('a' at: 1) isKindOfInteger ifTrue: 
		[1 to: length do:
			[:index |
			 (a at: index) < (b at: index) ifTrue: [^true].
			 (a at: index) > (b at: index) ifTrue: [^false]].
		^true].

	1 to: length do:
		[:index |
		 (a runeAt: index) < (b runeAt: index) ifTrue: [^true].
		 (a runeAt: index) > (b runeAt: index) ifTrue: [^false]].
	^true
)
namespaceMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
presenterForEntryAt: key <Symbol> ^ <EntryPresenter> = (
	| entry = subject namespace at: key. |
	entry isKindOfBehavior
		ifTrue: [^ClassEntryPresenter onSubject: (ClassSubject onModel: (ClassMirror reflecting: entry) mixin declaration)].

	entry isKindOfNamespace
		ifTrue: [^NamespaceEntryPresenter onSubject: (NamespaceSubject onModel: entry key: key)].

	^(ValueEntryPresenter onSubject: (objectSubjectFor: entry)) key: key
)
respondToAddForRoot = (
	openMenuWithLabelsAndActions: {
		{'Add Namespace'. [addNamespaceTemplate]}.
	}
)
respondToAddImage = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key form |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		form:: PNGReadWriter formFromFileNamed: fn.
		subject namespace at: key asSymbol put: form.
	].
)
respondToAddText = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key text |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		text:: ((MultiByteFileStream oldFileNamed: fn)
			converter: (TextConverter newForEncoding: 'utf8')) contents.
		subject namespace at: key asSymbol put: text.
	].
)
) : (
)
public class NamespaceSubject onModel: m <Map[Symbol, Object]> key: k <Symbol> = Subject onModel: m (|
	public key = k.
|ide namespacing refreshCategoryNamespaces) (
public = other ^<Boolean> = (
	^class = other class (* class is not public *)
		and: [namespace = other namespace]
		and: [key = other key].
)
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| builder <ClassDeclarationBuilder> mixin <MixinMirror> klass |
	('adding top level class: ', definition) out.
	[builder:: ClassDeclarationBuilder fromToplevelSource: definition]
		on: Error
		do: [:ex | ^failureBlock value: ex printString].
	(namespace includesKey: builder simpleName) ifTrue:
		[^failureBlock value: 'A class named ', builder simpleName, ' already exists in this namespace'].
	mixin:: builder install instanceSide.
	klass:: mixin apply: Object withName: builder simpleName.
	namespace at: klass name put: klass reflectee.
	successBlock value
)
public addNamespaceFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| selector <Symbol> = definition asSymbol. |
	(*model = ide namespacing Categories ifFalse: (* ? *)
		[Error signal: 'Not supported yet, only categories for now.'].*)

	(*selector isUnary ifFalse:
		[^failureBlock value: 'Must be a unary selector'].*)
	(namespace includesKey: selector) ifTrue:
		[^failureBlock value: 'A class named ', definition, ' already exists in this namespace'].
	(* ide namespacing categoryNamespace: selector.*)
	namespace at: selector put: (ide namespacing freshNamespace).
	successBlock value
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
|
	slot1
	slot2
|
) ()'
)
public colorizeClassSource: sourceText <String> editor: cm <CodeMirrorFragment>  = (
	^ide colorizer colorizeHeader: sourceText asString
		fromClass: Object mixin
		via: (colorizingBlockFor: cm)
)
public createPresenter ^ <NamespacePresenter> = (
	^NamespacePresenter onSubject: self
)
public hash ^<Integer> = (
	^model hash bitXor: key hash
)
public namespace ^ <Map[Symbol, Object]> = (
	^self model
)
public refreshmentSubject = (
	^self class onModel: model key: key
)
public summaryText = (
	| sb = StringBuilder new. |
	namespace keys
		do: [:k | sb add: k]
		separatedBy: [sb add: ', '].
	^sb asString
)
public title ^<String> = (
	^key
)
) : (
public new = (
	#NAMESPACEBOGUS.
	^self onModel: ide namespacing Root key: 'Root'
)
)
class NestedClassGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, a NestedClassGroupSubject, as a column of presenters for the nested classes in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS nested classes goes here. *)
) (
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[:newClass <ClassDeclarationMirror> |
			| 
			newSubject <ClassSubject> = ClassSubject onModel: newClass. 
			newPresenter <ClassPresenter> = newSubject presenter.
			|
			prefixes remove: aTemplate.
			content add: newPresenter.
			newPresenter expand. (* refresh *)
			]
		ifFailure:
			[:msg | 
			  aTemplate editor text: msg, aTemplate text.
			]
)
public addNewItemTemplate = (
	(* Handle a user's request to create a new nested class by displaying a new class template. *)
	prefixes add:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock: [:text <String> :cm <CodeMIrrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | prefixes remove: template]).
	prefixes refresh
)
public deleteClassInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteClassWithSubject: presenter subject.
	successResponse value
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^ClassEntryPresenter
)
) : (
)
public class NestedClassGroupSubject onModel: m <MirrorGroup[ClassDeclarationMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (
(* Represents the collection of nested classes of a Newspeak class. Holds onto the mirror group for the classes. *)
) (
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[:ClassDeclarationMirror]> ifFailure: failureBlock <[:String]> = (
	| builder <ClassDeclarationBuilder> klass <ClassDeclarationMirror> |
	(* WIP *)
	#BOGUS. (*Creates a new top level class, not a nested one*)
	[builder:: ClassDeclarationBuilder fromSource: definition]
		on: Error
		do: [:ex | ^failureBlock value: ex printString].
	(mirrorGroup includesMirrorNamed: builder simpleName) ifTrue:
		[^failureBlock value: 'A class named ', builder simpleName, ' already exists in this namespace'].
	klass:: builder install.
	(*mirrorGroup addMirror: klass. (*BOGUS. addMirror is not public. Also, either methods lack this or it is not needed*)*)
	successBlock value: klass
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
|
	slot1
	slot2
|
)'
)
public colorizeClassSource: sourceText <String> editor: cm <CodeMirrorFragment> = (
	^ide colorizer colorizeHeader: sourceText asString
		fromClass: Object mixin
		via: (colorizingBlockFor: cm)
)
public createPresenter = (
	^NestedClassGroupPresenter onSubject: self
)
public deleteClassWithSubject: classSubject <ClassSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder nestedClasses removeMirrorNamed: classSubject name.
	builder declaration install.
)
elementSubjectClass ^ <ClassSubject class> = (
	^ClassSubject
)
) : (
)
class ObjectPresenter onSubject: s = ProgrammingPresenter onSubject: s (
	|
	public selfCaption ::= 'self'.
	|
) (
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Mirror'. [respondToInspectMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
	}
)
captionBar: body = (
	^(padded: body with: {5. 5. 5. 5}) color: captionColor
)
classInfoLine = (
	^row: {
		(label: 'class')
			width: 0 elasticity: 1.
		(link: subject className action: [navigateToClass])
			width: 0 elasticity: detailAreaRatio.
	}
)
public definition = (
	^column: {
		captionBar: (column: {
			selfInfoLine.
			enclosingInfoLine.
			classInfoLine.
			smallBlank.
			EvaluationPresenter onSubject: subject.
		}).
		objectDetails.
	}
)
enclosingInfoLine = (
	^row: {
		(label: 'enclosingObject')
			width: 0 elasticity: 1.
		(link: subject enclosingObjectName action: [navigateToEnclosingObject])
			width: 0 elasticity: detailAreaRatio.
	}
)
navigateToClass = (
	enterSubject: subject classSubject.
)
navigateToEnclosingObject = (
	inspectObjectMirror: subject classMirror enclosingObject
)
navigateToSelf = (
	enterSubject: (ObjectSubject onModel: subject objectMirror)
)
objectDetails = (
	^column: ((subject classMirror) slots collect:
		[:slot <SlotDeclarationMirror> |
		 | val <ObjectMirror> = subject objectMirror getSlot: slot name. |
		 (SlotSubject name: slot name value: val) presenter])
)
respondToInspectMirror = (
	inspectObject: subject objectMirror.
)
selfInfoLine = (
	^row: {
		(label: selfCaption (*asText allBold*)) width: 0 elasticity: 1.
		(row: {
			(link: subject title action: [navigateToSelf]) compressibility: 1.
			filler compressibility: 0.
			mediumBlank.
			dropDownMenu: [actionsMenu].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public title = (
	^'Inspector on ', subject title
)
) : (
)
public class ObjectSubject onModel: m = Subject onModel: m (
) (
public classMirror ^<ClassMirror> = (
	^model getClass
)
public className ^<String> = (
	^classMirror mixin name
)
public classSubject = (
	^ClassSubject onModel: classMirror mixin declaration
)
public createPresenter = (
	^ObjectPresenter onSubject: self
)
public enclosingObjectName = (
	^classMirror enclosingObject reflectee printString
)
public evaluate: expression <String> ^<ThreadMirror> = (
	^objectMirror evaluate: expression
)
public objectMirror ^<ObjectMIrror> = (
	^model
)
public title = (
	^objectMirror reflectee printString
)
) : (
)
public class ProgrammingPresenter onSubject: s <Subject> = Presenter onSubject: s (
(* Common superclass for presenters of programming constructs. *)
) (
actionLinkColor = (
	^Color black
)
addButtonWithAction: aBlock = (
	^imageButton:
		{ide images addImage.
		ide images addOverImage.
		ide images addOutImage}
	action: aBlock
)
addButtonWithMenu: menu = (
	^dropDownMenu: menu
		images: {
		   ide images addImage.
		   ide images addOverImage.
		   ide images addOutImage
		}
)
browseMixinMirror: mixin <MixinMirror> = (
	enterSubject:: ClassSubject onModel: mixin declaration.
)
collapseButtonWithAction: aBlock = (
	^imageButton:
		{ide images collapseImage.
		 ide images collapseOverImage.
		 ide images collapseDownImage}
	action: aBlock
)
expandButtonWithAction: aBlock = (
	^imageButton:
		{ide images expandImage.
		 ide images expandOverImage.
		 ide images expandDownImage}
	action: aBlock
)
homeButton = (
	^imageButton: {
		ide images homeImage.
		ide images homeOutImage.
		ide images homeOverImage.
		ide images homeDownImage
		}
		action: [enterSubject: HomeSubject new].
)
iconForAccessModifier: am = (
	#private = am ifTrue: [^ide images privateAccessImage].
	#protected = am ifTrue: [^ide images protectedAccessImage].
	^ide images publicAccessImage
)
indentedBlock: body = (
	^column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		}
)
inspectObject: object <Object> = (
	enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: object).
)
inspectObjectMirror: object <ObjectMirror> = (
	enterSubject:: ObjectSubject onModel: object.
)
largeBlank = (
	^blank: 20
)
majorHeadingBlock: body = (
	^(padded: body with: {10. 10. 10. 10.})
		color: majorHeadingColor
)
majorHeadingColor = (
	(* This color is used for major definitions such as class headings. *)
	^Gradient
		from: (Color h: 240 s: 0.05 v: 0.92)
		to: (Color h: 240 s: 0.05 v: 0.86)
)
minorHeadingBlock: body = (
	^(padded: body with: {10. 5. 10. 5.})
		color: minorHeadingColor
)
minorHeadingColor = (
^Gradient
	from: (Color h: 240 s: 0.02 v: 0.94)
	to: (Color h: 240 s: 0.02 v: 0.9)
)
public objectSubjectFor: anObject = (
	^objectSubjectForMirror: (ObjectMirror reflecting: anObject)
)
objectSubjectForMirror: objectMirror <ObjectMirror> = (
	^ObjectSubject onModel: objectMirror
)
respondToInspectPresenter = (
	inspectObject: self.
)
secondaryTextColor ^ <Color> = (
	^Color gray: 0.6
)
smallBlank = (
	^blank: 5
)
tertiaryTextColor = (
	^Color gray: 0.8
)
) : (
)
class SlotPresenter onSubject: s <SlotSubject> = ProgrammingPresenter onSubject: s (
) (
caption ^<Fragment> = (
	^row: {
		(link: subject name action: [substance toggle])
			width: 0 elasticity: 1;
			color: actionLinkColor.
		smallBlank.
		(link: subject reflecteePrintString action: [inspectObjectMirror: subject objectMirror])
			width: 0 elasticity: detailAreaRatio.
	}
)
public definition ^<Fragment> = (
	^collapsed: [caption] expanded: [details]
)
details ^<Fragment> = (
	^(objectSubjectForMirror: subject objectMirror) presenter selfCaption: subject name
)
) : (
)
public class SlotSubject name: n value: v = Subject onModel: v (
	|
	public name = n.
	|
) (
public createPresenter = (
	^SlotPresenter onSubject: self
)
public objectMirror ^<ObjectMirror> = (
	^model
)
public reflecteePrintString = (
	^model reflectee printString
)
) : (
)
colorizingBlockFor: cm <CodeMirrorFragment> = (
	^[:r | | style <Alien[JSObject]> = JSObject new. |
	style at: 'css' put: (cssFor: r kind).
	cm style: style from: r start to: r end]
)
crToLf: string = (
	('a' at: 1) isKindOfInteger
		ifTrue:
			[ | bytes = ByteArray withAll: string. |
			1 to: bytes size do: [:index | (bytes at: index) = 13 ifTrue: [bytes at: index put: 10]].
			^bytes asString]
		ifFalse:
			[ | cr = String fromRune: 13. lf = String fromRune: 10. |
			^string replaceAll: cr with: lf]
)
cssConversionTable ^ <Map[Symbol, String]> = (
(* compute a mapping from 'kinds', which are symbols denoting logical categories of code, to CSS properties used to colorize them*)
	|
	redBoldUnderlined <String> = 'color:Red; font-weight:bold; text-decoration: underline'.
	redUnderlined <String> = 'color:Red; text-decoration: underline'.
	orangeBoldUnderlined <String> = 'color:Orange; font-weight:bold; text-decoration: underline'.
	underlined <String> = 'text-decoration: underline'.
	gray <String> = 'color:Gray'.
	blue <String> = 'color:Blue'.
	grayBold <String> = 'color:Gray; font-weight:bold'.
	blackBold <String> = 'color:Black; font-weight:bold'.
	blueBold <String> = 'color:Blue; font-weight:bold'.
	magentaBold <String> = 'color:Magenta; font-weight:bold'.
	bold <String> = 'font-weight:bold'.
	|
      ^Map new
		at: #error put: redBoldUnderlined;
		at: #undefinedUnary put: redUnderlined;
		at: #undefinedBinary put: redUnderlined;
		at: #undefinedKeyword put: redUnderlined;
		at: #shadowingTempVar put: orangeBoldUnderlined;
		at: #obsoleteMessage put: orangeBoldUnderlined;
		at: #whitespaceWarning put: orangeBoldUnderlined;
		at: #incompleteUnary put: underlined;
		at: #incompleteBinary put: underlined;
		at: #incompleteKeyword put: underlined;
		at: #self put: gray;
		at: #super put: gray;
		at: #outer put: gray;
		at: #true put: gray;
		at: #false put: gray;
		at: #nil put: gray;
		at: #string put: gray;
		at: #symbol put: gray;
		at: #number put: gray;
		at: #character put: gray;
		at: #public put: gray;
		at: #protected put: gray;
		at: #private put: gray;
		at: #tempVar put: grayBold;
		at: #blockTempVar put: grayBold;
		at: #blockPatternArg put: grayBold;
		at: #patternArg put: grayBold;
		at: #slotDecl put: grayBold;
		at: #patternTempVar put: grayBold;
		at: #methodTempBar put: blackBold;
		at: #leftParenthesis put: blackBold;
		at: #rightParenthesis put: blackBold;
		at: #leftParenthesis3 put: blackBold;
		at: #rightParenthesis3 put: blackBold;
		at: #leftParenthesis6 put: blackBold;
		at: #rightParenthesis6 put: blackBold;
		at: #blockStart put: blackBold;
		at: #blockEnd put: blackBold;
		at: #blockStart3 put: blackBold;
		at: #blockEnd3 put: blackBold;
		at: #blockStart6 put: blackBold;
		at: #blockEnd6 put: blackBold;
		at: #leftBrace put: blackBold;
		at: #rightBrace put: blackBold;
		at: #leftBrace3 put: blackBold;
		at: #rightBrace3 put: blackBold;
		at: #leftBrace6 put: blackBold;
		at: #rightBrace6 put: blackBold;
		at: #messagePatternDecl put: bold;
		at: #class put: gray;
		at: #className put: bold;
		at: #comment put: blue;
		at: #type put: blueBold;
		at: #return put: blueBold;
		at: #leftParenthesis1 put: blueBold;
		at: #rightParenthesis1 put: blueBold;
		at: #leftParenthesis4 put: blueBold;
		at: #rightParenthesis4 put: blueBold;
		at: #leftParenthesis7 put: blueBold;
		at: #rightParenthesis7 put: blueBold;
		at: #blockStart1 put: blueBold;
		at: #blockEnd1 put: blueBold;
		at: #blockStart4 put: blueBold;
		at: #blockEnd4 put: blueBold;
		at: #blockStart7 put: blueBold;
		at: #blockEnd7 put: blueBold;
		at: #leftBrace1 put: blueBold;
		at: #rightBrace1 put: blueBold;
		at: #leftBrace4 put: blueBold;
		at: #rightBrace4 put: blueBold;
		at: #leftBrace7 put: blueBold;
		at: #rightBrace7 put: blueBold;
		at: #leftParenthesis2 put: magentaBold;
		at: #rightParenthesis2 put: magentaBold;
		at: #leftParenthesis5 put: magentaBold;
		at: #rightParenthesis5 put: magentaBold;
		at: #blockStart2 put: magentaBold;
		at: #blockEnd2 put: magentaBold;
		at: #blockStart5 put: magentaBold;
		at: #blockEnd5 put: magentaBold;
		at: #leftBrace2 put: magentaBold;
		at: #rightBrace2 put: magentaBold;
		at: #leftBrace5 put: magentaBold;
		at: #rightBrace5 put: magentaBold;
		yourself
)
cssFor: k <Symbol> ^ <String> = (
        ^cssConverter at: k ifAbsent: [ 'color:Black; font-family: TimesNewRoman']
)
) : (
)
