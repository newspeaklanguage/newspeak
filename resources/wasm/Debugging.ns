Newspeak3
'HopscotchIDE'
class Debugging usingPlatform: platform ide: ide = (
(* Newspeak debugging module. Holds system-wide debugger parameters. An instance of the inner Debugger class gets instantiated to handle each specific debug session.

Copyright (c) 2008-2012 Cadence Design Systems, Inc.
Copyright (c) 2009 Peter von der Ahe
Copyright (c) 2008 Vassili Bykov

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
''Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. *)
|
	private Gradient = platform brazil plumbing Gradient.
	private RectangleShape = platform brazil widgets RectangleShape.
	private Row = platform brazil containers Row.

	private HopscotchImages = platform squeak HopscotchImages.
	private LeafFragment = platform hopscotch fragments LeafFragment.
	private Subject = platform hopscotch core Subject.
	private TextEditorFragment = platform hopscotch fragments TextEditorFragment.

	private MixinBuilder = platform mirrors MixinBuilder.
	private ObjectMirror = platform mirrors ObjectMirror.

	private CodeEditorFragment = ide tools CodeEditorFragment.
	private ExpandableMethodPresenter = ide browsing ExpandableMethodPresenter.
	private IDEWindow = ide tools IDEWindow.
	private MethodSubject = ide browsing MethodSubject.
	private NSMethodInheritanceSubject = ide browsingNS NSMethodInheritanceSubject.
	private InitializerMethodSubject = ide browsingNS InitializerMethodSubject.
	private OneLineDefinitionTemplate = ide tools OneLineDefinitionTemplate.
	private ProgrammingPresenter = ide tools ProgrammingPresenter.
	private ObjectSubject = ide inspection ObjectSubject.
	private ExceptionalResultPresenter = ide inspection ExceptionalResultPresenter.
	private workspaceManager = ide theWorkspaceManager.
	ide = ide.

	private Color = platform graphics Color.
	private List = platform collections List.
	private SqueakDebugger = platform squeak Debugger.
	private TextColor = platform squeak TextColor.
	private TextEmphasis = platform squeak TextEmphasis.
	private UnhandledError = platform squeak UnhandledError.
	private Semaphore = platform squeak Semaphore.

	errorReportBlock ::= [:activation | defaultErrorReportFor: activation].
	methodSourceRatio = 1.6.
|) (
public class Debugger thread: thread <ThreadMirror> activation: activation <ActivationMirror> = (
(* An instance of Debugger is created to manage a specific debug session represented by (mirrors on) the interrupted thread and its top activation passed as primary factory parameters. *)
|
	public thread <ThreadMirror> ::= thread.
	public activation <ActivationMirror> ::= activation.
	public description <String>

	public (*BOGUS*) registry
	protected debuggerHopscotchWindow
	protected InitializerActivationSubject = InitializerMethodSubject mixinApply: ActivationSubject.
|) (
class ActivationPresenter onSubject: subj <ActivationSubject> = ExpandableMethodPresenter onSubject: subj (|
	localVariables
	public okToRestartBlock ::= false.
	results
	public showMethodHeader ::= true.
|) (
addExceptionalResultPresenterFor: exception <Exception> in: thread <NewspeakDebugging ThreadSubject> = (
	results addFirst:
		(collapsed: [ExceptionalResultPresenter on: exception in: thread]
		expanded: [buildExceptionDetails: exception in: thread])
)
addResultPresenterOn: result <Object> = (
	results addFirst:
		(resultFragmentOn: (ObjectSubject onModel: result)).
)
buildActions = (
^column: {
		row: {
			button: 'over' action: [respondToStepOver].
			smallBlank.
			button: 'into' action: [respondToStepInto].
			smallBlank.
			button: 'into block' action: [respondToStepIntoBlock].
			filler.
			button: '^self' action: [respondtoReturnSelf].
			smallBlank.
			button: '^nil' action: [respondToReturnNil].
			holder: [buildReturnInterestingValue].
			smallBlank.
			button: 'Evaluate' action: [respondToEvaluate].
			smallBlank.
		      button: 'Continue' action: [respondToResume].
		      smallBlank.
		      button: 'Terminate' action: [respondToTerminate].
		}
	}
)
buildExceptionDetails: exception <Exception> in: thread <NewspeakDebugging ThreadSubject> = (
	^column: {
		ExceptionalResultPresenter on: exception in: thread.
		(ObjectSubject onModel: (ide mirrors ObjectMirror reflecting: exception)) presenter.
	}
)
buildLocalVariables = (
	localVariables:: subject activationStateSubject presenter.
	^floatingPanel: localVariables
)
buildMethodEditor = (
	| methodEditor |
	methodEditor:: super methodDetails.
	methodEditor colorizerBlock:
		[:text |
		subject colorizeMethodSource: text in: methodEditor editor].
	^methodEditor
)
buildReturnInterestingValue = (
	subject lastInterestingValueOnStack ifNotNil:
		[:it |
		^row: {
			smallBlank.
			button: '^', (it safePrintStringLimitedTo: 10) action: [respondToReturnValue: it].
		}].
	^nothing
)
clearErrors = (
	editor ifNotNil: [:it | it removeMessages]
)
debugActionsMenu = (
	^menuWithLabelsAndActions: {
		'over' -> [respondToStepOver].
		'into' -> [respondToStepInto].
		'intoBlock' -> [respondToStepIntoBlock].
	}
)
definition = (
	| toggler |
	showMethodHeader ifFalse: [^methodDetails].
	toggler::
		collapsed: methodHeading
		expanded: expandedMethod.
	toggler onUserToggled: [toggler isExpanded ifTrue: [requestVisibility]].
	^toggler
)
public expand = (
	(showMethodHeader isNil or: [showMethodHeader]) ifTrue: [super expand]
)
frameColor = (
	^Color h: 240 s: 0.15 v: 0.74
)
frameLine = (
	^((row: {}) color: frameColor) width: 1
)
methodActionsMenu = (
	^menuWithLabelsAndActions: {
		(* 'Versions' -> [respondToVersions]. *)
		subject isBlockActivation
			ifTrue: ['Restart block' -> [respondToRestart]]
			ifFalse: ['Restart method' -> [respondToRestart]].
		'Unwind Recursion' -> [respondToUnwindRecursion].
		'Inspect Context' -> [respondToInspectContext].
		'Inspect Mirror' -> [respondToInspectMirror].
		'Inspect Presenter' -> [respondToInspectPresenter].
	},(
		subject isMessageNotUnderstood ifTrue: [
			{'Create missing method ', subject notUnderstoodMessage printString -> [respondToCreateMissingMethod].},
						(subject notUnderstoodMessage isUnary ifTrue: [
			 { 'Create missing class ', subject notUnderstoodMessage printString -> [respondToCreateMissingClass].
			  'Create missing slot ', subject notUnderstoodMessage printString -> [respondToCreateMissingSlot].
			  'Create missing transient slot ', subject notUnderstoodMessage printString -> [respondToCreateMissingTransientSlot].
			}] ifFalse: [{}]).
			]
			ifFalse: [{}]
	)
)
methodDetails = (
	^column: {
		floatingHeader: (minorHeadingBlock: buildActions)
		body: (
			(row: {
				buildMethodEditor width: 0 elasticity: methodSourceRatio.
				smallBlank.
				buildLocalVariables width: 0 elasticity: 1.
			}) color: methodHeadingColor).

		row: {
			frameLine.
			elastic: (column: {
				minorHeadingBlock:
					(row: {
						label: 'Evaluation Results'.
						filler.
						link: '[clear]' action: [respondToDiscardResults].
					}).
				results:: column: {}.
			}).
		      frameLine.
		}.
		frameLine.
		smallBlank.
	}
)
public recategorizeMethodIn: p <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (
	| newName |
	newName:: newCategoryName withBlanksTrimmed.
	newName isEmpty ifTrue: [^failureResponse value].
	subject
		changeCategoryTo: newName asSymbol
		ifSuccess: successResponse
		ifFailure: failureResponse
)
public refreshActivationState = (
	localVariables ifNotNil: [:it | it refresh].
)
public refreshPcRangeIndication = (
	editor ifNotNil: [:it | it editor maybeColorize].
)
requestVisibilityOfPcRange = (
	| range |
	range:: subject model sourceRangeIn: thread.

	editor
		requestVisibilityOfTextInterval: range
		withExtraLines: 1
)
respondToBrowseReceiverClass = (
	browseClass: subject receiverMixin reflectee definingClass
)
respondToCreateMissingClass = (
	| receiverClass = subject receiverMixin reflectee definingClass. |
	browseClass: receiverClass.
	sendUp deliveryOptional navigatorDo:
		[:navigator |
		navigator currentPresenter sendDown
			addClassIn: receiverClass
			proposedSource: subject proposedMissingClassSource asString]
)
respondToCreateMissingMethod = (
	| receiverClass = subject receiverMixin reflectee definingClass. |
	browseClass: receiverClass.
	sendUp deliveryOptional navigatorDo:
		[:navigator |
		navigator currentPresenter sendDown
			addMethodIn: receiverClass
			proposedSource: subject proposedMissingMessageSource asString]
)
respondToCreateMissingSlot = (
	| receiverClass = subject receiverMixin reflectee definingClass. |
	browseClass: receiverClass.
)
respondToCreateMissingTransientSlot = (
	| receiverClass = subject receiverMixin reflectee definingClass. |
	browseClass: receiverClass.
	sendUp deliveryOptional navigatorDo:
		[:navigator |
		navigator currentPresenter sendDown
			addTransientSlotIn: receiverClass
			proposedSource: subject proposedMissingTransientSlotSource asString]
)
respondToDiscardResults = (
	results children size timesRepeat: [results removeAt: 1]
)
respondToEvaluate = (
	| result <ObjectMirror> |
	editor removeMessages.
	result::	(ActivationStateSubject onModel: subject activationMirror)
		evaluate:
			editor maybeSelectCurrentLine
		ifCompilerError:
			[:message |
			^editor addMessage: message]
		ifError:
			[:thread :exception |
			^addExceptionalResultPresenterFor: exception in: thread].
	localVariables refresh.
	addResultPresenterOn: result.
)
respondToInspectContext = (
	inspect: subject activationMirror context_slot
)
respondToInspectMirror = (
	inspect: subject activationMirror
)
respondToRestart = (
	clearErrors.
	subject restartIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
public respondToResume = (
 sendUp respondToResume
)
respondToReturn: textEditor <TextEditorFragment> = (
	clearErrors.
	subject
		returnWith: textEditor editedText asString
		ifFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToReturnNil = (
	subject returnNil.
	sendUp deliveryOptional refreshActivations
)
respondToReturnValue: objectMirror <ObjectMirror> = (
	subject return: objectMirror.
	sendUp deliveryOptional refreshActivations
)
respondToStepInto = (
	clearErrors.
	subject stepIntoIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToStepIntoBlock = (
	clearErrors.
	subject stepIntoBlockIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToStepOver = (
	clearErrors.
	subject stepOverIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
public respondToTerminate = (
	sendUp respondToTerminate
)
respondToUnwindRecursion = (
	clearErrors.
	subject unwindRecursionIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondtoReturnSelf = (
	subject return: subject receiver.
	sendUp deliveryOptional refreshActivations
)
resultFragmentOn: result <ObjectSubject> ^ <Fragment> = (
	^collapsed: [link: result title action: [enterSubject: result]]
		expanded: [result presenter]
)
selectorAndContainment = (
	(* Override to display only the immediately defining class instead of the complete nesting and to also display both the receiver class and the method class if they differ. *)
	|
	receiverClassLink =
		(link: subject receiverMixin simpleName
			action: [respondToBrowseReceiverClass])
				color: secondaryTextColor.
	methodClassLink =
		subject implementingClass
			ifNil: [nothing]
			ifNotNil:
				[:ic|
				row: {
					(label: ' (') color: secondaryTextColor.
					(link: ic simpleName
						action: [browseClass: subject implementingClass])
							color: secondaryTextColor.
					(label: ')') color: secondaryTextColor.
					}].
	selectorLink =
		(link: subject selectorWithBlockNesting
			action: [substance userToggle]
			dragSubject: subject
			withImage: HopscotchImages default hsExpandImage)
				color: actionLinkColor.
	|

	^row: {
		selectorLink.
		(label: ' in ') color: tertiaryTextColor.
		receiverClassLink.
		subject methodMixin = subject receiverMixin
			ifTrue: [nothing]
			ifFalse: [methodClassLink].
		}
)
sendersOfSubjectPresenter = (
	(* Override to hide in the debugger. *)
	^nothing
)
showClassName = (
	^true
)
) : (
)
class ActivationStatePresenter onSubject: subj <ActivationStateSubject> = ProgrammingPresenter onSubject: subj (|
	interactionEditor
	selfFragment
	localVarPresenters
	expressionStackPresenters
|) (
acceptNewValue: template <DefinitionTemplate> for: variableName = (
	subject
		setLocalVariable: variableName
		toExpression: template text asString
		ifFail: [:msg | template editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
public additionalResultFragment: fragmentConsumer <[:Fragment]> for: result <[:ObjectMirror]> = (
	fragmentConsumer
		value: (link: 'return it' action: [respondToReturn: result]) tinyFont
)
definition = (
	^list: [{
		ide settings useExemplarPresenters
			ifTrue: [nothing]
			ifFalse: [interactionDefinition].
		selfFragment:: selfDefinition.
	}, (localVarPresenters:: localVarDefinitions)
	, (expressionStackPresenters:: expressionStackDefinition)]
)
expressionStackDefinition = (
	^{
		smallBlank.
		heading: (label: 'Expression Stack' asText allBold)
			detailsExpanded:
				(list: (subject stackIndicesWithValuesCollect:
					[:index :mirror |
					localVariableNamed: index asString value: mirror]),
					{label: '--- end of stack ---'})
	}
)
headingForLocalVariableNamed: variableName value: object = (
	^row: {
		label: variableName asText allBold.
		smallBlank.
		link: (object safePrintStringLimitedTo: 39) action:
			[inspectObjectMirror: object].
	}
)
interactionDefinition = (
	^inspection EvaluatorPresenter onSubject: subject
)
localVarDefinitions = (
	^subject localNamesWithValuesCollect:
		[:localName :mirror |
		presenterForLocal: localName]
)
localVariableNamed: variableName value: object = (
	^collapsed:
		[headingForLocalVariableNamed: variableName value: object]
	expanded:
		[column: {
			OneLineDefinitionTemplate new
				initialText: 'new value for ', variableName;
				acceptResponse: [:t | acceptNewValue: t for: variableName];
				cancelResponse: [:t | t editor defaultCancelResponse];
				initiallyInEditState: false.
			(objectSubjectForMirror: object) presenter selfCaption: variableName.
		}]
)
presenterForLocal: localName = (
	^(LocalVariableSubject onActivationMirror: subject activationMirror name: localName) presenter
)
respondToEvaluate = (
)
respondToReturn: mirror <ObjectMirror> = (
	subject return: mirror.
	sendUp deliveryOptional; refreshActivations
)
selfDefinition = (
	^collapsed: [headingForLocalVariableNamed: 'self' value: subject receiver]
		expanded: [(objectSubjectForMirror: subject receiver) presenter]
)
) : (
)
class ActivationStateSubject onModel: mirror <ActivationMirror> = Subject onModel: mirror () (
public = other = (
	^class = other class and: [activationMirror = other activationMirror]
)
public activationMirror = (
	^model
)
public createPresenter = (
	^ActivationStatePresenter onSubject: self
)
public evaluate: expression <String>
ifCompilerError: onCompilerError <[:String]>
ifError: onError <[:NewspeakDebugging ThreadSubject :Exception]> ^<ObjectMirror> = (
	| compilerError failed sem result process |
	failed:: false.
	sem:: Semaphore new.
	process::
		[
			[result:: activationMirror
				evaluate: expression
				with: workspaceManager workspaceScope
				ifCompilerError: [:ex <Exception> |
					compilerError:: ex.
					sem signal.
					process suspend]
				ifError: [:ex <Exception> |
					failed:: true.
					result:: ex.
					sem signal.
					process suspend].
			sem signal]
				on: UnhandledError
				do:	[:ex |
					failed ifTrue: [ex pass]. (* don't fire twice *)
					failed:: true.
					result:: ex exception.
					sem signal.
					process suspend].
		] newProcess.
	process
		name: 'Evaluating ', expression asString;
		resume.
	sem wait.
	process offList.
	compilerError ifNotNil:
		[^onCompilerError value: compilerError description ].
	failed ifFalse:
		[^result].
	(* position the process to continue in the signalerContext *)
	process suspendedContext unwindTo: result signalerContext.
	result signalerContext push: result.
	process suspendedContext: result signalerContext.
	^onError value: (registry subjectFor: result in: process) value: result
)
public hash = (
	^activationMirror hash
)
public localNamesWithValuesCollect: action <[:Integer :ObjectMirror | T]> ^<SequenceableCollection[T]> = (
	^Array streamContents:
		[:s |
		activationMirror localNamesWithValuesDo:
			[:i :mirror | s nextPut: (action value: i value: mirror)]]
)
public localNamesWithValuesDo: action <[:String :ObjectMirror]> = (
	activationMirror localNamesWithValuesDo: action
)
public receiver = (
	^activationMirror receiver
)
public return: objectMirror = (
	activation:: thread return: objectMirror from: activationMirror
)
public setLocalVariable: variableName <String> toExpression: exprString <String> ifFail: onFail <[:String]> = (
	activationMirror setLocalVariable: variableName toExpression: exprString ifFail: onFail
)
public stackIndicesWithValuesCollect: action <[:Integer :ObjectMirror | T]> ^<SequenceableCollection[T]> = (
	^Array streamContents:
		[:s |
		activationMirror stackIndicesWithValuesDo:
			[:i :mirror | s nextPut: (action value: i value: mirror)]]
)
public stackIndicesWithValuesDo: action <[:Integer :ObjectMirror]> = (
	activationMirror stackIndicesWithValuesDo: action
)
public title = (
	^'Expression Stack'
)
) : (
)
class ActivationSubject onModel: mirrorOnActivation <ActivationMirror> = MethodSubject onModel: mirrorOnActivation (| methodMirror_slot |) (
public = other <Object> ^<Boolean> = (
	^self class = other class and: [activationMirror = other activationMirror]
)
public accessModifier = (
	^methodMirror accessModifier
)
public activationMirror ^<ActivationMirror> = (
	^model
)
public activationStateSubject = (
	^ActivationStateSubject onModel: model
)
public allMethodCategories ^<Collection[Symbol]> = (
	(* Answer a collection of all category names used in the implementor class, plus some common names. *)

	| names |
	names:: super allMethodCategories.
	names addAll: (methodMirror definingMixin methods collect: [:ea | ea category]).
	^names
)
public asMethodInheritanceSubject = (
	^NSMethodInheritanceSubject onModel: methodMirror
)
public changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
	| builder |
	builder:: MixinBuilder reflecting: methodMirror definingMixin reflectee.
	(builder methods findMirrorNamed: methodMirror simpleName) category: newName.
	builder declaration install.
	#BOGUS. (* Do this non atomically? *)

	successBlock value
)
colorizeMethodSource: sourceText = (
	#BOGUS. (* We should have decided not to colorize earlier when the method gave us nil source. *)
	activationMirror sourceAvailable ifFalse: [^sourceText].

	methodMirror definingClass language isNewspeakLanguage3
		ifFalse: [^super colorizeMethodSource: sourceText].

	^ide newspeakColorization NS3BrowserColorizer new
		parseText: sourceText asString
		fromClass: methodMirror definingMixin reflectee definingClass
		usingSelector: (methodMirror isExpression ifTrue: [#doItExpression] ifFalse: [model selectorForParsing])
)
public colorizeMethodSource: sourceText in: editor = (
	| range |

	#BOGUS. (* We should have decided not to colorize earlier when the method gave us nil source. *)
	activationMirror sourceAvailable ifFalse: [^sourceText].

	range:: activationMirror sourceRange.
	sourceText asString = source asString ifTrue:
		[^highlight: (colorizeMethodSource: sourceText) range: range].
	^colorizeMethodSource: sourceText
)
public compileNewSource: newSource <String> ifSuccess: onSuccess ifNewMethod: onNewMethod ifFailure: onFail = (
	| method failed |
	activationMirror homeMethod isSynthetic
		ifTrue: [^onFail valueWithPossibleArgument: 'Cannot change synthetic method.'].
	method:: activationMirror compile: newSource ifFail:
		[:msg | ^onFail valueWithPossibleArgument: msg].
	method simpleName = selector
		ifFalse: [^onNewMethod valueWithPossibleArgument: method].
	failed:: nil.
	activation:: thread install: method restart: model homeInThread ifFail:
		[:message | failed:: message].
	failed ifNotNil: [:it | ^onFail valueWithPossibleArgument: it].
	onSuccess value
)
public createPresenter = (
	^ActivationPresenter onSubject: self
)
public hash ^<SmallInteger> = (
	^self class hash bitXor: model hash
)
public implementingClass = (
	^methodMirror definingMixin reflectee definingClass
)
public isAnOverride = (
	superclass ifNotNil: [:it | ^it canUnderstand: selector].
	^false
)
public isBlockActivation = (
	^activationMirror isBlockActivation
)
public isInitializer ^ <Boolean> = (
	^methodMirror isInitializer
)
public isMessageNotUnderstood = (
	^selector = #doesNotUnderstand:
)
public isOverridden = (
	^false
)
public isValid = (
	^true
)
public lastInterestingValueOnStack ^<ObjectMirror | nil> = (
	| mirror |
	activationMirror stackIndicesWithValuesDo:
		(* Prefer topmost value which comes first *)
		[:ignored :current |
		current reflectee == nil ifFalse: [^current]].
	model localNamesWithValuesDo:
		(* Prefer last argument which comes last *)
		[:ignored :current |
		current reflectee == nil ifFalse: [mirror:: current]].
	^mirror
)
public localNames = (
	^activationMirror localNames
)
public messages = (
	^(activationMirror homeMethod ifNil: [^{}]) messages
)
public methodCategory = (
	^methodMirror category
)
methodMirror = (
	^model method
)
public methodMixin ^<MixinMirror> = (
	^methodMirror definingMixin
)
public notUnderstoodMessage = (
	^activationMirror notUnderstoodMessage
)
public proposedMissingClassSource ^ <String> = (
	| message |
	isMessageNotUnderstood ifFalse: [^''].
	message:: notUnderstoodMessage.
	assert: [message isUnary] message: 'Cannot define non-unary class accessor'.
	assert: [receiver getClass reflectee language isNewspeakLanguage3] message: 'Only Newspeak code can have nested classes'.

	^'class ', message asString, ' = ()( )'
)
public proposedMissingMessageSource ^ <String> = (
	| message args |
	isMessageNotUnderstood ifFalse: [^''].
	message:: notUnderstoodMessage.
	args:: activationMirror notUnderstoodArguments.
	message isUnary
		ifTrue: [message:: message, ' ']
		ifFalse:
			[message:: String streamContents:
				[:s |
				message keywords withIndexDo:
					[:each :i |
					s nextPutAll: each.
					s space.
					s nextPutAll: 'argument'.
					s nextPutAll: i asString.
					s space.
					s nextPut: "<".
					putInferredTypeOf: (args at: i) on: s.
					s nextPut: ">".
					s space]]].

	^activationMirror method definingMixin reflectee definingClass language isNewspeakLanguage3
		ifTrue: [message asString, '= (\	halt\)' withCRs]
		ifFalse: [message asString]
)
public proposedMissingTransientSlotSource ^ <String> = (
	| message args |
	isMessageNotUnderstood ifFalse: [^''].
	message:: notUnderstoodMessage, ' '.
	^activationMirror method definingMixin reflectee definingClass language isNewspeakLanguage3
		ifTrue: ['transient ', message asString, '= 	halt.' withCRs]
		ifFalse: [assert: [false] message: 'transient slots only occur in NS3+']
)
putInferredTypeOf: arg on: s <Stream> = (
	arg isBehavior ifTrue: [^s nextPutAll: 'Class'].
	arg isClosure ifTrue:
		[s nextPut: "[".
		(1 to: arg argumentCount)
			do: [:ignored | s nextPutAll: '_, '].
		s space.
		^s nextPutAll: '^_]'].
	s nextPutAll: (ObjectMirror reflecting: arg) getClass simpleName
)
public receiver = (
	^activationMirror receiver
)
public receiverMixin ^<Mixin> = (
	^receiver getClass mixin
)
public restartIfFail: onFail <[:String]> = (
	activation:: thread restart: activationMirror
)
public return: objectMirror = (
	activation:: thread return: objectMirror from: activationMirror
)
public returnNil = (
	return: (ObjectMirror reflecting: nil)
)
public returnWith: expression ifFail: onFail = (
	return:: activationMirror
		evaluate: expression
		with: workspaceManager workspaceScope
		ifCompilerError: [:e | ^onFail value: e description]
		ifError: [:e | ^onFail value: e description]
)
public selector = (
	^methodMirror name
)
public selectorWithBlockNesting = (
	(* [] in [] in foo. *)
	(* doesNotUnderstand: #message *)
	^String streamContents: [:stm |
		| act ::= activationMirror. |
		[act isBlockActivation and: [(nil == act home) not]]
			whileTrue:
				[stm nextPutAll: '[] in '.
				act:: act home].
		nil == act home
			ifTrue: [stm nextPutAll: '<<Orphaned block>>'].
		stm nextPutAll: selector.
		isMessageNotUnderstood
			ifTrue: [stm nextPutAll: ' #'; nextPutAll: notUnderstoodMessage]].
)
public source = (
	^[methodMirror source] ifError: [:desc | desc]
)
public stepIntoBlockIfFail: onFail = (
	activation:: thread stepIntoBlock: activationMirror.
)
public stepIntoIfFail: onFail = (
	activation:: thread stepInto: activationMirror.
)
public stepOverIfFail: onFail = (
	(thread stepOver: activationMirror)
		ifNil: [onFail value: 'computation terminated']
		ifNotNil: [:anActivation| activation:: anActivation]
)
superclass = (
	(* ^methodMirror enclosingClassStencil guessSuperclass *)
	#BOGUS yourself.
	^Object
)
public unwindRecursionIfFail: onFail <[:String]> = (
	activation:: thread unwindRecursion: activationMirror.
)
public variableBindingKeys = (
	^Array streamContents:
		[:s |
		(model homeMethod ifNil: [^{}]) literalsDo:
			[:lit |
			(lit isVariableBinding and: [lit key notNil])
				ifTrue: [s nextPut: lit key]]]
)
) : (
)
class GlobalDebuggerControlsPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Displays the global debugger control bar with buttons to go back to the debugger, continue or terminate execution. The subject of this presenter holds onto the original ThreadSubject for the current debugger window. *)
) (
controlsBar = (
	^row: {
		button: 'Back to Debugger' action: [enterSubject: subject debuggerSubject].
		filler.
		button: 'Continue' action: [subject debuggerSubject presenter respondToResume].
		smallBlank.
		button: 'Terminate' action: [respondToTerminate].
	}
)
definition = (
	^floatingHeader: ((padded: controlsBar with: {5. 5. 5. 5}) color: mainHeadingColor)
		body: (column: {
			smallBlank.
			subject wrappedPresenter.
		})
)
public navigateTo: s = (
	enterSubject:
		(shell shiftWasPressed
			ifTrue:
				[s]
			ifFalse:
				[((GlobalDebuggerControlsSubject onModel: s)
					debuggerSubject: subject debuggerSubject)])
)
public respondToTerminate = (
	fork: [releaseThread terminate]
		thenUpdateUI:
			[shell window close].
)
public title = (
	^subject wrappedPresenter title
)
) : (
)
class GlobalDebuggerControlsSubject onModel: wrappedSubject = Subject onModel: wrappedSubject (
(* The core of the functionality to implement a persistent control bar for debugger. On navigating out of a ThreadPresenter, the presenter wraps the target subject into an instance of this. The presenter for this subject provides the buttons to go back to the debugger and also intercepts further navigation attempts to wrap destination targets in a similar way, so that the global control bar stays there. *)
|
	public debuggerSubject <ThreadSubject>
|) (
public createPresenter = (
	^GlobalDebuggerControlsPresenter onSubject: self
)
public refreshmentSubject = (
	^(self class onModel: model refreshmentSubject) debuggerSubject: debuggerSubject
)
public wrappedPresenter = (
	^model presenter
)
) : (
)
class LocalVariablePresenter onSubject: subject <LocalVariableSubject> = ProgrammingPresenter onSubject: subject (|
	editorFragment
	valueLink
	inspectorHolder
|) (
collapsedDefinition = (
	^row: {
		label: subject name asText allBold.
		smallBlank.
		valueLink:: link: (subject valueStringLimitedTo: 200) action: [inspectObjectMirror: subject mirrorOnValue]
	}
)
definition = (
	^collapsed: [collapsedDefinition]
	expanded: [expandedDefinition]
)
editor = (
	^editorFragment editor
)
expandedDefinition = (
	editorFragment:: OneLineDefinitionTemplate new
		initialText: 'new value for ', subject name;
		acceptResponse: [:t | setValue: t text asString];
		cancelResponse: [:t | t editor defaultCancelResponse];
		initiallyInEditState: false.
	^column: {
		editorFragment.
		inspectorHolder:: holder:
			((objectSubjectForMirror: subject mirrorOnValue) presenter selfCaption: subject name).
	}
)
public refresh = (
	valueLink ifNotNil: [:it | it label: (subject valueStringLimitedTo: 200)].
	inspectorHolder ifNotNil:
		[:it | | current = subject mirrorOnValue. previous = it content subject objectMirror. |
		(* Only replace the content if the identity of the object has changed (current and
		    previous are mirrors and use identity comparision). *)
		current = previous
			ifTrue: [it content objectDetailsHolder refresh]
			ifFalse: [it content: ((objectSubjectForMirror: subject mirrorOnValue) presenter selfCaption: subject name)]]
)
setValue: expression <String> = (
	subject setValue: expression ifFail: [:msg | ^editor showMessage: msg].
	refresh.
	sendUp deliveryOptional refreshActivations
)
) : (
)
class LocalVariableSubject onActivationMirror: activationMirror <ActivationMirror> name: localVariableName <String> = Subject onModel: activationMirror (|
	public name = localVariableName.
|) (
public = another = (
	^self class = another class and: [self name = another name]
)
public createPresenter = (
	^LocalVariablePresenter onSubject: self
)
public hash = (
	^name hash
)
public mirrorOnValue = (
	^model localVariableValueMirror: name
)
public setValue: expression <String> ifFail: block = (
	| newValue <ObjectMirror> |
	newValue:: model evaluate: expression
		with: workspaceManager workspaceScope
		ifCompilerError: block
		ifError: block.
	model setLocalVariable: name toValue: newValue reflectee ifFail: block
)
public valueStringLimitedTo: numberOfCharacters <Integer> = (
	^mirrorOnValue safePrintStringLimitedTo: numberOfCharacters
)
) : (
)
class ThreadPresenter onSubject: subj <ThreadSubject> = ProgrammingPresenter onSubject: subj (
(*
This class will be instantiated inside a Debugger object, which provides access to the current thread (the thread I am  presenting and the top activation mirror) . On every step, the activation slot will be updated to hold the 'new' top activation. This situation is not ideal since it would be more reasonable to access the current activation and thread Mirrors  through ThreadSubject. #refreshActivations is being called from the ActivatiolnPresenters I'm containing, on every step.  See #refreshActivations methods to understand how Activation Presenters are updated on every step
*)
|
	protected activations <PresenterList>
	protected definitionHolder <HolderFragment>
	protected moreLinkHolder <HolderFragment>
|) (
chunkSize = (	(* Show at most this many activations at first. If there are more activations, show a 'more' link. *)	^100)
public compileMethod: newSource <String>inPresenter: p <ActivationPresenter>ifCompiledAsSame: onCompiledAsSame <[]>ifCompiledAsNew: onCompiledAsNew <[]>ifFailed: onFail <[:String]> = (	| edited <ActivationMirror> home <ActivationMirror> |	edited:: p subject activationMirror.	home:: edited homeInThread.	home ifNil: [^onFail value: 'Block''s method not on stack.'].	(edited = home or: [p okToRestartBlock]) ifFalse:		[p okToRestartBlock: true.		^onFail value: 'Need to revert to block''s method. Click Save again to revert.'].	p subject		compileNewSource: newSource		ifSuccess:			[refreshActivations.			onCompiledAsSame value.]		ifNewMethod: onCompiledAsNew		ifFailure:			[:message |			refreshActivations.			onFail valueWithPossibleArgument: message].)
createPresenterForActivation: anActivation = (
	^(createSubjectForActivation: anActivation)
		presenter showMethodHeader: subject isExemplar not.
)
createSubjectForActivation: anActivation = (
	^ActivationSubject onModel: anActivation.
)
definition = (
	isAlive ifFalse: [^nothing].

	(ide settings useExemplarPresenters
		and: [definitionForActivationsList presenters size = 1])
			ifTrue:
				[definitionHolder:: holder: definitionForSingleFrame.
				expandTopActivation.
				^definitionHolder].

	^definitionHolder:: holder: definitionForMainContent.
)
definitionForActivationsHeader = (
	^majorHeadingBlock: (
		row: {
			label: 'Call stack' asText allBold.
			filler.
			expandButtonWithAction: [respondToExpandAll].
			blank: 3.
			collapseButtonWithAction: [respondToCollapseAll].
		}
	)
)
definitionForActivationsList = (
	^withTopChunkOfActivationsAndMoreLinkDo:
		[:presenters :moreLinkOrNothing |
		moreLinkHolder:: holder: moreLinkOrNothing.
		list: presenters]
)
definitionForErrorReport = (
	| toggle |
	^toggle::
		heading:
			((link: 'Error Report' action: [toggle userToggle]) color: Color black)
		details:
			[TextEditorFragment new text: subject errorReport]
)
definitionForMainActions = (
	^padded: (row: {
		filler.
		button: 'Continue' action: [respondToResume].
		largeBlank.
		button: 'Terminate' action: [respondToTerminate].
		filler.
	}) with: {20. 20. 20. 20}
)
definitionForMainContent = (
	^column: {
		(padded: definitionForMainHeader with: {3. 3. 3. 3})
			color: mainHeadingColor.
		smallBlank.
		definitionForErrorReport.
		smallBlank.
		definitionForActivationsHeader.
		smallBlank.
		activations:: definitionForActivationsList.
		moreLinkHolder ifNil:
			[moreLinkHolder:: holder: [nothing]].
	}
)
definitionForMainHeader = (
	^column: {
		definitionForSummaryRow.
		definitionForMainActions.
	}
)
definitionForSingleFrame = (
	^column: {
		activations:: definitionForActivationsList.
	 (* activations presenters first.*)
		moreLinkHolder ifNil:
			[moreLinkHolder:: holder: [nothing]].
	}
)
definitionForSummaryRow = (
	^row: {
		(label: subject summary) color: mainHeadingTextColor.
		filler.
		dropDownMenu: [secondaryActionsMenu].
	}
)
expandTopActivation = (
	activations presenters size > 0 ifTrue:
		[| top = activations presenters first. |
		top
			expand;
			refreshPcRangeIndication]
)
private indexOfAnyOf: aCollection from: anotherCollection = (
	1 to: anotherCollection size do:
		[:index |
		(aCollection includes: (anotherCollection at: index)) ifTrue: [^ index]].
	^0.
)
public navigateTo: destinationSubject = (
	enterSubject::
		(isWindowOwnedByDebugger and: [shell shiftWasPressed not])
			ifTrue:
				[(GlobalDebuggerControlsSubject onModel: destinationSubject)
					debuggerSubject: subject]
			ifFalse:
				[destinationSubject])
public noticeEvaluationBy: evaluator <EvaluatorPresenter> = (
	(* Received via sendUp. *)
	refreshExistingActivationPresenters
)
public noticeRemoval = (
	thread ifNotNil: [releaseThread terminate]
)
public refreshActivations = (
	(* Refresh the ActivationPresenter 's  list after every step. Presenters which are no longer in the chain are removed. New ones are added. Modified Activations are updated with a new ActivationSubject. It's important not to recreate all Presenters so UI state of activations that are still alive can be preserved (e.g.the presenter is the only one knowing that weather it is expanded or not). *)

	| activationsInPresenters remainingPresenters indexOfTopOldActivation allActivations
	topOldActivation newActivations newPresenters |

	allActivations::	subject allActivations.
	activationsInPresenters:: activations presenters collect: [:each | each subject activationMirror].
	indexOfTopOldActivation:: indexOfAnyOf: allActivations from: activationsInPresenters.

	topOldActivation:: activationsInPresenters at: indexOfTopOldActivation.
	remainingPresenters:: activations presenters copyFrom: indexOfTopOldActivation to: activations presenters size.

	(* update subject of all remainingPresenters and refresh *)
	remainingPresenters do: [:each |
		| newActivation|
		newActivation:: allActivations at: (allActivations indexOf: each subject activationMirror).
		each subject: (createSubjectForActivation: newActivation).
		each refresh.
	].

	newActivations:: allActivations copyUpTo: topOldActivation. (*not including parameter *)
	newPresenters:: newActivations collect: [:each | createPresenterForActivation: each].

	activations presenters: (newPresenters,  remainingPresenters).
	expandTopActivation.
)
refreshExistingActivationPresenters = (
	activations presenters do: [:each | each refreshActivationState]
)
refreshPcRangeIndication = (
	activations presenters size > 0 ifTrue:
		[activations presenters first refreshPcRangeIndication]
)
releaseUi: body = (	majorUpdate:		[activations setPresenters: {}.		definitionHolder content: body].)
respondToCollapseAll = (
	majorUpdate:
		[activations presenters do: [:each | each collapse]]
)
respondToExpandAll = (
	majorUpdate:
		[activations presenters do: [:each | each expand]]
)
respondToOpenSqueakDebugger = (
	releaseUi:: label: 'Debugging in Squeak debugger.'.
	debugInSqueak
)
public respondToResume = (
	| threadToResume |
	releaseUi:: label: 'Resuming thread.'.
	threadToResume: releaseThread.
	isWindowOwnedByDebugger
		ifTrue: [shell window close]
		ifFalse: [shell goBack].
	threadToResume resume
)
respondToScrollPositionChange: p <Point> = (
	sendDown respondToScrollingInViewport: visual.
)
public respondToTerminate = (
	releaseUi:: label: 'Unwinding stack.'.
	fork: [releaseThread terminate]
		thenUpdateUI:
			[releaseUi:: label: 'Thread is terminated.'.
			isWindowOwnedByDebugger
				ifTrue: [debuggerHopscotchWindow window close]
				ifFalse: [shell goBack]].
)
secondaryActionsMenu = (
	^menuWithLabelsAndActions: {
		'Open in Squeak Debugger' -> [respondToOpenSqueakDebugger].
		'Inspect Presenter' -> [respondToInspectPresenter]
	}
)
showNextChunkOfActivations = (
	withNextChunkOfActivationsAndMoreLinkDo:
		[:presenters :moreLinkOrNothing |
		activations presenters: activations presenters, presenters.
		moreLinkHolder content: moreLinkOrNothing]
)
public title = (
	^'Stack Trace: ', subject title
)
withNextChunkOfActivationsAndMoreLinkDo: binaryBlock = (
	^withNextChunkOfActivationsAndMoreLinkDo: binaryBlock skipping: activations presenters size.
)
withNextChunkOfActivationsAndMoreLinkDo: binaryBlock skipping: numberOfActivationsToSkip = (
	| index presenters |
	index:: 1.
	presenters:: List new.
	subject activationsDo:
		[:each |
		index > numberOfActivationsToSkip ifTrue:
			[presenters size < chunkSize ifFalse:
				[^binaryBlock
					value: presenters
					value: (link: 'show more...' action: [showNextChunkOfActivations]) smallFont].
			presenters add: (createPresenterForActivation: each)].
		index:: index + 1].
	^binaryBlock value: presenters value: nothing
)
withTopChunkOfActivationsAndMoreLinkDo: binaryBlock = (
	^withNextChunkOfActivationsAndMoreLinkDo: binaryBlock skipping: 0.
)
) : (
)
public class ThreadSubject onModel: t <ThreadMirror> = Subject onModel: t () (
activationSubjectOnModel: m = (
	| subjectClass = m isInitializer
	   ifTrue: [InitializerActivationSubject]
	   ifFalse: [ActivationSubject].
	|
	^subjectClass oModel: m
)
public activationsDo: action = (
	(* The debugger does quite a bit of forking UI activity. From time to time (with debugger tests), activation is nil. So, the folliwing check was added. *)
	activation ifNotNil: [:it | it activationsDo: action]
)
public allActivations = (
	^activation withAllActivations.
)
public createPresenter = (
	^ThreadPresenter onSubject: self
)
public errorReport = (
	^errorReportBlock value: activation
)
public isExemplar = (
	^model squeakProcess name = 'Exemplar'
)
public summary = (
	^windowTitle, ' in ', model summary
)
public title = (
	^windowTitle
)
) : (
)
debugInSqueak = (
	| context |
	context:: activation context_slot.
	(* The Squeak debugger will schedule itself to be opened on in the Morphic UI thread. *)
	SqueakDebugger
		openOn: releaseThread squeakProcess
		context: context
		label: windowTitle
		contents: nil
		fullView: true.
)
public isAlive = (
	^thread isNil not
)
public isWindowOwnedByDebugger ^<Boolean> = (
	(* Returns true when the debugger operated by this module has been initially opened in its own top-level window, as opposed to navigated into in a previously existing window. In the own-window case we may want to close the window on the debugged thread termination. *)
	^debuggerHopscotchWindow notNil
)
public open = (
	^debuggerHopscotchWindow:: IDEWindow openSubjectFromBlock:
		[:hopscotch |
	      hopscotch initialExtent: 970 @ hopscotch initialExtent y.
		ThreadSubject onModel: thread]
)
public releaseThread ^ <ThreadMirror> = (
	| theThread <ThreadMirror> |
	theThread:: thread.
	thread:: nil.
	activation:: nil.
	registry release: self.
	^theThread
)
windowTitle = (
	(* Backward compatibility; eradicate. *)
	^description
)
) : (
public thread: thread <ThreadMirror> activation: activation <ActivationMirror> description: description <String> = (
	^(thread: thread activation: activation)
		description: description.
)
)
defaultErrorReportFor: activation = (
	^String streamContents:
		[:s|
		s nextPutAll: 'Please take a moment to complete the questions below and post this report to the forum: https://groups.google.com/group/newspeaklanguage?hl=en'; cr;
 		cr; nextPutAll: 'What did you want to do?'; cr;
		cr; nextPutAll: 'What did you do?'; cr;
		cr; nextPutAll: 'What happened?'; cr;
		cr; nextPutAll: 'What did you expect?'; cr;
		cr; nextPutAll: 'Please make sure you included all relevant information so that the problem can be verified and/or reproduced.'; cr;
		cr;
		cr; nextPutAll: 'DETAILS:'; cr; cr.
		activation errorReportOn: s]
)
highlight: text range: range = (
	range isNil ifTrue: [^text].
	range = (0 to: 0) ifTrue: [^text].

	^text
		addAttribute: TextEmphasis underlined from: range first to: range last;
		addAttribute: TextColor blue from: range first to: range last;
		addAttribute: TextEmphasis bold from: range first to: range last;
		yourself
)
mainHeadingColor = (
	^Gradient from: (Color h: 0 s: 0.5 v: 0.8) to: (Color h: 0 s: 0.5 v: 0.6).
)
mainHeadingTextColor = (
	^Color white
)
) : (
)
