Newspeak3
'Root'
class HopscotchForCroquet usingPlatform: p <Platform> hopscotch: H <HopscotchForHTML5 class> = (
(* 
Module definition enclosing Hopscotch UI subclass that integrates Croquet style synchronization. 
See that class (#Hopscotch) for details. 
*)
   |
(* imports *)
    private HopscotchForHTML5 = H.
    private Promise = p actors Promise.
    private Resolver = p actors Resolver.
    private List  = p collections List.
    private Map = p collections Map.
    |
) (
public class Hopscotch usingPlatform: p <Platform> images: images ducts: ds =
  HopscotchForHTML5 usingPlatform: p images: images ducts: ds

(
(*
This class overrides the normal Hopscotch UI module to allow the UI to synchronize using croquet.io. A series of croquet clients running a Newspeak application can be synchronized, without any modification to the Newspeak application code; the only requirement is that application be deployed using a platform object that uses an instance of this class as its GUI.

For every interactive fragment class, we maintain:

1) A subclass, defined here, that manages the interaction with Croquet.
2) A counter that is used to generate unique ids for each fragment.

Each fragment sets its id upon instantiation, accessing and incrementing the per-fragment type counter via a dedicated method in this class.

The fragment notifies the Croquet root view when an interaction occurs. The croquet view notifies the croquet model, which notifies the reflector; when the reflector has signaled the croquet model, it notifies the croquet view; the view then executes a call back in which the fragment performs the normal behavior defined in its superclass.

As a general recipe:

Every fragment type has a per type croquet event scope id, of the form #ns<fragmentypename>_, and, for each of its actions, a croquet event.  When an action occurs, we publish an event with the fragment type scope id, the action-specific event name, and event specific data. Usually this data is  a JS object with two fields: fid, containing the individual fragment id publishing, and a data field for additional event info. We produce these objects by calling out to JS via #newspeakFragmentData:data:. This JS function takes a fragment id and a data object, which can be anything that Croquet can serialize (so numbers, strings or vanilla objects, but not instances of specific classes with function valued fields etc.).

Back in Javascript, the root model subscribes to these events , scoping them using the aforementioned fragment type scope id.  The subscription specifies a root model method. When an event is detected, the method will be called with the event data as a parameter. The method in turn publishes an event whose name is of the form #model_<fragment specific scope>_ <action>. The fragment specific scope is the concatenation of the fragment type scope id and a fragment id number, which is usually found in the fid field of the incoming method argument. Associated with the event is the data from the incoming parameter.

Each fragment subscribes to such an event for each of its actions. Thus, it will be notified when croquet has processed the action - regardless of whether the action originated on the client that actually published, or any other client. Now it can act on the event data it receives.

The scheme is designed so that we only generate events upon user interaction. Thus the event pressure is bounded by the speed of human input. 

A complication to the above scheme is Croquet's use of snapshotting. Croquet expects all application state to be stored as serializable data in a Javascript Croquet model object, with the UI managed by the Croquet view objects that are essentially stateless. We are of course subverting this model, as all our state is in the Newspeak heap. In principle, we could add an image mechanism to Newspeak, store that image as a blob in the Croquet model and use it to restore the system. For now, we use a different solution. We store the entire event history in the model. This is a legitimate representation of the application state, as it can always be reconstructed from its initial state (the vfuel) by applying all events in order. 

When restoring a client from a Croquet snapshot, we play back any events in the snapshot that have not yet been seen by the client, bringing into sync. The logic managing the above process is located mainly in Javascript code. When the client starts up, it sets up Croquet before activating Newspeak. Usually, this will include playing back unprocessed events.  However, in the case where a fresh client starts up, Newspeak has not yet been run, no Hopscotch fragments have been created, and so no fragments have subscribed to events.  Hence, replaying events would have no effect in a fresh client. To remedy this, we have Hopscotch notify the JS code to replay after the very first presenter has been displayed. This is managed in #HopscotchShell>>displayPresenter:. We track whether this is the first presenter via the flag #isStartingUp.

A few other details also complicate the picture. These have to do with file handling, drag and drop, and menus, and are described in classes #FileChooserFragment, #MediaCreatorFragment and #Menu respectively.

Ultimately, we hope to go beyond the above, and be able to diff the saved model state and extend this to full local-first solution.
*)
  |
  (* Per fragment-type counters for managing fragment ids *)
  buttonCount <Integer> ::= 0.
  imageButtonCount <Integer> ::= 0.  
  radioButtonCount <Integer> ::= 0. 
  checkboxCount <Integer> ::= 0.
  hyperlinkCount <Integer> ::= 0.
  hyperlinkImageCount <Integer> ::= 0.
  codeMirrorCount <Integer> ::= 0.
  toggleComposerCount <Integer> ::= 0.
  textEditorCount <Integer> ::= 0.
  pickerCount <Integer> ::= 0.
  colorPickerCount <Integer> ::= 0.
  datePickerCount <Integer> ::= 0.  
  timePickerCount <Integer> ::= 0.
  sliderCount <Integer> ::= 0.
  dropDownMenuCount <Integer> ::= 0.  
  menuCount <Integer> ::= 0.
  windowCount <Integer> ::= 0.
  fileChooserCount <Integer> ::= 0.
  mediaCreatorCount <Integer> ::= 0.
  liveFileChoosers = List new.
  isStartingUp ::= true.
 (* JS access *)
  js = p js.   
|
) (
public class ButtonFragment label: l action: a = super ButtonFragment label: l action: a (
    |
    fragmentId <Integer> = newButtonId.
    scope_slot <String>
    |
    setupCroquetView
) (
updateVisualsFromSameKind: oldFragment <ButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[publish: 'nsbutton_' event: #button_click data: fragmentId printString]
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsbutton_', fragmentId printString].
  ^scope_slot
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        subscribe: #model_button_click handler: [:e | super action value]
)
) : (
)
public class ImageButtonFragment = super ImageButtonFragment (
    |
    fragmentId <Integer> = newImageButtonId.
    scope_slot <String>
    |
    setupCroquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsImagebutton_', fragmentId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ImageButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[publish: 'nsImagebutton_' event: #image_button_click data: fragmentId printString]
)
setupCroquetView = (
        subscribe: #model_image_button_click handler: [:e | super action value]
)
) : (
)
public class CheckboxFragment text: t <Holder> value: v <Boolean | Holder> action: a <[:Boolean]>  = super CheckboxFragment text: t value: v action: a (
    |
    fragmentId <Integer> = newCheckboxId.
    scope_slot <String>
    |
    setupCroquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscheckbox_', fragmentId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <CheckboxFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
writeInput: v = (
     checkbox at: 'checked' put: v.
     super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:b <Boolean> | (checkbox at: 'checked') printString out. publish: 'nscheckbox_' event: ((checkbox at: 'checked') ifTrue: [#checkBox_unchecked] ifFalse: [#checkBox_checked]) data: fragmentId printString. nil]
)
setupCroquetView = (
        subscribe: #model_checkBox_checked handler: [:e |  'checkbox checked event ' out. writeInput: true].
        subscribe: #model_checkBox_unchecked handler: [:e |  'checkbox unchecked event ' out. writeInput: false]
)
) : (
)
public class RadioButtonFragment text: t <String> 
	value: v <Boolean | Holder> 
	group: g <String> 
	action: a <[:Boolean]> = super RadioButtonFragment text: t value: v group: g action: a (
    |
    fragmentId <Integer> = newRadioButtonId.
    scope_slot <String>
    |
    setupCroquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsradiobutton_', fragmentId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <RadioButtonFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
writeInput: v = (
     button at: 'checked' put: v.
     super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:b <Boolean> | publish: 'nsradiobutton_' event: ((button at: 'checked') ifTrue: [#radioButton_pressed] ifFalse: [#radioButton_released]) data: fragmentId printString. nil]
)
setupCroquetView = (
  subscribe: #model_radioButton_pressed handler: [:e | writeInput: true].
  subscribe: #model_radioButton_released handler: [:e | writeInput: false]        
)
) : (
)
public class HyperlinkFragment label: l action: a = super HyperlinkFragment label: l action: a (
   |
    fragmentId <Integer> = newHyperlinkId.
    scope_slot <String>
    |
    setupCroquetView
) (
updateVisualsFromSameKind: oldFragment <HyperlinkFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
action = (
  ^[publish: 'nshyperlink_' event: #hyperlink_click data: fragmentId printString]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlink_', fragmentId printString].
  ^scope_slot
)
setupCroquetView = (
        subscribe: #model_hyperlink_click handler: [:e | super action value]
)
) : (
)
public class CodeMirrorFragment onText: t <String> = super CodeMirrorFragment onText: t (
    |
    fragmentId <Integer> = newCodeMirrorId.
    scope_slot <String>
    reflecting <Boolean> ::= true.
    |
    setupCroquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nscodemirror_', fragmentId printString].
  ^scope_slot
)
preventDefault: event <Alien>  = (
  (* Only the initiating client has an event to manage, and others have no access to this event; it cannot be serialized, so cannot be passed via croquet to other clients, and it would not be a valid event if it was. *)
)
respondToCancel = (
   reflecting ifTrue: [publish: 'nscodemirror_' event: #codeMirror_cancel data: codeMirrorData]
)
acceptFromKeydown: event <Alien> = (
  super respondToAccept: event
)
convertKeydown: kde <Alien[KeydownEvent]> ^ <Alien[JSObject]> = (
  ^js global sanitizeKeydownEvent: kde
)
cancelFromKeydown = (
  super respondToCancel
)
codeMirrorData = (
  ^js global newspeakFragmentData: fragmentId data: textBeingAccepted 
)
codeMirrorData: change <Alien[CodeMirrorChangeObject]> = (
  ^js global newspeakFragmentData: fragmentId data: (js global nsCodeMirrorData: textBeingAccepted change: change)
)
adjustCursorPos: change <Alien[CodeMirrorChangeRecord]> = (
(*
The change record from CodeMirror will have information on:

indices of change (#from, #to fields)
new text (#text field - an array of lines of new text)
old text (#removed field)
*)
  |
  text = change at: #text.
  linesInserted = text at: #length.
  from = change at: #from.
  fromLine = from at: #line.
  toLine = (change at: #to) at: #line.
  linesReplaced = toLine - fromLine +1.
  linesAdded = linesInserted - linesReplaced.
  targetLine = toLine + linesAdded.
  lastLineLength = linesInserted = 0 ifTrue: [0] ifFalse: [(text at: linesInserted - 1) size].
  baseCh = fromLine = targetLine ifTrue: [from at: #ch] ifFalse: [0].
  targetCh = baseCh + lastLineLength.
  |
  editor setCursor: (
    js global nsCursorPos: targetCh line: targetLine
  )
)
respondToKeyDown: event <Alien[Event]> = (
	| 
	key <Character> = event at: 'key'. 
    (* customary on mac, does not work on windows *)
	metaPressed <Boolean> = event at: 'metaKey'.
    (* works on windows *)
    ctrlPressed <Boolean> = event at: 'ctrlKey'.   
    shiftPressed <Boolean> = event at: 'shiftKey'.
	|
	reflecting ifTrue: [
          ((key = 'Enter' and: [metaPressed or: [ctrlPressed or: [shiftPressed]]])
	      or: [key = 'Escape']) ifTrue: [event preventDefault].
          publish: 'nscodemirror_' event: #codeMirror_keydown data: (js global newspeakFragmentData: fragmentId data: (convertKeydown: event))
      ]
)
respondToAccept: event <Alien[Event]> = (
  reflecting ifTrue: [publish: 'nscodemirror_' event: #codeMirror_accept data: codeMirrorData]
)
selectionEventData: event = (
  ^js global nsCodeMirrorSelectionChange: event 
)
adjustSelection: selection <Alien[Range]> = (
  editor setSelection: (selection at: #anchor) head: (selection at: #head)
)
respondToBeforeSelectionChange: event <Alien[Event]> = (
   reflecting ifTrue: [publish: 'nscodemirror_' event: #codeMirror_beforeSelectionChange data: (js global newspeakFragmentData: fragmentId data: (selectionEventData: event))]
)
updateVisualsFromSameKind: oldFragment <CodeMirrorFragment>  ^ <Alien[Element]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
updateEditedText: oldFragment <CodeMirrorFragment> = (
(* We don't want spurious changes signaling croquet, so we update only when needed. This isn't quite right. This will update when needed, but even that is not a real change. This method is called when no edits have occurred. The situation to worry about is when we edited a method and changed the selector, changing a different method. That method has changed, even though it was not being edited. At the same time, the edited method has not changed, yet the text in its editor has. So it was always best to just update the method. However, we do need to avoid the change events thereby generated. Once the correct test for this is implemented, it will likely be cheaper to use it to avoid the notification than to compare old and new text. *)
  textSlot = oldFragment textBeingAccepted ifFalse: [editor setValue: textSlot].
)
setupCroquetView = (
   subscribe: #model_codeMirror_change handler: [:e | 
     reflecting ifTrue: [
       reflecting:: false. 
       hasVisual ifTrue: [ 
         | newText = e at: #textBeingAccepted. |
         editor setValue: newText.
         adjustCursorPos: (e at: #change).
         ]. 
       super respondToChange: e. 
       reflecting:: true
     ] ifFalse: [reflecting:: true]].
   subscribe: #model_codeMirror_beforeChange handler: [:e | reflecting ifTrue: [reflecting:: false. super respondToBeforeChange: e. reflecting:: true] ifFalse: [reflecting:: true]].  
   subscribe: #model_codeMirror_keydown handler: [:e | reflecting ifTrue: [reflecting:: false. super respondToKeyDown: e. reflecting:: true] ifFalse: [reflecting:: true]].
   subscribe: #model_codeMirror_accept handler: [:e | reflecting ifTrue: [reflecting:: false. super respondToAccept: e. reflecting:: true] ifFalse: [reflecting:: true]].
   subscribe: #model_codeMirror_cancel handler: [:e | reflecting ifTrue: [reflecting:: false. super respondToCancel. reflecting:: true] ifFalse: [reflecting:: true]].
      subscribe: #model_codeMirror_beforeSelectionChange handler: [:e | reflecting ifTrue: [reflecting:: false. adjustSelection: e. reflecting:: true] ifFalse: [reflecting:: true]]
)
respondToChange: change <Alien[CodeMirrorChangeObject]> = (
  reflecting ifTrue: [publish: 'nscodemirror_' event: #codeMirror_change data: (codeMirrorData: (js global nsCodeMirrorChange: change))]
)
respondToBeforeChange: event <Alien[Event]> = (
   reflecting ifTrue: [publish: 'nscodemirror_' event: #codeMirror_beforeChange data: codeMirrorData]
)
) : (
)
public class HyperlinkImageFragment image: i action: a = super HyperlinkImageFragment (|
    fragmentId <Integer> = newHyperlinkImageId.
    scope_slot <String>
    |
    setupCroquetView
) (
action = (
  ^[publish: 'nshyperlinkImage_' event: #hyperlink_image_click data: fragmentId printString]
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nshyperlinkImage_', fragmentId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <HyperlinkImageFragment>  ^ <Alien[LinkElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
        subscribe: #model_hyperlink_image_click handler: [:e | super action value]
)
) : (
)
public class ToggleComposer collapsedDefinition: collapsed <[Fragment]>
    expandedDefinition: expanded <[Fragment]>
    initiallyExpanded: flag <Boolean> = super ToggleComposer collapsedDefinition: collapsed 
    expandedDefinition: expanded 
    initiallyExpanded: flag (
    |
    fragmentId <Integer> = newToggleComposerId.
    scope_slot <String>
    |
    setupCroquetView
) (
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nstogglecomposer_', fragmentId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <ToggleComposer>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
interactiveToggle = (
  publish: 'nstogglecomposer_' event: #toggleComposer_toggle data: fragmentId printString
)
setupCroquetView = (
        subscribe: #model_toggleComposer_toggle handler: [:e | super interactiveToggle]
)
) : (
)
public class TextEditorFragment = super TextEditorFragment (
    |
    fragmentId <Integer> = newTextEditorId.
    scope_slot <String>
    |
    setupCroquetView
) (
updateVisualsFromSameKind: oldFragment <TextEditorFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstexteditor_', fragmentId printString].
  ^scope_slot
)
textEditorData = (
  ^js global newspeakFragmentData: fragmentId data: (textEditor at: 'value')
)
respondToCancel: event <Alien[Event]> = (
  publish: 'nstexteditor_' event: #textEditor_cancel data: textEditorData 
)
respondToAccept: event <Alien[InputEvent]> = (
  publish: 'nstexteditor_' event: #textEditor_accept data: textEditorData
)
respondToChange: event <Alien[InputEvent]> = (
  publish: 'nstexteditor_' event: #textEditor_change data: textEditorData
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)

        subscribe: #model_textEditor_accept handler: [:e | 
          textEditor at: 'value' put: e. 
          super respondToAccept: e
        ].
        subscribe: #model_textEditor_change handler: [:e | 
          textEditor at: 'value' put: e.
          textEditor setSelectionRange: e size to: e size.
           super respondToChange: e. 
         ].
        subscribe: #model_textEditor_cancel handler: [:e | super respondToCancel: e]      
)
) : (
)
public class PickerFragment text: t <String> items: i <List[String]> action: a <[:String]> = super PickerFragment text: t items: i action: a (
    |
    fragmentId <Integer> = newPickerId.
    scope_slot <String>
    |
    setupCroquetView
) (
updateVisualsFromSameKind: oldFragment <PickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nspicker_', fragmentId printString].
  ^scope_slot
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)   
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | publish: 'nspicker_' event: #picker_pick data: pickerData. nil]
)
pickerData = (
  ^js global newspeakFragmentData: fragmentId data: extractInput
)
setupCroquetView = (
        (* ensure a corresponding Croquet view is set *)
        (* When the Croquet view is notified of a click, it will write the input *)
        subscribe: #model_picker_pick handler: [:e | writeInput: e]
)
) : (
)
public class ColorPickerFragment value: v <String | Holder> action: a <[:String]> = super ColorPickerFragment value: v action: a (
    |
    fragmentId <Integer> = newColorPickerId.
    scope_slot <String>
    |
    setupCroquetView
) (
updateVisualsFromSameKind: oldFragment <ColorPickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nscolorpicker_', fragmentId printString].
  ^scope_slot
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | publish: 'nscolorpicker_' event: #colorPicker_pick data: colorPickerData. nil]
)
colorPickerData = (
  ^js global newspeakFragmentData: fragmentId data: extractInput
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will write the input *)
        subscribe: #model_colorPicker_pick handler: [:e | writeInput: e]
)
) : (
)
public class DatePickerFragment value: v <String | Holder> action: a <[:String]> = super DatePickerFragment value: v action: a (
    |
    fragmentId <Integer> = newDatePickerId.
    scope_slot <String>
    |
    setupCroquetView
) (
updateVisualsFromSameKind: oldFragment <DatePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsdatepicker_', fragmentId printString].
  ^scope_slot
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | publish: 'nsdatepicker_' event: #datePicker_pick data: datePickerData. nil]
)
datePickerData = (
  ^js global newspeakFragmentData: fragmentId data: extractInput
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will write the input *)
        subscribe: #model_datePicker_pick handler: [:e | writeInput: e]
)
) : (
)
public class TimePickerFragment value: v <String | Holder> action: a <[:String]> = super TimePickerFragment value: v action: a (
    |
    fragmentId <Integer> = newTimePickerId.
    scope_slot <String>
    |
    setupCroquetView
) (
updateVisualsFromSameKind: oldFragment <TimePickerFragment>  ^ <Alien[ButtonElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nstimepicker_', fragmentId printString].
  ^scope_slot
)
writeInput: v = (
  (* Set the value, in the DOM, in case it is a remote notice from Croquet. This is needed when this client is not the one that initiated the change *)
   picker at: 'value' put: v.
   (* Then do the usual action via a call to the super method *)
   super writeInput: v.
)
inputHandler ^ <[:Alien | Boolean]> = (
  ^[:event | publish: 'nstimepicker_' event: #timePicker_pick data: timePickerData. nil]
)
timePickerData = (
  ^js global newspeakFragmentData: fragmentId data: extractInput
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will write the input *)
        subscribe: #model_timePicker_pick handler: [:e |  writeInput: e]
)
) : (
)
public class SliderFragment value: v <Holder> min: mn <Float> max: mx <Float> = super SliderFragment value: v min: mn max: mx (
    |
    fragmentId <Integer> = newSliderId.
    scope_slot <String>
    |
    setupCroquetView
) (
updateVisualsFromSameKind: oldFragment <SliderFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsslider_', fragmentId printString].
  ^scope_slot
)
writeInput: v = (
  visual at: 'value' put: v.
   super writeInput: v.
)
inputHandler ^ <[:Ailen | Boolean]> = (
  ^[:event | publish: 'nsslider_' event: #slider_pick data: sliderData. nil]
)
sliderData = (
  ^js global newspeakFragmentData: fragmentId data: extractInput
)
setupCroquetView = (
        (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
        subscribe: #model_slider_pick handler: [:e | writeInput: e]
)
) : (
)
public class DropDownMenuFragment menu: ms image: img <Image> alignment: side <Symbol> = super DropDownMenuFragment menu: ms image: img alignment: side (
(*
Dropdown menus operate in two stages: first, the menu button is clicked, to display the actual menu.  This is handled in this class, via #clickHandler, which publishes the #dropDownMenu_click event.
Once the menu is displayed, individual entries in it can be clicked.  This is handled via class #Menu. Here we compute an instance of #Menu based on the menu contents; this is what gets displayed.
*)
    |
    fragmentId <Integer> = newDropDownMenuId.
    public scope <String> =  'nsdropdownmenu_', fragmentId printString.
    |
    setupCroquetView
) (
updateVisualsFromSameKind: oldFragment <DropDownMenuFragment>  ^ <Alien[InputElement]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
setupCroquetView = (
  (* When the Croquet view is notified of a click, it will call back to the Newspeak button to perform its normal action *)
  subscribe: #model_dropDownMenu_click handler: [:e | super clickHandler value: e]
)
clickHandler ^ <[:Alien | Boolean]> = (
  ^[:event | publish: 'nsdropdownmenu_' event: #dropDownMenu_click data: fragmentId. nil]
)
updateContent ^ <Alien[Element]> = (
   (* Overriden so as to wrap the menu items so that their actions post Croquet events *)
    | menu <Alien[Div]> = computeContentForMenu: [(Menu supplier: menuSupplier) menuContents] . |
    isActive: true.
	showMenu: menu forShell: shell inVisual: visual.
    ^menu.
)
) : (
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: #right
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> alignment: side <Symbol> ^ <Instance> = (
   ^menu: ms image: dropDownImage alignment: side
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> image: img <Image> ^ <Instance> = (
   ^menu: ms image: img alignment: #right
)
)
public class Fragment = super Fragment (
|
public croquetView_slot <Promise[Alien[NewspeakCroquetFragmentView]]>
|
) (
croquetModel = (
    ^croquetView model.
)
croquetView = (
    croquetView_slot isNil ifTrue: [setupCroquetView].
    ^croquetView_slot
)
setupCroquetView = (
  (* only fragments that actively need croquet support need this *)
  subclassResponsibility
)
subscribe: eventSpec <String> handler: blk <[CroquetEvent]> = (
  subscribeFragment: fragmentId scope: scope eventSpec: eventSpec handler: blk
)
) : (
)
public class Menu supplier: ms <[{Symbol | {String. []}}]>  = (
(*
This class reifies the structure displayed by a dropdown menu when it is clicked, ergo, the list of menu entries (the actual menu). The handling of the latter clicking is done in #DropDownMenuFragment.

Instances of this class are not proper fragments in and of themselves (perhaps an oversight in the Hopscotch menu design for the web).
Nevertheless, it operates in a similar manner. Each entry shows the original menu text, but wraps the corresponding action so that when the entry is clicked, an event will get published indicating what entry was selected.  A handler is set up, subscribing to the notification events from the model, that uses the name of the entry provided by the event to choose the appropriate action. This is done by looking it up in a map, #menuItemMap, which is constructed from the original menu supplier, #ms, via the #buildMenuItemMap method.
*)
	| 
    fragmentId <Integer> = newMenuId.
    public menuContents <List[Symbol | {String. []}]> = List new.
    menuItemMap <Map[String, []]> = Map new.
	|
    buildMenuItemMap: ms.
    setupCroquetView.
) (
lazy scope <String> = 'nsmenu_', fragmentId printString.
buildMenuItemMap: ms <[{Symbol | {String. []}}]> ^  <Map[String, []]> = (
   ms value do: [:item <Symbol | {String. []}> |
       item = #separator ifFalse: [
	 menuItemMap at: item first put: item last.	 
	 menuContents add: {item first. [
         publish: 'nsmenu_' event: 'menu_click' data: (js global newspeakFragmentData: fragmentId data: item first)]}.
     ]
     ifTrue: [menuContents add: #separator].
   ]
)
setupCroquetView = (
        subscribeFragment: fragmentId scope: scope eventSpec: #model_menu_click handler: [:e <String> | (menuItemMap at: e) value]
)
) : (
)
class HopscotchShell = super HopscotchShell (
(* We override HopscotchShell, much like we override fragments. This is needed because users interact via the navigation buttons in the web browser (or our own navigation buttons in non-browser configurations. 

This behavior is routed through the #userBack: method, which handles web browser navigation events ('onpopstate'). 
*)
  | fragmentId <Integer> = newWindowId. |
  setupCroquetView.
) (
scope = (
  ^'nsshell_', fragmentId printString
)
setupCroquetView = (
  subscribeFragment: fragmentId scope: scope eventSpec: #model_shell_userBack handler: [:e | super userBack: e. nil]
)
convertPopState: event  = (
   ^js global nsPopstateData: event
)
userBack: event  = (
   publish: 'nsshell_' event: #shell_userBack data: (js global newspeakFragmentData: fragmentId data: (convertPopState: event))
)
public displayPresenter: p = (
  super displayPresenter: p.
  (* As explained in the class comment, the very first presenter we display needs to notify the JS code that a replay of any unprocessed events should be done.*)
  isStartingUp ifTrue: [
    isStartingUp:: false. 
    (* Notify croquet that it can reply. We cannot the replay code synchronously at this point. because the event handlers that will be replayed assume that all Newspeak processing for the turn was completed by the time they are called (as it is in normal execution).  Hence the async message send. *)
    rootView <-: replay
    ]. 
)
) : (
)
class FileChooserFragment allowMultiples: b <Boolean> = super FileChooserFragment allowMultiples: b (
(*
This fragment is a bit unusual. We deviate somewhat from this module's standard formula for overriding fragments. The browser will not allow the standard (i.e., inherited) FileChooserFragment action to take place unless there was an actual user action (i.e., the user activated the UI).
As a result, only the client where the request to load files was initiated can respond with a file dialog, and only in the same turn.  This means we must take action to read files immediately, and so the #chooseFileList: method calls the super method. However, it sends it a different closure than the one passed in to it.
The original closure is stored in the #lastAction slot, while the super method is passed a closure that accepts the locally read file metadata, and forwards that data as part of the event sent to the croquet reflector.  The actual file contents are stored on the croquet server as well. The separation of metadata and file contents is needed because of size restrictions on events. When the reflector responds, the data is used to look up file contents on the server so they can be fed into the original closure kept in #lastAction. See  #chooseFlieList: and #setupCroquetView for the details.

A complication is that the file API is asynchronous, so we only have promises initially. We must wait for these promises to be resolved to obtain the required data which we will forward to the reflector. This is handled in #extractFileData:whenReady:.
*)
    |
    fragmentId <Integer> = newFileChooserId.
    scope_slot <String>
    lastAction <[:List[Alien[File]]]>
    |
    ('creating file chooser ', fragmentId printString) out.
    liveFileChoosers add: self.
    setupCroquetView
) (
public scope ^ <String> = (
  (* Lazily return a unique identifier for this fragment *)
  scope_slot isNil ifTrue: [scope_slot: 'nsfilechooser_', fragmentId printString].
  ^scope_slot
)
updateVisualsFromSameKind: oldFragment <FileChooserFragment>  ^ <Alien[Node]> = (
  scope_slot: oldFragment scope.
  ^self.
)
descriptorFor: fd <JSObject> ^ <JSObject> = (
(* Given a file description, produce a description of the metadata only, without the contents*)
  | descriptor = JSObject new. |
  (* Copy all the data except the actual file contents (the array buffer) to the incoming file descriptor *)
  {#name. #type. #lastModified. #webkitRelativePath } do: [:pn <Symbol> |
      descriptor at: pn put: (fd at: pn)
      ].
   ^descriptor
)
public chooseFileList:  blk <[:List[Alien[File]]]> = (
  (* Save the original closure for later *)
  lastAction:: blk.
  (* Locally read the files and pass their data to the reflector. In more detail:
      Once we've extracted the actual file contents, we can store them on the Croquet server. We then separate out the file metadata and pass that in the Croquet event. When that data is received by clients (including the one that sent it), it will be placed in File-like objects so that the original closure (now stored in #lastAction) can consume it.  See #setupCroquetView for details.
  *)
  super chooseFileList: [:fs <List[Alien[File]]> |  
    extractFileData: fs whenReady: [:fds <JSArray[JSObject]> |
      | 
      ps <List[Alien[Promise[[ArrayBuffer]]]]>  = (js global at: 'Array') new: fds at: #length. 
      descriptors =  (js global at: 'Array') new: fs size.
      |
      1 to: fs size do: [:i <Integer> |  | fd <JSObject> = fds at: i -1. |
        (* store the file contents in the reflector *)
        ps at: i - 1 put: (rootView storedData store: (fd at: #arrayBuff)).
        (* Gather file metadata, to be published to all clients *)
        descriptors at: i -1 put: (descriptorFor: fd).
      ].
      (* When data has been stored, publish notification, which will be passed on to all clients *)
      ((js global at: 'Promise') all: ps) then: [:handles <JSArray[CroquetHandle]> |
        0 to: fs size - 1 do: [:i <Integer> | (descriptors at: i)  at: #handle put: (handles at: i)].
        publish: 'nsfilechooser_' event: #fileChooser_click data: (js global newspeakFragmentData: fragmentId data: descriptors).
        'published' out.
        ] onError: [:ex |  alert: 'HopscotchForCroquet FileChooserFragment chooseFileList: ', ex printString. nil].
      ]
    ]
)
extractFileData: fs <List[Alien[File]]> whenReady: blk <[:JSArray[JSObject]]> = (
(* In principle, the data is the file list, fs. However, files cannot be serialized as part of a Croquet event. Even if they could, they are often too large. We must obtain their contents via their asynchronous API and package that up. We then feed the data into the blk parameter for further processing. See #chooseFileList: for what that further processing looks like.
 *)
  |
  ps <List[Alien[Promise[[ArrayBuffer]]]]>  = (js global at: 'Array') new: fs size.
  (* An array of file descriptors - JS objects of the form 
  {name: String, type: String, lastModified: Float, webkitRelativePath: String, handle: JSPromise, arrayBuff: Blob}
  *)
  fds <JSArray[JSObject]>  = (js global at: 'Array') new: fs size.
  |
  1 to: fs size do: [:i <Integer> | | f <Alien[File]> = fs at: i. |
    ps at: i - 1 put: (fs at: i) arrayBuffer.
    fds at: i - 1 put:  (descriptorFor: f).
  ].
  ((js global at: 'Promise') all: ps) then: [:buffers <JSArray[ArrayBuffer]> |
      0 to: fs size -1 do: [:i <Integer> | (fds at: i) at: #arrayBuff put: (buffers at: i)].
	  [blk value: fds. nil] on: Error do:  [:ex | alert:  'HopscotchForCroquet FileChooserFragment extractFileData:whenReady ', ex printString. nil].
      nil
	] onError: [:ex |  alert: ex printString. nil]
)
setupCroquetView = (
        (* When the Croquet view is notified of the chosen files, it will message us back with the file metadata. We will use that metadata to extract the file contents, stored on the Croquet server. We want to submit all that information to the original action block passed into #chooseFileList:. 
        The block wants a list of Files, so we need to feed it objects with the same API - including async methods that return the data. Of course, we actually resolved that data before posting the original event, and so the incoming data needs to repackaged into File-like objects with a fake async API.
        *)
        subscribe: #model_fileChooser_click handler: [
          (* The event data: an array of file descriptors - JS objects of the form 
             {name: String, type: String, lastModified: Float, webkitRelativePath: String, handle:   JSPromise *)
          :e <JSArray[JSObject]> | 
          | 
          len <Integer> = e at: #length.
          fds <List[Alien[File]]> = List new: len. 
          contents <JSArray[JSPromise]> = (js global at: 'Array') new: len.
          |
          (* repackage the file data into File-ish objects *)
          'processing subscription' out.
          (* Get the data from the server *)
          0 to: len - 1 do: [:i <Integer> | | fd <JSObject> =  e at: i. |
            contents at: i put:  (rootView storedData fetch: (fd at: #handle))
            ].
          (* Wait for data to resolve, and generate the File objects*)
          ((js global at: 'Promise') all: contents) then: [:cs |
             0 to: len -1 do: [:i <Integer> | 
               (e at: i) at: #arrayBuff put: (cs at: i).
               fds add: (createFile: (e at: i)).
               ].
               lastAction value: fds. 
               liveFileChoosers remove: self.
             nil
             ] onError: [:ex |  alert:  'HopscotchForCroquet FileChooserFragment setupCroquetView: ', ex printString. nil].
        ]
)
) : (
public new ^ <Instance> = (
  ^allowMultiples: false
)
)
class MediaCreatorFragment type: t <Symbol> name: fn <String> registry: mr <Map[String, Blob]> = super MediaCreatorFragment type: t name: fn registry: mr (
    |
    fragmentId <Integer> = newMediaCreatorId.
    scope_slot <String>
    |
    setupCroquetView.
) (
updateVisualsFromSameKind: oldFragment <MediaCreatorFragment>  ^ <Alien[Element]> = (
  scope_slot: oldFragment scope.
  ^super updateVisualsFromSameKind: oldFragment.
)
public scope ^ <String> = (
  scope_slot isNil ifTrue: [scope_slot: 'nsmediacreator_', fragmentId printString].
  ^scope_slot
)
public setFile: f <Alien[File]> = (
  (* publish event *)
  extractFileData: {f} whenReady: [:fds <JSArray[JSObject]> | 
      | 
      fd = fds at: 0.
      (* store the file contents in the reflector *)
      p  <JSPromise[CroquetHandle]> = rootView storedData store: (fd at: #arrayBuff).
      (* Gather file metadata, to be published to all clients *)
      descriptor = descriptorFor: fd.
      | 
      (* When data has been stored, publish notification, which will be passed on to all clients *)
      p then: [:handle <[CroquetHandle]> |
        (* update descriptor with handle *)
        descriptor  at: #handle put: handle.
        (* publish *)
        publish: 'nsmediacreator_' event: #mediacreator_setFile data: (js global newspeakFragmentData: fragmentId data: descriptor). 
        nil
        ] onError: [:ex |  alert: 'HopscotchForCroquet mediaForFile: ', ex printString. nil].  
  ].
)
file: f <Alien[File]> = (
  | uri = blobURIFor: f. |
  registry at: fileName put: f.
  holder content: (computeHolderContentsFrom: uri)
)
setupCroquetView = (
        subscribe: #model_mediaCreator_setFile handler: [:e | 
          |
          (* extract handle from event *)
          handle <[CroquetHandle]> = e at: #handle.
          (* retrieve file data *)
          p <JSPromise> = rootView storedData fetch: handle.
          |
          (* when the file data is actually ready ... *)
          p then: [:fd <Alien[JSObject]> |
             (* get the file contents and add to the file descriptor *)
             e at: #arrayBuff put: fd.
             (* derive a file object and pass to the super method to do the actual update *)
             file: (createFile: e). 
             nil
          ] onError: [:ex |  alert:  'HopscotchForCroquet MediaCreatorFragment setupCroquetView: ', ex printString. nil].
        ]     
)
) : (
)
newImageButtonId ^ <Integer> = (
  imageButtonCount:: imageButtonCount + 1.
  ^imageButtonCount
)
newRadioButtonId ^ <Integer> = (
  radioButtonCount:: radioButtonCount + 1.
  ^radioButtonCount
)
newHyperlinkId ^ <Integer> = (
  hyperlinkCount:: hyperlinkCount + 1.
  ^hyperlinkCount
)
newCodeMirrorId ^ <Integer> = (
  codeMirrorCount:: codeMirrorCount + 1.
  ^codeMirrorCount
)
newHyperlinkImageId ^ <Integer> = (
  hyperlinkImageCount:: hyperlinkImageCount + 1.
  ^hyperlinkImageCount
)
newToggleComposerId ^ <Integer> = (
  toggleComposerCount:: toggleComposerCount + 1.
  ^toggleComposerCount
)
newCheckboxId ^ <Integer> = (
  checkboxCount:: checkboxCount + 1.
  ^checkboxCount
)
newTextEditorId ^ <Integer> = (
  textEditorCount:: textEditorCount + 1.
  ^textEditorCount
)
rootModel ^ <Alien[NewspeakCroquetView]> = (
  ^rootView model
)
newPickerId ^ <Integer> = (
  pickerCount:: pickerCount + 1.
  ^pickerCount
)
newSliderId ^ <Integer> = (
  sliderCount:: sliderCount + 1.
  ^sliderCount
)
newColorPickerId ^ <Integer> = (
  colorPickerCount:: colorPickerCount + 1.
  ^colorPickerCount
)
newDatePickerId ^ <Integer> = (
  datePickerCount:: datePickerCount + 1.
  ^datePickerCount
)
newTimePickerId ^ <Integer> = (
  timePickerCount:: timePickerCount + 1.
  ^timePickerCount
)
newDropDownMenuId ^ <Integer> = (
  dropDownMenuCount:: dropDownMenuCount + 1.
  ^dropDownMenuCount
)
public dropDownImage = (
  ^super dropDownImage
)
replaceUndefined: event = (
  ^js global replaceUndefined: event
)
printJSObjectTree: event  = (
  ^js global printJSObjectTree: event
)
newMenuId ^ <Integer> = (
  menuCount::menuCount + 1.
  ^menuCount
)
newWindowId ^ <Integer> = (
  windowCount:: windowCount + 1.
  ^windowCount
)
newFileChooserId ^ <Integer> = (
  fileChooserCount:: fileChooserCount + 1.
  ^fileChooserCount
)
newButtonId ^ <Integer> = (
  buttonCount:: buttonCount + 1.
  ^buttonCount
)
JSObject  = ((* make JS Object constructor available to nested classes *)
  ^super JSObject
)
descriptorFor: fd <JSObject> ^ <JSObject> = (
(* Given a file description, produce a description of the metadata only, without the contents*)
  | descriptor = JSObject new. |
  (* Copy all the data except the actual file contents (the array buffer) to the incoming file descriptor *)
  {#name. #type. #lastModified. #webkitRelativePath } do: [:pn <Symbol> |
      descriptor at: pn put: (fd at: pn)
      ].
   ^descriptor
)
extractFileData: fs <List[Alien[File]]> whenReady: blk <[:JSArray[JSObject]]> = (
(* In principle, the data is the file list, fs. However, files cannot be serialized as part of a Croquet event. Even if they could, they are often too large. We must obtain their contents via their asynchronous API and package that up. We then feed the data into the blk parameter for further processing. See #chooseFileList: for what that further processing looks like.
 *)
  |
  ps <List[Alien[Promise[[ArrayBuffer]]]]>  = (js global at: 'Array') new: fs size.
  (* An array of file descriptors - JS objects of the form 
  {name: String, type: String, lastModified: Float, webkitRelativePath: String, handle: JSPromise, arrayBuff: Blob}
  *)
  fds <JSArray[JSObject]>  = (js global at: 'Array') new: fs size.
  |
  1 to: fs size do: [:i <Integer> | | f <Alien[File]> = fs at: i. |
    ps at: i - 1 put: (fs at: i) arrayBuffer.
    fds at: i - 1 put:  (descriptorFor: f).
  ].
  ((js global at: 'Promise') all: ps) then: [:buffers <JSArray[ArrayBuffer]> |
      0 to: fs size -1 do: [:i <Integer> | (fds at: i) at: #arrayBuff put: (buffers at: i)].
	  [blk value: fds. nil] on: Error do:  [:ex | alert:  'HopscotchForCroquet FileChooserFragment extractFileData:whenReady ', ex printString. nil].
      nil
	] onError: [:ex |  alert: ex printString. nil]
)
processMediaUpdatesFromFiles: files <List[Alien[File]]> = (
  
)
createFile: fd <JSObject> ^ <Alien[File]> = (
(* 
Given a file description, return a corresponding JS File object.
The argument is of the form 
{name: String, type: String, lastModified: Float, webkitRelativePath: String, handle: JSPromise, arrayBuff: JSArrayBuffer}
    *)
  | contents <JSArray> = (js global at: 'Array') new: 1. options = JSObject new. |
  contents at: 0 put: (fd at: #arrayBuff).
  options at: #type put: (fd at: #type);
               at: #lastModified put: (fd at: #lastModified).
  ^ (js global at: #File) new: contents name:  (fd at: #name) options: options
)
newMediaCreatorId ^ <Integer> = (
  mediaCreatorCount:: mediaCreatorCount + 1.
  ^mediaCreatorCount
)
public blobURIFor: file <Alien[File]> ^ <String> = (
 (* Make inherited method accessible to nested classes *)
  ^super blobURIFor: file
)
publish: s <String> event: en <String> data: d = (
   rootView <-: publish: s event: en data: d
)
rootView ^ <Alien[NewspeakCroquetView]> = ( 
 ^js global at: #theView
)
subscribeFragment: fragmentId scope: scope eventSpec: eventSpec <String> handler: blk <[CroquetEvent]> = (
(* For every subscription to a croquet event, record the subscription so it is available for replay after rejoining the session, then subscribe. *)
  | 
  handler = [:e | blk value: e.  (js global at: #eventProcessed) apply: nil. nil].
  |
  (* Record the handler for replay *)
  rootView addSubscription: scope eventSpec: eventSpec handler: handler. 
  (* subscribe to croquet as usual*)
  rootView <-: subscribe: scope eventSpec: eventSpec handler: handler
)
showMenu: menu <Alien[Div]> 
		forShell: s <HopscotchShell> 
		inVisual: v <Visual> = (
        (* Make the inherited method visible to nested classes *)
   super showMenu: menu forShell: s inVisual: v 
)
computeContentForMenu: menuSupplier <[Menu]> ^ <Alien[Div]> = (
(* Make the inherited method visible to nested classes *)
  ^super computeContentForMenu: menuSupplier
)
openMenu: aMenu <Menu> = (	
   (* Overriden so as to wrap the menu items so that their actions post Croquet events *)
	showMenu: (computeContentForMenu: [(Menu supplier: [aMenu]) menuContents]) forShell: shell inVisual: visual.
)
) : (
)
) : (
)
