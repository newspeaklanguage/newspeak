Newspeak3
'StructuredVCS'
class VCSUI usingPlatform: p vcs: vcs ide: ide = ((* The actual source control application

Copyright (c) 2010-2011 Matthias Kleine

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ''Software''), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*)|

private FileDirectory = p squeak FileDirectory.
private SmalltalkImage = p squeak SmalltalkImage.
private Smalltalk = p squeak Smalltalk.

private ExternalLauncher = p squeak ExternalLauncher.
private UIManager = p squeak UIManager.
private FileStream = p squeak FileStream.


private Set = p squeak Set.
private OrderedCollection = p squeak OrderedCollection.
private Color = p brazil Color.
private Gradient = p brazil plumbing Gradient.
private hopscotch = p hopscotch.
private Subject = hopscotch core Subject.
private Presenter = hopscotch core Presenter.
private RowComposer = hopscotch composers RowComposer.
private ColumnComposer = hopscotch composers ColumnComposer.
private BlankFragment = hopscotch fragments BlankFragment.
private TextEditorFragment = hopscotch fragments TextEditorFragment.
private TextLineEditorFragment = hopscotch fragments TextLineEditorFragment.
private SeparatorItem = hopscotch SeparatorItem.
private Menu = hopscotch Menu.
private MenuItem = hopscotch MenuItem.
private EditableLinePresenter = hopscotch fragments EditableLinePresenter.
private ProgrammingPresenter = ide tools ProgrammingPresenter. 
private HopscotchImages = p squeak HopscotchImages.
private Text = p squeak Text.
private TextColor = p squeak TextColor.
private TextDiffBuilder = p squeak TextDiffBuilder.

private vcs = vcs.
private logger = Future computing: [vcs core logger].
private sourceMirrors = vcs sourceMirrors.
private WordMerger = vcs diffing WordMerger.

private ClassSourceMirror = vcs newspeakSourceMirrors ClassSourceMirror.
private STPackageSourceMirror = vcs smalltalkSourceMirrors STPackageSourceMirror.
private STClassSourceMirror = vcs smalltalkSourceMirrors STClassSourceMirror.
private STExtensionClassSourceMirror = vcs smalltalkSourceMirrors STExtensionClassSourceMirror.



private backgroundColor = Color white.
private frameColor ::= Color gray: 0.5.

private presenters = Presenters new.

private SourceControlPresenter = presenters SourceControlPresenter.
private LocalRepositoryPresenter = presenters LocalRepositoryPresenter.
private RemoteRepositoryPresenter = presenters RemoteRepositoryPresenter.

private LocalHistorianPresenter = presenters LocalHistorianPresenter.
private RemoteHistorianPresenter = presenters RemoteHistorianPresenter.

private IncomingOutgoingPresenter = presenters IncomingOutgoingPresenter.

private HistorianRelationPresenter = presenters HistorianRelationPresenter.

private ImageBasedChangePresenter = presenters ImageBasedChangePresenter.
private MergeHistorianPresenter = presenters MergeHistorianPresenter.

private LogPresenter = presenters LogPresenter.
private VersionPresenter = presenters VersionPresenter.

private theModel ::= OrderedCollection new.
|) (
class BasePresenter onSubject: subject = ProgrammingPresenter onSubject: subject (
(* Provides UI elements common for source control's presenters *)|
|) (
'accessing'
h2Color = (

	^ Gradient 
		from: (Color h: 240 s: 0.04 v: 0.88) 
		to: (Color h: 240 s: 0.04 v: 0.86)
)
mediumHeadingColor = (

	^ Gradient 
		from: (Color h: 240 s: 0.04 v: 0.88) 
		to: (Color h: 240 s: 0.04 v: 0.86)
)
'actions'
refreshSCAfter: block = (

	sendUp refreshSCAfter: block 
)
'as yet unclassified'
removeButtonWithAction: aBlock = (
	^imageButton: {
		HopscotchImages default cancel16px.
		HopscotchImages default cancel16pxOver.
		HopscotchImages default cancel16pxDown}
	action: aBlock
)
'combinators'
h1: body = (

	^ majorHeadingBlock: body
)
h2: body = (

	^ (padded: body with: {10. 5. 5. 5.})
		color: h2Color
)
h3: body = (

	^ minorHeadingBlock: body
)
h4: body = (

	^ (padded: body with: {10. 0. 0. 0}) color: minorHeadingColor
)
listPresentersOf: subjects inIncrementsOf: limit = (

	| versionPresenters |
	versionPresenters:: (subjects first: (subjects size min: limit))
		collect: [:each | each presenter].
	^ column: (
		subjects size > limit
			ifTrue: [
				versionPresenters,
				{(remainingDefinitionFor: (subjects allButFirst: limit) limit: limit)}]
			ifFalse: [versionPresenters])
)
remainingDefinitionFor: subjects limit: limit = (

	| restHolder |
	restHolder:: holder: (
		link: '...'
		action: [
			restHolder content: (listPresentersOf: subjects inIncrementsOf: limit)]).
	^ restHolder
)
) : (
)
class MergingUI = (
(* A Hopscotch-based UI for displaying and merging 2 or 3 Newspeak source mirrors.

MergeSubjects have access to different versions of the object to be presented. If set to #diff mode, their presenters only show differences between the objects. If set to #merge mode, their presenters also provide tools to choose how to merge.

Several specializations of MergeSubject exist that allow diffing/merging different kinds of objects. A MirrorMergeSubject merges 2 or 3 Newspeak mirrors, represented as a TreeDiff. Specializations exists for different kinds of mirrors. A TextMergeSubject allows diffing/merging plaing strings.

The UIs for diffing and merging are very similar, with the merging UI adding some features to the diffing UI. One could think of implementing the two functionalities as two sets of classes (e.g. ClassMirrorDiffSubject/Presenter and ClassMirrorMergeSubject/Presenter). It seems to be easier with only one set of classes, though. Presenter methods usually have to add new UI elements for the merging case. Currently they can simply do so by adding using ifMerging:. Using one set of classes, the mode becomes part of the model. *)|
|) (
class ClassMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|) (
'as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (

	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (

	| subjects |
	^ column: {
		subject category presenter.
		subject accessModifier presenter.
		subject name presenter.
		subject constructor presenter.
		subject superclassClause presenter.
		subject classComment presenter.
		subject slotsSource presenter.
		subject initExpressions presenter.
		sortedPresenters: subject unequalClassSubjects.
		sortedPresenters: subject unequalInstanceMethodSubjects
			labeledIfNotEmpty: 'Instance methods'.
		sortedPresenters: subject unequalClassMethodSubjects
			labeledIfNotEmpty: 'Class methods'}
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
sortedPresenters: subjects = (

	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])
		collect: [:each | each presenter])
)
sortedPresenters: presenters  labeledIfNotEmpty: label = (

	^ presenters isEmpty
		ifTrue: [nothing]
		ifFalse: [
			column: {
				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.
				sortedPresenters: presenters}]	
)
updateHolders = (

	headerHolder content: headingDefinition
)
) : (
)
public class ClassMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (|
public category = textMergeSubjectFor: #category title: 'Category'.
public accessModifier = textMergeSubjectFor: #accessModifier title: 'Access Modifier'.
public name = textMergeSubjectFor: #name title: 'Name'.
public constructor = textMergeSubjectFor: #constructor title: 'Constructor'.
public superclassClause = textMergeSubjectFor: #superclassClause title: 'Superclass Clause'.
public classComment = textMergeSubjectFor: #classComment title: 'Comment'.
public slotsSource = textMergeSubjectFor: #slotsSource title: 'Slots'.
public initExpressions = textMergeSubjectFor: #initExpressions title: 'Init Expressions'.
public classes = create: self class for: #classes.
public instanceMethods = create: MethodMirrorMergeSubject for: #instanceMethods.
public classMethods = create: MethodMirrorMergeSubject for: #classMethods.
|) (
'as yet unclassified'
public canLoadTheirs = (

	^ treeDiff anyNode isToplevel
)
create: klass for: nodeType = (

	^ Future computing: [
		| treeDiffs |
		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].
		treeDiffs collect: [:each | klass onModel: {each. mode. self}]]
)
public createPresenter = (

	^ ClassMirrorMergePresenter onSubject: self
)
public loadTheirs = (

	treeDiff left installAsToplevelClass.
)
manualMergeMirrorIfFail: failBlock = (

	^ ClassSourceMirror new
		category: category finalMerge asString;
		accessModifier: accessModifier finalMerge asString;
		name: name finalMerge asString;
		constructor: constructor finalMerge asString;
		superclassClause: superclassClause finalMerge asString;
		classComment: classComment finalMerge asString;
		slotsSource: slotsSource finalMerge asString;
		initExpressions: initExpressions finalMerge asString;
		classes: (presentMirrorsOf: classes ifFail: failBlock);
		instanceMethods: (presentMirrorsOf: instanceMethods ifFail: failBlock);
		classMethods: (presentMirrorsOf: classMethods ifFail: failBlock);
		yourself
)
public mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
mirrorMergeSubjects = (

	^ {classes. instanceMethods. classMethods}
)
textMergeSubjects = (

	^ {category. accessModifier. name. constructor. superclassClause. classComment. slotsSource. initExpressions}
)
public unequalClassMethodSubjects = (

	^ classMethods reject: [:each | each treeDiff isEquals]
)
public unequalClassSubjects = (

	^ classes reject: [:each | each treeDiff isEquals]
)
public unequalInstanceMethodSubjects = (

	^ instanceMethods reject: [:each | each treeDiff isEquals]
)
) : (
'as yet unclassified'
public diffSubjectOn: treeDiff = (
	^ onModel: treeDiff withMode: #diff
)
mergeSubjectOn: treeDiff = (

	^ onModel: treeDiff withMode: #merge
)
onModel: treeDiff withMode: mode = (
	| subjectClass |
	
	treeDiff anyNode yourself isPackageMirror
		ifTrue: [subjectClass:: PackageMirrorMergeSubject].
	
	treeDiff anyNode yourself isClassDeclarationMirror
		ifTrue: [subjectClass:: ClassMirrorMergeSubject].
	
	treeDiff anyNode yourself isImageMirror
		ifTrue: [subjectClass:: ImageMirrorMergeSubject].

	treeDiff anyNode yourself isTextMirror
		ifTrue: [subjectClass:: TextMirrorMergeSubject].
		
	^subjectClass onModel: {treeDiff. mode. nil}
)
)
class ExtendedClassMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|) (
'as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (

	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (

	| subjects |
	^ column: {
		subject name presenter.
		sortedPresenters: subject unequalInstanceMethodSubjects
			labeledIfNotEmpty: 'Instance methods'.
		sortedPresenters: subject unequalClassMethodSubjects
			labeledIfNotEmpty: 'Class methods'}
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
sortedPresenters: subjects = (

	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])
		collect: [:each | each presenter])
)
sortedPresenters: presenters  labeledIfNotEmpty: label = (

	^ presenters isEmpty
		ifTrue: [nothing]
		ifFalse: [
			column: {
				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.
				sortedPresenters: presenters}]	
)
updateHolders = (

	headerHolder content: headingDefinition
)
) : (
)
class ExtendedClassMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model ((*  *)|

name = textMergeSubjectFor: #name title: 'Name'.
instanceMethods = create: MethodMirrorMergeSubject for: #instanceMethods.
classMethods = create: MethodMirrorMergeSubject for: #classMethods.
|) (
'as yet unclassified'
public canLoadTheirs = (

	^false
)
create: klass for: nodeType = (

	^ Future computing: [
		| treeDiffs |
		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].
		treeDiffs collect: [:each | klass onModel: {each. mode. self}]]
)
public createPresenter = (

	^ ExtendedClassMirrorMergePresenter onSubject: self
)
manualMergeMirrorIfFail: failBlock = (

	^ExtendedClassSourceMirror new
		name: name finalMerge asString;
		instanceMethods: (presentMirrorsOf: instanceMethods ifFail: failBlock);
		classMethods: (presentMirrorsOf: classMethods ifFail: failBlock);
		yourself
)
public mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
mirrorMergeSubjects = (

	^ {instanceMethods. classMethods}
)
textMergeSubjects = (

	^ {name}
)
public title = (
	^'*', super title
)
public unequalClassMethodSubjects = (

	^ classMethods reject: [:each | each treeDiff isEquals]
)
public unequalInstanceMethodSubjects = (

	^ instanceMethods reject: [:each | each treeDiff isEquals]
)
) : (
)
class ImageMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|) (
'as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (
	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (
	^ row: {
		filler.
		subject leftForm ifNil: [label: '<nothing>'] ifNotNil: [:it | image: it].
		filler.
		filler.
		subject rightForm ifNil: [label: '<nothing>'] ifNotNil: [:it | image: it].
		filler}
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
updateHolders = (

	headerHolder content: headingDefinition
)
) : (
)
class ImageMirrorMergeSubject onModel: m = MirrorMergeSubject onModel: m () (
'as yet unclassified'
public canLoadTheirs = (

	^ true
)
public createPresenter = (
	^ ImageMirrorMergePresenter onSubject: self
)
leftForm = (

	^ treeDiff left ifNotNil: [:it | it form]
)
public loadTheirs = (
	treeDiff left installAsToplevelClass.
)
public mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		halt. ^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
rightForm = (

	^ treeDiff right ifNotNil: [:it | it form]
)
) : (
)
class MergePresenter onSubject: subject = BasePresenter onSubject: subject (|
|) (
'as yet unclassified'
colorFor: a and: b = (
	(a = b) ifTrue: [^Color transparent].
	a isNil ifTrue: [^Color paleGreen].
	b isNil ifTrue: [^Color paleRed].
	^Color paleYellow.
)
colorIndicatingSelectionStatusForSide: side = (
	subject currentSelection = side ifFalse: [^Color gray].
	subject isAddition ifTrue: [^Color r: 0 g: 0.5 b: 0].
	subject isDeletion ifTrue: [^Color r: 0.7 g: 0 b: 0].
	^Color black
)
display: a color: aColor fcolor: afColor nextTo: b color: bColor fcolor: bfColor = (
	^RowComposer definitions: {
		(ColumnComposer definitions: {RowComposer definitions: {((ColumnComposer definitions: {RowComposer definitions: {a width: 0 elasticity: 1}}) width: 0 elasticity: 1) color: aColor. BlankFragment size: 13}}) width: 0 elasticity: 1; color: afColor.
		(ColumnComposer definitions: {RowComposer definitions: {BlankFragment size: 13}}) color: backgroundColor.
		(ColumnComposer definitions: {RowComposer definitions: {BlankFragment size: 13. ((ColumnComposer definitions: {RowComposer definitions: {b width: 0 elasticity: 1}}) width: 0 elasticity: 1) color: bColor}}) width: 0 elasticity: 1; color: bfColor.
	}
)
display: a nextTo: b color: color = (
	^display: a
	color: color
	fcolor: Color transparent
	nextTo: b
	color: color
	fcolor: Color transparent
)
elasticTextDisplay: text = (

	^ (textDisplay: text) width: 0 elasticity: 1
)
headingDefinition = (
	^row: {
		headingForSide: #theirSource labeled: 'theirs'.
		halfColumnSeparator.
		ifConflict: [
			headingForSide: #commonAncestorSource labeled: 'common ancestor'].
		(* link: '?' action: [self inspect]. *)
		halfColumnSeparator.
		headingForSide: #ourSource labeled: 'ours'}
)
headingForSide: side labeled: sideLabel = (
	
	^ (h4: (row: 
		{
			(label: headingLabel asText allBold) 
				color: (colorIndicatingSelectionStatusForSide: side);
				compressibility: 1.
			smallBlank.
			linkToSelectSide: side
		})) width:0 elasticity: 1
)
headingLabel = (

	subject isAddition ifTrue: [^subject title, ' was added'].
	subject isDeletion ifTrue: [^subject title, ' was removed'].
	^subject title
)
ifConflict: block = (

	^ subject isConflict
		ifTrue: block
		ifFalse: [nothing]
)
ifMerging: block = (

	^ subject isMerge
		ifTrue: block
		ifFalse: [nothing]
)
linkToSelectSide: side = (

	^ side = subject currentSelection
		ifTrue: [nothing]
		ifFalse: [
			link: 'select' action: [
				chooseSide: side]]
)
textDiffPresenterFor: merger = (
	| useOldDiffStyle = true. |
	merger anyChanged ifFalse: [^ nil].
	
	(useOldDiffStyle and: [merger bothChanged not]) 
		ifTrue: [^textDiffPresenterOldStyle].
	
	^ row: {
		elasticTextDisplay: merger leftOut.
		halfColumnSeparator.
		merger bothChanged
			ifTrue: [elasticTextDisplay: merger ancestorOut]
			ifFalse: [nothing].
		halfColumnSeparator.
		elasticTextDisplay: merger rightOut}.
)
textDiffPresenterOldStyle = (
	| col |
	subject calculateChanges.
	col:: OrderedCollection new.
	subject leftChanges with: subject rightChanges do:
		[:a :b | | textA textB color |
		color:: colorFor: a and: b.
		textA:: Text streamContents:
			[:as |
			textB:: Text streamContents:
				[:bs |
				textFor: a with: as and: b with: bs]].
		col add: (display: (textDisplay: textA) nextTo: (textDisplay: textB) color: color)].
	col size > 300 ifTrue: [^column: {label: 'Diff too big for Hopscotch/Brazil to layout'}].
	^column: col
)
textFor: a with: as <WriteStream> and: b with: bs <WriteStream> = (
	| patchSequence |
	(a = b or: [a isNil or: [b isNil]]) ifTrue: [
		as nextPutAll: (a ifNil: [' ']).
		bs nextPutAll: (b ifNil: [' ']).
		^self].
	patchSequence: (WordDiffBuilder from: a to: b) buildPatchSequence.
	patchSequence do:
		[:patch |
		#match = patch key ifTrue: [
			as nextPutAll: patch value.
			bs nextPutAll: patch value].
		#remove = patch key ifTrue: [
			as withAttributes: {TextColor red} do: [
				as nextPutAll: patch value]].
		#insert = patch key ifTrue: [
			bs withAttributes: {TextColor color: (Color r: 0.0 g: 0.55 b: 0.0)} do: [
				bs nextPutAll: patch value]]]
)
) : (
)
class MergeSubject onModel: model = Subject onModel: model ((* A merge subject holds the state of an tree diff or text being merged or diffed. *)|
	public currentSelection ::= defaultResult.
|) (
'as yet unclassified'
childChoseSide: side = (

	currentSelection = side ifFalse: [
		currentSelection: #manualMerge].
	nil = parentSubject ifFalse: [
		parentSubject childChoseSide: currentSelection]
)
public chooseSide: side = (

	currentSelection: side.
	childChoseSide: side
)
defaultResult = (

	subclassResponsibility
)
isChange = (

	^ (self isAddition or: [self isDeletion or: [self isEquals]]) not
)
public isMerge = (

	mode = #merge ifTrue: [^true].
	mode = #diff ifTrue: [^false].
	halt.
)
public mergeModel = (

	^ model first
)
mode = (

	^ model second
)
parentSubject = (

	^ model third
)
) : (
)
class MethodMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|


|) (
'as yet unclassified'
definition = (

	(* Don't show the category unless it was actually changed *)
	^ subject category isChange
		ifFalse: [subject mergedSource presenter]
		ifTrue: [column: {
			subject category presenter.
			subject mergedSource presenter}]
)
) : (
)
class MethodMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (|
public mergedSource = textMergeSubjectFor: #source title: title verificationBlock: [:source :failBlock | createMirrorFrom: source ifFail: failBlock].
public category = textMergeSubjectFor: #category title: 'Category of ', title.
cachedMirror

|) (
'as yet unclassified'
createMirrorFrom: source ifFail: failBlock = (

	| newMirror |
	
	newMirror::  sourceMirrors
		methodMirrorForStream: source asString readStream
		ifError: failBlock.
	newMirror category: category finalMerge asString.
	^ newMirror
)
public createPresenter = (

	^ MethodMirrorMergePresenter onSubject: self
)
public mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	cachedMirror ifNil: [
		cachedMirror:: createMirrorFrom: mergedSource finalMerge ifFail: failBlock].
	presentBlock value: cachedMirror
)
removedAfterMerge = (

	^ mergedSource finalMerge isEmpty
)
textMergeSubjects = (

	^ {mergedSource. category}
)
public title = (
	^ super title
)
) : (
)
class MirrorMergePresenter onSubject: subject = MergePresenter onSubject: subject (|
	
|) (
) : (
)
class MirrorMergeSubject onModel: model <TreeDiff> = MergeSubject onModel: model (|

|) (
'as yet unclassified'
defaultResult = (

	treeDiff changeInfo isEquals ifTrue: [
		^ #ourSource].
	treeDiff changeInfo isLeft ifTrue: [
		^ #theirSource].
	treeDiff changeInfo isRight ifTrue: [
		^ #ourSource].
	^ #manualMerge
)
public interestingChange = (

	(* I this a change that should be shown by default? *)
	^ (isEquals or: [
		isAddition or: [
			isDeletion or: [
				(isMerge and: [treeDiff changeInfo isRight])
					or: [(* Hide top-level classes in general unless we're merging *)
						isMerge not and: [treeDiff anyNode isToplevel]]]]]) not
)
public isAddition = (

	^ treeDiff changeInfo isAddition
)
public isConflict = (

	^ treeDiff changeInfo isConflict
)
public isDeletion = (

	^ treeDiff changeInfo isDeletion
)
public isEquals = (

	^ treeDiff isEquals
)
mirrorMergeSubjects = (

	^ {}
)
removedAfterMerge = (

	currentSelection = #manualMerge ifTrue: [
		^ false].
	currentSelection = #ourSource ifTrue: [
		^ nil = treeDiff right].
	currentSelection = #theirSource ifTrue: [
		^ nil = treeDiff left].
	currentSelection = #commonAncestorSource ifTrue: [
		^ nil = treeDiff ancestor].
	error: 'unknown selection'
)
public sortKey = (

	^ {treeDiff nodeType. treeDiff name}
)
textMergeSubjectFor: selector = (

	^ textMergeSubjectFor: selector title: selector
)
textMergeSubjectFor: selector title: title = (

	^ textMergeSubjectFor: selector title: title verificationBlock: nil 
)
textMergeSubjectFor: selector title: title verificationBlock: verificationBlock = (

	^ Future computing: [
		| lar wordMerger |
		lar:: treeDiff leftAncestorRightCollect: [:each | each perform: selector].
		wordMerger:: WordMerger on: lar.
		(TextMergeSubject onModel: {wordMerger. mode. self})
			title: title;
			verificationBlock: verificationBlock;
			yourself]
)
textMergeSubjects = (

	^ {}
)
public title = (

	^ treeDiff name
)
public treeDiff = (

	^ mergeModel
)
) : (
)
class PackageMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|) (
'as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (

	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (

	| subjects |
	^ column: {
		subject name presenter.
		sortedPresenters: subject unequalClassSubjects.
		sortedPresenters: subject unequalExtendedClassSubjects.
	}
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
sortedPresenters: subjects = (

	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])
		collect: [:each | each presenter])
)
sortedPresenters: presenters  labeledIfNotEmpty: label = (

	^ presenters isEmpty
		ifTrue: [nothing]
		ifFalse: [
			column: {
				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.
				sortedPresenters: presenters}]	
)
updateHolders = (

	headerHolder content: headingDefinition
)
) : (
)
class PackageMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model ((*  *)|

name = textMergeSubjectFor: #name title: 'Name'.
classes = create: SmalltalkClassMirrorMergeSubject for: #classes.
extendedClasses = create: ExtendedClassMirrorMergeSubject for: #extendedClasses.

|) (
'as yet unclassified'
public canLoadTheirs = (
	^true
)
create: klass for: nodeType = (

	^ Future computing: [
		| treeDiffs |
		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].
		treeDiffs collect: [:each | klass onModel: {each. mode. self}]]
)
public createPresenter = (

	^ PackageMirrorMergePresenter onSubject: self
)
public loadTheirs = (

	treeDiff left installAsToplevelClass.
)
manualMergeMirrorIfFail: failBlock = (

	^ STPackageSourceMirror new
		name: name finalMerge asString;
		classes: (presentMirrorsOf: classes ifFail: failBlock);
		extendedClasses: (presentMirrorsOf: extendedClasses ifFail: failBlock);
		yourself
)
public mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
mirrorMergeSubjects = (

	^ {classes. extendedClasses}
)
textMergeSubjects = (

	^ {name}
)
public unequalClassSubjects = (

	^ classes reject: [:each | each treeDiff isEquals]
)
unequalExtendedClassSubjects = (

	^ extendedClasses reject: [:each | each treeDiff isEquals]
)
) : (
)
class SmalltalkClassMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|) (
'as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (

	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (

	| subjects |
	^ column: {
		subject category presenter.
		subject name presenter.
		subject superclassName presenter.
		subject classComment presenter.
		subject instanceVariables presenter.
		subject classInstanceVariables presenter.

		sortedPresenters: subject unequalInstanceMethodSubjects
			labeledIfNotEmpty: 'Instance methods'.
		sortedPresenters: subject unequalClassMethodSubjects
			labeledIfNotEmpty: 'Class methods'}
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
sortedPresenters: subjects = (

	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])
		collect: [:each | each presenter])
)
sortedPresenters: presenters  labeledIfNotEmpty: label = (

	^ presenters isEmpty
		ifTrue: [nothing]
		ifFalse: [
			column: {
				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.
				sortedPresenters: presenters}]	
)
updateHolders = (

	headerHolder content: headingDefinition
)
) : (
)
class SmalltalkClassMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model ((*  *)|
category = textMergeSubjectFor: #category title: 'Category'.
name = textMergeSubjectFor: #name title: 'Name'.
superclassName = textMergeSubjectFor: #superclassName title: 'Superclass'.
classComment = textMergeSubjectFor: #classComment title: 'Comment'.

instanceVariables = textMergeSubjectFor: #instanceVariablesString title: 'Instance Variables'.
classInstanceVariables = textMergeSubjectFor: #classInstanceVariablesString title: 'Class Instance Variables'.
classPoolVariables = textMergeSubjectFor: #classPoolVariablesString title: 'Class Pool Variables'.
sharedPoolVariables = textMergeSubjectFor: #sharedPoolVariablesString title: 'Shared Pool Variables'.

instanceMethods = create: MethodMirrorMergeSubject for: #instanceMethods.
classMethods = create: MethodMirrorMergeSubject for: #classMethods.
|) (
'as yet unclassified'
public canLoadTheirs = (

	^true
)
create: klass for: nodeType = (

	^ Future computing: [
		| treeDiffs |
		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].
		treeDiffs collect: [:each | klass onModel: {each. mode. self}]]
)
public createPresenter = (

	^ SmalltalkClassMirrorMergePresenter onSubject: self
)
manualMergeMirrorIfFail: failBlock = (

	^SmalltalkClassSourceMirror new
		category: category finalMerge asString;
		name: name finalMerge asString;
		superclassName: superclassName finalMerge asString;
		classComment: classComment finalMerge asString;
		instanceVariables: instanceVariables finalMerge asString;
		classInstanceVariables: classInstanceVariables finalMerge asString;
		classPoolVariables: classPoolVariables finalMerge asString;
		sharedPoolVariables: sharedPoolVariables finalMerge asString;
		instanceMethods: (presentMirrorsOf: instanceMethods ifFail: failBlock);
		classMethods: (presentMirrorsOf: classMethods ifFail: failBlock);
		yourself
)
public mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
mirrorMergeSubjects = (

	^ {instanceMethods. classMethods}
)
textMergeSubjects = (

	^ {category. name. superclassName. classComment. instanceVariables. classInstanceVariables. classPoolVariables . sharedPoolVariables }
)
public unequalClassMethodSubjects = (

	^ classMethods reject: [:each | each treeDiff isEquals]
)
public unequalInstanceMethodSubjects = (

	^ instanceMethods reject: [:each | each treeDiff isEquals]
)
) : (
)
class TextMergePresenter onSubject: subject = MergePresenter onSubject: subject (|
theToggle
theHolder
|) (
'as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	updateHolders.
	theToggle collapse
)
definition = (

	subject isEquals
		ifTrue: [^ nothing].
	theHolder:: holder: nil. 
	updateHolders.
	subject isMerge ifTrue: [
		(* Don't show our changes by default *)
		subject currentSelection = #ourSource ifTrue: [
			theToggle collapse]].
	^ theHolder
)
details = (

	^ column: {
		textDiffPresenterFor: subject merger.
		ifMerging: [manualMergeEditor]}
)
manualMergeEditor = (

	^
		heading: [
			row: {
				(label: 'Manual merge') color: (colorIndicatingSelectionStatusForSide: #manualMerge).
				smallBlank.
				linkToSelectSide: #manualMerge}]
		details: [mergeEditor]
		initiallyExpanded: subject currentSelection = #manualMerge.
)
mergeEditor  = (

	| editor |

	editor:: TextEditorFragment new
		text: subject manualMergeResult;
		acceptResponse: [ | failed |
			failed:: false.
			subject
				storeManualMerge: editor textBeingAccepted
				ifFail: [:msg :pos |
					failed:: true.
					editor showMessage: msg].
			failed ifFalse: [editor defaultAcceptResponse]].
	^ editor
)
updateHolders = (

	theToggle:: heading: [headingDefinition]
					detailsExpanded: [details].
	theHolder content: (
		column: {
			row: {
				theToggle width: 0 elasticity: 1.
				columnSeparator}})
)
) : (
)
class TextMergeSubject onModel: model = MergeSubject onModel: model (|
	public title
	manualMergeResult ::= merger automaticMergedOut.
	public verificationBlock
	
	public leftChanges
	public rightChanges
|) (
'as yet unclassified'
public calculateChanges = (
	| patchSequence sourceA sourceB sideAChanges sideBChanges |
	sourceA:: nil = left ifTrue: [' '] ifFalse: [left].
	sourceB:: nil = right ifTrue: [' '] ifFalse: [right].
	(nil = left or: [nil = right]) ifTrue: [
		leftChanges:: {left ifNotNil: [:it | it asText]}.
		rightChanges:: {right ifNotNil: [:it | it asText]}.
		^self].
	patchSequence:: (TextDiffBuilder from: sourceA to: sourceB) buildPatchSequence.
	sideAChanges:: Array streamContents: [ :as | sideBChanges:: Array streamContents: [ :bs |
		patchSequence do: [ :ea |
			[#match = ea key and: [as position < bs position]] whileTrue: [as nextPut: nil].
			[#match = ea key and: [bs position < as position]] whileTrue: [bs nextPut: nil].
			#match = ea key ifTrue: [as nextPut: ea value. bs nextPut: ea value].
			#remove = ea key ifTrue: [as nextPut: ea value].
			#insert = ea key ifTrue: [bs nextPut: ea value]].
		[as position < bs position] whileTrue: [as nextPut: nil].
		[bs position < as position] whileTrue: [bs nextPut: nil]]].
	leftChanges:: sideAChanges.
	rightChanges:: sideBChanges.
)
public createPresenter = (

	^ TextMergePresenter onSubject: self
)
defaultResult = (

	merger anyChanged ifFalse: [
		^ #commonAncestorSource].
	merger rightChanged ifTrue: [
		^ #ourSource].
	merger leftChanged ifTrue: [
		^ #theirSource].
	^ #manualMerge
)
finalMerge = (

	currentSelection =  #manualMerge ifTrue: [
		storeManualMerge: manualMergeResult ifFail: [halt].
		^ manualMergeResult].
	currentSelection =  #ourSource ifTrue: [
		^ merger rightOut].
	currentSelection =  #theirSource ifTrue: [
		^ merger leftOut].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ merger ancestorOut].
	error: 'unknown side'
)
public isAddition = (

	^ merger isAddition
)
public isConflict = (

	^ merger bothChanged
)
public isDeletion = (

	^ merger isDeletion
)
public isEquals = (

	^ merger anyChanged not
)
left = (
	^merger left	
)
public merger = (

	^ mergeModel
)
right = (
	^merger right	
)
storeManualMerge: mergeResult ifFail: failBlock = (

	verificationBlock = nil ifFalse: [
		verificationBlock value: mergeResult value: failBlock].
	manualMergeResult:: mergeResult.
)
) : (
)
class TextMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|) (
'as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (
	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (
	^column: {subject contents presenter}.
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
updateHolders = (

	headerHolder content: headingDefinition
)
) : (
)
class TextMirrorMergeSubject onModel: m = MirrorMergeSubject onModel: m (| contents = textMergeSubjectFor: #contents title: 'Contents'. |) (
'as yet unclassified'
public canLoadTheirs = (

	^ true
)
public createPresenter = (
	^ TextMirrorMergePresenter onSubject: self
)
public loadTheirs = (
	treeDiff left installAsToplevelClass.
)
public mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		halt. ^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
) : (
)
class WordDiffBuilder from: a to: b = TextDiffBuilder (|
	tabString
	eolString
	spaceString
	separatorCharacters = '(){}[]<>"''+-/.*' asSet.
|hideWhitespace.
	separatorCharacters add: Character space.
	separatorCharacters add: Character cr.
	separatorCharacters add: Character tab.
	separatorCharacters add: Character lf.
	separatorCharacters add: Character newPage.
	super from: a to: b) (
'as yet unclassified'
hideWhitespace = (
	tabString:: Character tab asString.
	eolString:: ''.
	spaceString:: Character space asString.
)
public split: string = (
	| separators previousSeparator |
	separators:: Array streamContents:
		[:s |
		string withIndexDo:
			[:each :i |
			(separatorCharacters includes: each)
				ifTrue: [s nextPut: i]]].
	separators isEmpty ifTrue: [^{string}].
	previousSeparator:: 0.
	^Array streamContents:
		[:s | | rest |
		separators do: [ :separator | | separatorChar |
			(separator - 1) <= previousSeparator ifFalse: [
				s nextPut: (string copyFrom: previousSeparator + 1 to: separator - 1)].
			separatorChar:: string at: separator.
			separatorChar = Character tab
				ifTrue: [s nextPut: tabString]
				ifFalse: [
					 separatorChar = Character space
						ifTrue: [s nextPut: spaceString]
						ifFalse: [s nextPut: separatorChar asString]].
			previousSeparator:: separator].
		rest:: string allButFirst: previousSeparator.
		rest isEmpty ifFalse: [s nextPut: rest].
		s nextPut: eolString]
)
) : (
)
'accessing'
blank: size color: color = (
	^(ColumnComposer definitions: {RowComposer definitions: {BlankFragment size: size}}) color: color
)
vblank: size color: color = (
	^(RowComposer definitions: {ColumnComposer definitions: {BlankFragment size: size}}) color: color
)
'private'
public presentMirrorsOf: mergeSubjects ifFail: failBlock = (

	| survivingElements |
	^ Array streamContents: [:stream |
		mergeSubjects do: [:each |
			each
				mirrorIfPresent: [:it | stream nextPut: it]
				ifRemoved: []
				ifFail: failBlock]]
)
) : (
)
class Presenters = () (
class CurrentLocalHistorianPresenter onSubject: subject = LocalHistorianPresenter onSubject: subject (|
|) (
'as yet unclassified'
arrangeContent = (

	^ column: {
		heading.
		details
		}
)
heading = (

	^ super heading
)
) : (
)
public class HistorianRelationPresenter onSubject: subject = BasePresenter onSubject: subject (|
|) (
'as yet unclassified'
definition = (

	^ column: {
		h4: (subject runActionOn: self).
		IncomingOutgoingPresenter onSubject: subject}
)
public forwardOther = (

	^ link: 'Forward ', otherHistorianAndRepositoryName
		action: [
			refreshSCAfter: [subject forwardOtherHistorian]]
)
forwardToOther = (

	^ link: 'Forward to ', otherHistorianAndRepositoryName
		action: [
			refreshSCAfter: [subject forwardToOtherHistorian]]
)
public inSynch = (

	^ (label: 'In sync with ', otherHistorianAndRepositoryName) color: Color gray
)
merge = (

	(* Allow merging only into image historian *)
	subject historianIsImageHistorian ifTrue: [
		^ link: 'Merge from ', otherHistorianAndRepositoryName
		action: [
			sendUp repositoryEnterSubject:
				subject mergeFromOtherHistorianSubject]].
	subject otherHistorianIsImageHistorian ifTrue: [
		^ link: 'Merge into ', otherHistorianAndRepositoryName
		action: [
			sendUp repositoryEnterSubject:
				subject mergeIntoOtherHistorianSubject]].
	^ (label: 'Out of sync') color: Color gray
)
otherHistorianAndRepositoryName = (

	^ subject otherHistorianAndRepositoryName
)
) : (
)
public class ImageBasedChangePresenter onSubject: subject = BasePresenter onSubject: subject (|
commitFragmentHolder
definitionHolder
|) (
'as yet unclassified'
beforeCommitFragment = (

	^ h2: (row: {
			smallBlank.
			label: 'Modified in Image' asText allBold.
			filler.
			link: 'revert' action: [
				refreshSCAfter: [subject revertImage]].
			smallBlank.
			link: 'commit'
				action: [commitFragmentHolder content: commitFragment]}).
)
cleanDefinition = (

	^ column: {
		h2:: row: {smallBlank. label: 'No Changes in Image' asText allBold. filler}.
		unversionedClassesPresenter}
)
commitFragment = (

	^ column: {
		h2: (row: {
			label: ('Commit to ', subject historianName) asText allBold}).
		TextEditorFragment new
			text: 'Enter Commit Message ...';
			acceptResponse: [:editor |
				editor defaultAcceptResponse.
				refreshSCAfter: [subject commit: editor text asString]];
			cancelResponse: [:editor |
				editor defaultCancelResponse.
				commitFragmentHolder content: beforeCommitFragment]}
)
definition = (

	definitionHolder:: holder: [definitionHolderContents].
	^ definitionHolder
)
definitionHolderContents = (

	^ column: {
		subject hasChanges
			ifTrue: [dirtyDefinition]
			ifFalse: [cleanDefinition]}
)
dirtyDefinition = (

	commitFragmentHolder:: holder: beforeCommitFragment.
	^ column: {
		commitFragmentHolder.
		unversionedClassesPresenter.
		hackStoreMergeHeader.
		column: (subject changedDiffSubjects collect: [:each | each presenter])}
)
hackStoreMergeHeader = (

	(* As long as we have not implemented stores and store diffs, use this to show the header that would usually be displayed by the StoreMergePresenter *)
	^row: {
	BlankFragment size: 13.
		(h2: (label: 'Historian' asText allBold)) width: 0 elasticity: 1.
		BlankFragment size: 12.
		(h2: (label: 'Image' asText allBold)) width: 0 elasticity: 1.
		BlankFragment size: 12}
)
linkForLog: showLog = (

	^ showLog
		ifTrue: [link: 'Log' action: [
					changesOrLogHolder content: subject logSubject presenter.
					changesOrLogLinkHolder contents: (linkForLog: showLog not)]]
		ifFalse: [link: 'Changes' action: [
					changesOrLogHolder content: changesPresenter.
					changesOrLogLinkHolder contents: (linkForLog: showLog not)]]
)
refreshImageBasedChangePresenter = (

	definitionHolder content: definitionHolderContents.
)
unversionedClassesPresenter = (

	^ UnversionedClassesPresenter onSubject: subject.
)
) : (
)
public class IncomingOutgoingPresenter onSubject: subject = BasePresenter onSubject: subject (|
	cachedPresenters
|) (
'as yet unclassified'
definition = (

	^ column: presenters
)
ifNotEmptyStreamPresentersFor: subjects labeled: label to: stream = (

	^ subjects isEmpty ifFalse: [
		stream nextPut: (column: {
			h4: (label: label).
			listPresentersOf: subjects inIncrementsOf: 25})]
)
isEmpty = (

	^ presenters isEmpty
)
presenters = (

	^Array streamContents: [:stream |
		self
			ifNotEmptyStreamPresentersFor: subject incomingVersionSubjects
			labeled: 'Coming in from ', subject otherHistorianAndRepositoryName
			to: stream.
		self
			ifNotEmptyStreamPresentersFor: subject outgoingVersionSubjects
			labeled: 'Going out to ', subject otherHistorianAndRepositoryName
			to: stream]
)
) : (
)
public class LocalHistorianPresenter onSubject: subject = BasePresenter onSubject: subject (|
|) (
class ChooseShareDestinationPresenter onSubject: subject = BasePresenter onSubject: subject () (
'as yet unclassified'
definition = (

	^link: 'share' action: [showMenu]
)
shareActionFor: action = (

	^ [ refreshSCAfter: [action value]]
)
shareMenu = (

	| menu |
	menu:: Menu forVisual: visual.
	subject shareNamesAndActions do:
		[:each |
		menu add: 
			(MenuItem 
				label: each first
				action: (shareActionFor: each second))].
	^menu
)
showMenu = (

	openMenu: shareMenu
)
viewerDefinition = (

	^link: 'share' action: [showMenu]
)
) : (
)
class EditableClonePresenter onSubject: s = EditableLinePresenter onSubject: s (|
|) (
'as yet unclassified'
definitionText = (

	^ 'enter name'
)
respondToAccept = (

	sendUp refreshSCAfter: [
		cloneAs: editor text asString ifFail: [
			(* We could show a error message somehow *)
			^ self].
		leaveEditState]
)
viewerDefinition = (

	^ (link: 'clone' asText action: [enterEditState])
)
) : (
)
'as yet unclassified'
actionCloneHistorian = (

	^ EditableClonePresenter onSubject: subject
)
actionDeleteHistorian = (
	^removeButtonWithAction:
		[confirm: 'Remove Historian'
		ifConfirmed:
			[refreshSCAfter:
				[subject deleteHistorianIfFail: [unexpected]]]].
)
actionLoadHistorian = (

	^ subject isImageHistorian
		ifTrue: [
			nothing]
		ifFalse: [
			link: 'load'
				action: [
					refreshSCAfter: [subject loadIntoImage]]]
)
actionShareHistorian = (

	^ subject trackedHistorianAccessor isTracking
		ifTrue: [nothing]
		ifFalse: [ChooseShareDestinationPresenter onSubject: subject]
)
arrangeContent = (

	(* Can be arranged differently in subclass *)
	^ self
		heading: heading
		details: details
)
cloneAs: forkName ifFail: failBlock = (

	^ subject cloneAs: forkName ifFail: failBlock.
)
definition = (
	^initially: (label: 'syncing') deferred: [arrangeContent]
)
details = (

	^ column: {
		infoTrackedHistorian.
		column: (subject historianRelationSubjects collect: [:each |
					each presenter])}
)
heading = (

	^ h3: (
		row: {
			smallBlank.
			label: subject name.
			filler.
			row: links})
)
infoTrackedHistorian = (

	^ subject trackedHistorianAccessor errorAccessingTrackingHistorian
		ifTrue: [(label: 'Cannot access tracked historian') color: Color red]
		ifFalse: [nothing]
)
links = (

	^ {actionLoadHistorian.
		smallBlank.
		actionCloneHistorian.
		smallBlank.
		actionShareHistorian.
		smallBlank.
		actionDeleteHistorian.}
)
) : (
)
public class LocalRepositoryPresenter onSubject: subject = BasePresenter onSubject: subject (|
deferredContent = holder: nothing.
changesNotification
messagesContainer
inspectionHolder
statusOrLogHolder
statusOrLogLinkHolder
|) (
'as yet unclassified'
actualDefinition = (

	messagesContainer:: OrderedCollection new.
	statusOrLogLinkHolder:: holder: (linkForLog: true).
	statusOrLogHolder:: holder: repositoryStatusPresenter.
	
	^column: {
		h1:: row: {
			presentTitle.
			filler.
			statusOrLogLinkHolder}.
		statusOrLogHolder
	}
)
definition = (
	^deferredContent
)
icon = (
	^subject repositoryIcon
)
linkForLog: showLog = (

	^ showLog
		ifTrue: [link: 'Log' action: [
					statusOrLogHolder content: subject logSubject presenter.
					statusOrLogLinkHolder content: (linkForLog: showLog not)]]
		ifFalse: [link: 'Status' action: [
					statusOrLogHolder content: repositoryStatusPresenter.
					statusOrLogLinkHolder content: (linkForLog: showLog not)]]
)
public noticeImminentExposure = (
	refreshSCAfter: []
)
presentAge = (
	(* subject isRecent ifTrue: [
		^(link: '[active]' action: [confirm: 'New version published to server within the last week.' ifConfirmed:[]]) tinyFont color: Color gray
		].
	subject isOld ifTrue: [
		^(link: '[dormant]' action: [confirm: 'Latest published version is more than 30 days old.' ifConfirmed:[]]) tinyFont color: Color gray
		]. *)
	^label: ''
)
presentLocalHistorians = (

	| localHistorianSubjects |
	localHistorianSubjects:: subject localHistorianSubjects.
	^ column: {
		h2:( row: {
			label: 'Current Local Historian' asText allBold.
			filler}).
		CurrentLocalHistorianPresenter onSubject: (localHistorianSubjects detect: [:each | each isImageHistorian]).
		h2:( row: {
			label: 'Other Local Historians' asText allBold.
			filler}).
		list: ((localHistorianSubjects reject: [:each | each isImageHistorian]) collect: [:each | each presenter])}
)
presentModifiedInImage = (

	^ subject modifiedInImageSubject presenter
)
presentRemoteRepositories = (

	^ column: {
		h2:( row: {
			label: 'Remote Repositories' asText allBold.
			filler}).
		list: (subject remoteRepositorySubjects collect: [:each |
			each presenter])}
)
presentTitle = (
	| prefix |
	prefix:: 'Repository [', subject repositoryType, ']: '.
	^ row: {
		label: prefix asText. 
		label: subject repositoryName asText allBold
	}
)
refreshSCAfter: block = (

	deferredContent content: (label: 'performing action...') tinyFont.
	[showWaitCursorWhile: [
		block value.
		shell desktop scheduleUIAction: [deferredContent content: actualDefinition].
	]
	]forkAt: 30 named: 'Refreshing: ', subject title
)
repositoryEnterSubject: newSubject = (

	statusOrLogHolder content: newSubject presenter.
	statusOrLogLinkHolder content: nothing.
)
repositoryStatusPresenter = (

	^ column: {
		presentModifiedInImage.
		presentLocalHistorians.
		presentRemoteRepositories}
)
) : (
)
public class LogPresenter onSubject: subject = BasePresenter onSubject: subject (|
|) (
'as yet unclassified'
definition = (

	^ listPresentersOf: subject versions  inIncrementsOf: 25
)
) : (
)
public class MergeHistorianPresenter onSubject: subject = BasePresenter onSubject: subject (|
|) (
'as yet unclassified'
definition = (

	| unequalMergeSubjects |
	unequalMergeSubjects:: subject mergeSubjects reject: [:each | each isEquals].
	^ column: {
		h1: (row: {
			label: 'Merge ', subject mergeSourceName, ' into ', subject mergeDestinationName.
			filler.
			link: 'Commit Merge' action: [
				refreshSCAfter: [
					subject mergeIfFail: [halt]]]}).
		column: (unequalMergeSubjects	collect: [:each | each presenter])}
)
) : (
)
public class RemoteHistorianPresenter onSubject: subject = BasePresenter onSubject: subject (|
|) (
'as yet unclassified'
definition = (

	^ h4: (
			row: {
				smallBlank.
				label: subject name.
				filler.
				row: links})
)
links = (

	^ {
		subject isTracked
			ifTrue: [(label: 'is tracked') color: Color gray]
			ifFalse: [link: 'track' action: [
					refreshSCAfter: [subject trackAs: subject name]]]}
)
) : (
)
public class RemoteRepositoryPresenter onSubject: subject = BasePresenter onSubject: subject (|
	|) (
'as yet unclassified'
deferredHistorianPresenters = (
(*
	| historianPresentersHolder |
	historianPresentersHolder:: holder: ((label: 'synching ...') color: Color gray).
	forkAndRemember: [historianPresentersHolder content: (column: historianPresenters)].
	^ historianPresentersHolder *)
	(* There is some problem with forking. See deferredActionTrackedHistorian *)
	^ initially: (label: 'synching ...') deferred: [column: historianPresenters]
)
definition = (

	^ heading: (h3: (label: subject name))
	details: deferredHistorianPresenters
)
historianPresenters = (

	^ subject historianSubjects collect: [:each | each presenter]
)
) : (
)
public class SourceControlPresenter onSubject: subject = BasePresenter onSubject: subject (|
addHolder
reposHolder
|) (
'as yet unclassified'
actionsMenu = (
	^menuWithLabelsAndActions: {
		'Clear image mirror cache' -> [subject clearImageMirrorCache].
		'Clear repository mirror caches' -> [subject clearRepositoryMirrorCaches].
		'Clear source mirror caches' -> [subject clearSourceMirrorCaches].
		#separator.
		'Inspect Presenter' -> [respondToInspectPresenter].
	}
)
definition = (
	^column: {
		majorHeadingBlock: (row: {
			label: 'Repositories' asText allBold.
			largeBlank.
			addButtonWithAction: [addHolder content: presentAddRepositories].
			filler.
			dropDownMenu: [actionsMenu].
		}).
		addHolder:: holder: nothing.
		mediumBlank.
		reposHolder:: holder: [presentRepositories].
	}
)
newRepositoryPanelBackgroundColor = (
	^Gradient
		from: (Color h: 100 s: 0.3 v: 0.9)
		to: (Color h: 100 s: 0.3 v: 0.8)
)
presentAddRepositories = (
	^column: {
		smallBlank.
		(indentedBlock: 
			(column: {
				repositoryLine: 'Clone remote Mercurial repository at:'
					path: 'https://bitbucket.org/newspeaklanguage/newspeak_bleeding_edge'
					acceptResponse: [:url | subject openRemoteHgRepoAt: url. refresh].
				blank: 2.
				repositoryLine: 'Add local Mercurial or Git repository at:'
					path: 'path/relativeTo/imageDirectory'
					acceptResponse: [:path | subject openLocalRepoAt: path. refresh].
				blank: 2.
				repositoryLine: 'Create new local Mercurial repository at:'
					path: 'path/relativeTo/imageDirectory'
					acceptResponse: [:path | subject createLocalHgRepoAt: path. refresh].
			}))
				color: newRepositoryPanelBackgroundColor.
	}
)
presentDocumentation = (
	^{
		row: {
			filler.
			(link: 'close help' action: [respondToCloseHelp]) tinyFont.
		}.
		textDisplay: 'Source Control provides an overview of what changes you have made and what others have made available. TBD'.
	}
)
presentHelp = (
	^(link: '[?]' action: [respondToHelp]) tinyFont
)
presentRepositories = (
	^list: (subject modifiedLocalRepositorySubjects collect: [:ea <LocalRepositorySubject> |		
		row: {
			smallBlank.
			draggableImage: ea repositoryIcon forSubject: ea.
			smallBlank.
			link: ea repositoryName action: [enterSubject: ea].
			filler.
			removeButtonWithAction: [confirm: 'Remove Repository' ifConfirmed: [subject removeRepository: ea model. self refresh]].
			smallBlank.
		}
	])
)
repositoryLine: label <String> path: path <String> acceptResponse: actionBlock <[:String]> = (
	^row: {
		label: label.
		filler.
		TextLineEditorFragment new
			text: path;
			cancelResponse: [(* Intentionally an empty block.  Not sure what to reset to, but surely better than a walkback. *)];
			acceptResponse: [:editor | 
				actionBlock value: editor text asString.
				addHolder content: nothing];
			cancelResponse: [:editor | addHolder content: nothing].
		smallBlank.
	}
)
respondToCloseHelp = (
	helpHolder setPresenters: {}
)
respondToHelp = (
	helpHolder setPresenters: presentDocumentation
)
) : (
)
class TextMergePresenter onSubject: subject = MergePresenter onSubject: subject (|
theToggle
theHolder
|) (
'as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	updateHolders.
	theToggle collapse
)
definition = (

	subject isEquals
		ifTrue: [^ nothing].
	theHolder:: holder: nil. 
	updateHolders.
	subject isMerge ifTrue: [
		(* Don't show our changes by default *)
		subject currentSelection = #ourSource ifTrue: [
			theToggle collapse]].
	^ theHolder
)
details = (

	^ column: {
		textDiffPresenterFor: subject merger.
		ifMerging: [manualMergeEditor]}
)
manualMergeEditor = (

	^
		heading: [
			row: {
				(label: 'Manual merge') color: (colorIndicatingSelectionStatusForSide: #manualMerge).
				smallBlank.
				linkToSelectSide: #manualMerge}]
		details: [mergeEditor]
		initiallyExpanded: subject currentSelection = #manualMerge.
)
mergeEditor  = (

	| editor |

	editor:: TextEditorFragment new
		text: subject manualMergeResult;
		acceptResponse: [ | failed |
			failed:: false.
			subject
				storeManualMerge: editor textBeingAccepted
				ifFail: [:msg :pos |
					failed:: true.
					editor showMessage: msg].
			failed ifFalse: [editor defaultAcceptResponse]].
	^ editor
)
updateHolders = (

	theToggle:: heading: [headingDefinition]
					detailsExpanded: [details].
	theHolder content: (
		column: {
			row: {
				theToggle width: 0 elasticity: 1.
				columnSeparator}})
)
) : (
)
class UnversionedClassesPresenter onSubject: subject <ImageBasedChangeSubject> = BasePresenter onSubject: subject ((* Allows adding unversioned classes to the current image based change *)|
	private unversionedImageMirrors = subject unversionedImageMirrors.|) (
'as yet unclassified'
definition = (

	^ unversionedImageMirrors isEmpty
		ifTrue: [nothing]
		ifFalse: [
			heading: header
			details: [column: (unversionedImageMirrors collect: [:each | mirrorEntry: each])]]
)
header = (

	^ h3: ( row: {
		label: 'Unversioned Classes'.
		(* largeBlank.
		link:  'Add All' action: [
			unversionedImageMirrors do: [:each | subject addMirror: each actualMirror].
			refreshImageBasedChangePresenter]. *)
		filler})
)
mirrorEntry: mirror = (

	^ row: {
		addButtonWithAction: [
			subject addMirror: mirror actualMirror.
			refreshImageBasedChangePresenter].
		mediumBlank.
		label: mirror name}
)
refreshImageBasedChangePresenter = (

	sendUp refreshImageBasedChangePresenter
)
) : (
)
public class VersionPresenter onSubject: subject = BasePresenter onSubject: subject (|
|) (
'as yet unclassified'
definition = (

	| toggle |
	toggle:: 
		heading: (row: {
			link: subject message action: [toggle toggle].
			mediumBlank.
			(label: '[', subject author, ']') color: Color gray.
			mediumBlank.
			subject isParentOfImage
				ifTrue: [
					row: {
						label: '(current)' asText allBold.
						mediumBlank}]
				ifFalse: [nothing].
			link: 'load' action: [loadIntoImage]})
		details: [
			| unequalDiffSubjects |
			column: {
				label: subject internalId asString.
				column: (subject unequaldiffsFromPrevious collect: [:each | 
					each presenter])}].
	^ toggle
)
public loadIntoImage = (

	refreshSCAfter: [subject loadIntoImage]
)
) : (
)
) : (
)
class SourceControlSubject onModel: model = Subject onModel: model (|
	mergingUI = MergingUI new.
|model isEmpty ifTrue: [findRepositories]) (
class LocalRepositorySubject onModel: model = Subject onModel: model (|

|model refresh) (
class HistorianSubject onModel: model = Subject onModel: model (|
|) (
'as yet unclassified'
public name = (

	^ model name
)
) : (
)
class ImageBasedChangeSubject onModel: model = Subject onModel: model (|
	cachedMergeSubjects
	cachedVersion
	newlyAddedMirrors = Set new.
|) (
'as yet unclassified'
public addMirror: mirror = (

	newlyAddedMirrors add: mirror.
	clearCaches
)
buildVersion = (

	| v 	nilsAndMirrors |
	v:: historian repository createNewVersion.
	
	(* Determines the classes in the image that correspond to the classes in the historian. I'm not sure how this can be extended to properly support renames, without having to check all classes in the image for possible correspondence. We could try to use renaming information provided by the external system. *)
	nilsAndMirrors:: historian version mirrors collect: [:each |
		logger
			log: 'Loading mirror corresponding to ', each name
			around: [
				sourceMirrors
					mirrorForClassInImageCorrespondingTo: each
					ifPresent: [:it | it]
					ifAbsent: [nil]]].
	v mirrors: newlyAddedMirrors, (nilsAndMirrors reject: [:each | nil = each]).
	v parents: {historian version}.
	^ v
)
public changedDiffSubjects = (

	^ mergeSubjects reject: [:each | each mergeModel isEquals]
)
clearCaches = (

	cachedVersion:: nil.
	cachedMergeSubjects:: nil.
)
public commit: message = (

	version
		mirrors: (mergingUI presentMirrorsOf: mergeSubjects ifFail: [logger error: 'unexpected']);
		message: message.
	historian commit: version.
)
public createPresenter = (
	^ ImageBasedChangePresenter onSubject: self
)
public hasChanges = (

	^ version diffsFromFirstParent anySatisfy: [:each |
		each isEquals not]
)
historian = (

	^ model
)
public historianName = (

	^ historian name
)
mergeSubjects= (

	nil = cachedMergeSubjects ifTrue: [
		cachedMergeSubjects:: version diffsFromFirstParent collect: [:each |
			diffSubjectOn: each]].
	^ cachedMergeSubjects
)
public revertImage = (

	historian loadIntoImage
)
public unversionedImageMirrors = (

	^ (sourceMirrors imageMirrorsNotCorrespondingTo: version mirrors, newlyAddedMirrors) 
		sort: [:a :b | a name < b name]
)
public version = (

	nil = cachedVersion ifTrue: [
		cachedVersion:: buildVersion].
	^ cachedVersion
)
) : (
)
class LocalHistorianSubject onModel: model = HistorianSubject onModel: model (|

	public trackedHistorianAccessor = TrackedHistorianAccessor new.
|) (
class HistorianRelationSubject onModel: oh = Subject onModel: oh (
(* Allows interacting with other historians *)|

|) (
'as yet unclassified'
canForwardOtherHistorian = (

	^ otherHistorian canForwardTo: historian
)
canForwardToOtherHistorian = (

	^ historian canForwardTo: otherHistorian
)
canMerge = (

	^ historian canMergeWith: otherHistorian
)
public createPresenter = (

	^ HistorianRelationPresenter onSubject: self
)
public forwardOtherHistorian = (

	otherHistorian setTo: historian version ifFail: [logger warn: 'Could not forward historian'].
	loadIfImageHistorian: otherHistorian
)
forwardToOtherHistorian = (

	historian setTo: otherHistorian version ifFail: [logger error: 'Could not forward historian'].
	loadIfImageHistorian: historian
)
historianIsImageHistorian = (

	^ historian = imageHistorian
)
public incomingVersionSubjects = (

	| versions |
	versions:: historian versionsIncomingFrom: otherHistorian.
	^ versions collect: [:each | VersionSubject onModel: each]
)
mergeFromOtherHistorianSubject = (

	^ MergeHistoriansSubject merging: otherHistorian into: historian
)
mergeIntoOtherHistorianSubject = (

	^ MergeHistoriansSubject merging: historian into: otherHistorian
)
otherHistorian = (

	^ model
)
public otherHistorianAndRepositoryName = (

	^ otherHistorian repository = repository
		ifTrue: ['local ', otherHistorian name]
		ifFalse: [otherHistorian name, ' on ', otherHistorian repository name]
)
otherHistorianIsImageHistorian = (

	^ otherHistorian = imageHistorian
)
public outgoingVersionSubjects = (

	| versions |
	versions:: otherHistorian versionsIncomingFrom: historian.
	^ versions collect: [:each | VersionSubject onModel: each]
)
public runActionOn: receiver = (

	canMerge ifTrue: [
		^ receiver merge].
	canForwardToOtherHistorian ifTrue: [
		^ receiver forwardToOther].
	canForwardOtherHistorian ifTrue: [
		^ receiver forwardOther].
	^ receiver inSynch
)
) : (
)
class IncomingOutgoingSubject onModel: otherHistorian = Subject onModel: otherHistorian (|

|) (
'as yet unclassified'
public createPresenter = (

	^ IncomingOutgoingPresenter onSubject: self
)
public incomingVersionSubjects = (

	| versions |
	versions:: historian versionsIncomingFrom: otherHistorian.
	^ versions collect: [:each | VersionSubject onModel: each]
)
otherHistorian = (

	^ model
)
otherHistorianName = (

	^ otherHistorian name
)
outgoingVersionSubjects = (

	| versions |
	versions:: otherHistorian versionsIncomingFrom: historian.
	^ versions collect: [:each | VersionSubject onModel: each]
)
) : (
)
class TrackedHistorianAccessor = (
(* Accessing a tracked historian can be slow. Funnel all access to it through this accessor to make it possibly slow commands explicit. *)|
	private cachedTrackingState
	private cachedTrackedHistorian
|) (
'as yet unclassified'
computeTrackedHistorian = (

	cachedTrackedHistorian:: historian
		trackedHistorianifPresent: [:tr |
			cachedTrackingState:: #tracked.
			tr]
		ifAbsent: [cachedTrackingState:: #untracked.]
		ifError: [cachedTrackingState:: #error]
)
public errorAccessingTrackingHistorian = (

	^ trackingState = #error
)
public isTracking = (

	^ trackingState = #tracked
)
public trackedHistorian = (

	nil = cachedTrackedHistorian ifTrue: [computeTrackedHistorian].
	^ cachedTrackedHistorian
)
trackingState = (

	nil = cachedTrackingState ifTrue: [computeTrackedHistorian].
	^ cachedTrackingState
)
) : (
)
'as yet unclassified'
cloneAs: cloneName ifFail: failBlock = (

	^ model cloneAs: cloneName ifFail: failBlock
)
public createPresenter = (

	^ LocalHistorianPresenter onSubject: self
)
deleteHistorianIfFail: failBlock = (

	model deleteIfFail: failBlock
)
historian = (

	^ model
)
public historianRelationSubjects = (

	^ Array streamContents: [:stream |
		trackedHistorianAccessor isTracking ifTrue: [stream nextPut: (HistorianRelationSubject onModel: trackedHistorianAccessor trackedHistorian)].
		imageHistorian = historian ifFalse: [
			stream nextPut: (HistorianRelationSubject onModel: imageHistorian)]]
)
public isImageHistorian = (

	^ model = imageHistorian
)
public loadIntoImage = (

	model loadIntoImage
)
shareNamesAndActionOf: remoteRepository = (

	(* We could put this into shareNamesAndActions if we had closures *)
	^ {remoteRepository name.
		[model shareTo: remoteRepository]}
)
shareNamesAndActions = (

	^ remoteRepositories collect: [:each |
		shareNamesAndActionOf: each]
)
) : (
)
class LogSubject onModel: model = Subject onModel: model (|
|) (
'as yet unclassified'
public createPresenter = (

	^ LogPresenter onSubject: self
)
public versions = (

	^ model logStream contents collect: [:each |
		VersionSubject onModel: each]
)
) : (
)
class MergeHistoriansSubject onModel: model = Subject onModel: model (|
cachedMergeSubjects

version = newVersion.
|) (
'as yet unclassified'
public createPresenter = (

	^ MergeHistorianPresenter onSubject: self
)
destinationHistorian = (

	^ model second
)
mergeDestinationName = (

	^ destinationHistorian name
)
mergeIfFail: failBlock = (

	version
		mirrors: (mergingUI presentMirrorsOf: mergeSubjects ifFail: failBlock);
		message: 'Merged from ', sourceHistorian name.
	destinationHistorian commit: version.
	(* While we usually do not load the version created by a commit (as not all changes may have been committed), we do so in this case to bring external changes into the image *)
	loadIfImageHistorian: destinationHistorian
)
mergeSourceName = (

	^ sourceHistorian name
)
mergeSubjects = (

	cachedMergeSubjects = nil ifTrue: [ | diffs |
		diffs:: destinationHistorian version diffsFrom: sourceHistorian version.
		cachedMergeSubjects:: diffs collect: [:each | mergeSubjectOn: each]].
	^ cachedMergeSubjects
)
newVersion = (

	| v |
	v:: repository createNewVersion.
	v parents: {sourceHistorian version. destinationHistorian version}.
	^ v
)
sourceHistorian = (

	^ model first
)
) : (
'as yet unclassified'
merging: sourceHistorian into: destinationHistorian = (

	^ MergeHistoriansSubject
		onModel: {sourceHistorian. destinationHistorian}
)
)
class RemoteHistorianSubject onModel: model = HistorianSubject onModel: model (|
|) (
'as yet unclassified'
public createPresenter = (

	^ RemoteHistorianPresenter onSubject: self
)
isTracked = (

	^ model isTracked
)
trackAs: name = (

	model trackAs: name
)
) : (
)
class RemoteRepositorySubject onModel: model = Subject onModel: model (|
|) (
'as yet unclassified'
public createPresenter = (

	^ RemoteRepositoryPresenter onSubject: self
)
historianSubjects = (

	^ model historians collect: [:each |
		RemoteHistorianSubject onModel: each]
)
public name = (

	^ model name
)
) : (
)
class VersionSubject onModel: model = Subject onModel: model (|
|) (
'as yet unclassified'
public author = (

	^ model author
)
public createPresenter = (

	^ VersionPresenter onSubject: self
)
public internalId = (

	^ model internalId
)
public isParentOfImage = (

	^ model isParentOfImage
)
public loadIntoImage = (

	model loadIntoImage
)
public message = (

	^ model message
)
public unequaldiffsFromPrevious = (

	| diffsFromPrevious |
	diffsFromPrevious:: model diffsFromFirstParent collect: [:each | diffSubjectOn: each].
	^ diffsFromPrevious reject: [:each | each isEquals]
)
) : (
)
'as yet unclassified'
public = other = (
	^class = other class and: [model = other model]
)
public createPresenter = (

	^ LocalRepositoryPresenter onSubject: self
)
public hash = (
	^model hash
)
public imageHistorian = (

	^ model imageHistorian
)
loadIfImageHistorian: historian = (

	(* Before this, we had a historian check whether it is the image historian on setTo:ifFail:. It turns out, that there are cases where it's desirable to change a historian's version without changing the code in the image, for example when doing partial commits.
	The new strategy is to have callers of setTo: distinguish the two cases. Ideally we wouldn't distinguish 'commit' and 'setTo'. Then we could offer a 'updatingImageSet:to:ifFail: *)
	imageHistorian = historian ifTrue: [
		imageHistorian loadIntoImage]
)
public localHistorianSubjects = (

	^ model historians collect: [:each | LocalHistorianSubject onModel: each].
)
logSubject = (

	^ LogSubject onModel: repository
)
public modifiedInImageSubject = (

	^ ImageBasedChangeSubject
		onModel: model imageHistorian.
)
public remoteRepositories = (

	^ model remoteRepositories
)
public remoteRepositorySubjects = (

	^ remoteRepositories collect: [:each | RemoteRepositorySubject onModel: each].
)
repository = (

	^ model
)
public repositoryIcon ^<Form> = (
	model repositoryType = #git ifTrue: [^vcs gitIcon].
	model repositoryType = #hg ifTrue: [^vcs hgIcon].
	^nil
)
public repositoryName = (

	^ model repositoryId
)
public repositoryType = (
	^ model repositoryType
)
public title = (
	^repositoryName
)
) : (
)
'as yet unclassified'
public = other = (
	^self class = other class and: [self model = other model]
)
clearImageMirrorCache = (
	vcs imageMirrorCache void.
	Smalltalk garbageCollect.
)
public clearRepositoryMirrorCaches = (
	model do: [:localRepository | | mirrorAccessor |
		localRepository cachedCommand: nil.
		mirrorAccessor:: localRepository repositoryVersionAccessing mirrorAccessor.
		mirrorAccessor lastLoadedMirrors keysAndValuesRemove: [:k :v| true]].
	Smalltalk garbageCollect.
)
clearSourceMirrorCaches = (
	vcs newspeakSourceMirrors clearCaches.
	Smalltalk garbageCollect.
)
createLocalHgRepoAt: relPath <String> = (

	| path hg uiusername repository |

	#BOGUS. (* This logic belongs somewhere else! *)

	path:: ((FileDirectory on: SmalltalkImage current imagePath) / relPath) pathName.

	hg:: ExternalLauncher for: 'hg'.
	hg otherUnixLocations: {'/opt/local/bin'. '/usr/local/bin'}.
	hg otherWindowsLocations: {'c:\cygwin\bin'}.

	(* hg init path *)
	hg 
		runWith: {'init'. path} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | Error signal: stderr contents].

	uiusername:: UIManager default
			request: 'Please provide your Mercurial username'
			initialAnswer: 'Full Name <email@company.com>'.

	(* setup hgrc *)
	(FileStream forceNewFileNamed: ((FileDirectory on: path) / '.hg' / 'hgrc') pathName) nextPutAll: 
'[ui]
username=',uiusername,'
[extensions]
bookmarks=
[newspeak]
current_historian=main
'; flush; close.

	(*  *)
	(FileStream forceNewFileNamed: ((FileDirectory on: path) / '.hgignore') pathName)
		flush; close. 

	hg 
		runWith: {'--cwd'. path. 'bookmark'. 'main'} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | Error signal: stderr contents].

	hg 
		runWith: {'--cwd'. path. 'add'. '.hgignore'} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | Error signal: stderr contents].
	
	hg 
		runWith: {'--cwd'. path. 'commit'. '-m'. 'Initial commit.'} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | Error signal: stderr contents].

	repository:: vcs hg Backend new LocalRepository onRepositoryId: path.

	model add: repository.
)
public createPresenter = (

	^ SourceControlPresenter onSubject: self
)
public diffSubjectOn: diff = (

	(* TODO: dispatch on the kind of diff *)
	^ mergingUI ClassMirrorMergeSubject diffSubjectOn: diff
)
findRepositories = (
	| path ::= FileDirectory default. |
	[path directoryNames do: [:dirname | 
		| dir = path directoryNamed: dirname. |
		(dir directoryExists: '.hg') ifTrue: [
			model add: (vcs hg Backend new LocalRepository onRepositoryId: dir pathName)].
		(dir directoryExists: '.git') ifTrue: [
			model add: (vcs git Backend new LocalRepository onRepositoryId: dir pathName)].
		].
	path = path containingDirectory]
		whileFalse: [path:: path containingDirectory].
)
public hash = (
	^model hash
)
mergeSubjectOn: diff = (

	(* TODO: dispatch on the kind of diff *)
	^ mergingUI ClassMirrorMergeSubject mergeSubjectOn: diff
)
public modifiedLocalRepositorySubjects = (

	^ model collect: [:each | LocalRepositorySubject onModel: each]
)
openLocalRepoAt: path = (
	| file repository |
	file:: (FileDirectory on: SmalltalkImage current imagePath) / path.
	(file / '.hg') exists ifTrue:
		[repository:: vcs hg Backend new LocalRepository onRepositoryId: file pathName.
		model add: repository.
		^self].
	(file / '.git') exists ifTrue:
		[repository:: vcs git Backend new LocalRepository onRepositoryId: file pathName.
		model add: repository.
		^self].
	Error signal: 'There does not appear to be a Git or Mercurial repository at ', file pathName.
)
openRemoteHgRepoAt: url <String> = (

	| isHttps path hg uiusername username password repository |

	isHttps:: url startsWith: 'https://'.

	path:: url copyFrom: (url lastIndexOf: "/")+1 to: url size.
	path:: ((FileDirectory on: SmalltalkImage current imagePath) / path) pathName.

	hg:: ExternalLauncher for: 'hg'.
	hg otherUnixLocations: {'/opt/local/bin'. '/usr/local/bin'}.
	hg otherWindowsLocations: {'c:\cygwin\bin'}.

	(* hg init path *)
	hg 
		runWith: {'init'. path} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | Error signal: stderr contents].

	uiusername:: UIManager default
			request: 'Please provide your Mercurial username'
			initialAnswer: 'Full Name <email@company.com>'.

	isHttps ifTrue: [
		username:: UIManager default
			request: 'Please provide your BitBucket, etc username'
			initialAnswer: 'wsmith'.

		password:: UIManager default
			request: 'Please provide your BitBucket, etc password'
			initialAnswer: 'downwithbigbrother'.
	].

	(* setup hgrc *)
	(FileStream forceNewFileNamed: ((FileDirectory on: path) / '.hg' / 'hgrc') pathName) nextPutAll: 
'[paths]
default=',url,'
[ui]
username=',uiusername,'
[extensions]
bookmarks=
', (isHttps ifTrue: ['[auth]
bb1.schemes=https
bb1.prefix=',url,'
bb1.password=',password,'
bb1.username=',username,'
'] ifFalse: ['']) ,
'[hostfingerprints]
https://bitbucket.org=24:9c:45:8b:9c:aa:ba:55:4e:01:6d:58:ff:e4:28:7d:2a:14:ae:3b
[newspeak]
current_historian=main
[newspeak_tracking_historian]
main=main
[newspeak_tracking_repository]
main=',url,'
'; flush; close.

	(* hg --cwd path pull -B *)
	hg 
		runWith: {'--cwd'. path. 'pull'. '-B'. 'main'} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | Error signal: stderr contents].
	
	hg 
		runWith: {'--cwd'. path. 'update'.} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | Error signal: stderr contents].

	repository:: vcs hg Backend new LocalRepository onRepositoryId: path.
	model add: repository.
)
removeRepository: r = (
	model remove: r.
)
sourceControlSubject = (

	^ self
)
public title = (
	^'Repositories'
)
) : (
)
'accessing'
columnSeparator = (

	^ BlankFragment size: 12
)
halfColumnSeparator = (

	^ BlankFragment size: 6
)
'as yet unclassified'
mainSubject = (
	^SourceControlSubject onModel: theModel
)
) : (
)
