Newspeak3
'Brazil'
class UISessionManager usingPlatform: platform <Platform> = NewspeakObject (
(* [Note: This class is not yet active. The real work is still handled by NativeSession.] Manages UISessions, which are objects that hold onto the UI layer state that is dependent on the host OS and may be invalidated by image restarts. *)|
	private BrazilMappingForWin32 = platform namespace BrazilMappingForWin32.
	private MorphicAgentFactory = platform blackMarket MorphicAgentFactory.
	
	private brazil = platform brazil.
	private Desktop =  brazil containers Desktop.
	private Error = platform blackMarket Exceptions Error.
	private OrderedCollection = platform collections OrderedCollection.
	private OSProcess = platform blackMarket OSProcess OSProcess.
	private Smalltalk = platform blackMarket Smalltalk.
	
	private cachedPlatform = platform.

	currentSession <UISession>
	protected activeSessions <Collection[UISession]> ::= OrderedCollection new.
|)
(
class MorphicSession = UISession (
(* Runs the UI inside the standard Squeak window. *)|
|)
('as yet unclassified'
activate = (
	desktop:: Desktop withMapping: MorphicAgentFactory new
)
discardStaleObjects = (
	(* Morphic mappings don't hold onto anything that could go stale. *)
)
isAppropriateForCurrentOS ^<Boolean> = (
	^true
)
isMorphic = (
	^true
)
restartInNewImageSession = (
	(* Nothing to do: all windows and morphs are preserved as is. *)
)) : ()
class UISession = (
(* The abstract superclass of UI sessions. For native session classes, the implementation should allow to create instances at any time, even when the current OS is actually not appropariate for the session (say, if it's a Windows session and we are running on a Mac). To support that, a newly created session should not actually create any heavyweight objects such as Brazil mappings, API modules or the desktop. It should only do that when the manager explicitly instructs it to do so by sending #activate. *)|
	desktop <Desktop>
|)
('as yet unclassified'
activate = (
	(* Sent by the manager when the receiver has been accepted into the rank of the manager's activeSessions to represent the current OS platform. This is the time to really create any heavyweight parts such as the API and Brazil mapping modules and (at the very minimum) the desktop. *)
	subclassResponsibility
)
discardStaleObjects = (
	(* Sent by the manager on image startup to all sessions saved as active. Sessions that hold onto OS data such as window handles should discard that information together with the mapping agents holding onto it. *)
	subclassResponsibility
)
isAppropriateForCurrentOS ^<Boolean> = (
	(* Answer whether the receiver is able to handle the current OS. Note that it doesn't require the receiver to be native for the current OS--a Morphic session is appropriate for anything. *)
	subclassResponsibility
)
isMorphic = (
	^false
)
isWindows = (
	^false
)
protected migrateWindowsTo: newDesktop <Desktop> = (
	desktop windows copy do:
		[:each |
		desktop remove: each.
		[newDesktop add: each]
			on: Error
			do: [:ex |
				newDesktop remove: each.
				ex pass]]
)
restartInNewImageSession = (
	(* Sent by the manager on image startup after it's been determined that this session is the current and will stay as current for the current image session as well. The instance has already been instructed to discard stale OS session-specific data. If native, this is the time to take any existing windows and rematerialize them. *)
	subclassResponsibility
)) : ()
class WindowsSession = UISession (
(* Runs the UI as native on Windows. *)|
	brazilMappingModule
|)
('as yet unclassified'
activate = (
	brazilMappingModule:: BrazilMappingForWin32 platform: cachedPlatform.
	desktop:: Desktop withMapping: brazilMappingModule agentFactory.
)
discardStaleObjects = (
	| newDesktop |
	brazilMappingModule resetForNewImageSession.
	desktop discardMappings.
)
isAppropriateForCurrentOS ^<Boolean> = (
	^OSProcess isWindows
)
isWindows = (
	^true
)
restartInNewImageSession = (
	| newDesktop |
	brazilMappingModule:: BrazilMappingForWin32 platform: cachedPlatform. (* Seems resetForNewImageSession is insufficient? *)
	
	newDesktop:: Desktop withMapping: brazilMappingModule agentFactory.
	migrateWindowsTo: newDesktop.
	desktop:: newDesktop.
)) : ()'accessing'
desktop ^<Desktop> = (
	^currentSession desktop
)
goMorphic = (
	currentSession isMorphic ifFalse:
		[switchToNewSession: MorphicSession new]
)
goWindowsNative = (
	currentSession isWindows ifFalse:
		[ | windowsSession |
		windowsSession:: WindowsSession new.
		windowsSession isAppropriateForCurrentOS
			ifTrue: [switchToNewSession: windowsSession]
			ifFalse: [error: 'The current OS is not Windows']]
)'as yet unclassified'
protected cleanupAndPurgeSessions = (
	activeSessions do: [:each | each discardStaleObjects].
	activeSessions removeAllSuchThat: [:any | any isAppropriateForCurrentOS not].
	activeSessions removeAllSuchThat: [:any | (any == currentSession) not].
)
preferredSessionClassForCurrentOS = (
	^OSProcess isWindows
		ifTrue: [WindowsSession]
		ifFalse: [MorphicSession]
)
protected resetForNewImageSession = (
	cleanupAndPurgeSessions.
	(currentSession isNil not and: 
		[currentSession class = preferredSessionClassForCurrentOS])
			ifTrue: [currentSession restartInNewImageSession]
			ifFalse: [switchToNewSession: newSessionForCurrentOS].
	
	brazil theDesktop: desktop.
)
showSqueakWindow = (
	| api squeakWindowClassName classNameBuffer handle  |

	cachedPlatform blackMarket OSProcess OSProcess isWindows ifFalse: [
		^self (* Always open on Mac and Linux *)
	].

	api:: cachedPlatform apiManager win32api.
	squeakWindowClassName:: cachedPlatform blackMarket BlackMarket theSystemScope systemName, 'WindowClass'.
	classNameBuffer:: cachedPlatform blackMarket Alien newCString: squeakWindowClassName.
	handle:: api FindWindow unsignedValue: classNameBuffer address value: 0.
	handle ~= 0 ifTrue: [
		api ShowWindow value: handle value: api SW_SHOW.
		api SetActiveWindow value: handle.
	]
)'private'
protected findSimilarOrActivateSession: session <UISession> ^<UISession> = (
	^activeSessions
		detect: [:any | any class = session class]
		ifNone:
			[session activate.
			activeSessions add: session]
)
protected newSessionForCurrentOS = (
	^preferredSessionClassForCurrentOS new
)
protected switchToNewSession: proposedSession <UISession> = (
	(* Note that the session that ends up being current is not the one passed in as the argument, if there already is an active session of the same class. *)
	| newSession |
	newSession:: findSimilarOrActivateSession: proposedSession.
	newSession = currentSession ifFalse:
		[currentSession isNil ifFalse: 
			[currentSession migrateWindowsTo: newSession desktop].
		currentSession:: newSession].
)'testing'
isMorphic = (
	^currentSession isMorphic
)
isWindows = (
	^currentSession isWindows
)) : ()