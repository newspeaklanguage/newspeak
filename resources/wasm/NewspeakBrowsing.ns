Newspeak3
'HopscotchIDE'
class NewspeakBrowsing usingPlatform: p ide: ide = (
(*
Class browsing for NS3 using new mirrors.

It would be nice to additionally support:

	editing a class header to a different name makes a copy a la the classic browser
	pull a nested class up as a sibling of its parent
	push a nested class down into one of its siblings

	auto-initialization of new slots in existing instances
	(but if it depends on a factory argument, what can we do?)

	senders/implementors restricted to the same module?
*)
|
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	private ObjectMirror = p mirrors ObjectMirror.
	private Color = p hopscotch Color.
	private Duct = p ducts Duct.
	private EditableLinePresenter = p hopscotch fragments EditableLinePresenter.
	private HopscotchImages = p hopscotch HopscotchImages.
	private MixinBuilder = p mirrors MixinBuilder.
	private List = p collections List.
	private Set = p collections Set.
	private Subject = p hopscotch core Subject.
	private VFSerializer = p victoryFuel Serializer.
	private newspeakLanguage3 = p kernel newspeakLanguage3.
	private cachedPlatform = p.

	ide = ide.
	systemScope = ide systemScope.
	private AssortedMethodsPresenter = ide browsing AssortedMethodsPresenter.
	private AssortedMethodsSubject = ide browsing AssortedMethodsSubject.
	private ClassCommentPresenter = ide browsingMisc ClassCommentPresenter.
	private CodeEditorFragment = ide tools CodeEditorFragment.
	private DefinitionListPresenter = ide tools DefinitionListPresenter.
	private DefinitionTemplate = ide tools DefinitionTemplate.
	private DeletedClassSubject = ide browsingMisc DeletedClassSubject.
	private EditableNSClassNamePresenter = ide browsing EditableNSClassNamePresenter.
	private ExpandableMethodPresenter = ide browsing ExpandableMethodPresenter.
	private NS3Colorizer = ide newspeakColorization NS3BrowserColorizer.
	private ProgrammingPresenter = ide tools ProgrammingPresenter.
	private SelectorSubject = ide browsing SelectorSubject.
	private MethodSubject = ide browsing MethodSubject.
	private ClassSubject = ide browsing ClassSubject.
	private MethodInheritanceSubject = ide browsingST MethodInheritanceSubject.

	private languageUiDescriptionRegistry = ide languageUiDescriptionRegistry.
	private minitestUI = ide minitestUI.
	private minitest = ide minitest.
	private finalizer = ide finalizer.
	private Root = ide namespacing Root.

	private Deployment = p squeak Deployment.
	private ExternalLauncher = p squeak ExternalLauncher.
	private FileStream = p squeak FileStream.
	private CrLfFileStream = p squeak CrLfFileStream.
	private MethodContext = p squeak MethodContext.
	private OSProcess = p squeak OSProcess.
	private Smalltalk = p squeak Smalltalk.
	private UIManager = p squeak UIManager.
|) (
class AbstractClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Common behavior for presenting a Newspeak class. *)
|
	classNamePresenter
	descriptionOrSourceSwitchHolder
	descriptionOrSourceSwitcherHolder
	descriptionOrSourceHolder
	summaryOrEditor
|) (
acceptClassDefinition: editor = (
	(* This class's definition has been changed in the definition editor. *)

	^majorUpdate:
		[[subject acceptClassDefinition: editor textBeingAccepted]
			on: Error
			do: [:ex | editor showMessage: ex description. false]]
)
accessModifierLabel = (
	^(label: subject accessModifier) tinyFont
)
addOutlineItemsTo: parentItem = (
| selfItem |
selfItem:: (OutlineItem onModel: self)
	text: subject className;
	image: icon.
substance addOutlineItemsTo: selfItem.
parentItem addChild: selfItem
)
browseNSClassReferences: className = (
	sendUp navigatorDo:
		[:shell | shell enterSubject: (ClassReferencesSubject onModel: className)]
)
browseNamespace: categoryName <Symbol> = (
	ide defaultPopularityRecord
		rememberNamespaceVisit: categoryName.

	enterSubject:: ide browsingMisc NamespaceSubject
		onModel: (ide namespacing categoryNamespace: categoryName)
		key: categoryName.
)
classActionsMenu = (
	^menuWithLabelsAndActions: {
		'Save to File' -> [respondToSave].
		#separator.
		'Inspect Mixin' -> [inspect: subject implementationClass].
		'Inspect Mirror' -> [inspect: subject classMirror].
		#separator.
		'Inspect Instances' -> [enterSubject: subject instancesSubject].
		'Inspect Subinstances' -> [enterSubject: subject subInstancesSubject].
		#separator.
		'Copy' -> [respondToCopy].
		'Move up' -> [respondToMoveUp].
		'Move down' -> [respondToMoveDown].
		#separator.
		'Delete' -> [respondToDelete].
		#separator.
		'Inspect Presenter' -> [respondToInspectPresenter]}
)
classDescriptionDefinition = (
	^subclassResponsibility
)
classNameAndContainmentDefinition = (
	^row: {
		draggableImage: icon forSubject: subject.
		smallBlank.
		elastic:: column: {
			row: {
				classNamePresenter:: EditableNSClassNamePresenter onSubject: subject.
				smallBlank.
				linkImage: HopscotchImages default editImage action: [respondToRename].
				smallBlank.
				(nestingInformationLine) compressibility: 1.
				filler compressibility: 0.
				(* right hand side begins *)
				ClassActionsPresenter onSubject: subject.
				smallBlank.
				itemReferencesButtonWithAction:
					[browseNSClassReferences: subject className].
				smallBlank.
				dropDownMenu: [classActionsMenu].
				}.
			row: {
				(label: 'Access Modifier: ') tinyFont.
				accessModifierLabel.
				mediumBlank.
				(label: 'Namespace: ') tinyFont.
				classNamespaceLink.
				}
			}
		}.
)
classNamespaceLink = (
	^(subject classCategoryName
		ifNil: [label: '(uncategorized)']
		ifNotNil:
			[:cat |
			link: cat action: [browseNamespace: cat]])
				tinyFont
)
classSourceDefinition = (
	| editor init <InitializerMethodSubject> |
	^column: {
		editor:: CodeEditorFragment new
			text: subject classHeaderSource;
			colorizerBlock: [:text | subject colorizeHeaderSource: text];
			acceptResponse:
					[(acceptClassDefinition: editor)
						ifTrue: [editor defaultAcceptResponse]].
	}
)
classSummaryDefinition = (
^
	column: {
		smallBlank.
		classNameAndContainmentDefinition.
		mediumBlank.
		preambleLine.
		mediumBlank.
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
		row: {
			label: 'Slots' asText allBold.
			largeBlank.
			addButtonWithAction: [slotsPresenter addNewItemTemplate].
			}.
		mediumBlank.
		slotsPresenter:: subject slotsSubject presenter.
		mediumBlank.
		initializerDefinition.
		}
)
collapsedHeadingDefinition = (
	(* Second level of the class header block, contained inside #headingDefinition. *)
	^column: {
		smallBlank.
		row:
			{image: icon.
			smallBlank.
			link: subject className asText allBold
				action: [browseClassMirror: subject classMirror].
			filler.
			itemReferencesButtonWithAction:
				[browseNSClassReferences: subject className].
			smallBlank.
			dropDownMenu: [classActionsMenu].
			}.
			smallBlank
		}
)
expandedHeadingDefinition = (
	(* Second level of the class header block, contained inside #headingDefinition. Defines the floating header block including the class name, containing classes, category and package, and the description/source switcher. *)
	^(column: {
		smallBlank.
		classNameAndContainmentDefinition.
		blank: 15.
		descriptionOrSourceSwitcherHolder:: holder: (switcherShowingSource: false).
		(row: {}) width: 1; color: (Color gray: 0.8).
		mediumBlank.
		descriptionOrSourceHolder:: holder: classDescriptionDefinition
	})
)
expandedHeadingDefinitionWithFloatingHeader = (
	(* UNUSED, but saving it for the time being as an experiment. *)
	(* Second level of the class header block, contained inside #headingDefinition. Defines the floating header block including the class name, containing classes, category and package, and the description/source switcher. *)
	^floatingHeader:
		((column: {
			smallBlank.
			classNameAndContainmentDefinition.
			blank: 15.
			descriptionOrSourceSwitcherHolder::
				holder: (switcherShowingSource: false).
			(row: {}) width: 1; color: (Color h: 240 s: 0.05 v: 0.8).
		}) color: (Color h: 240 s: 0.05 v: 0.9))
	body:
		(column: {
			smallBlank.
			descriptionOrSourceHolder:: holder: classDescriptionDefinition
		})
)
extraInformationMetapresenter = (
	| enclosingClasses |
	enclosingClasses:: subject enclosingClasses.
	^enclosingClasses isEmpty
		ifTrue: [nothing]
		ifFalse:
			[ | labelStream |
			labelStream:: (String new: 50) writeStream.
			enclosingClasses do:
				[:each |
				labelStream
					nextPutAll: ' in ';
					nextPutAll: each simpleName].
			(label: labelStream contents) color: (Color gray: 0.5)]
)
headingDefinition = (
	(* Top level of the class header block, the one that provides the expand/collapse button in the top left corner. *)
	^(row: {
		elastic:
			(expanded: expandedHeadingDefinition
			collapsed: collapsedHeadingDefinition).
		smallBlank
	}) color: (Color h: 240 s: 0.05 v: 0.9)
)
public icon = (
	^subject classUiDescription classIcon
)
initializerDefinition = (
	| editor fragment success |

	^subclassResponsibility
)
linkToBrowseEnclosingClass: mirror <ClassDeclarationMirror> = (
	^link: mirror simpleName asText allBold
		action: [enterSubject:: NormalClassSubject onModel: mirror]
)
nestingInformationLine = (
	| enclosingClasses |
	enclosingClasses:: subject enclosingClasses.
	^enclosingClasses isEmpty
		ifTrue: [label: 'top level class']
		ifFalse:
			[ | rowElements |
			rowElements:: List new.

			enclosingClasses do:
				[:each |
				rowElements add: (label: ' in ').
				rowElements add: (linkToBrowseEnclosingClass: each)].
			row: rowElements asArray]
)
public parentClassSubjectDo: action = (
	^action value: subject
)
requestPresentationChange: newPresenter = (
	parent
		replaceChild: self
		with: newPresenter
)
respondToBrowseSuperclass = (
	browseClass: subject superclass
)
respondToCopy = (
	| copyName |
	copyName:: UIManager default
			request: 'Copy as...'
			initialAnswer: subject className, '2'.
	copyName isEmpty ifTrue: [^self (* User cancelled *)].
	browseClass:: subject copyAs: copyName.
)
respondToDelete = (
	| deletedName |
	deletedName:: subject deleteClass.
	requestPresentationChange:
		(DeletedClassSubject onModel: deletedName) presenter.
)
respondToMoveDown = (
(* Refactoring: move class to a nested class of its enclosing class *)
halt. (* Not yet implemented *)
)
respondToMoveUp = (
(* Refactoring: move class to enclosing class of its enclosing class *)
notYetImplemented
)
respondToRename = (
	classNamePresenter enterEditState
)
respondToSave = (
	CrLfFileStream
		forceNewFileNamed: subject fileName
		do: [:stm | stm nextPutAll: subject classMirror compilationUnitSource].
)
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> = (
	| groupPresenter |
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				blank: 3.
				reorderButtonWithAction: [groupPresenter switchSortOrder].
				}
			).
		groupPresenter:: groupSubject presenter.
		}
)
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> allowSwitch: allowSwitch = (
	| groupPresenter |
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				blank: 3.
				allowSwitch
					ifTrue: [reorderButtonWithAction: [groupPresenter switchSortOrder]]
					ifFalse: [nothing]
				}
			).
		groupPresenter:: groupSubject presenter.
		}
)
public showHeaderEditor = (
	switchToSource
)
switchToDescription = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: false).
	descriptionOrSourceHolder content: classDescriptionDefinition.
)
switchToSource = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: true).
	descriptionOrSourceHolder content: classSourceDefinition
)
switcherShowingSource: showingSourceNow <Boolean> = (
	^showingSourceNow
		ifTrue:
			[row: {
				(link: 'Description' action: [switchToDescription]) smallFont.
				mediumBlank.
				(label: 'Source' asText allBold) smallFont.
			}]
		ifFalse:
			[row: {
				(label: 'Description' asText allBold) smallFont.
				mediumBlank.
				(link: 'Source' action: [switchToSource]) smallFont.
			}]
)
) : (
)
class AbstractClassSubject onModel: m = ClassSubject onModel: m (
(*Represents common behavior of NS class subjects. These include both class declarations which provide their own slots, methods and nested classes, and mixin applications.*)
| guessedSuperclass guessedSubclasses |) (
public acceptClassDefinition: aString = (
	| builder |
	builder:: ClassDeclarationBuilder reflecting: model reflectee.
	builder headerFromSource: aString.
	builder install.
	^true
)
public accessModifier = (
	^classMirror accessModifier
)
public classCategoryName ^<Symbol | nil> = (
	^classMirror reflectee definingModule category asSymbol
)
public classHeaderSource = (
	^classMirror header source
)
classLanguage = (
	^newspeakLanguage3
)
public classMirror ^<ClassDeclarationMirror> = (
	(* A synonym of #model, for readability. *)
	^model
)
public className = (
	^classMirror simpleName
)
public colorizeHeaderSource: sourceText <String | Text> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model reflectee definingClass
		usingSelector: #classHeader
)
public copyAs: newName <String> = (
	#BOGUS. (* Does not check if this will clobber an existing class. Should this case be an error or a warning? *)
	isTopLevel
		ifTrue:
			[ | builder mixin klass |
			builder:: ClassDeclarationBuilder fromSource: classMirror source.
			builder header name: newName.
			mixin:: builder install reflectee.
			klass:: mixin apply: Object withName: builder name.
			Root at: klass name put: klass.
			klass mixin category: classCategoryName.
			^mixin]
		ifFalse:
			[ | builder newSource nestedBuilder |
			builder:: ClassDeclarationBuilder fromSource: classMirror source.
			builder header name: newName.
			newSource:: builder source.
			builder:: ClassDeclarationBuilder reflecting: classMirror enclosingClass reflectee.
			nestedBuilder:: builder instanceSide nestedClasses addFromSource: newSource.
			builder install.
			^nestedBuilder reflectee].
)
public deleteClass = (
	nil = model enclosingClass
		ifTrue:
			[ide namespacing removeKey: model simpleName]
		ifFalse:
			[ | builder |
			builder:: ClassDeclarationBuilder reflecting: model enclosingClass reflectee.
			builder instanceSide nestedClasses removeMirrorNamed: model simpleName.
			builder install].
	^model simpleName
)
public deployAsChromeApp = (
	| packager path |
	packager:: ide jsPackaging ChromeAppPackager usingPlatform: cachedPlatform.
	path:: packager
		packageApplicationConfiguration: (Root at: model simpleName)
		usingNamespace: ide namespacing Root.

	(* Only works if Chrome isn't already running :( *)
	(ExternalLauncher for: 'open')
		runWith: {'-a'. 'Google Chrome.app'. '--args'. '--load-and-launch-app=',path}
		ifSuccess: [:stdout :stderr | ]
		ifFailure: [:stdout :stderr | ].
)
public deployAsPackagedImage = (
	| appDef app |
	appDef:: Root at: model simpleName.
	app:: appDef packageUsing: ide namespacing manifestForSqueak.
	Deployment makeDeploymentImageFor: app.
)
public deployAsVictoryFuel = (
	| appDef app bytes |
	appDef:: Root at: model simpleName.
	app:: appDef packageUsing: ide namespacing manifestForSqueak.
	bytes:: ByteArray streamContents:
		[:stream |
		| ser = VFSerializer over: stream withGlobals: Smalltalk globals. |
		ser serialize: app].
	FileStream
		forceNewFileNamed: appDef name, '.vfuel'
		do: [:stream | stream nextPutAll: bytes].
)
public deployAsWebPage = (
	ide webPackager isNil ifTrue:
		[ide webPackager: (ide jsPackaging WebPagePackager usingPlatform: cachedPlatform)].

	open:: ide webPackager
		packageApplicationConfiguration: (Root at: model simpleName)
		withRuntimeConfiguration: ide jsPackaging Runtime
		usingNamespace: ide namespacing Root.
)
public deployAsWebPageWithMirrorBuilders = (
	ide webPackager isNil ifTrue:
		[ide webPackager: (ide jsPackaging WebPagePackager usingPlatform: cachedPlatform)].

	open:: ide webPackager
		packageApplicationConfiguration: (Root at: model simpleName)
		withRuntimeConfiguration: ide jsPackaging RuntimeWithMirrorBuilders
		usingNamespace: ide namespacing Root.
)
enclosingClass ^ <NS2ClassStencilMirror> = (
	^classMirror enclosingClass
)
public enclosingClasses ^<List[NSClassMirror]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| classes currentClass |
	classes:: List new.
	currentClass:: classMirror enclosingClass.
	[currentClass notNil] whileTrue:
		[classes add: currentClass.
		currentClass:: currentClass enclosingClass].
	^classes
)
public fileName = (
	^className, '.', newspeakLanguage3 fileExtension
)
public implementationClass = (
(* The Smalltalk class behind the scenes. *)
^model reflectee definingClass
)
public instancesSubject ^<ObjectSubject> = (
	| instances = List new. |
	#BOGUS. (* Put allInstancesDo: on ClassMirror? *)
	model reflectee applications do:
		[:application |
		application allInstancesDo:
			[:instance | instances add: instance]].
	^presenter objectSubjectFor: instances
)
public isApplicationConfiguration = (
	^isTopLevel and: [model classSide canUnderstand: #packageUsing:]
)
public isTestConfiguration = (
	^isTopLevel and: [model classSide canUnderstand: #packageTestsUsing:]
)
public isTopLevel = (
	^model enclosingClass == nil
)
public methodCount ^<Integer> = (
	^subclassResponsibility
)
open: path = (
	OSProcess isUnixMac ifTrue: [
		^(ExternalLauncher for: 'open')
			runWith: {path}
			ifSuccess: [:stdout :stderr | ]
			ifFailure: [:stdout :stderr | ]].

	OSProcess isUnix ifTrue: [
		^(ExternalLauncher for: 'xdg-open')
			runWith: {path}
			ifSuccess: [:stdout :stderr | ]
			ifFailure: [:stdout :stderr | ]].

	OSProcess isWindows ifTrue: [
	 	^(ExternalLauncher for: 'cmd')
			runWith: {'/c'. 'start'. path}
			ifSuccess: [:stdout :stderr | ]
			ifFailure: [:stdout :stderr | ]].
)
public runApp = (
	| appDef app |
	appDef:: Root at: model simpleName.
	app:: appDef packageUsing: ide namespacing manifestForSqueak.
	[app main: cachedPlatform args: {}] forkNamed: app printString.
)
public subInstancesSubject ^<ObjectSubject> = (
	| instances = List new. |
	#BOGUS. (* Put allInstancesDo: on ClassMirror? *)
	model reflectee applications do:
		[:application |
		application allInstancesDo:
			[:instance | instances add: instance].
		application allSubclassesDo:
			[:subclass | subclass allInstancesDo:
				[:instance | instances add: instance]]].
	^presenter objectSubjectFor: instances
)
subclasses = (
(* guessedSubclasses ifNotNil: [:sc | ^sc].
flag: #BOGUS.
guessedSubclasses:: model guessSubclassesIfFail: [^NewspeakObject].
^guessedSubclasses *)
	^Object
)
public superclass = (
	| applications |
	applications:: model instanceSide applications.
	applications
		detect: [:any <ClassMirror> | ^any superclass mixin reflectee definingClass]
		ifNone: [^Object]
)
public superclassName = (
	^classMirror superclassName
)
public testingSubject = (
	^minitestUI TestingInProgressSubject
		onConfiguration: (Root at: model simpleName)
		platform: cachedPlatform
		minitest: minitest
)
public title = (
	^className asString
)
public totalSubclassCount = (
	(* flag: #BOGUS.
	^(classMirror guessSubclassesIfFail: [Array new]) size *)
	^0
)
) : (
)
class BodylessClassPresenter onSubject: s = AbstractClassPresenter onSubject: s (
(* Presents a mixin application class. The subject is an MixinApplicationClassSubject. *)
) (
classDescriptionDefinition = (
	^column: {
		preambleLine.
		}
)
definition = (
	| classesPresenter |
^
	column: {
		headingDefinition.
	}
)
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble equalIndex prefix suffix |
	preamble:: subject model header source.
	equalIndex:: preamble indexOf: "=".
	equalIndex = 0
		ifTrue:
			[prefix:: preamble withBlanksTrimmed.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1)
				withBlanksTrimmed.
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)
				withBlanksTrimmed].
	^row: {
			label: prefix, ' = '.
			link: suffix action: [respondToBrowseSuperclass]
			}
)
) : (
)
class BodylessClassSubject onModel: m = AbstractClassSubject onModel: m (
(* WIP. Represents a mixin application class rather than a class declaration.  *)
) (
public createPresenter = (
	^BodylessClassPresenter onSubject: self
)
public methodCount ^<Integer> = (
	^0
)
) : (
)
public class ClassActionsPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
applicationActions = (
	subject isApplicationConfiguration ifFalse: [^nothing].
	^row: {
		mediumBlank.
		(link: '[deploy]' action: [
			openMenu:: menuWithLabelsAndActions: {
				'as VictoryFuel' ->
					[subject rememberVisit. showWaitCursorWhile: [subject deployAsVictoryFuel]].
				'as Web Page' ->
					[subject rememberVisit. showWaitCursorWhile: [subject deployAsWebPage]].
				'as Web Page with Mirror Builders' ->
					[subject rememberVisit. showWaitCursorWhile: [subject deployAsWebPageWithMirrorBuilders]].
			}
		]) tinyFont.
		smallBlank.
		(link: '[run]' action: [subject runApp]) tinyFont.
	}
)
benchmarkActions = (
	^nothing
)
definition = (
	^row: {testActions. benchmarkActions. applicationActions}
)
testActions = (
	subject isTestConfiguration ifFalse: [^nothing].
	^row: {
		mediumBlank.
		(link: '[run tests]' action: [subject rememberVisit. enterSubject:: subject testingSubject]) tinyFont.
	}
)
) : (
)
class ClassReferencesPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* The subject is an NSClassReferencesSubject. Displays the list of methods provided by the subject, which are those that seem to reference an NS class. *)
) (
definition = (
	| references |
	^column: {
		minorHeadingBlock: (
			row: {
				label: subject className asText allBold.
				label: ' references'.
				filler.
				expandButtonWithAction: [references expandAll].
				blank: 3.
				collapseButtonWithAction: [references collapseAll]
				}
			).
		blank: 10.
		row: {
			blank: 10.
			elastic:
				(references::
				(AssortedMethodsSubject onModel: subject referencesSubjects) presenter).
			}.
		blank: 10
		}
)
) : (
)
class ClassReferencesSubject onModel: m = Subject onModel: m (
(* The model is the class name. Provides access to methods that are likely to reference the class because they are sending that name as a message. *)
| nameSelectorSubject |nameSelectorSubject:: SelectorSubject onModel: className) (
public = anotherSubject = (
	^(anotherSubject class = self class)
		and: [anotherSubject className = className]
)
public className = (
	^model
)
public createPresenter = (
	^ClassReferencesPresenter onSubject: self
)
public hash = (
	^model hash
)
public referencesSubjects = (
	^nameSelectorSubject senderSubjects
)
public title = (
	^className, ' References'
)
) : (
)
public class ExemplarMethodGroupSubject onModel: m = MethodGroupSubject onModel: m () (
elementSubjectClass = (
	^ExemplarMethodSubject
)
) : (
)
public class ExemplarMethodPresenter onSubject: s = ExpandableMethodPresenter onSubject: s () (
methodDetails ^ <Fragment> = (
	^(finalizer subjectForContext: subject exemplar) createPresenter.
)
) : (
)
class ExemplarMethodSubject onModel: m = NSMethodSubject onModel: m () (
public createPresenter = (
	^ExemplarMethodPresenter onSubject: self
)
) : (
)
class ExpandableClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Presents the subject (an NSClassSubject) as a line displaying the class name and expandable into a full-blown class view. *)
) (
public collapse = (
	substance collapse
)
definition = (
	| toggle |
	toggle::
		collapsed: (NestedClassPresenter onSubject: subject)
		expanded: [subject classSubject createPresenter].
	toggle onUserToggled: [requestVisibility].
	^toggle
)
public expand = (
	substance expand
)
) : (
)
class InitializerMethodPresenter onSubject: s = ExpandableMethodPresenter onSubject: s (
(* A specialized presenter for instance initializers. These present the initializer as a method, with a signature and sent messages information etc.. *)
) (
acceptClassDefinition: classEditor = (
	(* This class's definition has been changed in the definition editor. *)

	^majorUpdate:
		[[subject classSubject acceptClassDefinition: classEditor textBeingAccepted]
			on: Error
			do: [:ex | classEditor showMessage: ex description. false]]
)
categoryLink ^ <Fragment> = (
  (* don't display a category at all *)
	^(label: '<instance initializer>') tinyFont
)
classSourceDefinition = (
	^column: {
		editor:: CodeEditorFragment new
			text: subject classSubject classHeaderSource;
			colorizerBlock: [:text | subject classSubject colorizeHeaderSource: text];
			acceptResponse:
					[(acceptClassDefinition: editor)
						ifTrue: [editor defaultAcceptResponse]].
	}
)
methodDetails = (
	^classSourceDefinition
)
) : (
)
public class InitializerMethodSubject onModel: m <MethodMirror> = NSMethodSubject onModel: m (
(* WIP: Designed to handle synthetic initializer methods, including the primary  class factory, the instance initializer and its subparts *)
|
_classSubject <ClassSubject | ClassHeaderSubject>
|) (
allInitializers ^ <Collection[CompiledMethod]> = (
	(* get all the methods that represent instance initializer code.
	A principled way of doing this is needed, so that we don't rely on the
	conventions of the compiler here. Perhaps mirrors should support this?
	*)
	^classSubject classMirror reflectee methodDict values select: [:m | m properties includesKey: #isSubinitializer ]
)
public changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
   failureBlock value
)
public classSubject ^ <ClassSubject> = (
	_classSubject isNil ifTrue: [_classSubject:: (classSubjectOn: methodMirror definingMixin declaration)].
	^_classSubject
)
public createPresenter ^ <Presenter> = (
	| presenterClass |
	presenterClass:: ide settings useExemplarPresenters
	    	ifTrue: [ExemplarMethodPresenter]
		ifFalse: [InitializerMethodPresenter].

	^(presenterClass onSubject: self)
)
public deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
  (* do nothing for now. Should report an error, or better yet,
   not have the option in the menu *)
)
public isAnOverride = (
(* True if one of the superclasses has a method with the same selector. *)
 ^false
)
public isAnOverrideIn: classSubj <NSClassSubject | nil> = (
	^false
)
public isOverriden = (
	(* True if one of the subclasses has a method with the same selector. *)
	^false
)
public isValid ^ <Boolean> = (
	^true
)
public messages ^ <List[Symbol]> = (
	(* This is missing messages in the inheritance clause. *)
	| accumulator <Set[Symbol]> = Set new. |
	allInitializers do: [:i |
		i  messages do: [:each | accumulator add: each]].
	^accumulator asMutableArrayList select: [:n | (n includes: "`") not]
)
public methodCategory ^<String> = (
	^'<instance initializer>'
)
public selector = (
	^methodMirror definingMixin declaration header primaryFactoryName
)
public source ^ <String> = (
	^classSubject classHeaderSource
)
public variableBindingKeys ^ <List[Symbol]> = (
	| accumulator <Set[Symbol]> = Set new. |

	allInitializers do: [:i |
		i  literalsDo: [:each |
			(each isVariableBinding and: [each key notNil]) ifTrue:
			[accumulator add: each key]]].
	^accumulator asMutableArrayList
)
) : (
)
class MethodGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s (
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)
| groupedByCategory ::=false. |) (
public addMethodIn: cls proposedSource: src = (
subject mirrorGroup enclosingMixin reflectee == cls ifTrue:
	[| template |
	template:: addNewItemTemplate: src.
	turnOnTemplateEditorMode: src in: template]
)
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	addNewItemTemplate: subject methodTemplateText
)
addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template |
	template:: DefinitionTemplate new
		caption: 'Adding new method:';
		initialText: src;
		colorizerBlock: [:text | subject colorizeSource: text];
		acceptResponse:
			[createNewMethodFromTemplate: template];
		cancelResponse:
			[prefixes remove: template].
	prefixes add: template.
	^template
)
public compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <Block> ifCompiledAsNew: successNewResponse <Block> ifFailed: failureResponse <Block> = (
	majorUpdate:
		[subject
			compileSource: source
			ifSuccess:
				[:newSelector |
				newSelector = requestor subject selector
					ifTrue: [successResponse value]
					ifFalse: [successNewResponse value].
				content refresh.
				(content detectPresenter: [:some | some subject selector = newSelector])
					expand]
			ifFailure: failureResponse]
)
contentPresenters = (
	| subjects |
	subjects:: groupedByCategory
		ifTrue: [subject sortedCategories]
		ifFalse: [subject elements].
	^subjects collect:
		[:each | createPresenterForSubject: each]
)
createNewMethodFromTemplate: template <DefinitionTemplate> = (
	subject
		compileSource: template text
		ifSuccess:
			[:newSelector |
			prefixes remove: template.
			(content detectPresenter: [:some | some subject selector = newSelector]) expand]
		ifFailure: [:message | template editor showMessage: message]
)
public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteMethodWithSubject: presenter subject.
	successResponse value
)
public recategorizeMethodIn: presenter <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (
	| newName |
	newName:: newCategoryName withBlanksTrimmed.
	newName isEmpty ifTrue: [^failureResponse value].
	presenter subject
		changeCategoryTo: newName asSymbol
		ifSuccess:
			[refresh. (* so the methods are reshuffled according to categories *)
			successResponse value]
		ifFailure: failureResponse
)
repondToEnter: template defaultAction: defaultAction = (
| src index indexType range pos end |
range:: template editor editor selectionInterval.
pos:: range isEmpty ifTrue: [range first] ifFalse: [range last].
src:: (template editor editedText ifNil: [template editor text]) asString.
index:: src asString findString: 'argument' startingAt: pos.
indexType:: src indexOf: "<" startingAt: pos.
(index ~= 0 and: [indexType ~= 0]) ifTrue:
	[index:: index min: indexType].
index = 0 ifTrue:
	[index:: indexType].
index = 0 ifTrue:
	[template editor enterKeyResponse: nil.
	index:: src indexOf: Character tab startingAt: pos.
	index ~= 0 ifTrue:
		[template editor editor
			selectFrom: index + 1
			to: index].
	^self].
end:: index = indexType
	ifTrue:
		[index:: index + 1.
		(src indexOf: ">" startingAt: pos) - 1]
	ifFalse: ['argument' size + index].
template editor editor
	selectFrom: index
	to: end
)
public switchSortOrder = (
	groupedByCategory: groupedByCategory not.
	refresh
)
turnOnTemplateEditorMode: src in: template = (
| indexOfFirstArg |
indexOfFirstArg:: src findString: 'argument1'.
indexOfFirstArg > 0 ifTrue:
	[template editor enterKeyResponse:
		[:defaultAction |
		repondToEnter: template defaultAction: defaultAction].
	template editor editor
		selectFrom: indexOfFirstArg
		to: 'argument1' size + indexOfFirstArg - 1]
)
) : (
)
public class MethodGroupSubject onModel: m = MirrorGroupSubject onModel: m (
(* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)
) (
public colorizeSource: sourceText <String | Text> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model enclosingMixin reflectee
		usingSelector: #methodDecl
)
public compileSource: aString ifSuccess: successBlock ifFailure: failureBlock = (
	[ | builder newMirror |
	builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	newMirror:: builder methods addFromSource: aString.
	builder declaration install.
	successBlock value: newMirror simpleName]
		on: Error
		do: [:ex | failureBlock value: ex description].
)
public createPresenter = (
	^MethodGroupPresenter onSubject: self
)
public deleteMethodWithSubject: methodSubject = (
	| builder |
	builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	builder methods removeMirrorNamed: methodSubject selector.
	builder declaration install.
)
elementSubjectClass = (
	^NSMethodSubject
)
public methodSubjectsInCategory: categoryName <Symbol> ^<Collection[MethodSubject]> = (
	| matches |
	matches:: (modelMirrorCollection select: [:each | each category = categoryName]).
	^matches collect: [:mirrorMethod | elementSubjectClass onModel: mirrorMethod].
)
public methodTemplateText = (
^
'messageSelector = (
)'
)
modelMirrorCollection = (
	^super modelMirrorCollection asSortedList: [:a :b | a simpleName < b simpleName]
)
public sortedCategories = (
(* Answer a collection of method subjects sorted by their category names found in the class, sorted with initialization first and private categories last. *)
| categories init privateCategories unclassified lineup |
categories:: modelMirrorCollection inject: Set new into: [:s :m | s add: m category. s].
init:: categories select: [:each | 'init*' match: each].
categories:: categories reject: [:each | init includes: each].
privateCategories:: categories select: [:each | 'private*' match: each].
categories:: categories reject: [:each | privateCategories includes: each].
(categories includes: #'as yet unclassified')
	ifTrue:
		[unclassified:: {#'as yet unclassified'}.
		categories remove: #'as yet unclassified']
	ifFalse:
		[unclassified:: {}].
lineup:: List new: categories size.
lineup
	addAll: unclassified;
	addAll: init asSortedList;
	addAll: categories asSortedList;
	addAll: privateCategories asSortedList.
^lineup
	inject: List new
	into:
		[:collection :each |
		collection addAll: (methodSubjectsInCategory: each).
		collection]
)
) : (
)
class MirrorGroupPresenter onSubject: s = DefinitionListPresenter onSubject: s (| elementPresenterClass |self subject: s) (
public addNewItemTemplate = (
	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)

	subclassResponsibility
)
contentPresenters = (
	^subject elements collect:
		[:each | createPresenterForSubject: each]
)
createPresenterForSubject: aSubject = (
	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)

	^elementPresenterClass
		ifNil: [aSubject presenter]
		ifNotNil: [:pclass | pclass onSubject: aSubject]
)
subject: aMirrorGroupSubject = (
	super subject: aMirrorGroupSubject.
	subject changedChannel => [:whatever | content refresh]
)
) : (
)
class MirrorGroupSubject onModel: m = Subject onModel: m (
(* An abstract superclass of subjects on mirror groups. Registers to receive update events from the mirror group and broadcasts its own update events through its 'changedChannel' when that happens. The presenter will listen to those and update itself when needed. *)
|
mirrorGroupChangesOutlet
public changedChannel ::= Duct owner: self.
|self model: m) (
elementSubjectClass = (
	(* Answer the class of the subjects we create on individual elements of our subject group. *)

	subclassResponsibility
)
public elements ^<Collection[Subject]> = (
	(* Answer a collection of subjects on individual elements of the group which is our subject. *)

	^modelMirrorCollection collect: [:each | elementSubjectClass onModel: each]
)
public mirrorGroup ^ <MirrorGroup> = (
	^model
)
model: mirrors <MirrorGroup> = (
	super model: mirrors.
	(* We expect the mirror group changes channel to be weak so we are retaining the outlet and expect that the old one, if any, will get garbage-collected. *)

	mirrorGroupChangesOutlet::
		model channelForChanges => [:x | changedChannel send: true].
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^(model collect: [:x | x]) asMutableArrayList
)
) : (
)
public class NSMethodInheritanceSubject onModel: m = MethodInheritanceSubject onModel: m () (
public implementingClass = (
	halt
)
public methodTitle = (
	^model definingMixin name, '>>', selector
)
selector = (
	^model simpleName
)
) : (
)
public class NSMethodSubject onModel: m = MethodSubject onModel: m (|
	exemplar_slot <MethodContext>
|) (
public = other <Object> ^<Boolean> = (
	^self class = other class and: [methodMirror = other methodMirror]
)
public allMethodCategories ^<Collection[Symbol]> = (
	(* Answer a collection of all category names used in the implementor class, plus some common names. *)
	| names |
	names:: super allMethodCategories.
	names addAll: (methodMirror definingMixin methods collect: [:ea | ea category]).
	^names
)
public asMethodInheritanceSubject = (
	^NSMethodInheritanceSubject onModel: methodMirror
)
public changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
	| builder |
	builder:: MixinBuilder reflecting: methodMirror definingMixin reflectee.
	(builder methods findMirrorNamed: methodMirror simpleName) category: newName.
	builder declaration install.
	#BOGUS. (* Do this non atomically? *)

	successBlock value
)
classExemplar ^ <Class> = (
	^systemScope exemplarClassFor: methodMirror definingMixin reflectee
)
public className = (
	^methodMirror definingMixin name
)
public colorizeMethodSource: sourceText = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: implementingClass
		usingSelector: #methodDecl
)
public compileNewSource: newSource <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (
	| builder <MixinBuilder> newMethod <MirrorBuilder> |
	builder:: MixinBuilder reflecting: methodMirror definingMixin reflectee.
	newMethod:: builder methods addFromSource: newSource.
	builder declaration install.
	newMethod simpleName = methodMirror simpleName
		ifTrue: [(* same *) successBlock value]
		ifFalse: [(* new *) newBlock1arg value: (methodMirror definingMixin methods findMirrorNamed: newMethod simpleName) ].
)
public compiledMethod = (
	^methodMirror reflectee
)
public createPresenter = (
	| presenterClass |
	presenterClass::
	  (ide settings useExemplarPresenters
		and: [implementingClass language isNewspeakLanguage3
		and: [isSynthetic not]])
	    		ifTrue: [ExemplarMethodPresenter]
			ifFalse: [ExpandableMethodPresenter].

	^(presenterClass onSubject: self)
)
public deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
	| builder |
	builder:: MixinBuilder reflecting: methodMirror definingMixin reflectee.
	builder methods removeMirrorNamed: selector.
	builder declaration install.
	successBlock value (* always succeed? *)
)
public enclosingClasses ^<List[Mixin]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| classes currentClass |
	classes:: List new.
	currentClass:: methodMirror definingMixin.
	[classes add: currentClass reflectee.
	currentClass:: currentClass declaration enclosingClass.
	currentClass isNil]
		whileFalse: [currentClass:: currentClass instanceSide].
	^classes
)
public exemplar ^ <MethodContext> = (
   exemplar_slot ifNil: [
	exemplar_slot::
		(MethodContext newForMethod: methodMirror reflectee)
				setSender: nil
				receiver: instanceExemplar
				method: methodMirror reflectee arguments: exemplarArgs.
	].
	^exemplar_slot
)
exemplarArgs ^ <Array> = (
	^Array new: methodMirror reflectee numArgs
)
public hash ^<SmallInteger> = (
	^self class hash bitXor: model hash
)
public implementingClass = (
	^methodMirror reflectee methodClass
)
instanceExemplar = (
	^systemScope exemplarInstanceFor: classExemplar
)
public isAnOverride = (
	^superclass canUnderstand: self selector
)
public isAnOverrideIn: classSubject <NSClassSubject | nil> = (
	^(classSubject ifNil: [^isAnOverride]) superclass canUnderstand: self selector
)
public isOverridden = (
	flag: #BOGUS.
	^false.
)
public isOverriddenIn: classSubject <NSClassSubject | nil> = (
(* (classSubject ifNil: [^isOverridden]) subclasses do: [:ea |
	(ea mixin methods includesMirrorNamed: selector)
		ifTrue: [^true]]. *)
^false
)
public isValid = (
	^true
)
public messages = (
	^compiledMethod messages
)
public methodCategory = (
	^methodMirror category
)
public methodMirror = (
	^model
)
public selector = (
	^methodMirror name
)
public source = (
	^methodMirror source
)
superclass = (
	#BOGUS.
	^Object
)
public variableBindingKeys ^ <List[Symbol]> = (
	| result <List[Symbol]> |
	result:: List new.
	compiledMethod literalsDo:
		[:each |
		(each isVariableBinding and: [each key notNil]) ifTrue:
			[result add: each key]].
	^result
)
) : (
)
class NestedClassGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s (
(* Presents nested classes of an NS class and takes care of their creation and deletion. *)
) (
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
public addClassIn: receiverClass <Mixin> proposedSource: src <String> = (
	subject classObject == receiverClass ifTrue:
	[addNewItemTemplate: src]
)
public addNewItemTemplate = (
	| template |
	template:: DefinitionTemplate new
		caption: 'Adding new class:';
		initialText: subject classDefinitionHeaderPartTemplate;
		colorizerBlock: [:text | subject colorizeSource: text];
		acceptResponse:
			[acceptNewClassDefinitionFrom: template];
		cancelResponse:
			[prefixes remove: template].
	prefixes add: template
)
addNewItemTemplate: src <String> = (
	| template |
	template:: DefinitionTemplate new
		caption: 'Adding new class:';
		initialText: src;
		colorizerBlock: [:text | subject colorizeSource: text];
		acceptResponse:
			[acceptNewClassDefinitionFrom: template];
		cancelResponse:
			[prefixes remove: template].
	prefixes add: template
)
) : (
)
class NestedClassGroupSubject onModel: m = MirrorGroupSubject onModel: m (
(* Represents the collection of classes nested in a Newspeak class. Holds onto the mirror group for the classes.
*)
) (
public addClassFromDefinition: aString ifSuccess: successBlock ifFailure: failureBlock = (
	| builder newMirror |
	[builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	builder nestedClasses addFromSource: aString.
	builder declaration install]
		on: Error
		do: [:e <Error> | ^failureBlock value: e description].

	successBlock value
)
public classDefinitionHeaderPartTemplate = (
^
'class ClassNameHere = (
|
	slot1
	slot2
|
) ()'
)
public classObject = (
	^model enclosingMixin reflectee
)
public colorizeSource: sourceText <Text | String> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model enclosingMixin reflectee
		usingSelector: #classDecl
)
public createPresenter = (
	^NestedClassGroupPresenter onSubject: self
)
elementSubjectClass = (
	^NestedClassSubject
)
modelMirrorCollection = (
	^super modelMirrorCollection asSortedList: [:a :b | a simpleName < b simpleName]
)
) : (
)
class NestedClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Presents an NSClassSubject as link that browses the class. *)
) (
accessModifierIcon = (
	^image: (iconForAccessModifier: subject accessModifier)
)
definition = (
^row: {
	accessModifierIcon.
	smallBlank.
	link: subject classMirror simpleName action: [ browseClassMirror: subject classMirror]
	}
)
) : (
)
class NestedClassSubject onModel: m = Subject onModel: m (
(* Represents a class nested inside another class. The default presenter renders this as a link that enters the class definition when clicked. *)
) (
public accessModifier = (
	^classMirror accessModifier
)
public classMirror = (
	^model
)
public classSubject = (
	^classSubjectOn: classMirror
)
public createPresenter = (
	^ExpandableClassPresenter onSubject: self
)
) : (
)
class NormalClassPresenter onSubject: s = AbstractClassPresenter onSubject: s (
(* Presents a Newspeak class, as a full view that includes slots, nested classes, methods, etc. The subject is a ClassDeclarationSubject. *)
|
	slotsSubject
	slotsPresenterX
|) (
classDescriptionDefinition = (
	^column: {
		preambleLine.
		mediumBlank.
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
		row: {
			label: 'Slots' asText allBold.
			largeBlank.
			addButtonWithAction: [slotsPresenter addNewItemTemplate].
			}.
		mediumBlank.
		slotsPresenter:: subject slotsSubject presenter.
		mediumBlank.
		initializerDefinition.
		}
)
definition = (
	| classesPresenter |
^
	column: {
		headingDefinition.
		sectionLabelled: 'Classes' presenting: subject nestedClassesSubject allowSwitch: false.
		sectionLabelled: 'Transient Slots' presenting: subject transientSlotsSubject allowSwitch: true.
		sectionLabelled: 'Methods' presenting: subject methodsSubject allowSwitch: true.
		sectionLabelled: 'Class Methods' presenting: subject classMethodsSubject allowSwitch: true.
	}
)
initializerDefinition = (
	| editor fragment success |

	^nothing
(*
	editor:: CodeEditorFragment new
		text: subject initExprs;
		colorizerBlock: [:text | NS2BrowserColorizer new
			parseText: text asString
			fromClass: subject classMirror
			usingSelector: #initExprs];
		acceptResponse: [[
			success:: true.
			subject initExprs: editor textBeingAccepted]
				ifError: [:err |
					success:: false.
					editor showMessage: err].
			success ifTrue: [
				editor defaultAcceptResponse.
				fragment refresh]].

	^fragment:: column: {
		holder: [ |additionalText|
			additionalText:: subject hasInitExprs ifTrue: [''] ifFalse: [' (empty)'].
			heading: (row: {
				label: 'Initializer ' asText allBold.
				label: additionalText.
				})
			details: editor]
		} *)
)
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble equalIndex prefix suffix |
	preamble:: subject classMirror header preamble.
	equalIndex:: preamble indexOf: "=".
	equalIndex = 0
		ifTrue:
			[prefix:: preamble withBlanksTrimmed.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1)
				withBlanksTrimmed.
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)
				withBlanksTrimmed].
	^suffix isEmpty
		ifTrue:
			[label: prefix]
		ifFalse:
			[row: {
				label: prefix, ' = '.
				link: suffix action: [respondToBrowseSuperclass]
				}]
)
slotsPresenter = (
	^slotsPresenterX
)
slotsPresenter: aPresenter = (
	(* Users of this expect that we answer the presenter rather than the receiver. *)
	slotsPresenterX:: aPresenter.
	^aPresenter
)
) : (
)
class NormalClassSubject onModel: m = AbstractClassSubject onModel: m (
(* Represents the ''normal'' perspective of looking at a full class declaration, so that its details such as slots, nested classes, and methods are visible. The model is the mirror on the class. By default presented by NormalClassPresenter. *)
| commentPresenter nestedClassesPresenter methodsPresenter |) (
public acceptClassDefinition: aString = (
	| builder |
	builder:: ClassDeclarationBuilder reflecting: model reflectee.
	builder headerFromSource: aString.
	builder install.
	^true
)
public classCommentText ^<String> = (
	^model header classComment ifNil: ['']
)
public classCommentText: newComment <String> = (
	| builder |
	builder:: ClassDeclarationBuilder reflecting: model reflectee.
	builder header classComment: newComment.
	builder install.
)
public classHeaderSource = (
	^classMirror header source
)
public classMethodsSubject = (
	ide settings useExemplarPresenters ifTrue:
		[^ExemplarMethodGroupSubject onModel: classMirror classSide methods].
	^MethodGroupSubject onModel: classMirror classSide methods
)
public createPresenter = (
	^NormalClassPresenter onSubject: self
)
initExprs = (
	^classMirror initExprs
)
initExprs: newInitExprs = (
	^classMirror initExprs: newInitExprs
)
initializer ^ <MethodMirror> = (
	classMirror instanceSide initializer isNil ifTrue: [^nil].
	(* temporary measure until all classes have been recompiled *)
	^InitializerMethodSubject onModel: classMirror instanceSide initializer
)
public methodCount ^<Integer> = (
	| instanceCount classCount |
	instanceCount:: model instanceSide methods size.
	classCount:: model classSide methods size.
	^instanceCount + classCount
)
public methodsSubject = (
	(ide settings useExemplarPresenters) ifTrue:
		[^ExemplarMethodGroupSubject onModel: model instanceSide methods].
	^MethodGroupSubject onModel: model instanceSide methods
)
public nestedClassesSubject = (
	^NestedClassGroupSubject onModel: model instanceSide nestedClasses
)
public slotsSubject = (
	^SlotGroupSubject onModel: classMirror instanceSide slots
)
public subclasses = (
(* guessedSubclasses ifNotNil: [:sc | ^sc].
flag: #BOGUS.
guessedSubclasses:: model guessSubclassesIfFail: [^NewspeakObject].
^guessedSubclasses *)
	^Object
)
public transientSlotsSubject = (
		(ide settings useExemplarPresenters) ifTrue:
		[
		(* must be implemented*)
		(* self error.  *)
		].

	^TransientSlotGroupSubject onModel: model instanceSide transientSlots.
)
) : (
)
class SlotGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s (
(* Displays the slots of a Newspeak class and handles their definiting, editing and removal. The subject is an NSSlotGroupSubject. *)
) (
acceptNewSlotDefinitionFrom: aTemplate = (
	majorUpdate:
		[subject
			acceptSlotDefinition: aTemplate text
			ifSuccess:
				[prefixes remove: aTemplate]
			ifFailure:
				[:message |
				error: message]]
)
public addNewItemTemplate = (
	sendUp showHeaderEditor
)
defineSlot: definition <String> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (
	majorUpdate:
		[subject
			acceptSlotDefinition: definition
			ifSuccess: successResponse
			ifFailure: failureResponse]
)
deleteSlotInPresenter: presenter <NSSlotPresenter> = (
	| slotSubject residue |
	slotSubject:: presenter subject.
	residue:: DefinitionResidue new
		caption: 'Deleted slot ', slotSubject slotName;
		definitionText: slotSubject definitionText;
		restoreResponse: [error: 'unimplemented'];
		forgetResponse: [suffixes remove: residue].
	subject deleteSlotSubject: slotSubject.
	suffixes add: residue
)
) : (
)
public class SlotGroupSubject onModel: m = MirrorGroupSubject onModel: m () (
acceptSlotDefinition: definitionString ifSuccess: successBlock0 ifFailure: failureBlock1 = (
	self unimplemented. (* Does it make sense to edit slots in isolation? *)
)
public createPresenter = (
	^SlotGroupPresenter onSubject: self
)
deleteSlotSubject: aSlotSubject = (
	model removeMirrorNamed: aSlotSubject slotName
)
elementSubjectClass = (
	^SlotSubject
)
) : (
)
class SlotPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* The subject is an NSSlotSubject. Presents the slot as a link expandable into a full definition. *)
| editor |) (
definition = (
	^row: {
		image: (iconForAccessModifier: subject slotAccessModifier).
		smallBlank.
		link: subject slotNameAndInitializerString action: [sendUp showHeaderEditor].
		filler.
		itemReferencesMenuButtonWithAction: [goToMessages].
		}
)
definitionText = (
	^subject slotDefinitionString
)
goToMessages = (
	| messagesAndActions messageItems classItems |
	messagesAndActions:: List new.
	messagesAndActions
		add: subject slotName -> [browseSelector: subject slotName];
		add: (subject slotName, ':') -> [browseSelector: subject slotName, ':'].
	(* messageItems:: referencesMenuMessageItems.
	classItems:: referencesMenuClassItems.
	messageItems notEmpty ifTrue:
		[messagesAndActions
			add: #separator;
			addAll: messageItems].
	classItems notEmpty ifTrue:
		[messagesAndActions
			add: #separator;
			addAll: classItems]. *)
	openMenuWithLabelsAndActions: messagesAndActions
)
) : (
)
class SlotSubject onModel: m = Subject onModel: m (| deleteResponse |) (
public acceptSlotDefinition: definitionString ifSuccess: successBlock0 ifFailure: failureBlock1 = (
	flag:: #BOGUS. (* do something! *)
	failureBlock1 value: 'Sorry, saving is not implemented yet'
)
public createPresenter = (
	^SlotPresenter onSubject: self
)
definitionText = (
	^slotDefinitionString
)
public slotAccessModifier = (
	^slotMirror accessModifier
)
slotDefinitionString = (
	^slotMirror source copy
)
slotInitializer = (
	^slotMirror initializer
)
slotMirror = (
(* A synonym of #model, for readability. *)

^model
)
public slotName = (
	^slotMirror name
)
public slotNameAndInitializerString ^<String> = (
	(* Answer a string that includes the name of the slot and some information from its initializer. The initializer information does not have to be complete; rather it should be formatted so as to look nice as a single line. *)

	| stream initializer |
	stream:: (String new: 30) writeStream.
	stream nextPutAll: slotMirror name.
	(* initializer:: slotMirror initializer.
	initializer notEmpty ifTrue:
		[stream nextPutAll: ' = ', (shorten: initializer toFirstCROrCharacters: 40)]. *)
	^stream contents
)
) : (
)
class TransientSlotGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s (
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)
) (
public addNewItemTemplate = (
	(* Handle a user's request to create a new transient slot by displaying a new transient slot template. *)
	addNewItemTemplate: subject transientSlotTemplateText
)
addNewItemTemplate: src = (
	| template |
	template:: DefinitionTemplate new
		caption: 'Adding new transient slot:';
		initialText: src;
		colorizerBlock: [:text | subject colorizeSource: text];
		acceptResponse:
			[createNewTransientSlotFromTemplate: template];
		cancelResponse:
			[prefixes remove: template].
	prefixes add: template.
	^template
)
public addTransientSlotIn: cls proposedSource: src = (
	subject mirrorGroup enclosingMixin reflectee == cls ifTrue:
		[ | template |
		 template:: addNewItemTemplate: src.
		 ]
)
public compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <Block> ifCompiledAsNew: successNewResponse <Block> ifFailed: failureResponse <Block> = (
	majorUpdate:
		[subject
			compileSource: source
			ifSuccess:
				[:newSelector |
				newSelector = requestor subject selector
					ifTrue: [successResponse value]
					ifFalse: [successNewResponse value].
				content refresh.
				(content detectPresenter: [:some | some subject selector = newSelector])
					expand]
			ifFailure: failureResponse]
)
contentPresenters = (
	| subjects |
	subjects:: subject elements.
	^subjects collect:
		[:each | createPresenterForSubject: each]
)
createNewTransientSlotFromTemplate: template <DefinitionTemplate> = (
	subject
		compileSource: template text
		ifSuccess:
			[:newSelector |
			prefixes remove: template.
			(content detectPresenter: [:some | some subject selector = newSelector]) expand]
		ifFailure: [:message | template editor showMessage: message]
)
public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (
	subject deleteMethodWithSubject: presenter subject.
	successResponse value
)
repondToEnter: template defaultAction: defaultAction = (
| src index indexType range pos end |
range:: template editor editor selectionInterval.
pos:: range isEmpty ifTrue: [range first] ifFalse: [range last].
src:: (template editor editedText ifNil: [template editor text]) asString.
index:: src asString findString: 'argument' startingAt: pos.
indexType:: src indexOf: "<" startingAt: pos.
(index ~= 0 and: [indexType ~= 0]) ifTrue:
	[index:: index min: indexType].
index = 0 ifTrue:
	[index:: indexType].
index = 0 ifTrue:
	[template editor enterKeyResponse: nil.
	index:: src indexOf: Character tab startingAt: pos.
	index ~= 0 ifTrue:
		[template editor editor
			selectFrom: index + 1
			to: index].
	^self].
end:: index = indexType
	ifTrue:
		[index:: index + 1.
		(src indexOf: ">" startingAt: pos) - 1]
	ifFalse: ['argument' size + index].
template editor editor
	selectFrom: index
	to: end
)
public switchSortOrder = (
	refresh
)
) : (
)
public class TransientSlotGroupSubject onModel: m = MirrorGroupSubject onModel: m (
(* Represents the collection of transient slots of a Newspeak class. Holds onto the mirror group for the transient slots. *)
) (
public colorizeSource: sourceText <String | Text> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model enclosingMixin declaration reflectee definingClass
		usingSelector: #transientSlotDecl
)
public compileSource: aString ifSuccess: successBlock ifFailure: failureBlock = (
	| newMirror |
	[ | builder |
	builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	newMirror:: builder transientSlots addFromSource: aString.
	builder declaration install]
		on: Error
		do: [:ex | ^failureBlock value: ex description].

	successBlock value: newMirror simpleName.
)
public createPresenter = (
	^TransientSlotGroupPresenter onSubject: self
)
public deleteMethodWithSubject: methodSubject = (
	| builder |

	builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	builder transientSlots removeMirrorNamed: methodSubject selector.
	builder declaration install.
)
elementSubjectClass = (
	^TransientSlotSubject
)
modelMirrorCollection = (
	^super modelMirrorCollection asSortedList: [:a :b | a simpleName < b simpleName]
)
public transientSlotTemplateText = (
	^'transient messageSelector = expression.'
)
) : (
)
public class TransientSlotSubject onModel: m = MethodSubject onModel: m (|
	exemplar_slot <MethodContext>
|
) (
public = other <Object> ^<Boolean> = (
	^self class = other class and: [methodMirror = other methodMirror]
)
public asMethodInheritanceSubject = (
	^NSMethodInheritanceSubject onModel: methodMirror
)
classExemplar ^ <Class> = (
	^systemScope exemplarClassFor: methodMirror definingMixin reflectee
)
public className = (
	^methodMirror definingMixin name
)
public colorizeMethodSource: sourceText = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: implementingClass
		usingSelector: #transientSlotDecl
)
public compileNewSource: newSource <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (
	| builder newMethod |
	builder:: MixinBuilder reflecting: methodMirror definingMixin reflectee.
	newMethod:: builder transientSlots addFromSource: newSource.
	builder declaration install.
	newMethod simpleName = methodMirror simpleName
		ifTrue: [(* same *) successBlock value]
		ifFalse: [(* new *) newBlock1arg value: (methodMirror definingMixin transientSlots findMirrorNamed: newMethod simpleName) ].
)
public compiledMethod = (
	^methodMirror initMethod
)
public createPresenter = (
	 | presenterClass |

	(* presenterClass::
	  (ide settings useExemplarPresenters
		and: [implementingClass language isNewspeakLanguage3
		and: [isSynthetic not]])
	    		ifTrue: [ExemplarMethodPresenter]
			ifFalse: [ExpandableMethodPresenter].
	*)
	presenterClass:: ExpandableMethodPresenter.

	^(presenterClass onSubject: self)
)
public deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
	| builder |
	builder:: MixinBuilder reflecting: methodMirror definingMixin reflectee.
	builder methods removeMirrorNamed: selector.
	builder declaration install.
	successBlock value (* always succeed? *)
)
public enclosingClasses ^<List[Mixin]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| classes currentClass |
	classes:: List new.
	currentClass:: methodMirror definingMixin.
	[classes add: currentClass reflectee.
	currentClass:: currentClass declaration enclosingClass.
	currentClass isNil]
		whileFalse: [currentClass:: currentClass instanceSide].
	^classes
)
public exemplar ^ <MethodContext> = (
   exemplar_slot ifNil: [
	exemplar_slot::
		(MethodContext newForMethod: methodMirror mainMethod)
				setSender: nil
				receiver: instanceExemplar
				method: methodMirror mainMethod arguments: exemplarArgs.
	].
	^exemplar_slot
)
exemplarArgs ^ <Array> = (
	^Array new: 0
)
public hash ^<SmallInteger> = (
	^self class hash bitXor: model hash
)
public implementingClass = (
	^methodMirror enclosingMixin
)
instanceExemplar = (
	^systemScope exemplarInstanceFor: classExemplar
)
public isAnOverride = (
	^superclass canUnderstand: self selector
)
public isAnOverrideIn: classSubject <NSClassSubject | nil> = (
	^(classSubject ifNil: [^isAnOverride]) superclass canUnderstand: self selector
)
public isOverridden = (
	flag: #BOGUS.
	^false.
)
public isOverriddenIn: classSubject <NSClassSubject | nil> = (
(* (classSubject ifNil: [^isOverridden]) subclasses do: [:ea |
	(ea mixin methods includesMirrorNamed: selector)
		ifTrue: [^true]]. *)
^false
)
public isValid = (
	^true
)
public messages = (
	^methodMirror messages
)
public methodCategory = (
	^#'transientslots'
)
public methodMirror = (
	^model
)
public selector = (
	^methodMirror name
)
public source = (
	^methodMirror source
)
superclass = (
	#BOGUS.
	^Object
)
public variableBindingKeys ^ <List[Symbol]> = (
	^methodMirror variableBindingKeys.
)
) : (
)
public classSubjectOn: cm <ClassDeclarationMirror> = (
	^cm hasBody
		ifTrue: [NormalClassSubject onModel: cm]
		ifFalse: [BodylessClassSubject onModel: cm]
)
) : (
)
