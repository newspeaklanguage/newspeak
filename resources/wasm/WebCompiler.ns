Newspeak3
'Root'
class WebCompiler packageUsing: manifest = (
(*
The web compiler is a command line app used to create vfuel files for execution by Psoup in the web browser. 
It expects a series of strings denoting paths to resources, followed by a series of 
triples of the form runtime-name app-name vfuel-file-name.vfuel. Each such triple specifies that the given vfuel file will be created to represent for the given app, using the given runtime. Example:

WebCompiler.vfuel \
    *.ns \
    *.png \
    CodeMirror/lib/codemirror.js \
    CodeMirror/addon/display/autorefresh.js \
    RuntimeWithMirrorsForPrimordialSoup HopscotchWebIDE HopscotchWebIDE.vfuel \
    RuntimeWithMirrorsForPrimordialSoup Ampleforth Ampleforth.vfuel \

*)
) (
class Manifest forNamespace: ns <Map[Class | String | Alien]> = (
	|
	protected namespace <Map[Class | String | Alien]> = ns.
	|
) (
protected doesNotUnderstand: message ^ <Class | String | Alien> = (
	^namespace at: message selector
)
) : (
)
class Packager usingPlatform: platform = (
	|
	private List = platform collections List.
	private Map = platform collections Map.
	private ClassDeclarationBuilder = platform mirrors ClassDeclarationBuilder.
	private Snapshotter = platform victoryFuel Snapshotter.

	protected namespace <Map[{String. String. String | Class}]> = Map new.
	|
) (
assembleRuntime: runtimeName <String> application: appName <String> to: snapshotPath <String> = (
	| runtimeConfig <Class> appConfig <Class>  runtime accessedResources <List> app bytes <ByteArray> |
	runtimeConfig:: (namespace at: runtimeName) at: 3.
	appConfig:: (namespace at: appName) at: 3.

	runtime:: runtimeConfig packageRuntimeUsing:
		(RecordingManifest namespace: namespace accessedResources: List new).

	accessedResources:: List new.
	appConfig packageUsing:
		(RecordingManifest namespace: namespace accessedResources: accessedResources).

	app:: Preloader
		resources: (Array withAll: accessedResources)
		applicationConfiguration: appConfig.

	bytes:: Snapshotter new snapshotApp: app withRuntime: runtime keepSource: true.
	writeBytes: bytes toFileNamed: snapshotPath.
)
compileFile: filename <String> ^ <Class> = (
	| source builder |
	filename out.
	source:: readFileAsString: filename.
	builder:: ClassDeclarationBuilder fromUnitSource: source.
	^builder install applyToObject reflectee
)
loadResource: path <String> ^ <{String. String. String | Class}> = (
	| from |
	from:: (path lastIndexOf: '/') + 1.

    (path endsWith: '.ns') ifTrue:
		[ | klass = compileFile: path. |
		 ^{klass name. 'ns'. klass}].
	(path endsWith: '.txt') ifTrue:
		[ | name = path copyFrom: from to: path size - 4. |
		 ^{name. 'txt'. readFileAsString: path}].
	(path endsWith: '.png') ifTrue:
		[ | name = path copyFrom: from to: path size - 4. |
		 ^{name. 'png'. path}].
	(path endsWith: '.js') ifTrue:
		[ | name = path copyFrom: from to: path size - 3. |
		 ^{name. 'js'. path}].
	(path endsWith: '.css') ifTrue:
		[ | name = path copyFrom: from to: path size - 4. |
		 ^{name. 'css'. path}].

	Error signal: 'Unknown resource type: ', path
)
readFileAsBytes: filename = (
	(* :literalmessage: primitive: 130 *)
	halt.
)
readFileAsString: filename = (
	^String withAll: (readFileAsBytes: filename)
)
writeBytes: bytes toFileNamed: filename = (
	(* :literalmessage: primitive: 128 *)
	halt.
)
public main: args <Sequence[String]> = (
	| index ::= 1. |
(* Phase 1: process resource arguments; collect them under their
    names, in a map *)
	[((args at: index) indexOf: '.') > 0] whileTrue:
		[ | resource <{String. String. String | Class}> |
		 resource:: loadResource: (args at: index).
		 namespace at: (resource at: 1) put: resource.
		 index:: index + 1].
(* Phase 2: process vfuel file specifications (triples). *)
	[(index + 2) <= args size] whileTrue:
		[assembleRuntime: (args at: index) application: (args at: index + 1) to: (args at: index + 2).
		 index:: index + 3].
)
) : (
)
class Preloader resources: r <Array[{String. String. String | Class}]> applicationConfiguration: a <Class> = (
(* Given a list of resources and an app, this class creates a wrapper for the app that converts the resources
    into actual objects and feeds them to the app so it can be instantiated.
*)
	|
	protected resources <Array[{String. String. String | Class}]> = r.
	protected applicationConfiguration <Class> = a.
	|
) (
public main: platform args: args ^ <Object> = (
	| namespace <Map[String, Class | String | Alien]> manifest <Manifest> |
	namespace:: platform collections Map new.
	resources do:
		[:resource <{String. String. String | Class}> | 
		| name <String> type <String> payload <String | Class> |
		 name:: resource at: 1.
		 type:: resource at: 2.
		 payload:: resource at: 3.
		 namespace
			at: name
			put: (unpackResourceType: type payload: payload platform: platform)].
	manifest:: Manifest forNamespace: namespace.
	^(applicationConfiguration packageUsing: manifest) main: platform args: args
)
unpackResourceType: type <String> payload: payload <String | Class> platform: platform ^ <Class | String | Alien> = (
(* Convert a resource of a given type into a suitable runtime object as needed *)
	'ns' = type ifTrue:
		[^payload]. (* It's a class - no need to convert *)
	'txt' = type ifTrue:
		[^payload]. (* It's a string - no need to convert *)
	'png' = type ifTrue: (* It's an image - create a JS image from the raw data and return it *)
		[^(platform js global at: 'Image') new at: 'src' put: payload; yourself].
	'js' = type ifTrue: (* It's js code. Create a script  DOM node based on the code *)
		[ | document script |
		document:: platform js global at: 'document'.
		script:: document createElement: 'script'.
		script at: 'type' put: 'text/javascript'.
		script at: 'src' put: payload.
		(document at: 'head') appendChild: script.
		^script].
	'css' = type ifTrue: (* It's css. Create a suitable DOM node *)
		[ | document script |
		document:: platform js global at: 'document'.
		script:: document createElement: 'link'.
		script at: 'rel' put: 'stylesheet'.
		script at: 'href' put: payload.
		(document at: 'head') appendChild: script.
		^script].

	^Error signal: 'Unknown resource type: ', type
)
) : (
)
class RecordingManifest namespace: ns <Map[{String. String. String | Class}]> accessedResources: list <List[{String. String. String | Class}]> = (
(* This class is used to record the dependencies of an app, based on a provided map of names to resource triples. 
    Instantiating the app with an instance of this class as its manifest will record every resource accessed via the manifest, 
    in the provided list. The overall set of resources is given in the provided map. The app is of course, provided with the actual
    value desired, which is the third element of the resource triple. 
 *)
	|
	protected namespace <Map[{String. String. String | Class}]> = ns.
	protected accessedResources <List[{String. String. String | Class}]> = list.
	|
) (
protected doesNotUnderstand: message = (
	| resource <Map[{String. String. String | Class}]> = namespace at: message selector. |
	accessedResources add: resource.
	^resource at: 3
)
) : (
)
public main: platform args: args = (
	^(Packager usingPlatform: platform) main: args
)
) : (
)
